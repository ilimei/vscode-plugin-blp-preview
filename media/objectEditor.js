/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = (Array(48).concat([
/* 48 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),
/* 49 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Pane": () => (/* binding */ Pane),
/* harmony export */   "DefaultPaneDndController": () => (/* binding */ DefaultPaneDndController),
/* harmony export */   "PaneView": () => (/* binding */ PaneView)
/* harmony export */ });
/* harmony import */ var _browser_browser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(50);
/* harmony import */ var _browser_dnd__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(60);
/* harmony import */ var _browser_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(61);
/* harmony import */ var _browser_event__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(85);
/* harmony import */ var _browser_keyboardEvent__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(63);
/* harmony import */ var _browser_touch__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(86);
/* harmony import */ var _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(89);
/* harmony import */ var _common_color__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(91);
/* harmony import */ var _common_event__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(51);
/* harmony import */ var _common_keyCodes__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(64);
/* harmony import */ var _common_lifecycle__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(54);
/* harmony import */ var _paneview_css__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(92);
/* harmony import */ var _common_nls__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(59);
/* harmony import */ var _splitview__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(93);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/















/**
 * A Pane is a structured SplitView view.
 *
 * WARNING: You must call `render()` after you construct it.
 * It can't be done automatically at the end of the ctor
 * because of the order of property initialization in TypeScript.
 * Subclasses wouldn't be able to set own properties
 * before the `render()` call, thus forbidding their use.
 */
class Pane extends _common_lifecycle__WEBPACK_IMPORTED_MODULE_10__.Disposable {
  static HEADER_SIZE = 22;
  expandedSize = undefined;
  _headerVisible = true;
  styles = {};
  animationTimer = undefined;
  _onDidChange = this._register(new _common_event__WEBPACK_IMPORTED_MODULE_8__.Emitter());
  onDidChange = this._onDidChange.event;
  _onDidChangeExpansionState = this._register(new _common_event__WEBPACK_IMPORTED_MODULE_8__.Emitter());
  onDidChangeExpansionState = this._onDidChangeExpansionState.event;

  get draggableElement() {
    return this.header;
  }

  get dropTargetElement() {
    return this.element;
  }

  get dropBackground() {
    return this._dropBackground;
  }

  get minimumBodySize() {
    return this._minimumBodySize;
  }

  set minimumBodySize(size) {
    this._minimumBodySize = size;

    this._onDidChange.fire(undefined);
  }

  get maximumBodySize() {
    return this._maximumBodySize;
  }

  set maximumBodySize(size) {
    this._maximumBodySize = size;

    this._onDidChange.fire(undefined);
  }

  get headerSize() {
    return this.headerVisible ? Pane.HEADER_SIZE : 0;
  }

  get minimumSize() {
    const headerSize = this.headerSize;
    const expanded = !this.headerVisible || this.isExpanded();
    const minimumBodySize = expanded ? this.minimumBodySize : 0;
    return headerSize + minimumBodySize;
  }

  get maximumSize() {
    const headerSize = this.headerSize;
    const expanded = !this.headerVisible || this.isExpanded();
    const maximumBodySize = expanded ? this.maximumBodySize : 0;
    return headerSize + maximumBodySize;
  }

  orthogonalSize = 0;

  constructor(options) {
    super();
    this._expanded = typeof options.expanded === 'undefined' ? true : !!options.expanded;
    this._orientation = typeof options.orientation === 'undefined' ? _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_6__.Orientation.VERTICAL : options.orientation;
    this.ariaHeaderLabel = (0,_common_nls__WEBPACK_IMPORTED_MODULE_12__.localize)('viewSection', "{0} Section", options.title);
    this._minimumBodySize = typeof options.minimumBodySize === 'number' ? options.minimumBodySize : this._orientation === _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_6__.Orientation.HORIZONTAL ? 200 : 120;
    this._maximumBodySize = typeof options.maximumBodySize === 'number' ? options.maximumBodySize : Number.POSITIVE_INFINITY;
    this.element = (0,_browser_dom__WEBPACK_IMPORTED_MODULE_2__.$)('.pane');
  }

  isExpanded() {
    return this._expanded;
  }

  setExpanded(expanded) {
    if (this._expanded === !!expanded) {
      return false;
    }

    this.element?.classList.toggle('expanded', expanded);
    this._expanded = !!expanded;
    this.updateHeader();

    if (expanded) {
      if (typeof this.animationTimer === 'number') {
        clearTimeout(this.animationTimer);
      }

      (0,_browser_dom__WEBPACK_IMPORTED_MODULE_2__.append)(this.element, this.body);
    } else {
      this.animationTimer = window.setTimeout(() => {
        this.body.remove();
      }, 200);
    }

    this._onDidChangeExpansionState.fire(expanded);

    this._onDidChange.fire(expanded ? this.expandedSize : undefined);

    return true;
  }

  get headerVisible() {
    return this._headerVisible;
  }

  set headerVisible(visible) {
    if (this._headerVisible === !!visible) {
      return;
    }

    this._headerVisible = !!visible;
    this.updateHeader();

    this._onDidChange.fire(undefined);
  }

  get orientation() {
    return this._orientation;
  }

  set orientation(orientation) {
    if (this._orientation === orientation) {
      return;
    }

    this._orientation = orientation;

    if (this.element) {
      this.element.classList.toggle('horizontal', this.orientation === _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_6__.Orientation.HORIZONTAL);
      this.element.classList.toggle('vertical', this.orientation === _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_6__.Orientation.VERTICAL);
    }

    if (this.header) {
      this.updateHeader();
    }
  }

  render() {
    this.element.classList.toggle('expanded', this.isExpanded());
    this.element.classList.toggle('horizontal', this.orientation === _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_6__.Orientation.HORIZONTAL);
    this.element.classList.toggle('vertical', this.orientation === _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_6__.Orientation.VERTICAL);
    this.header = (0,_browser_dom__WEBPACK_IMPORTED_MODULE_2__.$)('.pane-header');
    (0,_browser_dom__WEBPACK_IMPORTED_MODULE_2__.append)(this.element, this.header);
    this.header.setAttribute('tabindex', '0'); // Use role button so the aria-expanded state gets read https://github.com/microsoft/vscode/issues/95996

    this.header.setAttribute('role', 'button');
    this.header.setAttribute('aria-label', this.ariaHeaderLabel);
    this.renderHeader(this.header);
    const focusTracker = (0,_browser_dom__WEBPACK_IMPORTED_MODULE_2__.trackFocus)(this.header);

    this._register(focusTracker);

    this._register(focusTracker.onDidFocus(() => this.header.classList.add('focused'), null));

    this._register(focusTracker.onDidBlur(() => this.header.classList.remove('focused'), null));

    this.updateHeader();

    const eventDisposables = this._register(new _common_lifecycle__WEBPACK_IMPORTED_MODULE_10__.DisposableStore());

    const onKeyDown = this._register(new _browser_event__WEBPACK_IMPORTED_MODULE_3__.DomEmitter(this.header, 'keydown'));

    const onHeaderKeyDown = _common_event__WEBPACK_IMPORTED_MODULE_8__.Event.map(onKeyDown.event, e => new _browser_keyboardEvent__WEBPACK_IMPORTED_MODULE_4__.StandardKeyboardEvent(e), eventDisposables);

    this._register(_common_event__WEBPACK_IMPORTED_MODULE_8__.Event.filter(onHeaderKeyDown, e => e.keyCode === _common_keyCodes__WEBPACK_IMPORTED_MODULE_9__.KeyCode.Enter || e.keyCode === _common_keyCodes__WEBPACK_IMPORTED_MODULE_9__.KeyCode.Space, eventDisposables)(() => this.setExpanded(!this.isExpanded()), null));

    this._register(_common_event__WEBPACK_IMPORTED_MODULE_8__.Event.filter(onHeaderKeyDown, e => e.keyCode === _common_keyCodes__WEBPACK_IMPORTED_MODULE_9__.KeyCode.LeftArrow, eventDisposables)(() => this.setExpanded(false), null));

    this._register(_common_event__WEBPACK_IMPORTED_MODULE_8__.Event.filter(onHeaderKeyDown, e => e.keyCode === _common_keyCodes__WEBPACK_IMPORTED_MODULE_9__.KeyCode.RightArrow, eventDisposables)(() => this.setExpanded(true), null));

    this._register(_browser_touch__WEBPACK_IMPORTED_MODULE_5__.Gesture.addTarget(this.header));

    [_browser_dom__WEBPACK_IMPORTED_MODULE_2__.EventType.CLICK, _browser_touch__WEBPACK_IMPORTED_MODULE_5__.EventType.Tap].forEach(eventType => {
      this._register((0,_browser_dom__WEBPACK_IMPORTED_MODULE_2__.addDisposableListener)(this.header, eventType, e => {
        if (!e.defaultPrevented) {
          this.setExpanded(!this.isExpanded());
        }
      }));
    });
    this.body = (0,_browser_dom__WEBPACK_IMPORTED_MODULE_2__.append)(this.element, (0,_browser_dom__WEBPACK_IMPORTED_MODULE_2__.$)('.pane-body'));
    this.renderBody(this.body);

    if (!this.isExpanded()) {
      this.body.remove();
    }
  }

  layout(size) {
    console.info(size);
    const headerSize = this.headerVisible ? Pane.HEADER_SIZE : 0;
    const width = this._orientation === _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_6__.Orientation.VERTICAL ? this.orthogonalSize : size;
    const height = this._orientation === _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_6__.Orientation.VERTICAL ? size - headerSize : this.orthogonalSize - headerSize;

    if (this.isExpanded()) {
      this.body.classList.toggle('wide', width >= 600);
      this.layoutBody(height, width);
      this.expandedSize = size;
    }
  }

  style(styles) {
    this.styles = styles;

    if (!this.header) {
      return;
    }

    this.updateHeader();
  }

  updateHeader() {
    const expanded = !this.headerVisible || this.isExpanded();
    this.header.style.lineHeight = `${this.headerSize}px`;
    this.header.classList.toggle('hidden', !this.headerVisible);
    this.header.classList.toggle('expanded', expanded);
    this.header.setAttribute('aria-expanded', String(expanded));
    this.header.style.color = this.styles.headerForeground ? this.styles.headerForeground.toString() : '';
    this.header.style.backgroundColor = this.styles.headerBackground ? this.styles.headerBackground.toString() : '';
    this.header.style.borderTop = this.styles.headerBorder && this.orientation === _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_6__.Orientation.VERTICAL ? `1px solid ${this.styles.headerBorder}` : '';
    this._dropBackground = this.styles.dropBackground;
    this.element.style.borderLeft = this.styles.leftBorder && this.orientation === _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_6__.Orientation.HORIZONTAL ? `1px solid ${this.styles.leftBorder}` : '';
  }

}

class PaneDraggable extends _common_lifecycle__WEBPACK_IMPORTED_MODULE_10__.Disposable {
  static DefaultDragOverBackgroundColor = new _common_color__WEBPACK_IMPORTED_MODULE_7__.Color(new _common_color__WEBPACK_IMPORTED_MODULE_7__.RGBA(128, 128, 128, 0.5));
  dragOverCounter = 0; // see https://github.com/microsoft/vscode/issues/14470

  _onDidDrop = this._register(new _common_event__WEBPACK_IMPORTED_MODULE_8__.Emitter());
  onDidDrop = this._onDidDrop.event;

  constructor(pane, dnd, context) {
    super();
    this.pane = pane;
    this.dnd = dnd;
    this.context = context;
    pane.draggableElement.draggable = true;

    this._register((0,_browser_dom__WEBPACK_IMPORTED_MODULE_2__.addDisposableListener)(pane.draggableElement, 'dragstart', e => this.onDragStart(e)));

    this._register((0,_browser_dom__WEBPACK_IMPORTED_MODULE_2__.addDisposableListener)(pane.dropTargetElement, 'dragenter', e => this.onDragEnter(e)));

    this._register((0,_browser_dom__WEBPACK_IMPORTED_MODULE_2__.addDisposableListener)(pane.dropTargetElement, 'dragleave', e => this.onDragLeave(e)));

    this._register((0,_browser_dom__WEBPACK_IMPORTED_MODULE_2__.addDisposableListener)(pane.dropTargetElement, 'dragend', e => this.onDragEnd(e)));

    this._register((0,_browser_dom__WEBPACK_IMPORTED_MODULE_2__.addDisposableListener)(pane.dropTargetElement, 'drop', e => this.onDrop(e)));
  }

  onDragStart(e) {
    if (!this.dnd.canDrag(this.pane) || !e.dataTransfer) {
      e.preventDefault();
      e.stopPropagation();
      return;
    }

    e.dataTransfer.effectAllowed = 'move';

    if (_browser_browser__WEBPACK_IMPORTED_MODULE_0__.isFirefox) {
      // Firefox: requires to set a text data transfer to get going
      e.dataTransfer?.setData(_browser_dnd__WEBPACK_IMPORTED_MODULE_1__.DataTransfers.TEXT, this.pane.draggableElement.textContent || '');
    }

    const dragImage = (0,_browser_dom__WEBPACK_IMPORTED_MODULE_2__.append)(document.body, (0,_browser_dom__WEBPACK_IMPORTED_MODULE_2__.$)('.monaco-drag-image', {}, this.pane.draggableElement.textContent || ''));
    e.dataTransfer.setDragImage(dragImage, -10, -10);
    setTimeout(() => document.body.removeChild(dragImage), 0);
    this.context.draggable = this;
  }

  onDragEnter(e) {
    if (!this.context.draggable || this.context.draggable === this) {
      return;
    }

    if (!this.dnd.canDrop(this.context.draggable.pane, this.pane)) {
      return;
    }

    this.dragOverCounter++;
    this.render();
  }

  onDragLeave(e) {
    if (!this.context.draggable || this.context.draggable === this) {
      return;
    }

    if (!this.dnd.canDrop(this.context.draggable.pane, this.pane)) {
      return;
    }

    this.dragOverCounter--;

    if (this.dragOverCounter === 0) {
      this.render();
    }
  }

  onDragEnd(e) {
    if (!this.context.draggable) {
      return;
    }

    this.dragOverCounter = 0;
    this.render();
    this.context.draggable = null;
  }

  onDrop(e) {
    if (!this.context.draggable) {
      return;
    }

    _browser_dom__WEBPACK_IMPORTED_MODULE_2__.EventHelper.stop(e);
    this.dragOverCounter = 0;
    this.render();

    if (this.dnd.canDrop(this.context.draggable.pane, this.pane) && this.context.draggable !== this) {
      this._onDidDrop.fire({
        from: this.context.draggable.pane,
        to: this.pane
      });
    }

    this.context.draggable = null;
  }

  render() {
    let backgroundColor = null;

    if (this.dragOverCounter > 0) {
      backgroundColor = (this.pane.dropBackground || PaneDraggable.DefaultDragOverBackgroundColor).toString();
    }

    this.pane.dropTargetElement.style.backgroundColor = backgroundColor || '';
  }

}

class DefaultPaneDndController {
  canDrag(pane) {
    return true;
  }

  canDrop(pane, overPane) {
    return true;
  }

}
class PaneView extends _common_lifecycle__WEBPACK_IMPORTED_MODULE_10__.Disposable {
  dndContext = {
    draggable: null
  };
  paneItems = [];
  orthogonalSize = 0;
  size = 0;
  animationTimer = undefined;
  _onDidDrop = this._register(new _common_event__WEBPACK_IMPORTED_MODULE_8__.Emitter());
  onDidDrop = this._onDidDrop.event;

  constructor(container, options = {}) {
    super();
    this.dnd = options.dnd;
    this.orientation = options.orientation ?? _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_6__.Orientation.VERTICAL;
    this.element = (0,_browser_dom__WEBPACK_IMPORTED_MODULE_2__.append)(container, (0,_browser_dom__WEBPACK_IMPORTED_MODULE_2__.$)('.monaco-pane-view'));
    this.splitview = this._register(new _splitview__WEBPACK_IMPORTED_MODULE_13__.SplitView(this.element, {
      orientation: this.orientation
    }));
    this.onDidSashReset = this.splitview.onDidSashReset;
    this.onDidSashChange = this.splitview.onDidSashChange;
    this.onDidScroll = this.splitview.onDidScroll;

    const eventDisposables = this._register(new _common_lifecycle__WEBPACK_IMPORTED_MODULE_10__.DisposableStore());

    const onKeyDown = this._register(new _browser_event__WEBPACK_IMPORTED_MODULE_3__.DomEmitter(this.element, 'keydown'));

    const onHeaderKeyDown = _common_event__WEBPACK_IMPORTED_MODULE_8__.Event.map(_common_event__WEBPACK_IMPORTED_MODULE_8__.Event.filter(onKeyDown.event, e => e.target instanceof HTMLElement && e.target.classList.contains('pane-header'), eventDisposables), e => new _browser_keyboardEvent__WEBPACK_IMPORTED_MODULE_4__.StandardKeyboardEvent(e), eventDisposables);

    this._register(_common_event__WEBPACK_IMPORTED_MODULE_8__.Event.filter(onHeaderKeyDown, e => e.keyCode === _common_keyCodes__WEBPACK_IMPORTED_MODULE_9__.KeyCode.UpArrow, eventDisposables)(() => this.focusPrevious()));

    this._register(_common_event__WEBPACK_IMPORTED_MODULE_8__.Event.filter(onHeaderKeyDown, e => e.keyCode === _common_keyCodes__WEBPACK_IMPORTED_MODULE_9__.KeyCode.DownArrow, eventDisposables)(() => this.focusNext()));
  }

  addPane(pane, size, index = this.splitview.length) {
    const disposables = new _common_lifecycle__WEBPACK_IMPORTED_MODULE_10__.DisposableStore();
    pane.onDidChangeExpansionState(this.setupAnimation, this, disposables);
    const paneItem = {
      pane: pane,
      disposable: disposables
    };
    this.paneItems.splice(index, 0, paneItem);
    pane.orientation = this.orientation;
    pane.orthogonalSize = this.orthogonalSize;
    this.splitview.addView(pane, size, index);

    if (this.dnd) {
      const draggable = new PaneDraggable(pane, this.dnd, this.dndContext);
      disposables.add(draggable);
      disposables.add(draggable.onDidDrop(this._onDidDrop.fire, this._onDidDrop));
    }
  }

  removePane(pane) {
    const index = this.paneItems.findIndex(item => item.pane === pane);

    if (index === -1) {
      return;
    }

    this.splitview.removeView(index, pane.isExpanded() ? _splitview__WEBPACK_IMPORTED_MODULE_13__.Sizing.Distribute : undefined);
    const paneItem = this.paneItems.splice(index, 1)[0];
    paneItem.disposable.dispose();
  }

  movePane(from, to) {
    const fromIndex = this.paneItems.findIndex(item => item.pane === from);
    const toIndex = this.paneItems.findIndex(item => item.pane === to);

    if (fromIndex === -1 || toIndex === -1) {
      return;
    }

    const [paneItem] = this.paneItems.splice(fromIndex, 1);
    this.paneItems.splice(toIndex, 0, paneItem);
    this.splitview.moveView(fromIndex, toIndex);
  }

  resizePane(pane, size) {
    const index = this.paneItems.findIndex(item => item.pane === pane);

    if (index === -1) {
      return;
    }

    this.splitview.resizeView(index, size);
  }

  getPaneSize(pane) {
    const index = this.paneItems.findIndex(item => item.pane === pane);

    if (index === -1) {
      return -1;
    }

    return this.splitview.getViewSize(index);
  }

  layout(height, width) {
    this.orthogonalSize = this.orientation === _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_6__.Orientation.VERTICAL ? width : height;
    this.size = this.orientation === _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_6__.Orientation.HORIZONTAL ? width : height;

    for (const paneItem of this.paneItems) {
      paneItem.pane.orthogonalSize = this.orthogonalSize;
    }

    this.splitview.layout(this.size);
  }

  flipOrientation(height, width) {
    this.orientation = this.orientation === _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_6__.Orientation.VERTICAL ? _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_6__.Orientation.HORIZONTAL : _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_6__.Orientation.VERTICAL;
    const paneSizes = this.paneItems.map(pane => this.getPaneSize(pane.pane));
    this.splitview.dispose();
    (0,_browser_dom__WEBPACK_IMPORTED_MODULE_2__.clearNode)(this.element);
    this.splitview = this._register(new _splitview__WEBPACK_IMPORTED_MODULE_13__.SplitView(this.element, {
      orientation: this.orientation
    }));
    const newOrthogonalSize = this.orientation === _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_6__.Orientation.VERTICAL ? width : height;
    const newSize = this.orientation === _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_6__.Orientation.HORIZONTAL ? width : height;
    this.paneItems.forEach((pane, index) => {
      pane.pane.orthogonalSize = newOrthogonalSize;
      pane.pane.orientation = this.orientation;
      const viewSize = this.size === 0 ? 0 : newSize * paneSizes[index] / this.size;
      this.splitview.addView(pane.pane, viewSize, index);
    });
    this.size = newSize;
    this.orthogonalSize = newOrthogonalSize;
    this.splitview.layout(this.size);
  }

  setupAnimation() {
    if (typeof this.animationTimer === 'number') {
      window.clearTimeout(this.animationTimer);
    }

    this.element.classList.add('animated');
    this.animationTimer = window.setTimeout(() => {
      this.animationTimer = undefined;
      this.element.classList.remove('animated');
    }, 200);
  }

  getPaneHeaderElements() {
    return [...this.element.querySelectorAll('.pane-header')];
  }

  focusPrevious() {
    const headers = this.getPaneHeaderElements();
    const index = headers.indexOf(document.activeElement);

    if (index === -1) {
      return;
    }

    headers[Math.max(index - 1, 0)].focus();
  }

  focusNext() {
    const headers = this.getPaneHeaderElements();
    const index = headers.indexOf(document.activeElement);

    if (index === -1) {
      return;
    }

    headers[Math.min(index + 1, headers.length - 1)].focus();
  }

  dispose() {
    super.dispose();
    this.paneItems.forEach(i => i.disposable.dispose());
  }

}

/***/ }),
/* 50 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addMatchMediaChangeListener": () => (/* binding */ addMatchMediaChangeListener),
/* harmony export */   "PixelRatio": () => (/* binding */ PixelRatio),
/* harmony export */   "setZoomLevel": () => (/* binding */ setZoomLevel),
/* harmony export */   "getZoomLevel": () => (/* binding */ getZoomLevel),
/* harmony export */   "getZoomFactor": () => (/* binding */ getZoomFactor),
/* harmony export */   "setZoomFactor": () => (/* binding */ setZoomFactor),
/* harmony export */   "setFullscreen": () => (/* binding */ setFullscreen),
/* harmony export */   "isFullscreen": () => (/* binding */ isFullscreen),
/* harmony export */   "onDidChangeFullscreen": () => (/* binding */ onDidChangeFullscreen),
/* harmony export */   "isFirefox": () => (/* binding */ isFirefox),
/* harmony export */   "isWebKit": () => (/* binding */ isWebKit),
/* harmony export */   "isChrome": () => (/* binding */ isChrome),
/* harmony export */   "isSafari": () => (/* binding */ isSafari),
/* harmony export */   "isWebkitWebView": () => (/* binding */ isWebkitWebView),
/* harmony export */   "isElectron": () => (/* binding */ isElectron),
/* harmony export */   "isAndroid": () => (/* binding */ isAndroid),
/* harmony export */   "isStandalone": () => (/* binding */ isStandalone)
/* harmony export */ });
/* harmony import */ var _common_event__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(51);
/* harmony import */ var _common_lifecycle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(54);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/



class WindowManager {
  static INSTANCE = new WindowManager(); // --- Zoom Level

  _zoomLevel = 0;

  getZoomLevel() {
    return this._zoomLevel;
  }

  setZoomLevel(zoomLevel, isTrusted) {
    if (this._zoomLevel === zoomLevel) {
      return;
    }

    this._zoomLevel = zoomLevel;
  } // --- Zoom Factor


  _zoomFactor = 1;

  getZoomFactor() {
    return this._zoomFactor;
  }

  setZoomFactor(zoomFactor) {
    this._zoomFactor = zoomFactor;
  } // --- Fullscreen


  _fullscreen = false;
  _onDidChangeFullscreen = new _common_event__WEBPACK_IMPORTED_MODULE_0__.Emitter();
  onDidChangeFullscreen = this._onDidChangeFullscreen.event;

  setFullscreen(fullscreen) {
    if (this._fullscreen === fullscreen) {
      return;
    }

    this._fullscreen = fullscreen;

    this._onDidChangeFullscreen.fire();
  }

  isFullscreen() {
    return this._fullscreen;
  }

}
/**
 * See https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio#monitoring_screen_resolution_or_zoom_level_changes
 */


class DevicePixelRatioMonitor extends _common_lifecycle__WEBPACK_IMPORTED_MODULE_1__.Disposable {
  _onDidChange = this._register(new _common_event__WEBPACK_IMPORTED_MODULE_0__.Emitter());
  onDidChange = this._onDidChange.event;

  constructor() {
    super();

    this._listener = () => this._handleChange(true);

    this._mediaQueryList = null;

    this._handleChange(false);
  }

  _handleChange(fireEvent) {
    this._mediaQueryList?.removeEventListener('change', this._listener);
    this._mediaQueryList = matchMedia(`(resolution: ${window.devicePixelRatio}dppx)`);

    this._mediaQueryList.addEventListener('change', this._listener);

    if (fireEvent) {
      this._onDidChange.fire();
    }
  }

}

class PixelRatioImpl extends _common_lifecycle__WEBPACK_IMPORTED_MODULE_1__.Disposable {
  _onDidChange = this._register(new _common_event__WEBPACK_IMPORTED_MODULE_0__.Emitter());
  onDidChange = this._onDidChange.event;

  get value() {
    return this._value;
  }

  constructor() {
    super();
    this._value = this._getPixelRatio();

    const dprMonitor = this._register(new DevicePixelRatioMonitor());

    this._register(dprMonitor.onDidChange(() => {
      this._value = this._getPixelRatio();

      this._onDidChange.fire(this._value);
    }));
  }

  _getPixelRatio() {
    const ctx = document.createElement('canvas').getContext('2d');
    const dpr = window.devicePixelRatio || 1;
    const bsr = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;
    return dpr / bsr;
  }

}

class PixelRatioFacade {
  _pixelRatioMonitor = null;

  _getOrCreatePixelRatioMonitor() {
    if (!this._pixelRatioMonitor) {
      this._pixelRatioMonitor = (0,_common_lifecycle__WEBPACK_IMPORTED_MODULE_1__.markAsSingleton)(new PixelRatioImpl());
    }

    return this._pixelRatioMonitor;
  }
  /**
   * Get the current value.
   */


  get value() {
    return this._getOrCreatePixelRatioMonitor().value;
  }
  /**
   * Listen for changes.
   */


  get onDidChange() {
    return this._getOrCreatePixelRatioMonitor().onDidChange;
  }

}

function addMatchMediaChangeListener(query, callback) {
  if (typeof query === 'string') {
    query = window.matchMedia(query);
  }

  query.addEventListener('change', callback);
}
/**
 * Returns the pixel ratio.
 *
 * This is useful for rendering <canvas> elements at native screen resolution or for being used as
 * a cache key when storing font measurements. Fonts might render differently depending on resolution
 * and any measurements need to be discarded for example when a window is moved from a monitor to another.
 */

const PixelRatio = new PixelRatioFacade();
/** A zoom index, e.g. 1, 2, 3 */

function setZoomLevel(zoomLevel, isTrusted) {
  WindowManager.INSTANCE.setZoomLevel(zoomLevel, isTrusted);
}
function getZoomLevel() {
  return WindowManager.INSTANCE.getZoomLevel();
}
/** The zoom scale for an index, e.g. 1, 1.2, 1.4 */

function getZoomFactor() {
  return WindowManager.INSTANCE.getZoomFactor();
}
function setZoomFactor(zoomFactor) {
  WindowManager.INSTANCE.setZoomFactor(zoomFactor);
}
function setFullscreen(fullscreen) {
  WindowManager.INSTANCE.setFullscreen(fullscreen);
}
function isFullscreen() {
  return WindowManager.INSTANCE.isFullscreen();
}
const onDidChangeFullscreen = WindowManager.INSTANCE.onDidChangeFullscreen;
const userAgent = navigator.userAgent;
const isFirefox = userAgent.indexOf('Firefox') >= 0;
const isWebKit = userAgent.indexOf('AppleWebKit') >= 0;
const isChrome = userAgent.indexOf('Chrome') >= 0;
const isSafari = !isChrome && userAgent.indexOf('Safari') >= 0;
const isWebkitWebView = !isChrome && !isSafari && isWebKit;
const isElectron = userAgent.indexOf('Electron/') >= 0;
const isAndroid = userAgent.indexOf('Android') >= 0;
let standalone = false;

if (window.matchMedia) {
  const standaloneMatchMedia = window.matchMedia('(display-mode: standalone) or (display-mode: window-controls-overlay)');
  const fullScreenMatchMedia = window.matchMedia('(display-mode: fullscreen)');
  standalone = standaloneMatchMedia.matches;
  addMatchMediaChangeListener(standaloneMatchMedia, ({
    matches
  }) => {
    // entering fullscreen would change standaloneMatchMedia.matches to false
    // if standalone is true (running as PWA) and entering fullscreen, skip this change
    if (standalone && fullScreenMatchMedia.matches) {
      return;
    } // otherwise update standalone (browser to PWA or PWA to browser)


    standalone = matches;
  });
}

function isStandalone() {
  return standalone;
}

/***/ }),
/* 51 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Event": () => (/* binding */ Event),
/* harmony export */   "EventProfiling": () => (/* binding */ EventProfiling),
/* harmony export */   "setGlobalLeakWarningThreshold": () => (/* binding */ setGlobalLeakWarningThreshold),
/* harmony export */   "Emitter": () => (/* binding */ Emitter),
/* harmony export */   "EventDeliveryQueue": () => (/* binding */ EventDeliveryQueue),
/* harmony export */   "AsyncEmitter": () => (/* binding */ AsyncEmitter),
/* harmony export */   "PauseableEmitter": () => (/* binding */ PauseableEmitter),
/* harmony export */   "DebounceEmitter": () => (/* binding */ DebounceEmitter),
/* harmony export */   "MicrotaskEmitter": () => (/* binding */ MicrotaskEmitter),
/* harmony export */   "EventMultiplexer": () => (/* binding */ EventMultiplexer),
/* harmony export */   "EventBufferer": () => (/* binding */ EventBufferer),
/* harmony export */   "Relay": () => (/* binding */ Relay)
/* harmony export */ });
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);
/* harmony import */ var _functional__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(53);
/* harmony import */ var _lifecycle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(54);
/* harmony import */ var _linkedList__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(56);
/* harmony import */ var _stopwatch__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(57);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/




 // -----------------------------------------------------------------------------------------------------------------------
// Uncomment the next line to print warnings whenever an emitter with listeners is disposed. That is a sign of code smell.
// -----------------------------------------------------------------------------------------------------------------------

const _enableDisposeWithListenerWarning = false; // _enableDisposeWithListenerWarning = Boolean("TRUE"); // causes a linter warning so that it cannot be pushed
// -----------------------------------------------------------------------------------------------------------------------
// Uncomment the next line to print warnings whenever a snapshotted event is used repeatedly without cleanup.
// See https://github.com/microsoft/vscode/issues/142851
// -----------------------------------------------------------------------------------------------------------------------

const _enableSnapshotPotentialLeakWarning = false; // _enableSnapshotPotentialLeakWarning = Boolean("TRUE"); // causes a linter warning so that it cannot be pushed

/**
 * To an event a function with one or zero parameters
 * can be subscribed. The event is the subscriber function itself.
 */

let Event;

(function (_Event) {
  const None = _Event.None = () => _lifecycle__WEBPACK_IMPORTED_MODULE_2__.Disposable.None;

  function _addLeakageTraceLogic(options) {
    if (_enableSnapshotPotentialLeakWarning) {
      const {
        onListenerDidAdd: origListenerDidAdd
      } = options;
      const stack = Stacktrace.create();
      let count = 0;

      options.onListenerDidAdd = () => {
        if (++count === 2) {
          console.warn('snapshotted emitter LIKELY used public and SHOULD HAVE BEEN created with DisposableStore. snapshotted here');
          stack.print();
        }

        origListenerDidAdd?.();
      };
    }
  }
  /**
   * Given an event, returns another event which only fires once.
   */


  function once(event) {
    return (listener, thisArgs = null, disposables) => {
      // we need this, in case the event fires during the listener call
      let didFire = false;
      let result = undefined;
      result = event(e => {
        if (didFire) {
          return;
        } else if (result) {
          result.dispose();
        } else {
          didFire = true;
        }

        return listener.call(thisArgs, e);
      }, null, disposables);

      if (didFire) {
        result.dispose();
      }

      return result;
    };
  }

  _Event.once = once;

  function map(event, map, disposable) {
    return snapshot((listener, thisArgs = null, disposables) => event(i => listener.call(thisArgs, map(i)), null, disposables), disposable);
  }

  _Event.map = map;

  function forEach(event, each, disposable) {
    return snapshot((listener, thisArgs = null, disposables) => event(i => {
      each(i);
      listener.call(thisArgs, i);
    }, null, disposables), disposable);
  }

  _Event.forEach = forEach;

  function filter(event, filter, disposable) {
    return snapshot((listener, thisArgs = null, disposables) => event(e => filter(e) && listener.call(thisArgs, e), null, disposables), disposable);
  }

  _Event.filter = filter;

  function signal(event) {
    return event;
  }

  _Event.signal = signal;

  function any(...events) {
    return (listener, thisArgs = null, disposables) => (0,_lifecycle__WEBPACK_IMPORTED_MODULE_2__.combinedDisposable)(...events.map(event => event(e => listener.call(thisArgs, e), null, disposables)));
  }

  _Event.any = any;

  function reduce(event, merge, initial, disposable) {
    let output = initial;
    return map(event, e => {
      output = merge(output, e);
      return output;
    }, disposable);
  }

  _Event.reduce = reduce;

  function snapshot(event, disposable) {
    let listener;
    const options = {
      onFirstListenerAdd() {
        listener = event(emitter.fire, emitter);
      },

      onLastListenerRemove() {
        listener?.dispose();
      }

    };

    if (!disposable) {
      _addLeakageTraceLogic(options);
    }

    const emitter = new Emitter(options);
    disposable?.add(emitter);
    return emitter.event;
  }
  /**
   * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned
   * event is accessible to "third parties", e.g the event is a public property. Otherwise a leaked listener on the
   * returned event causes this utility to leak a listener on the original event.
   */


  function debounce(event, merge, delay = 100, leading = false, leakWarningThreshold, disposable) {
    let subscription;
    let output = undefined;
    let handle = undefined;
    let numDebouncedCalls = 0;
    const options = {
      leakWarningThreshold,

      onFirstListenerAdd() {
        subscription = event(cur => {
          numDebouncedCalls++;
          output = merge(output, cur);

          if (leading && !handle) {
            emitter.fire(output);
            output = undefined;
          }

          clearTimeout(handle);
          handle = setTimeout(() => {
            const _output = output;
            output = undefined;
            handle = undefined;

            if (!leading || numDebouncedCalls > 1) {
              emitter.fire(_output);
            }

            numDebouncedCalls = 0;
          }, delay);
        });
      },

      onLastListenerRemove() {
        subscription.dispose();
      }

    };

    if (!disposable) {
      _addLeakageTraceLogic(options);
    }

    const emitter = new Emitter(options);
    disposable?.add(emitter);
    return emitter.event;
  }

  _Event.debounce = debounce;

  function latch(event, equals = (a, b) => a === b, disposable) {
    let firstCall = true;
    let cache;
    return filter(event, value => {
      const shouldEmit = firstCall || !equals(value, cache);
      firstCall = false;
      cache = value;
      return shouldEmit;
    }, disposable);
  }

  _Event.latch = latch;

  function split(event, isT, disposable) {
    return [Event.filter(event, isT, disposable), Event.filter(event, e => !isT(e), disposable)];
  }

  _Event.split = split;

  function buffer(event, flushAfterTimeout = false, _buffer = []) {
    let buffer = _buffer.slice();

    let listener = event(e => {
      if (buffer) {
        buffer.push(e);
      } else {
        emitter.fire(e);
      }
    });

    const flush = () => {
      buffer?.forEach(e => emitter.fire(e));
      buffer = null;
    };

    const emitter = new Emitter({
      onFirstListenerAdd() {
        if (!listener) {
          listener = event(e => emitter.fire(e));
        }
      },

      onFirstListenerDidAdd() {
        if (buffer) {
          if (flushAfterTimeout) {
            setTimeout(flush);
          } else {
            flush();
          }
        }
      },

      onLastListenerRemove() {
        if (listener) {
          listener.dispose();
        }

        listener = null;
      }

    });
    return emitter.event;
  }

  _Event.buffer = buffer;

  class ChainableEvent {
    disposables = new _lifecycle__WEBPACK_IMPORTED_MODULE_2__.DisposableStore();

    constructor(event) {
      this.event = event;
    }

    map(fn) {
      return new ChainableEvent(map(this.event, fn, this.disposables));
    }

    forEach(fn) {
      return new ChainableEvent(forEach(this.event, fn, this.disposables));
    }

    filter(fn) {
      return new ChainableEvent(filter(this.event, fn, this.disposables));
    }

    reduce(merge, initial) {
      return new ChainableEvent(reduce(this.event, merge, initial, this.disposables));
    }

    latch() {
      return new ChainableEvent(latch(this.event, undefined, this.disposables));
    }

    debounce(merge, delay = 100, leading = false, leakWarningThreshold) {
      return new ChainableEvent(debounce(this.event, merge, delay, leading, leakWarningThreshold, this.disposables));
    }

    on(listener, thisArgs, disposables) {
      return this.event(listener, thisArgs, disposables);
    }

    once(listener, thisArgs, disposables) {
      return once(this.event)(listener, thisArgs, disposables);
    }

    dispose() {
      this.disposables.dispose();
    }

  }

  function chain(event) {
    return new ChainableEvent(event);
  }

  _Event.chain = chain;

  function fromNodeEventEmitter(emitter, eventName, map = id => id) {
    const fn = (...args) => result.fire(map(...args));

    const onFirstListenerAdd = () => emitter.on(eventName, fn);

    const onLastListenerRemove = () => emitter.removeListener(eventName, fn);

    const result = new Emitter({
      onFirstListenerAdd,
      onLastListenerRemove
    });
    return result.event;
  }

  _Event.fromNodeEventEmitter = fromNodeEventEmitter;

  function fromDOMEventEmitter(emitter, eventName, map = id => id) {
    const fn = (...args) => result.fire(map(...args));

    const onFirstListenerAdd = () => emitter.addEventListener(eventName, fn);

    const onLastListenerRemove = () => emitter.removeEventListener(eventName, fn);

    const result = new Emitter({
      onFirstListenerAdd,
      onLastListenerRemove
    });
    return result.event;
  }

  _Event.fromDOMEventEmitter = fromDOMEventEmitter;

  function toPromise(event) {
    return new Promise(resolve => once(event)(resolve));
  }

  _Event.toPromise = toPromise;

  function runAndSubscribe(event, handler) {
    handler(undefined);
    return event(e => handler(e));
  }

  _Event.runAndSubscribe = runAndSubscribe;

  function runAndSubscribeWithStore(event, handler) {
    let store = null;

    function run(e) {
      store?.dispose();
      store = new _lifecycle__WEBPACK_IMPORTED_MODULE_2__.DisposableStore();
      handler(e, store);
    }

    run(undefined);
    const disposable = event(e => run(e));
    return (0,_lifecycle__WEBPACK_IMPORTED_MODULE_2__.toDisposable)(() => {
      disposable.dispose();
      store?.dispose();
    });
  }

  _Event.runAndSubscribeWithStore = runAndSubscribeWithStore;

  class EmitterObserver {
    _counter = 0;
    _hasChanged = false;

    constructor(obs, store) {
      this.obs = obs;
      const options = {
        onFirstListenerAdd: () => {
          obs.addObserver(this);
        },
        onLastListenerRemove: () => {
          obs.removeObserver(this);
        }
      };

      if (!store) {
        _addLeakageTraceLogic(options);
      }

      this.emitter = new Emitter(options);

      if (store) {
        store.add(this.emitter);
      }
    }

    beginUpdate(_observable) {
      // console.assert(_observable === this.obs);
      this._counter++;
    }

    handleChange(_observable, _change) {
      this._hasChanged = true;
    }

    endUpdate(_observable) {
      if (--this._counter === 0) {
        if (this._hasChanged) {
          this._hasChanged = false;
          this.emitter.fire(this.obs.get());
        }
      }
    }

  }

  function fromObservable(obs, store) {
    const observer = new EmitterObserver(obs, store);
    return observer.emitter.event;
  }

  _Event.fromObservable = fromObservable;
})(Event || (Event = {}));

class EventProfiling {
  static all = new Set();
  static _idPool = 0;
  listenerCount = 0;
  invocationCount = 0;
  elapsedOverall = 0;
  durations = [];

  constructor(name) {
    this.name = `${name}_${EventProfiling._idPool++}`;
    EventProfiling.all.add(this);
  }

  start(listenerCount) {
    this._stopWatch = new _stopwatch__WEBPACK_IMPORTED_MODULE_4__.StopWatch(true);
    this.listenerCount = listenerCount;
  }

  stop() {
    if (this._stopWatch) {
      const elapsed = this._stopWatch.elapsed();

      this.durations.push(elapsed);
      this.elapsedOverall += elapsed;
      this.invocationCount += 1;
      this._stopWatch = undefined;
    }
  }

}

let _globalLeakWarningThreshold = -1;

function setGlobalLeakWarningThreshold(n) {
  const oldValue = _globalLeakWarningThreshold;
  _globalLeakWarningThreshold = n;
  return {
    dispose() {
      _globalLeakWarningThreshold = oldValue;
    }

  };
}

class LeakageMonitor {
  _warnCountdown = 0;

  constructor(customThreshold, name = Math.random().toString(18).slice(2, 5)) {
    this.customThreshold = customThreshold;
    this.name = name;
  }

  dispose() {
    if (this._stacks) {
      this._stacks.clear();
    }
  }

  check(stack, listenerCount) {
    let threshold = _globalLeakWarningThreshold;

    if (typeof this.customThreshold === 'number') {
      threshold = this.customThreshold;
    }

    if (threshold <= 0 || listenerCount < threshold) {
      return undefined;
    }

    if (!this._stacks) {
      this._stacks = new Map();
    }

    const count = this._stacks.get(stack.value) || 0;

    this._stacks.set(stack.value, count + 1);

    this._warnCountdown -= 1;

    if (this._warnCountdown <= 0) {
      // only warn on first exceed and then every time the limit
      // is exceeded by 50% again
      this._warnCountdown = threshold * 0.5; // find most frequent listener and print warning

      let topStack;
      let topCount = 0;

      for (const [stack, count] of this._stacks) {
        if (!topStack || topCount < count) {
          topStack = stack;
          topCount = count;
        }
      }

      console.warn(`[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`);
      console.warn(topStack);
    }

    return () => {
      const count = this._stacks.get(stack.value) || 0;

      this._stacks.set(stack.value, count - 1);
    };
  }

}

class Stacktrace {
  static create() {
    return new Stacktrace(new Error().stack ?? '');
  }

  constructor(value) {
    this.value = value;
  }

  print() {
    console.warn(this.value.split('\n').slice(2).join('\n'));
  }

}

class Listener {
  subscription = new _lifecycle__WEBPACK_IMPORTED_MODULE_2__.SafeDisposable();

  constructor(callback, callbackThis, stack) {
    this.callback = callback;
    this.callbackThis = callbackThis;
    this.stack = stack;
  }

  invoke(e) {
    this.callback.call(this.callbackThis, e);
  }

}
/**
 * The Emitter can be used to expose an Event to the public
 * to fire it from the insides.
 * Sample:
	class Document {

		private readonly _onDidChange = new Emitter<(value:string)=>any>();

		public onDidChange = this._onDidChange.event;

		// getter-style
		// get onDidChange(): Event<(value:string)=>any> {
		// 	return this._onDidChange.event;
		// }

		private _doIt() {
			//...
			this._onDidChange.fire(value);
		}
	}
 */


class Emitter {
  _disposed = false;

  constructor(options) {
    this._options = options;
    this._leakageMon = _globalLeakWarningThreshold > 0 ? new LeakageMonitor(this._options && this._options.leakWarningThreshold) : undefined;
    this._perfMon = this._options?._profName ? new EventProfiling(this._options._profName) : undefined;
    this._deliveryQueue = this._options?.deliveryQueue;
  }

  dispose() {
    if (!this._disposed) {
      this._disposed = true; // It is bad to have listeners at the time of disposing an emitter, it is worst to have listeners keep the emitter
      // alive via the reference that's embedded in their disposables. Therefore we loop over all remaining listeners and
      // unset their subscriptions/disposables. Looping and blaming remaining listeners is done on next tick because the
      // the following programming pattern is very popular:
      //
      // const someModel = this._disposables.add(new ModelObject()); // (1) create and register model
      // this._disposables.add(someModel.onDidChange(() => { ... }); // (2) subscribe and register model-event listener
      // ...later...
      // this._disposables.dispose(); disposes (1) then (2): don't warn after (1) but after the "overall dispose" is done

      if (this._listeners) {
        if (_enableDisposeWithListenerWarning) {
          const listeners = Array.from(this._listeners);
          queueMicrotask(() => {
            for (const listener of listeners) {
              if (listener.subscription.isset()) {
                listener.subscription.unset();
                listener.stack?.print();
              }
            }
          });
        }

        this._listeners.clear();
      }

      this._deliveryQueue?.clear(this);
      this._options?.onLastListenerRemove?.();
      this._leakageMon?.dispose();
    }
  }
  /**
   * For the public to allow to subscribe
   * to events from this Emitter
   */


  get event() {
    if (!this._event) {
      this._event = (callback, thisArgs, disposables) => {
        if (!this._listeners) {
          this._listeners = new _linkedList__WEBPACK_IMPORTED_MODULE_3__.LinkedList();
        }

        const firstListener = this._listeners.isEmpty();

        if (firstListener && this._options?.onFirstListenerAdd) {
          this._options.onFirstListenerAdd(this);
        }

        let removeMonitor;
        let stack;

        if (this._leakageMon && this._listeners.size >= 30) {
          // check and record this emitter for potential leakage
          stack = Stacktrace.create();
          removeMonitor = this._leakageMon.check(stack, this._listeners.size + 1);
        }

        if (_enableDisposeWithListenerWarning) {
          stack = stack ?? Stacktrace.create();
        }

        const listener = new Listener(callback, thisArgs, stack);

        const removeListener = this._listeners.push(listener);

        if (firstListener && this._options?.onFirstListenerDidAdd) {
          this._options.onFirstListenerDidAdd(this);
        }

        if (this._options?.onListenerDidAdd) {
          this._options.onListenerDidAdd(this, callback, thisArgs);
        }

        const result = listener.subscription.set(() => {
          removeMonitor?.();

          if (!this._disposed) {
            removeListener();

            if (this._options && this._options.onLastListenerRemove) {
              const hasListeners = this._listeners && !this._listeners.isEmpty();

              if (!hasListeners) {
                this._options.onLastListenerRemove(this);
              }
            }
          }
        });

        if (disposables instanceof _lifecycle__WEBPACK_IMPORTED_MODULE_2__.DisposableStore) {
          disposables.add(result);
        } else if (Array.isArray(disposables)) {
          disposables.push(result);
        }

        return result;
      };
    }

    return this._event;
  }
  /**
   * To be kept private to fire an event to
   * subscribers
   */


  fire(event) {
    if (this._listeners) {
      // put all [listener,event]-pairs into delivery queue
      // then emit all event. an inner/nested event might be
      // the driver of this
      if (!this._deliveryQueue) {
        this._deliveryQueue = new PrivateEventDeliveryQueue();
      }

      for (const listener of this._listeners) {
        this._deliveryQueue.push(this, listener, event);
      } // start/stop performance insight collection


      this._perfMon?.start(this._deliveryQueue.size);

      this._deliveryQueue.deliver();

      this._perfMon?.stop();
    }
  }

  hasListeners() {
    if (!this._listeners) {
      return false;
    }

    return !this._listeners.isEmpty();
  }

}
class EventDeliveryQueue {
  _queue = new _linkedList__WEBPACK_IMPORTED_MODULE_3__.LinkedList();

  get size() {
    return this._queue.size;
  }

  push(emitter, listener, event) {
    this._queue.push(new EventDeliveryQueueElement(emitter, listener, event));
  }

  clear(emitter) {
    const newQueue = new _linkedList__WEBPACK_IMPORTED_MODULE_3__.LinkedList();

    for (const element of this._queue) {
      if (element.emitter !== emitter) {
        newQueue.push(element);
      }
    }

    this._queue = newQueue;
  }

  deliver() {
    while (this._queue.size > 0) {
      const element = this._queue.shift();

      try {
        element.listener.invoke(element.event);
      } catch (e) {
        (0,_errors__WEBPACK_IMPORTED_MODULE_0__.onUnexpectedError)(e);
      }
    }
  }

}
/**
 * An `EventDeliveryQueue` that is guaranteed to be used by a single `Emitter`.
 */

class PrivateEventDeliveryQueue extends EventDeliveryQueue {
  clear(emitter) {
    // Here we can just clear the entire linked list because
    // all elements are guaranteed to belong to this emitter
    this._queue.clear();
  }

}

class EventDeliveryQueueElement {
  constructor(emitter, listener, event) {
    this.emitter = emitter;
    this.listener = listener;
    this.event = event;
  }

}

class AsyncEmitter extends Emitter {
  async fireAsync(data, token, promiseJoin) {
    if (!this._listeners) {
      return;
    }

    if (!this._asyncDeliveryQueue) {
      this._asyncDeliveryQueue = new _linkedList__WEBPACK_IMPORTED_MODULE_3__.LinkedList();
    }

    for (const listener of this._listeners) {
      this._asyncDeliveryQueue.push([listener, data]);
    }

    while (this._asyncDeliveryQueue.size > 0 && !token.isCancellationRequested) {
      const [listener, data] = this._asyncDeliveryQueue.shift();

      const thenables = [];
      const event = { ...data,
        token,
        waitUntil: p => {
          if (Object.isFrozen(thenables)) {
            throw new Error('waitUntil can NOT be called asynchronous');
          }

          if (promiseJoin) {
            p = promiseJoin(p, listener.callback);
          }

          thenables.push(p);
        }
      };

      try {
        listener.invoke(event);
      } catch (e) {
        (0,_errors__WEBPACK_IMPORTED_MODULE_0__.onUnexpectedError)(e);
        continue;
      } // freeze thenables-collection to enforce sync-calls to
      // wait until and then wait for all thenables to resolve


      Object.freeze(thenables);
      await Promise.allSettled(thenables).then(values => {
        for (const value of values) {
          if (value.status === 'rejected') {
            (0,_errors__WEBPACK_IMPORTED_MODULE_0__.onUnexpectedError)(value.reason);
          }
        }
      });
    }
  }

}
class PauseableEmitter extends Emitter {
  _isPaused = 0;
  _eventQueue = new _linkedList__WEBPACK_IMPORTED_MODULE_3__.LinkedList();

  constructor(options) {
    super(options);
    this._mergeFn = options?.merge;
  }

  pause() {
    this._isPaused++;
  }

  resume() {
    if (this._isPaused !== 0 && --this._isPaused === 0) {
      if (this._mergeFn) {
        // use the merge function to create a single composite
        // event. make a copy in case firing pauses this emitter
        if (this._eventQueue.size > 0) {
          const events = Array.from(this._eventQueue);

          this._eventQueue.clear();

          super.fire(this._mergeFn(events));
        }
      } else {
        // no merging, fire each event individually and test
        // that this emitter isn't paused halfway through
        while (!this._isPaused && this._eventQueue.size !== 0) {
          super.fire(this._eventQueue.shift());
        }
      }
    }
  }

  fire(event) {
    if (this._listeners) {
      if (this._isPaused !== 0) {
        this._eventQueue.push(event);
      } else {
        super.fire(event);
      }
    }
  }

}
class DebounceEmitter extends PauseableEmitter {
  constructor(options) {
    super(options);
    this._delay = options.delay ?? 100;
  }

  fire(event) {
    if (!this._handle) {
      this.pause();
      this._handle = setTimeout(() => {
        this._handle = undefined;
        this.resume();
      }, this._delay);
    }

    super.fire(event);
  }

}
/**
 * An emitter which queue all events and then process them at the
 * end of the event loop.
 */

class MicrotaskEmitter extends Emitter {
  _queuedEvents = [];

  constructor(options) {
    super(options);
    this._mergeFn = options?.merge;
  }

  fire(event) {
    if (!this.hasListeners()) {
      return;
    }

    this._queuedEvents.push(event);

    if (this._queuedEvents.length === 1) {
      queueMicrotask(() => {
        if (this._mergeFn) {
          super.fire(this._mergeFn(this._queuedEvents));
        } else {
          this._queuedEvents.forEach(e => super.fire(e));
        }

        this._queuedEvents = [];
      });
    }
  }

}
class EventMultiplexer {
  hasListeners = false;
  events = [];

  constructor() {
    this.emitter = new Emitter({
      onFirstListenerAdd: () => this.onFirstListenerAdd(),
      onLastListenerRemove: () => this.onLastListenerRemove()
    });
  }

  get event() {
    return this.emitter.event;
  }

  add(event) {
    const e = {
      event: event,
      listener: null
    };
    this.events.push(e);

    if (this.hasListeners) {
      this.hook(e);
    }

    const dispose = () => {
      if (this.hasListeners) {
        this.unhook(e);
      }

      const idx = this.events.indexOf(e);
      this.events.splice(idx, 1);
    };

    return (0,_lifecycle__WEBPACK_IMPORTED_MODULE_2__.toDisposable)((0,_functional__WEBPACK_IMPORTED_MODULE_1__.once)(dispose));
  }

  onFirstListenerAdd() {
    this.hasListeners = true;
    this.events.forEach(e => this.hook(e));
  }

  onLastListenerRemove() {
    this.hasListeners = false;
    this.events.forEach(e => this.unhook(e));
  }

  hook(e) {
    e.listener = e.event(r => this.emitter.fire(r));
  }

  unhook(e) {
    if (e.listener) {
      e.listener.dispose();
    }

    e.listener = null;
  }

  dispose() {
    this.emitter.dispose();
  }

}
/**
 * The EventBufferer is useful in situations in which you want
 * to delay firing your events during some code.
 * You can wrap that code and be sure that the event will not
 * be fired during that wrap.
 *
 * ```
 * const emitter: Emitter;
 * const delayer = new EventDelayer();
 * const delayedEvent = delayer.wrapEvent(emitter.event);
 *
 * delayedEvent(console.log);
 *
 * delayer.bufferEvents(() => {
 *   emitter.fire(); // event will not be fired yet
 * });
 *
 * // event will only be fired at this point
 * ```
 */

class EventBufferer {
  buffers = [];

  wrapEvent(event) {
    return (listener, thisArgs, disposables) => {
      return event(i => {
        const buffer = this.buffers[this.buffers.length - 1];

        if (buffer) {
          buffer.push(() => listener.call(thisArgs, i));
        } else {
          listener.call(thisArgs, i);
        }
      }, undefined, disposables);
    };
  }

  bufferEvents(fn) {
    const buffer = [];
    this.buffers.push(buffer);
    const r = fn();
    this.buffers.pop();
    buffer.forEach(flush => flush());
    return r;
  }

}
/**
 * A Relay is an event forwarder which functions as a replugabble event pipe.
 * Once created, you can connect an input event to it and it will simply forward
 * events from that input event through its own `event` property. The `input`
 * can be changed at any point in time.
 */

class Relay {
  listening = false;
  inputEvent = Event.None;
  inputEventListener = _lifecycle__WEBPACK_IMPORTED_MODULE_2__.Disposable.None;
  emitter = new Emitter({
    onFirstListenerDidAdd: () => {
      this.listening = true;
      this.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);
    },
    onLastListenerRemove: () => {
      this.listening = false;
      this.inputEventListener.dispose();
    }
  });
  event = this.emitter.event;

  set input(event) {
    this.inputEvent = event;

    if (this.listening) {
      this.inputEventListener.dispose();
      this.inputEventListener = event(this.emitter.fire, this.emitter);
    }
  }

  dispose() {
    this.inputEventListener.dispose();
    this.emitter.dispose();
  }

}

/***/ }),
/* 52 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ErrorHandler": () => (/* binding */ ErrorHandler),
/* harmony export */   "errorHandler": () => (/* binding */ errorHandler),
/* harmony export */   "setUnexpectedErrorHandler": () => (/* binding */ setUnexpectedErrorHandler),
/* harmony export */   "onUnexpectedError": () => (/* binding */ onUnexpectedError),
/* harmony export */   "onUnexpectedExternalError": () => (/* binding */ onUnexpectedExternalError),
/* harmony export */   "transformErrorForSerialization": () => (/* binding */ transformErrorForSerialization),
/* harmony export */   "isCancellationError": () => (/* binding */ isCancellationError),
/* harmony export */   "CancellationError": () => (/* binding */ CancellationError),
/* harmony export */   "canceled": () => (/* binding */ canceled),
/* harmony export */   "illegalArgument": () => (/* binding */ illegalArgument),
/* harmony export */   "illegalState": () => (/* binding */ illegalState),
/* harmony export */   "readonly": () => (/* binding */ readonly),
/* harmony export */   "disposed": () => (/* binding */ disposed),
/* harmony export */   "getErrorMessage": () => (/* binding */ getErrorMessage),
/* harmony export */   "NotImplementedError": () => (/* binding */ NotImplementedError),
/* harmony export */   "NotSupportedError": () => (/* binding */ NotSupportedError),
/* harmony export */   "ExpectedError": () => (/* binding */ ExpectedError),
/* harmony export */   "ErrorNoTelemetry": () => (/* binding */ ErrorNoTelemetry),
/* harmony export */   "BugIndicatingError": () => (/* binding */ BugIndicatingError)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// Avoid circular dependency on EventEmitter by implementing a subset of the interface.
class ErrorHandler {
  constructor() {
    this.listeners = [];

    this.unexpectedErrorHandler = function (e) {
      setTimeout(() => {
        if (e.stack) {
          if (ErrorNoTelemetry.isErrorNoTelemetry(e)) {
            throw new ErrorNoTelemetry(e.message + '\n\n' + e.stack);
          }

          throw new Error(e.message + '\n\n' + e.stack);
        }

        throw e;
      }, 0);
    };
  }

  addListener(listener) {
    this.listeners.push(listener);
    return () => {
      this._removeListener(listener);
    };
  }

  emit(e) {
    this.listeners.forEach(listener => {
      listener(e);
    });
  }

  _removeListener(listener) {
    this.listeners.splice(this.listeners.indexOf(listener), 1);
  }

  setUnexpectedErrorHandler(newUnexpectedErrorHandler) {
    this.unexpectedErrorHandler = newUnexpectedErrorHandler;
  }

  getUnexpectedErrorHandler() {
    return this.unexpectedErrorHandler;
  }

  onUnexpectedError(e) {
    this.unexpectedErrorHandler(e);
    this.emit(e);
  } // For external errors, we don't want the listeners to be called


  onUnexpectedExternalError(e) {
    this.unexpectedErrorHandler(e);
  }

}
const errorHandler = new ErrorHandler();
function setUnexpectedErrorHandler(newUnexpectedErrorHandler) {
  errorHandler.setUnexpectedErrorHandler(newUnexpectedErrorHandler);
}
function onUnexpectedError(e) {
  // ignore errors from cancelled promises
  if (!isCancellationError(e)) {
    errorHandler.onUnexpectedError(e);
  }

  return undefined;
}
function onUnexpectedExternalError(e) {
  // ignore errors from cancelled promises
  if (!isCancellationError(e)) {
    errorHandler.onUnexpectedExternalError(e);
  }

  return undefined;
}
function transformErrorForSerialization(error) {
  if (error instanceof Error) {
    const {
      name,
      message
    } = error;
    const stack = error.stacktrace || error.stack;
    return {
      $isError: true,
      name,
      message,
      stack,
      noTelemetry: ErrorNoTelemetry.isErrorNoTelemetry(error)
    };
  } // return as is


  return error;
} // see https://github.com/v8/v8/wiki/Stack%20Trace%20API#basic-stack-traces

const canceledName = 'Canceled';
/**
 * Checks if the given error is a promise in canceled state
 */

function isCancellationError(error) {
  if (error instanceof CancellationError) {
    return true;
  }

  return error instanceof Error && error.name === canceledName && error.message === canceledName;
} // !!!IMPORTANT!!!
// Do NOT change this class because it is also used as an API-type.

class CancellationError extends Error {
  constructor() {
    super(canceledName);
    this.name = this.message;
  }

}
/**
 * @deprecated use {@link CancellationError `new CancellationError()`} instead
 */

function canceled() {
  const error = new Error(canceledName);
  error.name = error.message;
  return error;
}
function illegalArgument(name) {
  if (name) {
    return new Error(`Illegal argument: ${name}`);
  } else {
    return new Error('Illegal argument');
  }
}
function illegalState(name) {
  if (name) {
    return new Error(`Illegal state: ${name}`);
  } else {
    return new Error('Illegal state');
  }
}
function readonly(name) {
  return name ? new Error(`readonly property '${name} cannot be changed'`) : new Error('readonly property cannot be changed');
}
function disposed(what) {
  const result = new Error(`${what} has been disposed`);
  result.name = 'DISPOSED';
  return result;
}
function getErrorMessage(err) {
  if (!err) {
    return 'Error';
  }

  if (err.message) {
    return err.message;
  }

  if (err.stack) {
    return err.stack.split('\n')[0];
  }

  return String(err);
}
class NotImplementedError extends Error {
  constructor(message) {
    super('NotImplemented');

    if (message) {
      this.message = message;
    }
  }

}
class NotSupportedError extends Error {
  constructor(message) {
    super('NotSupported');

    if (message) {
      this.message = message;
    }
  }

}
class ExpectedError extends Error {
  isExpected = true;
}
/**
 * Error that when thrown won't be logged in telemetry as an unhandled error.
 */

class ErrorNoTelemetry extends Error {
  constructor(msg) {
    super(msg);
    this.name = 'CodeExpectedError';
  }

  static fromError(err) {
    if (err instanceof ErrorNoTelemetry) {
      return err;
    }

    const result = new ErrorNoTelemetry();
    result.message = err.message;
    result.stack = err.stack;
    return result;
  }

  static isErrorNoTelemetry(err) {
    return err.name === 'CodeExpectedError';
  }

}
/**
 * This error indicates a bug.
 * Do not throw this for invalid user input.
 * Only catch this error to recover gracefully from bugs.
 */

class BugIndicatingError extends Error {
  constructor(message) {
    super(message || 'An unexpected bug occurred.');
    Object.setPrototypeOf(this, BugIndicatingError.prototype); // Because we know for sure only buggy code throws this,
    // we definitely want to break here and fix the bug.
    // eslint-disable-next-line no-debugger

    debugger;
  }

}

/***/ }),
/* 53 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "once": () => (/* binding */ once)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
function once(fn) {
  const _this = this;

  let didCall = false;
  let result;
  return function () {
    if (didCall) {
      return result;
    }

    didCall = true;
    result = fn.apply(_this, arguments);
    return result;
  };
}

/***/ }),
/* 54 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "setDisposableTracker": () => (/* binding */ setDisposableTracker),
/* harmony export */   "markAsSingleton": () => (/* binding */ markAsSingleton),
/* harmony export */   "isDisposable": () => (/* binding */ isDisposable),
/* harmony export */   "dispose": () => (/* binding */ dispose),
/* harmony export */   "disposeIfDisposable": () => (/* binding */ disposeIfDisposable),
/* harmony export */   "combinedDisposable": () => (/* binding */ combinedDisposable),
/* harmony export */   "toDisposable": () => (/* binding */ toDisposable),
/* harmony export */   "DisposableStore": () => (/* binding */ DisposableStore),
/* harmony export */   "Disposable": () => (/* binding */ Disposable),
/* harmony export */   "MutableDisposable": () => (/* binding */ MutableDisposable),
/* harmony export */   "RefCountedDisposable": () => (/* binding */ RefCountedDisposable),
/* harmony export */   "SafeDisposable": () => (/* binding */ SafeDisposable),
/* harmony export */   "ReferenceCollection": () => (/* binding */ ReferenceCollection),
/* harmony export */   "AsyncReferenceCollection": () => (/* binding */ AsyncReferenceCollection),
/* harmony export */   "ImmortalReference": () => (/* binding */ ImmortalReference),
/* harmony export */   "disposeOnReturn": () => (/* binding */ disposeOnReturn)
/* harmony export */ });
/* harmony import */ var _functional__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(53);
/* harmony import */ var _iterator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(55);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


/**
 * Enables logging of potentially leaked disposables.
 *
 * A disposable is considered leaked if it is not disposed or not registered as the child of
 * another disposable. This tracking is very simple an only works for classes that either
 * extend Disposable or use a DisposableStore. This means there are a lot of false positives.
 */

const TRACK_DISPOSABLES = false;
let disposableTracker = null;
function setDisposableTracker(tracker) {
  disposableTracker = tracker;
}

if (TRACK_DISPOSABLES) {
  const __is_disposable_tracked__ = '__is_disposable_tracked__';
  setDisposableTracker(new class {
    trackDisposable(x) {
      const stack = new Error('Potentially leaked disposable').stack;
      setTimeout(() => {
        if (!x[__is_disposable_tracked__]) {
          console.log(stack);
        }
      }, 3000);
    }

    setParent(child, parent) {
      if (child && child !== Disposable.None) {
        try {
          child[__is_disposable_tracked__] = true;
        } catch {// noop
        }
      }
    }

    markAsDisposed(disposable) {
      if (disposable && disposable !== Disposable.None) {
        try {
          disposable[__is_disposable_tracked__] = true;
        } catch {// noop
        }
      }
    }

    markAsSingleton(disposable) {}

  }());
}

function trackDisposable(x) {
  disposableTracker?.trackDisposable(x);
  return x;
}

function markAsDisposed(disposable) {
  disposableTracker?.markAsDisposed(disposable);
}

function setParentOfDisposable(child, parent) {
  disposableTracker?.setParent(child, parent);
}

function setParentOfDisposables(children, parent) {
  if (!disposableTracker) {
    return;
  }

  for (const child of children) {
    disposableTracker.setParent(child, parent);
  }
}
/**
 * Indicates that the given object is a singleton which does not need to be disposed.
*/


function markAsSingleton(singleton) {
  disposableTracker?.markAsSingleton(singleton);
  return singleton;
}
function isDisposable(thing) {
  return typeof thing.dispose === 'function' && thing.dispose.length === 0;
}
function dispose(arg) {
  if (_iterator__WEBPACK_IMPORTED_MODULE_1__.Iterable.is(arg)) {
    const errors = [];

    for (const d of arg) {
      if (d) {
        try {
          d.dispose();
        } catch (e) {
          errors.push(e);
        }
      }
    }

    if (errors.length === 1) {
      throw errors[0];
    } else if (errors.length > 1) {
      throw new AggregateError(errors, 'Encountered errors while disposing of store');
    }

    return Array.isArray(arg) ? [] : arg;
  } else if (arg) {
    arg.dispose();
    return arg;
  }
}
function disposeIfDisposable(disposables) {
  for (const d of disposables) {
    if (isDisposable(d)) {
      d.dispose();
    }
  }

  return [];
}
function combinedDisposable(...disposables) {
  const parent = toDisposable(() => dispose(disposables));
  setParentOfDisposables(disposables, parent);
  return parent;
}
function toDisposable(fn) {
  const self = trackDisposable({
    dispose: (0,_functional__WEBPACK_IMPORTED_MODULE_0__.once)(() => {
      markAsDisposed(self);
      fn();
    })
  });
  return self;
}
class DisposableStore {
  static DISABLE_DISPOSED_WARNING = false;
  _toDispose = new Set();
  _isDisposed = false;

  constructor() {
    trackDisposable(this);
  }
  /**
   * Dispose of all registered disposables and mark this object as disposed.
   *
   * Any future disposables added to this object will be disposed of on `add`.
   */


  dispose() {
    if (this._isDisposed) {
      return;
    }

    markAsDisposed(this);
    this._isDisposed = true;
    this.clear();
  }
  /**
   * Returns `true` if this object has been disposed
   */


  get isDisposed() {
    return this._isDisposed;
  }
  /**
   * Dispose of all registered disposables but do not mark this object as disposed.
   */


  clear() {
    try {
      dispose(this._toDispose.values());
    } finally {
      this._toDispose.clear();
    }
  }

  add(o) {
    if (!o) {
      return o;
    }

    if (o === this) {
      throw new Error('Cannot register a disposable on itself!');
    }

    setParentOfDisposable(o, this);

    if (this._isDisposed) {
      if (!DisposableStore.DISABLE_DISPOSED_WARNING) {
        console.warn(new Error('Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!').stack);
      }
    } else {
      this._toDispose.add(o);
    }

    return o;
  }

}
class Disposable {
  static None = Object.freeze({
    dispose() {}

  });
  _store = new DisposableStore();

  constructor() {
    trackDisposable(this);
    setParentOfDisposable(this._store, this);
  }

  dispose() {
    markAsDisposed(this);

    this._store.dispose();
  }

  _register(o) {
    if (o === this) {
      throw new Error('Cannot register a disposable on itself!');
    }

    return this._store.add(o);
  }

}
/**
 * Manages the lifecycle of a disposable value that may be changed.
 *
 * This ensures that when the disposable value is changed, the previously held disposable is disposed of. You can
 * also register a `MutableDisposable` on a `Disposable` to ensure it is automatically cleaned up.
 */

class MutableDisposable {
  _isDisposed = false;

  constructor() {
    trackDisposable(this);
  }

  get value() {
    return this._isDisposed ? undefined : this._value;
  }

  set value(value) {
    if (this._isDisposed || value === this._value) {
      return;
    }

    this._value?.dispose();

    if (value) {
      setParentOfDisposable(value, this);
    }

    this._value = value;
  }

  clear() {
    this.value = undefined;
  }

  dispose() {
    this._isDisposed = true;
    markAsDisposed(this);
    this._value?.dispose();
    this._value = undefined;
  }
  /**
   * Clears the value, but does not dispose it.
   * The old value is returned.
  */


  clearAndLeak() {
    const oldValue = this._value;
    this._value = undefined;

    if (oldValue) {
      setParentOfDisposable(oldValue, null);
    }

    return oldValue;
  }

}
class RefCountedDisposable {
  _counter = 1;

  constructor(_disposable) {
    this._disposable = _disposable;
  }

  acquire() {
    this._counter++;
    return this;
  }

  release() {
    if (--this._counter === 0) {
      this._disposable.dispose();
    }

    return this;
  }

}
/**
 * A safe disposable can be `unset` so that a leaked reference (listener)
 * can be cut-off.
 */

class SafeDisposable {
  dispose = () => {};
  unset = () => {};
  isset = () => false;

  constructor() {
    trackDisposable(this);
  }

  set(fn) {
    let callback = fn;

    this.unset = () => callback = undefined;

    this.isset = () => callback !== undefined;

    this.dispose = () => {
      if (callback) {
        callback();
        callback = undefined;
        markAsDisposed(this);
      }
    };

    return this;
  }

}
class ReferenceCollection {
  references = new Map();

  acquire(key, ...args) {
    let reference = this.references.get(key);

    if (!reference) {
      reference = {
        counter: 0,
        object: this.createReferencedObject(key, ...args)
      };
      this.references.set(key, reference);
    }

    const {
      object
    } = reference;
    const dispose = (0,_functional__WEBPACK_IMPORTED_MODULE_0__.once)(() => {
      if (--reference.counter === 0) {
        this.destroyReferencedObject(key, reference.object);
        this.references.delete(key);
      }
    });
    reference.counter++;
    return {
      object,
      dispose
    };
  }

}
/**
 * Unwraps a reference collection of promised values. Makes sure
 * references are disposed whenever promises get rejected.
 */

class AsyncReferenceCollection {
  constructor(referenceCollection) {
    this.referenceCollection = referenceCollection;
  }

  async acquire(key, ...args) {
    const ref = this.referenceCollection.acquire(key, ...args);

    try {
      const object = await ref.object;
      return {
        object,
        dispose: () => ref.dispose()
      };
    } catch (error) {
      ref.dispose();
      throw error;
    }
  }

}
class ImmortalReference {
  constructor(object) {
    this.object = object;
  }

  dispose() {
    /* noop */
  }

}
function disposeOnReturn(fn) {
  const store = new DisposableStore();

  try {
    fn(store);
  } finally {
    store.dispose();
  }
}

/***/ }),
/* 55 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Iterable": () => (/* binding */ Iterable)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
let Iterable;

(function (_Iterable) {
  function is(thing) {
    return thing && typeof thing === 'object' && typeof thing[Symbol.iterator] === 'function';
  }

  _Iterable.is = is;

  const _empty = Object.freeze([]);

  function empty() {
    return _empty;
  }

  _Iterable.empty = empty;

  function* single(element) {
    yield element;
  }

  _Iterable.single = single;

  function from(iterable) {
    return iterable || _empty;
  }

  _Iterable.from = from;

  function isEmpty(iterable) {
    return !iterable || iterable[Symbol.iterator]().next().done === true;
  }

  _Iterable.isEmpty = isEmpty;

  function first(iterable) {
    return iterable[Symbol.iterator]().next().value;
  }

  _Iterable.first = first;

  function some(iterable, predicate) {
    for (const element of iterable) {
      if (predicate(element)) {
        return true;
      }
    }

    return false;
  }

  _Iterable.some = some;

  function find(iterable, predicate) {
    for (const element of iterable) {
      if (predicate(element)) {
        return element;
      }
    }

    return undefined;
  }

  _Iterable.find = find;

  function* filter(iterable, predicate) {
    for (const element of iterable) {
      if (predicate(element)) {
        yield element;
      }
    }
  }

  _Iterable.filter = filter;

  function* map(iterable, fn) {
    let index = 0;

    for (const element of iterable) {
      yield fn(element, index++);
    }
  }

  _Iterable.map = map;

  function* concat(...iterables) {
    for (const iterable of iterables) {
      for (const element of iterable) {
        yield element;
      }
    }
  }

  _Iterable.concat = concat;

  function* concatNested(iterables) {
    for (const iterable of iterables) {
      for (const element of iterable) {
        yield element;
      }
    }
  }

  _Iterable.concatNested = concatNested;

  function reduce(iterable, reducer, initialValue) {
    let value = initialValue;

    for (const element of iterable) {
      value = reducer(value, element);
    }

    return value;
  }

  _Iterable.reduce = reduce;

  function forEach(iterable, fn) {
    let index = 0;

    for (const element of iterable) {
      fn(element, index++);
    }
  }

  _Iterable.forEach = forEach;

  function* slice(arr, from, to = arr.length) {
    if (from < 0) {
      from += arr.length;
    }

    if (to < 0) {
      to += arr.length;
    } else if (to > arr.length) {
      to = arr.length;
    }

    for (; from < to; from++) {
      yield arr[from];
    }
  }

  _Iterable.slice = slice;

  function consume(iterable, atMost = Number.POSITIVE_INFINITY) {
    const consumed = [];

    if (atMost === 0) {
      return [consumed, iterable];
    }

    const iterator = iterable[Symbol.iterator]();

    for (let i = 0; i < atMost; i++) {
      const next = iterator.next();

      if (next.done) {
        return [consumed, Iterable.empty()];
      }

      consumed.push(next.value);
    }

    return [consumed, {
      [Symbol.iterator]() {
        return iterator;
      }

    }];
  }

  _Iterable.consume = consume;

  function collect(iterable) {
    return consume(iterable)[0];
  }

  _Iterable.collect = collect;

  function equals(a, b, comparator = (at, bt) => at === bt) {
    const ai = a[Symbol.iterator]();
    const bi = b[Symbol.iterator]();

    while (true) {
      const an = ai.next();
      const bn = bi.next();

      if (an.done !== bn.done) {
        return false;
      } else if (an.done) {
        return true;
      } else if (!comparator(an.value, bn.value)) {
        return false;
      }
    }
  }

  _Iterable.equals = equals;
})(Iterable || (Iterable = {}));

/***/ }),
/* 56 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LinkedList": () => (/* binding */ LinkedList)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
class Node {
  static Undefined = new Node(undefined);

  constructor(element) {
    this.element = element;
    this.next = Node.Undefined;
    this.prev = Node.Undefined;
  }

}

class LinkedList {
  _first = Node.Undefined;
  _last = Node.Undefined;
  _size = 0;

  get size() {
    return this._size;
  }

  isEmpty() {
    return this._first === Node.Undefined;
  }

  clear() {
    let node = this._first;

    while (node !== Node.Undefined) {
      const next = node.next;
      node.prev = Node.Undefined;
      node.next = Node.Undefined;
      node = next;
    }

    this._first = Node.Undefined;
    this._last = Node.Undefined;
    this._size = 0;
  }

  unshift(element) {
    return this._insert(element, false);
  }

  push(element) {
    return this._insert(element, true);
  }

  _insert(element, atTheEnd) {
    const newNode = new Node(element);

    if (this._first === Node.Undefined) {
      this._first = newNode;
      this._last = newNode;
    } else if (atTheEnd) {
      // push
      const oldLast = this._last;
      this._last = newNode;
      newNode.prev = oldLast;
      oldLast.next = newNode;
    } else {
      // unshift
      const oldFirst = this._first;
      this._first = newNode;
      newNode.next = oldFirst;
      oldFirst.prev = newNode;
    }

    this._size += 1;
    let didRemove = false;
    return () => {
      if (!didRemove) {
        didRemove = true;

        this._remove(newNode);
      }
    };
  }

  shift() {
    if (this._first === Node.Undefined) {
      return undefined;
    } else {
      const res = this._first.element;

      this._remove(this._first);

      return res;
    }
  }

  pop() {
    if (this._last === Node.Undefined) {
      return undefined;
    } else {
      const res = this._last.element;

      this._remove(this._last);

      return res;
    }
  }

  _remove(node) {
    if (node.prev !== Node.Undefined && node.next !== Node.Undefined) {
      // middle
      const anchor = node.prev;
      anchor.next = node.next;
      node.next.prev = anchor;
    } else if (node.prev === Node.Undefined && node.next === Node.Undefined) {
      // only node
      this._first = Node.Undefined;
      this._last = Node.Undefined;
    } else if (node.next === Node.Undefined) {
      // last
      this._last = this._last.prev;
      this._last.next = Node.Undefined;
    } else if (node.prev === Node.Undefined) {
      // first
      this._first = this._first.next;
      this._first.prev = Node.Undefined;
    } // done


    this._size -= 1;
  }

  *[Symbol.iterator]() {
    let node = this._first;

    while (node !== Node.Undefined) {
      yield node.element;
      node = node.next;
    }
  }

}

/***/ }),
/* 57 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StopWatch": () => (/* binding */ StopWatch)
/* harmony export */ });
/* harmony import */ var _platform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(58);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

const hasPerformanceNow = _platform__WEBPACK_IMPORTED_MODULE_0__.globals.performance && typeof _platform__WEBPACK_IMPORTED_MODULE_0__.globals.performance.now === 'function';
class StopWatch {
  static create(highResolution = true) {
    return new StopWatch(highResolution);
  }

  constructor(highResolution) {
    this._highResolution = hasPerformanceNow && highResolution;
    this._startTime = this._now();
    this._stopTime = -1;
  }

  stop() {
    this._stopTime = this._now();
  }

  elapsed() {
    if (this._stopTime !== -1) {
      return this._stopTime - this._startTime;
    }

    return this._now() - this._startTime;
  }

  _now() {
    return this._highResolution ? _platform__WEBPACK_IMPORTED_MODULE_0__.globals.performance.now() : Date.now();
  }

}

/***/ }),
/* 58 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LANGUAGE_DEFAULT": () => (/* binding */ LANGUAGE_DEFAULT),
/* harmony export */   "globals": () => (/* binding */ globals),
/* harmony export */   "Platform": () => (/* binding */ Platform),
/* harmony export */   "PlatformToString": () => (/* binding */ PlatformToString),
/* harmony export */   "isWindows": () => (/* binding */ isWindows),
/* harmony export */   "isMacintosh": () => (/* binding */ isMacintosh),
/* harmony export */   "isLinux": () => (/* binding */ isLinux),
/* harmony export */   "isLinuxSnap": () => (/* binding */ isLinuxSnap),
/* harmony export */   "isNative": () => (/* binding */ isNative),
/* harmony export */   "isElectron": () => (/* binding */ isElectron),
/* harmony export */   "isWeb": () => (/* binding */ isWeb),
/* harmony export */   "isWebWorker": () => (/* binding */ isWebWorker),
/* harmony export */   "isIOS": () => (/* binding */ isIOS),
/* harmony export */   "isMobile": () => (/* binding */ isMobile),
/* harmony export */   "isCI": () => (/* binding */ isCI),
/* harmony export */   "platform": () => (/* binding */ platform),
/* harmony export */   "userAgent": () => (/* binding */ userAgent),
/* harmony export */   "language": () => (/* binding */ language),
/* harmony export */   "Language": () => (/* binding */ Language),
/* harmony export */   "locale": () => (/* binding */ locale),
/* harmony export */   "translationsConfigFile": () => (/* binding */ translationsConfigFile),
/* harmony export */   "setTimeout0IsFaster": () => (/* binding */ setTimeout0IsFaster),
/* harmony export */   "setTimeout0": () => (/* binding */ setTimeout0),
/* harmony export */   "OperatingSystem": () => (/* binding */ OperatingSystem),
/* harmony export */   "OS": () => (/* binding */ OS),
/* harmony export */   "isLittleEndian": () => (/* binding */ isLittleEndian),
/* harmony export */   "isChrome": () => (/* binding */ isChrome),
/* harmony export */   "isFirefox": () => (/* binding */ isFirefox),
/* harmony export */   "isSafari": () => (/* binding */ isSafari),
/* harmony export */   "isEdge": () => (/* binding */ isEdge),
/* harmony export */   "isAndroid": () => (/* binding */ isAndroid)
/* harmony export */ });
/* harmony import */ var _nls__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

const LANGUAGE_DEFAULT = 'en';
let _isWindows = false;
let _isMacintosh = false;
let _isLinux = false;
let _isLinuxSnap = false;
let _isNative = false;
let _isWeb = false;
let _isElectron = false;
let _isIOS = false;
let _isCI = false;
let _isMobile = false;
let _locale = undefined;
let _language = LANGUAGE_DEFAULT;
let _translationsConfigFile = undefined;
let _userAgent = undefined;
const globals = typeof self === 'object' ? self : typeof global === 'object' ? global : {};
let nodeProcess = undefined;

if (typeof globals.vscode !== 'undefined' && typeof globals.vscode.process !== 'undefined') {
  // Native environment (sandboxed)
  nodeProcess = globals.vscode.process;
} else if (typeof process !== 'undefined') {
  // Native environment (non-sandboxed)
  nodeProcess = process;
}

const isElectronProcess = typeof nodeProcess?.versions?.electron === 'string';
const isElectronRenderer = isElectronProcess && nodeProcess?.type === 'renderer';

// Web environment
if (typeof navigator === 'object' && !isElectronRenderer) {
  _userAgent = navigator.userAgent;
  _isWindows = _userAgent.indexOf('Windows') >= 0;
  _isMacintosh = _userAgent.indexOf('Macintosh') >= 0;
  _isIOS = (_userAgent.indexOf('Macintosh') >= 0 || _userAgent.indexOf('iPad') >= 0 || _userAgent.indexOf('iPhone') >= 0) && !!navigator.maxTouchPoints && navigator.maxTouchPoints > 0;
  _isLinux = _userAgent.indexOf('Linux') >= 0;
  _isMobile = _userAgent?.indexOf('Mobi') >= 0;
  _isWeb = true;
  const configuredLocale = _nls__WEBPACK_IMPORTED_MODULE_0__.getConfiguredDefaultLocale( // This call _must_ be done in the file that calls `nls.getConfiguredDefaultLocale`
  // to ensure that the NLS AMD Loader plugin has been loaded and configured.
  // This is because the loader plugin decides what the default locale is based on
  // how it's able to resolve the strings.
  _nls__WEBPACK_IMPORTED_MODULE_0__.localize({
    key: 'ensureLoaderPluginIsLoaded',
    comment: ['{Locked}']
  }, '_'));
  _locale = configuredLocale || LANGUAGE_DEFAULT;
  _language = _locale;
} // Native environment
else if (typeof nodeProcess === 'object') {
  _isWindows = nodeProcess.platform === 'win32';
  _isMacintosh = nodeProcess.platform === 'darwin';
  _isLinux = nodeProcess.platform === 'linux';
  _isLinuxSnap = _isLinux && !!nodeProcess.env['SNAP'] && !!nodeProcess.env['SNAP_REVISION'];
  _isElectron = isElectronProcess;
  _isCI = !!nodeProcess.env['CI'] || !!nodeProcess.env['BUILD_ARTIFACTSTAGINGDIRECTORY'];
  _locale = LANGUAGE_DEFAULT;
  _language = LANGUAGE_DEFAULT;
  const rawNlsConfig = nodeProcess.env['VSCODE_NLS_CONFIG'];

  if (rawNlsConfig) {
    try {
      const nlsConfig = JSON.parse(rawNlsConfig);
      const resolved = nlsConfig.availableLanguages['*'];
      _locale = nlsConfig.locale; // VSCode's default language is 'en'

      _language = resolved ? resolved : LANGUAGE_DEFAULT;
      _translationsConfigFile = nlsConfig._translationsConfigFile;
    } catch (e) {}
  }

  _isNative = true;
} // Unknown environment
else {
  console.error('Unable to resolve platform.');
}

let Platform;

(function (Platform) {
  Platform[Platform["Web"] = 0] = "Web";
  Platform[Platform["Mac"] = 1] = "Mac";
  Platform[Platform["Linux"] = 2] = "Linux";
  Platform[Platform["Windows"] = 3] = "Windows";
})(Platform || (Platform = {}));

function PlatformToString(platform) {
  switch (platform) {
    case Platform.Web:
      return 'Web';

    case Platform.Mac:
      return 'Mac';

    case Platform.Linux:
      return 'Linux';

    case Platform.Windows:
      return 'Windows';
  }
}
let _platform = Platform.Web;

if (_isMacintosh) {
  _platform = Platform.Mac;
} else if (_isWindows) {
  _platform = Platform.Windows;
} else if (_isLinux) {
  _platform = Platform.Linux;
}

const isWindows = _isWindows;
const isMacintosh = _isMacintosh;
const isLinux = _isLinux;
const isLinuxSnap = _isLinuxSnap;
const isNative = _isNative;
const isElectron = _isElectron;
const isWeb = _isWeb;
const isWebWorker = _isWeb && typeof globals.importScripts === 'function';
const isIOS = _isIOS;
const isMobile = _isMobile;
/**
 * Whether we run inside a CI environment, such as
 * GH actions or Azure Pipelines.
 */

const isCI = _isCI;
const platform = _platform;
const userAgent = _userAgent;
/**
 * The language used for the user interface. The format of
 * the string is all lower case (e.g. zh-tw for Traditional
 * Chinese)
 */

const language = _language;
let Language;
/**
 * The OS locale or the locale specified by --locale. The format of
 * the string is all lower case (e.g. zh-tw for Traditional
 * Chinese). The UI is not necessarily shown in the provided locale.
 */

(function (_Language) {
  function value() {
    return language;
  }

  _Language.value = value;

  function isDefaultVariant() {
    if (language.length === 2) {
      return language === 'en';
    } else if (language.length >= 3) {
      return language[0] === 'e' && language[1] === 'n' && language[2] === '-';
    } else {
      return false;
    }
  }

  _Language.isDefaultVariant = isDefaultVariant;

  function isDefault() {
    return language === 'en';
  }

  _Language.isDefault = isDefault;
})(Language || (Language = {}));

const locale = _locale;
/**
 * The translations that are available through language packs.
 */

const translationsConfigFile = _translationsConfigFile;
const setTimeout0IsFaster = typeof globals.postMessage === 'function' && !globals.importScripts;
/**
 * See https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#:~:text=than%204%2C%20then-,set%20timeout%20to%204,-.
 *
 * Works similarly to `setTimeout(0)` but doesn't suffer from the 4ms artificial delay
 * that browsers set when the nesting level is > 5.
 */

const setTimeout0 = (() => {
  if (setTimeout0IsFaster) {
    const pending = [];
    globals.addEventListener('message', e => {
      if (e.data && e.data.vscodeScheduleAsyncWork) {
        for (let i = 0, len = pending.length; i < len; i++) {
          const candidate = pending[i];

          if (candidate.id === e.data.vscodeScheduleAsyncWork) {
            pending.splice(i, 1);
            candidate.callback();
            return;
          }
        }
      }
    });
    let lastId = 0;
    return callback => {
      const myId = ++lastId;
      pending.push({
        id: myId,
        callback: callback
      });
      globals.postMessage({
        vscodeScheduleAsyncWork: myId
      }, '*');
    };
  }

  return callback => setTimeout(callback);
})();
let OperatingSystem;

(function (OperatingSystem) {
  OperatingSystem[OperatingSystem["Windows"] = 1] = "Windows";
  OperatingSystem[OperatingSystem["Macintosh"] = 2] = "Macintosh";
  OperatingSystem[OperatingSystem["Linux"] = 3] = "Linux";
})(OperatingSystem || (OperatingSystem = {}));

const OS = _isMacintosh || _isIOS ? OperatingSystem.Macintosh : _isWindows ? OperatingSystem.Windows : OperatingSystem.Linux;
let _isLittleEndian = true;
let _isLittleEndianComputed = false;
function isLittleEndian() {
  if (!_isLittleEndianComputed) {
    _isLittleEndianComputed = true;
    const test = new Uint8Array(2);
    test[0] = 1;
    test[1] = 2;
    const view = new Uint16Array(test.buffer);
    _isLittleEndian = view[0] === (2 << 8) + 1;
  }

  return _isLittleEndian;
}
const isChrome = !!(userAgent && userAgent.indexOf('Chrome') >= 0);
const isFirefox = !!(userAgent && userAgent.indexOf('Firefox') >= 0);
const isSafari = !!(!isChrome && userAgent && userAgent.indexOf('Safari') >= 0);
const isEdge = !!(userAgent && userAgent.indexOf('Edg/') >= 0);
const isAndroid = !!(userAgent && userAgent.indexOf('Android') >= 0);

/***/ }),
/* 59 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "localize": () => (/* binding */ localize),
/* harmony export */   "getConfiguredDefaultLocale": () => (/* binding */ getConfiguredDefaultLocale),
/* harmony export */   "setPseudoTranslation": () => (/* binding */ setPseudoTranslation),
/* harmony export */   "create": () => (/* binding */ create)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
let isPseudo = typeof document !== 'undefined' && document.location && document.location.hash.indexOf('pseudo=true') >= 0;

function _format(message, args) {
  let result;

  if (args.length === 0) {
    result = message;
  } else {
    result = message.replace(/\{(\d+)\}/g, (match, rest) => {
      const index = rest[0];
      const arg = args[index];
      let result = match;

      if (typeof arg === 'string') {
        result = arg;
      } else if (typeof arg === 'number' || typeof arg === 'boolean' || arg === void 0 || arg === null) {
        result = String(arg);
      }

      return result;
    });
  }

  if (isPseudo) {
    // FF3B and FF3D is the Unicode zenkaku representation for [ and ]
    result = '\uFF3B' + result.replace(/[aouei]/g, '$&$&') + '\uFF3D';
  }

  return result;
}

function endWithSlash(path) {
  if (path.charAt(path.length - 1) === '/') {
    return path;
  }

  return path + '/';
}

async function getMessagesFromTranslationsService(translationServiceUrl, language, name) {
  const url = endWithSlash(translationServiceUrl) + endWithSlash(language) + 'vscode/' + endWithSlash(name);
  const res = await fetch(url);

  if (res.ok) {
    const messages = await res.json();
    return messages;
  }

  throw new Error(`${res.status} - ${res.statusText}`);
}

function createScopedLocalize(scope) {
  return function (idx, defaultValue) {
    const restArgs = Array.prototype.slice.call(arguments, 2);
    return _format(scope[idx], restArgs);
  };
}
/**
 * Localize a message.
 *
 * `message` can contain `{n}` notation where it is replaced by the nth value in `...args`
 * For example, `localize({ key: 'sayHello', comment: ['Welcomes user'] }, 'hello {0}', name)`
 */


function localize(data, message, ...args) {
  return _format(message, args);
}
/**
 *
 * @param stringFromLocalizeCall You must pass in a string that was returned from a `nls.localize()` call
 * in order to ensure the loader plugin has been initialized before this function is called.
 */

function getConfiguredDefaultLocale(_) {
  // This returns undefined because this implementation isn't used and is overwritten by the loader
  // when loaded.
  return undefined;
}
function setPseudoTranslation(value) {
  isPseudo = value;
}
/**
 * Invoked in a built product at run-time
 */

function create(key, data) {
  return {
    localize: createScopedLocalize(data[key]),
    getConfiguredDefaultLocale: data.getConfiguredDefaultLocale ?? (_ => undefined)
  };
}

/***/ }),
/* 60 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DelayedDragHandler": () => (/* binding */ DelayedDragHandler),
/* harmony export */   "DataTransfers": () => (/* binding */ DataTransfers),
/* harmony export */   "applyDragImage": () => (/* binding */ applyDragImage)
/* harmony export */ });
/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(61);
/* harmony import */ var _common_lifecycle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(54);
/* harmony import */ var _common_mime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(84);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/



/**
 * A helper that will execute a provided function when the provided HTMLElement receives
 *  dragover event for 800ms. If the drag is aborted before, the callback will not be triggered.
 */

class DelayedDragHandler extends _common_lifecycle__WEBPACK_IMPORTED_MODULE_1__.Disposable {
  constructor(container, callback) {
    super();

    this._register((0,_dom__WEBPACK_IMPORTED_MODULE_0__.addDisposableListener)(container, 'dragover', e => {
      e.preventDefault(); // needed so that the drop event fires (https://stackoverflow.com/questions/21339924/drop-event-not-firing-in-chrome)

      if (!this.timeout) {
        this.timeout = setTimeout(() => {
          callback();
          this.timeout = null;
        }, 800);
      }
    }));

    ['dragleave', 'drop', 'dragend'].forEach(type => {
      this._register((0,_dom__WEBPACK_IMPORTED_MODULE_0__.addDisposableListener)(container, type, () => {
        this.clearDragTimeout();
      }));
    });
  }

  clearDragTimeout() {
    if (this.timeout) {
      clearTimeout(this.timeout);
      this.timeout = null;
    }
  }

  dispose() {
    super.dispose();
    this.clearDragTimeout();
  }

} // Common data transfers

const DataTransfers = {
  /**
   * Application specific resource transfer type
   */
  RESOURCES: 'ResourceURLs',

  /**
   * Browser specific transfer type to download
   */
  DOWNLOAD_URL: 'DownloadURL',

  /**
   * Browser specific transfer type for files
   */
  FILES: 'Files',

  /**
   * Typically transfer type for copy/paste transfers.
   */
  TEXT: _common_mime__WEBPACK_IMPORTED_MODULE_2__.Mimes.text
};
function applyDragImage(event, label, clazz) {
  const dragImage = document.createElement('div');
  dragImage.className = clazz;
  dragImage.textContent = label;

  if (event.dataTransfer) {
    document.body.appendChild(dragImage);
    event.dataTransfer.setDragImage(dragImage, -10, -10); // Removes the element when the DND operation is done

    setTimeout(() => document.body.removeChild(dragImage), 0);
  }
}

/***/ }),
/* 61 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "clearNode": () => (/* binding */ clearNode),
/* harmony export */   "isInDOM": () => (/* binding */ isInDOM),
/* harmony export */   "addDisposableListener": () => (/* binding */ addDisposableListener),
/* harmony export */   "addStandardDisposableListener": () => (/* binding */ addStandardDisposableListener),
/* harmony export */   "addStandardDisposableGenericMouseDownListener": () => (/* binding */ addStandardDisposableGenericMouseDownListener),
/* harmony export */   "addStandardDisposableGenericMouseUpListener": () => (/* binding */ addStandardDisposableGenericMouseUpListener),
/* harmony export */   "addDisposableGenericMouseDownListener": () => (/* binding */ addDisposableGenericMouseDownListener),
/* harmony export */   "addDisposableGenericMouseMoveListener": () => (/* binding */ addDisposableGenericMouseMoveListener),
/* harmony export */   "addDisposableGenericMouseUpListener": () => (/* binding */ addDisposableGenericMouseUpListener),
/* harmony export */   "runAtThisOrScheduleAtNextAnimationFrame": () => (/* binding */ runAtThisOrScheduleAtNextAnimationFrame),
/* harmony export */   "scheduleAtNextAnimationFrame": () => (/* binding */ scheduleAtNextAnimationFrame),
/* harmony export */   "measure": () => (/* binding */ measure),
/* harmony export */   "modify": () => (/* binding */ modify),
/* harmony export */   "addDisposableThrottledListener": () => (/* binding */ addDisposableThrottledListener),
/* harmony export */   "getComputedStyle": () => (/* binding */ getComputedStyle),
/* harmony export */   "getClientArea": () => (/* binding */ getClientArea),
/* harmony export */   "Dimension": () => (/* binding */ Dimension),
/* harmony export */   "getTopLeftOffset": () => (/* binding */ getTopLeftOffset),
/* harmony export */   "size": () => (/* binding */ size),
/* harmony export */   "position": () => (/* binding */ position),
/* harmony export */   "getDomNodePagePosition": () => (/* binding */ getDomNodePagePosition),
/* harmony export */   "getDomNodeZoomLevel": () => (/* binding */ getDomNodeZoomLevel),
/* harmony export */   "getTotalWidth": () => (/* binding */ getTotalWidth),
/* harmony export */   "getContentWidth": () => (/* binding */ getContentWidth),
/* harmony export */   "getTotalScrollWidth": () => (/* binding */ getTotalScrollWidth),
/* harmony export */   "getContentHeight": () => (/* binding */ getContentHeight),
/* harmony export */   "getTotalHeight": () => (/* binding */ getTotalHeight),
/* harmony export */   "getLargestChildWidth": () => (/* binding */ getLargestChildWidth),
/* harmony export */   "isAncestor": () => (/* binding */ isAncestor),
/* harmony export */   "setParentFlowTo": () => (/* binding */ setParentFlowTo),
/* harmony export */   "isAncestorUsingFlowTo": () => (/* binding */ isAncestorUsingFlowTo),
/* harmony export */   "findParentWithClass": () => (/* binding */ findParentWithClass),
/* harmony export */   "hasParentWithClass": () => (/* binding */ hasParentWithClass),
/* harmony export */   "isShadowRoot": () => (/* binding */ isShadowRoot),
/* harmony export */   "isInShadowDOM": () => (/* binding */ isInShadowDOM),
/* harmony export */   "getShadowRoot": () => (/* binding */ getShadowRoot),
/* harmony export */   "getActiveElement": () => (/* binding */ getActiveElement),
/* harmony export */   "createStyleSheet": () => (/* binding */ createStyleSheet),
/* harmony export */   "createMetaElement": () => (/* binding */ createMetaElement),
/* harmony export */   "createCSSRule": () => (/* binding */ createCSSRule),
/* harmony export */   "removeCSSRulesContainingSelector": () => (/* binding */ removeCSSRulesContainingSelector),
/* harmony export */   "isHTMLElement": () => (/* binding */ isHTMLElement),
/* harmony export */   "EventType": () => (/* binding */ EventType),
/* harmony export */   "EventHelper": () => (/* binding */ EventHelper),
/* harmony export */   "saveParentsScrollTop": () => (/* binding */ saveParentsScrollTop),
/* harmony export */   "restoreParentsScrollTop": () => (/* binding */ restoreParentsScrollTop),
/* harmony export */   "trackFocus": () => (/* binding */ trackFocus),
/* harmony export */   "after": () => (/* binding */ after),
/* harmony export */   "append": () => (/* binding */ append),
/* harmony export */   "prepend": () => (/* binding */ prepend),
/* harmony export */   "reset": () => (/* binding */ reset),
/* harmony export */   "Namespace": () => (/* binding */ Namespace),
/* harmony export */   "$": () => (/* binding */ $),
/* harmony export */   "join": () => (/* binding */ join),
/* harmony export */   "show": () => (/* binding */ show),
/* harmony export */   "hide": () => (/* binding */ hide),
/* harmony export */   "removeTabIndexAndUpdateFocus": () => (/* binding */ removeTabIndexAndUpdateFocus),
/* harmony export */   "finalHandler": () => (/* binding */ finalHandler),
/* harmony export */   "domContentLoaded": () => (/* binding */ domContentLoaded),
/* harmony export */   "computeScreenAwareSize": () => (/* binding */ computeScreenAwareSize),
/* harmony export */   "windowOpenNoOpener": () => (/* binding */ windowOpenNoOpener),
/* harmony export */   "windowOpenPopup": () => (/* binding */ windowOpenPopup),
/* harmony export */   "windowOpenWithSuccess": () => (/* binding */ windowOpenWithSuccess),
/* harmony export */   "animate": () => (/* binding */ animate),
/* harmony export */   "asCSSUrl": () => (/* binding */ asCSSUrl),
/* harmony export */   "asCSSPropertyValue": () => (/* binding */ asCSSPropertyValue),
/* harmony export */   "triggerDownload": () => (/* binding */ triggerDownload),
/* harmony export */   "triggerUpload": () => (/* binding */ triggerUpload),
/* harmony export */   "DetectedFullscreenMode": () => (/* binding */ DetectedFullscreenMode),
/* harmony export */   "detectFullscreen": () => (/* binding */ detectFullscreen),
/* harmony export */   "hookDomPurifyHrefAndSrcSanitizer": () => (/* binding */ hookDomPurifyHrefAndSrcSanitizer),
/* harmony export */   "basicMarkupHtmlTags": () => (/* binding */ basicMarkupHtmlTags),
/* harmony export */   "safeInnerHtml": () => (/* binding */ safeInnerHtml),
/* harmony export */   "multibyteAwareBtoa": () => (/* binding */ multibyteAwareBtoa),
/* harmony export */   "ModifierKeyEmitter": () => (/* binding */ ModifierKeyEmitter),
/* harmony export */   "getCookieValue": () => (/* binding */ getCookieValue),
/* harmony export */   "DragAndDropObserver": () => (/* binding */ DragAndDropObserver),
/* harmony export */   "computeClippingRect": () => (/* binding */ computeClippingRect),
/* harmony export */   "h": () => (/* binding */ h)
/* harmony export */ });
/* harmony import */ var _browser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(50);
/* harmony import */ var _canIUse__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(62);
/* harmony import */ var _keyboardEvent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(63);
/* harmony import */ var _mouseEvent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(66);
/* harmony import */ var _common_async__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(68);
/* harmony import */ var _common_errors__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(52);
/* harmony import */ var _common_event__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(51);
/* harmony import */ var _dompurify_dompurify__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(83);
/* harmony import */ var _dompurify_dompurify__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_dompurify_dompurify__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _common_keyCodes__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(64);
/* harmony import */ var _common_lifecycle__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(54);
/* harmony import */ var _common_network__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(80);
/* harmony import */ var _common_platform__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(58);
/* harmony import */ var _common_types__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(79);
/* harmony import */ var _common_uri__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(81);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/














function clearNode(node) {
  while (node.firstChild) {
    node.firstChild.remove();
  }
}
/**
 * @deprecated Use node.isConnected directly
 */

function isInDOM(node) {
  return node?.isConnected ?? false;
}

class DomListener {
  constructor(node, type, handler, options) {
    this._node = node;
    this._type = type;
    this._handler = handler;
    this._options = options || false;

    this._node.addEventListener(this._type, this._handler, this._options);
  }

  dispose() {
    if (!this._handler) {
      // Already disposed
      return;
    }

    this._node.removeEventListener(this._type, this._handler, this._options); // Prevent leakers from holding on to the dom or handler func


    this._node = null;
    this._handler = null;
  }

}

function addDisposableListener(node, type, handler, useCaptureOrOptions) {
  return new DomListener(node, type, handler, useCaptureOrOptions);
}

function _wrapAsStandardMouseEvent(handler) {
  return function (e) {
    return handler(new _mouseEvent__WEBPACK_IMPORTED_MODULE_3__.StandardMouseEvent(e));
  };
}

function _wrapAsStandardKeyboardEvent(handler) {
  return function (e) {
    return handler(new _keyboardEvent__WEBPACK_IMPORTED_MODULE_2__.StandardKeyboardEvent(e));
  };
}

const addStandardDisposableListener = function addStandardDisposableListener(node, type, handler, useCapture) {
  let wrapHandler = handler;

  if (type === 'click' || type === 'mousedown') {
    wrapHandler = _wrapAsStandardMouseEvent(handler);
  } else if (type === 'keydown' || type === 'keypress' || type === 'keyup') {
    wrapHandler = _wrapAsStandardKeyboardEvent(handler);
  }

  return addDisposableListener(node, type, wrapHandler, useCapture);
};
const addStandardDisposableGenericMouseDownListener = function addStandardDisposableListener(node, handler, useCapture) {
  const wrapHandler = _wrapAsStandardMouseEvent(handler);

  return addDisposableGenericMouseDownListener(node, wrapHandler, useCapture);
};
const addStandardDisposableGenericMouseUpListener = function addStandardDisposableListener(node, handler, useCapture) {
  const wrapHandler = _wrapAsStandardMouseEvent(handler);

  return addDisposableGenericMouseUpListener(node, wrapHandler, useCapture);
};
function addDisposableGenericMouseDownListener(node, handler, useCapture) {
  return addDisposableListener(node, _common_platform__WEBPACK_IMPORTED_MODULE_11__.isIOS && _canIUse__WEBPACK_IMPORTED_MODULE_1__.BrowserFeatures.pointerEvents ? EventType.POINTER_DOWN : EventType.MOUSE_DOWN, handler, useCapture);
}
function addDisposableGenericMouseMoveListener(node, handler, useCapture) {
  return addDisposableListener(node, _common_platform__WEBPACK_IMPORTED_MODULE_11__.isIOS && _canIUse__WEBPACK_IMPORTED_MODULE_1__.BrowserFeatures.pointerEvents ? EventType.POINTER_MOVE : EventType.MOUSE_MOVE, handler, useCapture);
}
function addDisposableGenericMouseUpListener(node, handler, useCapture) {
  return addDisposableListener(node, _common_platform__WEBPACK_IMPORTED_MODULE_11__.isIOS && _canIUse__WEBPACK_IMPORTED_MODULE_1__.BrowserFeatures.pointerEvents ? EventType.POINTER_UP : EventType.MOUSE_UP, handler, useCapture);
}
/**
 * Schedule a callback to be run at the next animation frame.
 * This allows multiple parties to register callbacks that should run at the next animation frame.
 * If currently in an animation frame, `runner` will be executed immediately.
 * @return token that can be used to cancel the scheduled runner (only if `runner` was not executed immediately).
 */

let runAtThisOrScheduleAtNextAnimationFrame;
/**
 * Schedule a callback to be run at the next animation frame.
 * This allows multiple parties to register callbacks that should run at the next animation frame.
 * If currently in an animation frame, `runner` will be executed at the next animation frame.
 * @return token that can be used to cancel the scheduled runner.
 */

let scheduleAtNextAnimationFrame;

class AnimationFrameQueueItem {
  constructor(runner, priority = 0) {
    this._runner = runner;
    this.priority = priority;
    this._canceled = false;
  }

  dispose() {
    this._canceled = true;
  }

  execute() {
    if (this._canceled) {
      return;
    }

    try {
      this._runner();
    } catch (e) {
      (0,_common_errors__WEBPACK_IMPORTED_MODULE_5__.onUnexpectedError)(e);
    }
  } // Sort by priority (largest to lowest)


  static sort(a, b) {
    return b.priority - a.priority;
  }

}

(function () {
  /**
   * The runners scheduled at the next animation frame
   */
  let NEXT_QUEUE = [];
  /**
   * The runners scheduled at the current animation frame
   */

  let CURRENT_QUEUE = null;
  /**
   * A flag to keep track if the native requestAnimationFrame was already called
   */

  let animFrameRequested = false;
  /**
   * A flag to indicate if currently handling a native requestAnimationFrame callback
   */

  let inAnimationFrameRunner = false;

  const animationFrameRunner = () => {
    animFrameRequested = false;
    CURRENT_QUEUE = NEXT_QUEUE;
    NEXT_QUEUE = [];
    inAnimationFrameRunner = true;

    while (CURRENT_QUEUE.length > 0) {
      CURRENT_QUEUE.sort(AnimationFrameQueueItem.sort);
      const top = CURRENT_QUEUE.shift();
      top.execute();
    }

    inAnimationFrameRunner = false;
  };

  scheduleAtNextAnimationFrame = (runner, priority = 0) => {
    const item = new AnimationFrameQueueItem(runner, priority);
    NEXT_QUEUE.push(item);

    if (!animFrameRequested) {
      animFrameRequested = true;
      requestAnimationFrame(animationFrameRunner);
    }

    return item;
  };

  runAtThisOrScheduleAtNextAnimationFrame = (runner, priority) => {
    if (inAnimationFrameRunner) {
      const item = new AnimationFrameQueueItem(runner, priority);
      CURRENT_QUEUE.push(item);
      return item;
    } else {
      return scheduleAtNextAnimationFrame(runner, priority);
    }
  };
})();

function measure(callback) {
  return scheduleAtNextAnimationFrame(callback, 10000
  /* must be early */
  );
}
function modify(callback) {
  return scheduleAtNextAnimationFrame(callback, -10000
  /* must be late */
  );
}
/**
 * Add a throttled listener. `handler` is fired at most every 8.33333ms or with the next animation frame (if browser supports it).
 */

const MINIMUM_TIME_MS = 8;

const DEFAULT_EVENT_MERGER = function (lastEvent, currentEvent) {
  return currentEvent;
};

class TimeoutThrottledDomListener extends _common_lifecycle__WEBPACK_IMPORTED_MODULE_9__.Disposable {
  constructor(node, type, handler, eventMerger = DEFAULT_EVENT_MERGER, minimumTimeMs = MINIMUM_TIME_MS) {
    super();
    let lastEvent = null;
    let lastHandlerTime = 0;

    const timeout = this._register(new _common_async__WEBPACK_IMPORTED_MODULE_4__.TimeoutTimer());

    const invokeHandler = () => {
      lastHandlerTime = new Date().getTime();
      handler(lastEvent);
      lastEvent = null;
    };

    this._register(addDisposableListener(node, type, e => {
      lastEvent = eventMerger(lastEvent, e);
      const elapsedTime = new Date().getTime() - lastHandlerTime;

      if (elapsedTime >= minimumTimeMs) {
        timeout.cancel();
        invokeHandler();
      } else {
        timeout.setIfNotSet(invokeHandler, minimumTimeMs - elapsedTime);
      }
    }));
  }

}

function addDisposableThrottledListener(node, type, handler, eventMerger, minimumTimeMs) {
  return new TimeoutThrottledDomListener(node, type, handler, eventMerger, minimumTimeMs);
}
function getComputedStyle(el) {
  return document.defaultView.getComputedStyle(el, null);
}
function getClientArea(element) {
  // Try with DOM clientWidth / clientHeight
  if (element !== document.body) {
    return new Dimension(element.clientWidth, element.clientHeight);
  } // If visual view port exits and it's on mobile, it should be used instead of window innerWidth / innerHeight, or document.body.clientWidth / document.body.clientHeight


  if (_common_platform__WEBPACK_IMPORTED_MODULE_11__.isIOS && window.visualViewport) {
    return new Dimension(window.visualViewport.width, window.visualViewport.height);
  } // Try innerWidth / innerHeight


  if (window.innerWidth && window.innerHeight) {
    return new Dimension(window.innerWidth, window.innerHeight);
  } // Try with document.body.clientWidth / document.body.clientHeight


  if (document.body && document.body.clientWidth && document.body.clientHeight) {
    return new Dimension(document.body.clientWidth, document.body.clientHeight);
  } // Try with document.documentElement.clientWidth / document.documentElement.clientHeight


  if (document.documentElement && document.documentElement.clientWidth && document.documentElement.clientHeight) {
    return new Dimension(document.documentElement.clientWidth, document.documentElement.clientHeight);
  }

  throw new Error('Unable to figure out browser width and height');
}

class SizeUtils {
  // Adapted from WinJS
  // Converts a CSS positioning string for the specified element to pixels.
  static convertToPixels(element, value) {
    return parseFloat(value) || 0;
  }

  static getDimension(element, cssPropertyName, jsPropertyName) {
    const computedStyle = getComputedStyle(element);
    const value = computedStyle ? computedStyle.getPropertyValue(cssPropertyName) : '0';
    return SizeUtils.convertToPixels(element, value);
  }

  static getBorderLeftWidth(element) {
    return SizeUtils.getDimension(element, 'border-left-width', 'borderLeftWidth');
  }

  static getBorderRightWidth(element) {
    return SizeUtils.getDimension(element, 'border-right-width', 'borderRightWidth');
  }

  static getBorderTopWidth(element) {
    return SizeUtils.getDimension(element, 'border-top-width', 'borderTopWidth');
  }

  static getBorderBottomWidth(element) {
    return SizeUtils.getDimension(element, 'border-bottom-width', 'borderBottomWidth');
  }

  static getPaddingLeft(element) {
    return SizeUtils.getDimension(element, 'padding-left', 'paddingLeft');
  }

  static getPaddingRight(element) {
    return SizeUtils.getDimension(element, 'padding-right', 'paddingRight');
  }

  static getPaddingTop(element) {
    return SizeUtils.getDimension(element, 'padding-top', 'paddingTop');
  }

  static getPaddingBottom(element) {
    return SizeUtils.getDimension(element, 'padding-bottom', 'paddingBottom');
  }

  static getMarginLeft(element) {
    return SizeUtils.getDimension(element, 'margin-left', 'marginLeft');
  }

  static getMarginTop(element) {
    return SizeUtils.getDimension(element, 'margin-top', 'marginTop');
  }

  static getMarginRight(element) {
    return SizeUtils.getDimension(element, 'margin-right', 'marginRight');
  }

  static getMarginBottom(element) {
    return SizeUtils.getDimension(element, 'margin-bottom', 'marginBottom');
  }

} // ----------------------------------------------------------------------------------------
// Position & Dimension


class Dimension {
  static None = new Dimension(0, 0);

  constructor(width, height) {
    this.width = width;
    this.height = height;
  }

  with(width = this.width, height = this.height) {
    if (width !== this.width || height !== this.height) {
      return new Dimension(width, height);
    } else {
      return this;
    }
  }

  static is(obj) {
    return typeof obj === 'object' && typeof obj.height === 'number' && typeof obj.width === 'number';
  }

  static lift(obj) {
    if (obj instanceof Dimension) {
      return obj;
    } else {
      return new Dimension(obj.width, obj.height);
    }
  }

  static equals(a, b) {
    if (a === b) {
      return true;
    }

    if (!a || !b) {
      return false;
    }

    return a.width === b.width && a.height === b.height;
  }

}
function getTopLeftOffset(element) {
  // Adapted from WinJS.Utilities.getPosition
  // and added borders to the mix
  let offsetParent = element.offsetParent;
  let top = element.offsetTop;
  let left = element.offsetLeft;

  while ((element = element.parentNode) !== null && element !== document.body && element !== document.documentElement) {
    top -= element.scrollTop;
    const c = isShadowRoot(element) ? null : getComputedStyle(element);

    if (c) {
      left -= c.direction !== 'rtl' ? element.scrollLeft : -element.scrollLeft;
    }

    if (element === offsetParent) {
      left += SizeUtils.getBorderLeftWidth(element);
      top += SizeUtils.getBorderTopWidth(element);
      top += element.offsetTop;
      left += element.offsetLeft;
      offsetParent = element.offsetParent;
    }
  }

  return {
    left: left,
    top: top
  };
}
function size(element, width, height) {
  if (typeof width === 'number') {
    element.style.width = `${width}px`;
  }

  if (typeof height === 'number') {
    element.style.height = `${height}px`;
  }
}
function position(element, top, right, bottom, left, position = 'absolute') {
  if (typeof top === 'number') {
    element.style.top = `${top}px`;
  }

  if (typeof right === 'number') {
    element.style.right = `${right}px`;
  }

  if (typeof bottom === 'number') {
    element.style.bottom = `${bottom}px`;
  }

  if (typeof left === 'number') {
    element.style.left = `${left}px`;
  }

  element.style.position = position;
}
/**
 * Returns the position of a dom node relative to the entire page.
 */

function getDomNodePagePosition(domNode) {
  const bb = domNode.getBoundingClientRect();
  return {
    left: bb.left + window.scrollX,
    top: bb.top + window.scrollY,
    width: bb.width,
    height: bb.height
  };
}
/**
 * Returns the effective zoom on a given element before window zoom level is applied
 */

function getDomNodeZoomLevel(domNode) {
  let testElement = domNode;
  let zoom = 1.0;

  do {
    const elementZoomLevel = getComputedStyle(testElement).zoom;

    if (elementZoomLevel !== null && elementZoomLevel !== undefined && elementZoomLevel !== '1') {
      zoom *= elementZoomLevel;
    }

    testElement = testElement.parentElement;
  } while (testElement !== null && testElement !== document.documentElement);

  return zoom;
} // Adapted from WinJS
// Gets the width of the element, including margins.

function getTotalWidth(element) {
  const margin = SizeUtils.getMarginLeft(element) + SizeUtils.getMarginRight(element);
  return element.offsetWidth + margin;
}
function getContentWidth(element) {
  const border = SizeUtils.getBorderLeftWidth(element) + SizeUtils.getBorderRightWidth(element);
  const padding = SizeUtils.getPaddingLeft(element) + SizeUtils.getPaddingRight(element);
  return element.offsetWidth - border - padding;
}
function getTotalScrollWidth(element) {
  const margin = SizeUtils.getMarginLeft(element) + SizeUtils.getMarginRight(element);
  return element.scrollWidth + margin;
} // Adapted from WinJS
// Gets the height of the content of the specified element. The content height does not include borders or padding.

function getContentHeight(element) {
  const border = SizeUtils.getBorderTopWidth(element) + SizeUtils.getBorderBottomWidth(element);
  const padding = SizeUtils.getPaddingTop(element) + SizeUtils.getPaddingBottom(element);
  return element.offsetHeight - border - padding;
} // Adapted from WinJS
// Gets the height of the element, including its margins.

function getTotalHeight(element) {
  const margin = SizeUtils.getMarginTop(element) + SizeUtils.getMarginBottom(element);
  return element.offsetHeight + margin;
} // Gets the left coordinate of the specified element relative to the specified parent.

function getRelativeLeft(element, parent) {
  if (element === null) {
    return 0;
  }

  const elementPosition = getTopLeftOffset(element);
  const parentPosition = getTopLeftOffset(parent);
  return elementPosition.left - parentPosition.left;
}

function getLargestChildWidth(parent, children) {
  const childWidths = children.map(child => {
    return Math.max(getTotalScrollWidth(child), getTotalWidth(child)) + getRelativeLeft(child, parent) || 0;
  });
  const maxWidth = Math.max(...childWidths);
  return maxWidth;
} // ----------------------------------------------------------------------------------------

function isAncestor(testChild, testAncestor) {
  while (testChild) {
    if (testChild === testAncestor) {
      return true;
    }

    testChild = testChild.parentNode;
  }

  return false;
}
const parentFlowToDataKey = 'parentFlowToElementId';
/**
 * Set an explicit parent to use for nodes that are not part of the
 * regular dom structure.
 */

function setParentFlowTo(fromChildElement, toParentElement) {
  fromChildElement.dataset[parentFlowToDataKey] = toParentElement.id;
}

function getParentFlowToElement(node) {
  const flowToParentId = node.dataset[parentFlowToDataKey];

  if (typeof flowToParentId === 'string') {
    return document.getElementById(flowToParentId);
  }

  return null;
}
/**
 * Check if `testAncestor` is an ancestor of `testChild`, observing the explicit
 * parents set by `setParentFlowTo`.
 */


function isAncestorUsingFlowTo(testChild, testAncestor) {
  let node = testChild;

  while (node) {
    if (node === testAncestor) {
      return true;
    }

    if (node instanceof HTMLElement) {
      const flowToParentElement = getParentFlowToElement(node);

      if (flowToParentElement) {
        node = flowToParentElement;
        continue;
      }
    }

    node = node.parentNode;
  }

  return false;
}
function findParentWithClass(node, clazz, stopAtClazzOrNode) {
  while (node && node.nodeType === node.ELEMENT_NODE) {
    if (node.classList.contains(clazz)) {
      return node;
    }

    if (stopAtClazzOrNode) {
      if (typeof stopAtClazzOrNode === 'string') {
        if (node.classList.contains(stopAtClazzOrNode)) {
          return null;
        }
      } else {
        if (node === stopAtClazzOrNode) {
          return null;
        }
      }
    }

    node = node.parentNode;
  }

  return null;
}
function hasParentWithClass(node, clazz, stopAtClazzOrNode) {
  return !!findParentWithClass(node, clazz, stopAtClazzOrNode);
}
function isShadowRoot(node) {
  return node && !!node.host && !!node.mode;
}
function isInShadowDOM(domNode) {
  return !!getShadowRoot(domNode);
}
function getShadowRoot(domNode) {
  while (domNode.parentNode) {
    if (domNode === document.body) {
      // reached the body
      return null;
    }

    domNode = domNode.parentNode;
  }

  return isShadowRoot(domNode) ? domNode : null;
}
function getActiveElement() {
  let result = document.activeElement;

  while (result?.shadowRoot) {
    result = result.shadowRoot.activeElement;
  }

  return result;
}
function createStyleSheet(container = document.getElementsByTagName('head')[0]) {
  const style = document.createElement('style');
  style.type = 'text/css';
  style.media = 'screen'; // @ts-ignore

  style.nonce = window.nonce || '';
  container.appendChild(style);
  return style;
}
function createMetaElement(container = document.getElementsByTagName('head')[0]) {
  const meta = document.createElement('meta');
  container.appendChild(meta);
  return meta;
}
let _sharedStyleSheet = null;

function getSharedStyleSheet() {
  if (!_sharedStyleSheet) {
    _sharedStyleSheet = createStyleSheet();
  }

  return _sharedStyleSheet;
}

function getDynamicStyleSheetRules(style) {
  if (style?.sheet?.rules) {
    // Chrome, IE
    return style.sheet.rules;
  }

  if (style?.sheet?.cssRules) {
    // FF
    return style.sheet.cssRules;
  }

  return [];
}

function createCSSRule(selector, cssText, style = getSharedStyleSheet()) {
  if (!style || !cssText) {
    return;
  }

  style.sheet.insertRule(selector + '{' + cssText + '}', 0);
}
function removeCSSRulesContainingSelector(ruleName, style = getSharedStyleSheet()) {
  if (!style) {
    return;
  }

  const rules = getDynamicStyleSheetRules(style);
  const toDelete = [];

  for (let i = 0; i < rules.length; i++) {
    const rule = rules[i];

    if (rule.selectorText.indexOf(ruleName) !== -1) {
      toDelete.push(i);
    }
  }

  for (let i = toDelete.length - 1; i >= 0; i--) {
    style.sheet.deleteRule(toDelete[i]);
  }
}
function isHTMLElement(o) {
  if (typeof HTMLElement === 'object') {
    return o instanceof HTMLElement;
  }

  return o && typeof o === 'object' && o.nodeType === 1 && typeof o.nodeName === 'string';
}
const EventType = {
  // Mouse
  CLICK: 'click',
  AUXCLICK: 'auxclick',
  DBLCLICK: 'dblclick',
  MOUSE_UP: 'mouseup',
  MOUSE_DOWN: 'mousedown',
  MOUSE_OVER: 'mouseover',
  MOUSE_MOVE: 'mousemove',
  MOUSE_OUT: 'mouseout',
  MOUSE_ENTER: 'mouseenter',
  MOUSE_LEAVE: 'mouseleave',
  MOUSE_WHEEL: 'wheel',
  POINTER_UP: 'pointerup',
  POINTER_DOWN: 'pointerdown',
  POINTER_MOVE: 'pointermove',
  POINTER_LEAVE: 'pointerleave',
  CONTEXT_MENU: 'contextmenu',
  WHEEL: 'wheel',
  // Keyboard
  KEY_DOWN: 'keydown',
  KEY_PRESS: 'keypress',
  KEY_UP: 'keyup',
  // HTML Document
  LOAD: 'load',
  BEFORE_UNLOAD: 'beforeunload',
  UNLOAD: 'unload',
  PAGE_SHOW: 'pageshow',
  PAGE_HIDE: 'pagehide',
  ABORT: 'abort',
  ERROR: 'error',
  RESIZE: 'resize',
  SCROLL: 'scroll',
  FULLSCREEN_CHANGE: 'fullscreenchange',
  WK_FULLSCREEN_CHANGE: 'webkitfullscreenchange',
  // Form
  SELECT: 'select',
  CHANGE: 'change',
  SUBMIT: 'submit',
  RESET: 'reset',
  FOCUS: 'focus',
  FOCUS_IN: 'focusin',
  FOCUS_OUT: 'focusout',
  BLUR: 'blur',
  INPUT: 'input',
  // Local Storage
  STORAGE: 'storage',
  // Drag
  DRAG_START: 'dragstart',
  DRAG: 'drag',
  DRAG_ENTER: 'dragenter',
  DRAG_LEAVE: 'dragleave',
  DRAG_OVER: 'dragover',
  DROP: 'drop',
  DRAG_END: 'dragend',
  // Animation
  ANIMATION_START: _browser__WEBPACK_IMPORTED_MODULE_0__.isWebKit ? 'webkitAnimationStart' : 'animationstart',
  ANIMATION_END: _browser__WEBPACK_IMPORTED_MODULE_0__.isWebKit ? 'webkitAnimationEnd' : 'animationend',
  ANIMATION_ITERATION: _browser__WEBPACK_IMPORTED_MODULE_0__.isWebKit ? 'webkitAnimationIteration' : 'animationiteration'
};
const EventHelper = {
  stop: (e, cancelBubble) => {
    e.preventDefault();

    if (cancelBubble) {
      e.stopPropagation();
    }

    return e;
  }
};
function saveParentsScrollTop(node) {
  const r = [];

  for (let i = 0; node && node.nodeType === node.ELEMENT_NODE; i++) {
    r[i] = node.scrollTop;
    node = node.parentNode;
  }

  return r;
}
function restoreParentsScrollTop(node, state) {
  for (let i = 0; node && node.nodeType === node.ELEMENT_NODE; i++) {
    if (node.scrollTop !== state[i]) {
      node.scrollTop = state[i];
    }

    node = node.parentNode;
  }
}

class FocusTracker extends _common_lifecycle__WEBPACK_IMPORTED_MODULE_9__.Disposable {
  _onDidFocus = this._register(new _common_event__WEBPACK_IMPORTED_MODULE_6__.Emitter());
  onDidFocus = this._onDidFocus.event;
  _onDidBlur = this._register(new _common_event__WEBPACK_IMPORTED_MODULE_6__.Emitter());
  onDidBlur = this._onDidBlur.event;

  static hasFocusWithin(element) {
    const shadowRoot = getShadowRoot(element);
    const activeElement = shadowRoot ? shadowRoot.activeElement : document.activeElement;
    return isAncestor(activeElement, element);
  }

  constructor(element) {
    super();
    let hasFocus = FocusTracker.hasFocusWithin(element);
    let loosingFocus = false;

    const onFocus = () => {
      loosingFocus = false;

      if (!hasFocus) {
        hasFocus = true;

        this._onDidFocus.fire();
      }
    };

    const onBlur = () => {
      if (hasFocus) {
        loosingFocus = true;
        window.setTimeout(() => {
          if (loosingFocus) {
            loosingFocus = false;
            hasFocus = false;

            this._onDidBlur.fire();
          }
        }, 0);
      }
    };

    this._refreshStateHandler = () => {
      const currentNodeHasFocus = FocusTracker.hasFocusWithin(element);

      if (currentNodeHasFocus !== hasFocus) {
        if (hasFocus) {
          onBlur();
        } else {
          onFocus();
        }
      }
    };

    this._register(addDisposableListener(element, EventType.FOCUS, onFocus, true));

    this._register(addDisposableListener(element, EventType.BLUR, onBlur, true));

    this._register(addDisposableListener(element, EventType.FOCUS_IN, () => this._refreshStateHandler()));

    this._register(addDisposableListener(element, EventType.FOCUS_OUT, () => this._refreshStateHandler()));
  }

  refreshState() {
    this._refreshStateHandler();
  }

}

function trackFocus(element) {
  return new FocusTracker(element);
}
function after(sibling, child) {
  sibling.after(child);
  return child;
}
function append(parent, ...children) {
  parent.append(...children);

  if (children.length === 1 && typeof children[0] !== 'string') {
    return children[0];
  }
}
function prepend(parent, child) {
  parent.insertBefore(child, parent.firstChild);
  return child;
}
/**
 * Removes all children from `parent` and appends `children`
 */

function reset(parent, ...children) {
  parent.innerText = '';
  append(parent, ...children);
}
const SELECTOR_REGEX = /([\w\-]+)?(#([\w\-]+))?((\.([\w\-]+))*)/;
let Namespace;

(function (Namespace) {
  Namespace["HTML"] = "http://www.w3.org/1999/xhtml";
  Namespace["SVG"] = "http://www.w3.org/2000/svg";
})(Namespace || (Namespace = {}));

function _$(namespace, description, attrs, ...children) {
  const match = SELECTOR_REGEX.exec(description);

  if (!match) {
    throw new Error('Bad use of emmet');
  }

  attrs = { ...(attrs || {})
  };
  const tagName = match[1] || 'div';
  let result;

  if (namespace !== Namespace.HTML) {
    result = document.createElementNS(namespace, tagName);
  } else {
    result = document.createElement(tagName);
  }

  if (match[3]) {
    result.id = match[3];
  }

  if (match[4]) {
    result.className = match[4].replace(/\./g, ' ').trim();
  }

  Object.keys(attrs).forEach(name => {
    const value = attrs[name];

    if (typeof value === 'undefined') {
      return;
    }

    if (/^on\w+$/.test(name)) {
      result[name] = value;
    } else if (name === 'selected') {
      if (value) {
        result.setAttribute(name, 'true');
      }
    } else {
      result.setAttribute(name, value);
    }
  });
  result.append(...children);
  return result;
}

function $(description, attrs, ...children) {
  return _$(Namespace.HTML, description, attrs, ...children);
}

$.SVG = function (description, attrs, ...children) {
  return _$(Namespace.SVG, description, attrs, ...children);
};

function join(nodes, separator) {
  const result = [];
  nodes.forEach((node, index) => {
    if (index > 0) {
      if (separator instanceof Node) {
        result.push(separator.cloneNode());
      } else {
        result.push(document.createTextNode(separator));
      }
    }

    result.push(node);
  });
  return result;
}
function show(...elements) {
  for (const element of elements) {
    element.style.display = '';
    element.removeAttribute('aria-hidden');
  }
}
function hide(...elements) {
  for (const element of elements) {
    element.style.display = 'none';
    element.setAttribute('aria-hidden', 'true');
  }
}

function findParentWithAttribute(node, attribute) {
  while (node && node.nodeType === node.ELEMENT_NODE) {
    if (node instanceof HTMLElement && node.hasAttribute(attribute)) {
      return node;
    }

    node = node.parentNode;
  }

  return null;
}

function removeTabIndexAndUpdateFocus(node) {
  if (!node || !node.hasAttribute('tabIndex')) {
    return;
  } // If we are the currently focused element and tabIndex is removed,
  // standard DOM behavior is to move focus to the <body> element. We
  // typically never want that, rather put focus to the closest element
  // in the hierarchy of the parent DOM nodes.


  if (document.activeElement === node) {
    const parentFocusable = findParentWithAttribute(node.parentElement, 'tabIndex');
    parentFocusable?.focus();
  }

  node.removeAttribute('tabindex');
}
function finalHandler(fn) {
  return e => {
    e.preventDefault();
    e.stopPropagation();
    fn(e);
  };
}
function domContentLoaded() {
  return new Promise(resolve => {
    const readyState = document.readyState;

    if (readyState === 'complete' || document && document.body !== null) {
      resolve(undefined);
    } else {
      window.addEventListener('DOMContentLoaded', resolve, false);
    }
  });
}
/**
 * Find a value usable for a dom node size such that the likelihood that it would be
 * displayed with constant screen pixels size is as high as possible.
 *
 * e.g. We would desire for the cursors to be 2px (CSS px) wide. Under a devicePixelRatio
 * of 1.25, the cursor will be 2.5 screen pixels wide. Depending on how the dom node aligns/"snaps"
 * with the screen pixels, it will sometimes be rendered with 2 screen pixels, and sometimes with 3 screen pixels.
 */

function computeScreenAwareSize(cssPx) {
  const screenPx = window.devicePixelRatio * cssPx;
  return Math.max(1, Math.floor(screenPx)) / window.devicePixelRatio;
}
/**
 * Open safely a new window. This is the best way to do so, but you cannot tell
 * if the window was opened or if it was blocked by the browser's popup blocker.
 * If you want to tell if the browser blocked the new window, use {@link windowOpenWithSuccess}.
 *
 * See https://github.com/microsoft/monaco-editor/issues/601
 * To protect against malicious code in the linked site, particularly phishing attempts,
 * the window.opener should be set to null to prevent the linked site from having access
 * to change the location of the current page.
 * See https://mathiasbynens.github.io/rel-noopener/
 */

function windowOpenNoOpener(url) {
  // By using 'noopener' in the `windowFeatures` argument, the newly created window will
  // not be able to use `window.opener` to reach back to the current page.
  // See https://stackoverflow.com/a/46958731
  // See https://developer.mozilla.org/en-US/docs/Web/API/Window/open#noopener
  // However, this also doesn't allow us to realize if the browser blocked
  // the creation of the window.
  window.open(url, '_blank', 'noopener');
}
/**
 * Open a new window in a popup. This is the best way to do so, but you cannot tell
 * if the window was opened or if it was blocked by the browser's popup blocker.
 * If you want to tell if the browser blocked the new window, use {@link windowOpenWithSuccess}.
 *
 * Note: this does not set {@link window.opener} to null. This is to allow the opened popup to
 * be able to use {@link window.close} to close itself. Because of this, you should only use
 * this function on urls that you trust.
 *
 * In otherwords, you should almost always use {@link windowOpenNoOpener} instead of this function.
 */

const popupWidth = 780,
      popupHeight = 640;
function windowOpenPopup(url) {
  const left = Math.floor(window.screenLeft + window.innerWidth / 2 - popupWidth / 2);
  const top = Math.floor(window.screenTop + window.innerHeight / 2 - popupHeight / 2);
  window.open(url, '_blank', `width=${popupWidth},height=${popupHeight},top=${top},left=${left}`);
}
/**
 * Attempts to open a window and returns whether it succeeded. This technique is
 * not appropriate in certain contexts, like for example when the JS context is
 * executing inside a sandboxed iframe. If it is not necessary to know if the
 * browser blocked the new window, use {@link windowOpenNoOpener}.
 *
 * See https://github.com/microsoft/monaco-editor/issues/601
 * See https://github.com/microsoft/monaco-editor/issues/2474
 * See https://mathiasbynens.github.io/rel-noopener/
 *
 * @param url the url to open
 * @param noOpener whether or not to set the {@link window.opener} to null. You should leave the default
 * (true) unless you trust the url that is being opened.
 * @returns boolean indicating if the {@link window.open} call succeeded
 */

function windowOpenWithSuccess(url, noOpener = true) {
  const newTab = window.open();

  if (newTab) {
    if (noOpener) {
      // see `windowOpenNoOpener` for details on why this is important
      newTab.opener = null;
    }

    newTab.location.href = url;
    return true;
  }

  return false;
}
function animate(fn) {
  const step = () => {
    fn();
    stepDisposable = scheduleAtNextAnimationFrame(step);
  };

  let stepDisposable = scheduleAtNextAnimationFrame(step);
  return (0,_common_lifecycle__WEBPACK_IMPORTED_MODULE_9__.toDisposable)(() => stepDisposable.dispose());
}
_common_network__WEBPACK_IMPORTED_MODULE_10__.RemoteAuthorities.setPreferredWebSchema(/^https:/.test(window.location.href) ? 'https' : 'http');
/**
 * returns url('...')
 */

function asCSSUrl(uri) {
  if (!uri) {
    return `url('')`;
  }

  return `url('${_common_network__WEBPACK_IMPORTED_MODULE_10__.FileAccess.asBrowserUri(uri).toString(true).replace(/'/g, '%27')}')`;
}
function asCSSPropertyValue(value) {
  return `'${value.replace(/'/g, '%27')}'`;
}
function triggerDownload(dataOrUri, name) {
  // If the data is provided as Buffer, we create a
  // blob URL out of it to produce a valid link
  let url;

  if (_common_uri__WEBPACK_IMPORTED_MODULE_13__.URI.isUri(dataOrUri)) {
    url = dataOrUri.toString(true);
  } else {
    const blob = new Blob([dataOrUri]);
    url = URL.createObjectURL(blob); // Ensure to free the data from DOM eventually

    setTimeout(() => URL.revokeObjectURL(url));
  } // In order to download from the browser, the only way seems
  // to be creating a <a> element with download attribute that
  // points to the file to download.
  // See also https://developers.google.com/web/updates/2011/08/Downloading-resources-in-HTML5-a-download


  const anchor = document.createElement('a');
  document.body.appendChild(anchor);
  anchor.download = name;
  anchor.href = url;
  anchor.click(); // Ensure to remove the element from DOM eventually

  setTimeout(() => document.body.removeChild(anchor));
}
function triggerUpload() {
  return new Promise(resolve => {
    // In order to upload to the browser, create a
    // input element of type `file` and click it
    // to gather the selected files
    const input = document.createElement('input');
    document.body.appendChild(input);
    input.type = 'file';
    input.multiple = true; // Resolve once the input event has fired once

    _common_event__WEBPACK_IMPORTED_MODULE_6__.Event.once(_common_event__WEBPACK_IMPORTED_MODULE_6__.Event.fromDOMEventEmitter(input, 'input'))(() => {
      resolve((0,_common_types__WEBPACK_IMPORTED_MODULE_12__.withNullAsUndefined)(input.files));
    });
    input.click(); // Ensure to remove the element from DOM eventually

    setTimeout(() => document.body.removeChild(input));
  });
}
let DetectedFullscreenMode;

(function (DetectedFullscreenMode) {
  DetectedFullscreenMode[DetectedFullscreenMode["DOCUMENT"] = 1] = "DOCUMENT";
  DetectedFullscreenMode[DetectedFullscreenMode["BROWSER"] = 2] = "BROWSER";
})(DetectedFullscreenMode || (DetectedFullscreenMode = {}));

function detectFullscreen() {
  // Browser fullscreen: use DOM APIs to detect
  if (document.fullscreenElement || document.webkitFullscreenElement || document.webkitIsFullScreen) {
    return {
      mode: DetectedFullscreenMode.DOCUMENT,
      guess: false
    };
  } // There is no standard way to figure out if the browser
  // is using native fullscreen. Via checking on screen
  // height and comparing that to window height, we can guess
  // it though.


  if (window.innerHeight === screen.height) {
    // if the height of the window matches the screen height, we can
    // safely assume that the browser is fullscreen because no browser
    // chrome is taking height away (e.g. like toolbars).
    return {
      mode: DetectedFullscreenMode.BROWSER,
      guess: false
    };
  }

  if (_common_platform__WEBPACK_IMPORTED_MODULE_11__.isMacintosh || _common_platform__WEBPACK_IMPORTED_MODULE_11__.isLinux) {
    // macOS and Linux do not properly report `innerHeight`, only Windows does
    if (window.outerHeight === screen.height && window.outerWidth === screen.width) {
      // if the height of the browser matches the screen height, we can
      // only guess that we are in fullscreen. It is also possible that
      // the user has turned off taskbars in the OS and the browser is
      // simply able to span the entire size of the screen.
      return {
        mode: DetectedFullscreenMode.BROWSER,
        guess: true
      };
    }
  } // Not in fullscreen


  return null;
} // -- sanitize and trusted html

/**
 * Hooks dompurify using `afterSanitizeAttributes` to check that all `href` and `src`
 * attributes are valid.
 */

function hookDomPurifyHrefAndSrcSanitizer(allowedProtocols, allowDataImages = false) {
  // https://github.com/cure53/DOMPurify/blob/main/demos/hooks-scheme-allowlist.html
  // build an anchor to map URLs to
  const anchor = document.createElement('a');
  _dompurify_dompurify__WEBPACK_IMPORTED_MODULE_7__.addHook('afterSanitizeAttributes', node => {
    // check all href/src attributes for validity
    for (const attr of ['href', 'src']) {
      if (node.hasAttribute(attr)) {
        const attrValue = node.getAttribute(attr);

        if (attr === 'href' && attrValue.startsWith('#')) {
          // Allow fragment links
          continue;
        }

        anchor.href = attrValue;

        if (!allowedProtocols.includes(anchor.protocol.replace(/:$/, ''))) {
          if (allowDataImages && attr === 'src' && anchor.href.startsWith('data:')) {
            continue;
          }

          node.removeAttribute(attr);
        }
      }
    }
  });
  return (0,_common_lifecycle__WEBPACK_IMPORTED_MODULE_9__.toDisposable)(() => {
    _dompurify_dompurify__WEBPACK_IMPORTED_MODULE_7__.removeHook('afterSanitizeAttributes');
  });
}
const defaultSafeProtocols = [_common_network__WEBPACK_IMPORTED_MODULE_10__.Schemas.http, _common_network__WEBPACK_IMPORTED_MODULE_10__.Schemas.https, _common_network__WEBPACK_IMPORTED_MODULE_10__.Schemas.command];
/**
 * List of safe, non-input html tags.
 */

const basicMarkupHtmlTags = Object.freeze(['a', 'abbr', 'b', 'bdo', 'blockquote', 'br', 'caption', 'cite', 'code', 'col', 'colgroup', 'dd', 'del', 'details', 'dfn', 'div', 'dl', 'dt', 'em', 'figcaption', 'figure', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'hr', 'i', 'img', 'ins', 'kbd', 'label', 'li', 'mark', 'ol', 'p', 'pre', 'q', 'rp', 'rt', 'ruby', 'samp', 'small', 'small', 'span', 'strike', 'strong', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'tfoot', 'th', 'thead', 'time', 'tr', 'tt', 'u', 'ul', 'var', 'video', 'wbr']);
/**
 * Sanitizes the given `value` and reset the given `node` with it.
 */

function safeInnerHtml(node, value) {
  const options = {
    ALLOWED_TAGS: ['a', 'button', 'blockquote', 'code', 'div', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'hr', 'input', 'label', 'li', 'p', 'pre', 'select', 'small', 'span', 'strong', 'textarea', 'ul', 'ol'],
    ALLOWED_ATTR: ['href', 'data-href', 'data-command', 'target', 'title', 'name', 'src', 'alt', 'class', 'id', 'role', 'tabindex', 'style', 'data-code', 'width', 'height', 'align', 'x-dispatch', 'required', 'checked', 'placeholder', 'type'],
    RETURN_DOM: false,
    RETURN_DOM_FRAGMENT: false
  };
  const hook = hookDomPurifyHrefAndSrcSanitizer(defaultSafeProtocols);

  try {
    const html = _dompurify_dompurify__WEBPACK_IMPORTED_MODULE_7__.sanitize(value, { ...options,
      RETURN_TRUSTED_TYPE: true
    });
    node.innerHTML = html;
  } finally {
    hook.dispose();
  }
}
/**
 * Convert a Unicode string to a string in which each 16-bit unit occupies only one byte
 *
 * From https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/btoa
 */

function toBinary(str) {
  const codeUnits = new Uint16Array(str.length);

  for (let i = 0; i < codeUnits.length; i++) {
    codeUnits[i] = str.charCodeAt(i);
  }

  let binary = '';
  const uint8array = new Uint8Array(codeUnits.buffer);

  for (let i = 0; i < uint8array.length; i++) {
    binary += String.fromCharCode(uint8array[i]);
  }

  return binary;
}
/**
 * Version of the global `btoa` function that handles multi-byte characters instead
 * of throwing an exception.
 */


function multibyteAwareBtoa(str) {
  return btoa(toBinary(str));
}
class ModifierKeyEmitter extends _common_event__WEBPACK_IMPORTED_MODULE_6__.Emitter {
  _subscriptions = new _common_lifecycle__WEBPACK_IMPORTED_MODULE_9__.DisposableStore();

  constructor() {
    super();
    this._keyStatus = {
      altKey: false,
      shiftKey: false,
      ctrlKey: false,
      metaKey: false
    };

    this._subscriptions.add(addDisposableListener(window, 'keydown', e => {
      if (e.defaultPrevented) {
        return;
      }

      const event = new _keyboardEvent__WEBPACK_IMPORTED_MODULE_2__.StandardKeyboardEvent(e); // If Alt-key keydown event is repeated, ignore it #112347
      // Only known to be necessary for Alt-Key at the moment #115810

      if (event.keyCode === _common_keyCodes__WEBPACK_IMPORTED_MODULE_8__.KeyCode.Alt && e.repeat) {
        return;
      }

      if (e.altKey && !this._keyStatus.altKey) {
        this._keyStatus.lastKeyPressed = 'alt';
      } else if (e.ctrlKey && !this._keyStatus.ctrlKey) {
        this._keyStatus.lastKeyPressed = 'ctrl';
      } else if (e.metaKey && !this._keyStatus.metaKey) {
        this._keyStatus.lastKeyPressed = 'meta';
      } else if (e.shiftKey && !this._keyStatus.shiftKey) {
        this._keyStatus.lastKeyPressed = 'shift';
      } else if (event.keyCode !== _common_keyCodes__WEBPACK_IMPORTED_MODULE_8__.KeyCode.Alt) {
        this._keyStatus.lastKeyPressed = undefined;
      } else {
        return;
      }

      this._keyStatus.altKey = e.altKey;
      this._keyStatus.ctrlKey = e.ctrlKey;
      this._keyStatus.metaKey = e.metaKey;
      this._keyStatus.shiftKey = e.shiftKey;

      if (this._keyStatus.lastKeyPressed) {
        this._keyStatus.event = e;
        this.fire(this._keyStatus);
      }
    }, true));

    this._subscriptions.add(addDisposableListener(window, 'keyup', e => {
      if (e.defaultPrevented) {
        return;
      }

      if (!e.altKey && this._keyStatus.altKey) {
        this._keyStatus.lastKeyReleased = 'alt';
      } else if (!e.ctrlKey && this._keyStatus.ctrlKey) {
        this._keyStatus.lastKeyReleased = 'ctrl';
      } else if (!e.metaKey && this._keyStatus.metaKey) {
        this._keyStatus.lastKeyReleased = 'meta';
      } else if (!e.shiftKey && this._keyStatus.shiftKey) {
        this._keyStatus.lastKeyReleased = 'shift';
      } else {
        this._keyStatus.lastKeyReleased = undefined;
      }

      if (this._keyStatus.lastKeyPressed !== this._keyStatus.lastKeyReleased) {
        this._keyStatus.lastKeyPressed = undefined;
      }

      this._keyStatus.altKey = e.altKey;
      this._keyStatus.ctrlKey = e.ctrlKey;
      this._keyStatus.metaKey = e.metaKey;
      this._keyStatus.shiftKey = e.shiftKey;

      if (this._keyStatus.lastKeyReleased) {
        this._keyStatus.event = e;
        this.fire(this._keyStatus);
      }
    }, true));

    this._subscriptions.add(addDisposableListener(document.body, 'mousedown', () => {
      this._keyStatus.lastKeyPressed = undefined;
    }, true));

    this._subscriptions.add(addDisposableListener(document.body, 'mouseup', () => {
      this._keyStatus.lastKeyPressed = undefined;
    }, true));

    this._subscriptions.add(addDisposableListener(document.body, 'mousemove', e => {
      if (e.buttons) {
        this._keyStatus.lastKeyPressed = undefined;
      }
    }, true));

    this._subscriptions.add(addDisposableListener(window, 'blur', () => {
      this.resetKeyStatus();
    }));
  }

  get keyStatus() {
    return this._keyStatus;
  }

  get isModifierPressed() {
    return this._keyStatus.altKey || this._keyStatus.ctrlKey || this._keyStatus.metaKey || this._keyStatus.shiftKey;
  }
  /**
   * Allows to explicitly reset the key status based on more knowledge (#109062)
   */


  resetKeyStatus() {
    this.doResetKeyStatus();
    this.fire(this._keyStatus);
  }

  doResetKeyStatus() {
    this._keyStatus = {
      altKey: false,
      shiftKey: false,
      ctrlKey: false,
      metaKey: false
    };
  }

  static getInstance() {
    if (!ModifierKeyEmitter.instance) {
      ModifierKeyEmitter.instance = new ModifierKeyEmitter();
    }

    return ModifierKeyEmitter.instance;
  }

  dispose() {
    super.dispose();

    this._subscriptions.dispose();
  }

}
function getCookieValue(name) {
  const match = document.cookie.match('(^|[^;]+)\\s*' + name + '\\s*=\\s*([^;]+)'); // See https://stackoverflow.com/a/25490531

  return match ? match.pop() : undefined;
}
class DragAndDropObserver extends _common_lifecycle__WEBPACK_IMPORTED_MODULE_9__.Disposable {
  // A helper to fix issues with repeated DRAG_ENTER / DRAG_LEAVE
  // calls see https://github.com/microsoft/vscode/issues/14470
  // when the element has child elements where the events are fired
  // repeadedly.
  counter = 0; // Allows to measure the duration of the drag operation.

  dragStartTime = 0;

  constructor(element, callbacks) {
    super();
    this.element = element;
    this.callbacks = callbacks;
    this.registerListeners();
  }

  registerListeners() {
    this._register(addDisposableListener(this.element, EventType.DRAG_ENTER, e => {
      this.counter++;
      this.dragStartTime = e.timeStamp;
      this.callbacks.onDragEnter(e);
    }));

    this._register(addDisposableListener(this.element, EventType.DRAG_OVER, e => {
      e.preventDefault(); // needed so that the drop event fires (https://stackoverflow.com/questions/21339924/drop-event-not-firing-in-chrome)

      this.callbacks.onDragOver?.(e, e.timeStamp - this.dragStartTime);
    }));

    this._register(addDisposableListener(this.element, EventType.DRAG_LEAVE, e => {
      this.counter--;

      if (this.counter === 0) {
        this.dragStartTime = 0;
        this.callbacks.onDragLeave(e);
      }
    }));

    this._register(addDisposableListener(this.element, EventType.DRAG_END, e => {
      this.counter = 0;
      this.dragStartTime = 0;
      this.callbacks.onDragEnd(e);
    }));

    this._register(addDisposableListener(this.element, EventType.DROP, e => {
      this.counter = 0;
      this.dragStartTime = 0;
      this.callbacks.onDrop(e);
    }));
  }

}
function computeClippingRect(elementOrRect, clipper) {
  const frameRect = elementOrRect instanceof HTMLElement ? elementOrRect.getBoundingClientRect() : elementOrRect;
  const rootRect = clipper.getBoundingClientRect();
  const top = Math.max(rootRect.top - frameRect.top, 0);
  const right = Math.max(frameRect.width - (frameRect.right - rootRect.right), 0);
  const bottom = Math.max(frameRect.height - (frameRect.bottom - rootRect.bottom), 0);
  const left = Math.max(rootRect.left - frameRect.left, 0);
  return {
    top,
    right,
    bottom,
    left
  };
}
const H_REGEX = /(?<tag>[\w\-]+)?(?:#(?<id>[\w\-]+))?(?<class>(?:\.(?:[\w\-]+))*)(?:@(?<name>(?:[\w\_])+))?/;
/**
 * A helper function to create nested dom nodes.
 *
 *
 * ```ts
 * const elements = h('div.code-view', [
 * 	h('div.title@title'),
 * 	h('div.container', [
 * 		h('div.gutter@gutterDiv'),
 * 		h('div@editor'),
 * 	]),
 * ]);
 * const editor = createEditor(elements.editor);
 * ```
*/

function h(tag, ...args) {
  let attributes;
  let children;

  if (Array.isArray(args[0])) {
    attributes = {};
    children = args[0];
  } else {
    attributes = args[0] || {};
    children = args[1];
  }

  const match = H_REGEX.exec(tag);

  if (!match || !match.groups) {
    throw new Error('Bad use of h');
  }

  const tagName = match.groups['tag'] || 'div';
  const el = document.createElement(tagName);

  if (match.groups['id']) {
    el.id = match.groups['id'];
  }

  if (match.groups['class']) {
    el.className = match.groups['class'].replace(/\./g, ' ').trim();
  }

  const result = {};

  if (match.groups['name']) {
    result[match.groups['name']] = el;
  }

  if (children) {
    for (const c of children) {
      if (c instanceof HTMLElement) {
        el.appendChild(c);
      } else if (typeof c === 'string') {
        el.append(c);
      } else {
        Object.assign(result, c);
        el.appendChild(c.root);
      }
    }
  }

  for (const [key, value] of Object.entries(attributes)) {
    if (key === 'style') {
      for (const [cssKey, cssValue] of Object.entries(value)) {
        el.style.setProperty(camelCaseToHyphenCase(cssKey), typeof cssValue === 'number' ? cssValue + 'px' : '' + cssValue);
      }
    } else if (key === 'tabIndex') {
      el.tabIndex = value;
    } else {
      el.setAttribute(camelCaseToHyphenCase(key), value.toString());
    }
  }

  result['root'] = el;
  return result;
}

function camelCaseToHyphenCase(str) {
  return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
}

/***/ }),
/* 62 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "KeyboardSupport": () => (/* binding */ KeyboardSupport),
/* harmony export */   "BrowserFeatures": () => (/* binding */ BrowserFeatures)
/* harmony export */ });
/* harmony import */ var _browser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(50);
/* harmony import */ var _common_platform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(58);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


let KeyboardSupport;
/**
 * Browser feature we can support in current platform, browser and environment.
 */

(function (KeyboardSupport) {
  KeyboardSupport[KeyboardSupport["Always"] = 0] = "Always";
  KeyboardSupport[KeyboardSupport["FullScreen"] = 1] = "FullScreen";
  KeyboardSupport[KeyboardSupport["None"] = 2] = "None";
})(KeyboardSupport || (KeyboardSupport = {}));

const BrowserFeatures = {
  clipboard: {
    writeText: _common_platform__WEBPACK_IMPORTED_MODULE_1__.isNative || document.queryCommandSupported && document.queryCommandSupported('copy') || !!(navigator && navigator.clipboard && navigator.clipboard.writeText),
    readText: _common_platform__WEBPACK_IMPORTED_MODULE_1__.isNative || !!(navigator && navigator.clipboard && navigator.clipboard.readText)
  },
  keyboard: (() => {
    if (_common_platform__WEBPACK_IMPORTED_MODULE_1__.isNative || _browser__WEBPACK_IMPORTED_MODULE_0__.isStandalone()) {
      return KeyboardSupport.Always;
    }

    if (navigator.keyboard || _browser__WEBPACK_IMPORTED_MODULE_0__.isSafari) {
      return KeyboardSupport.FullScreen;
    }

    return KeyboardSupport.None;
  })(),
  // 'ontouchstart' in window always evaluates to true with typescript's modern typings. This causes `window` to be
  // `never` later in `window.navigator`. That's why we need the explicit `window as Window` cast
  touch: 'ontouchstart' in window || navigator.maxTouchPoints > 0,
  pointerEvents: window.PointerEvent && ('ontouchstart' in window || window.navigator.maxTouchPoints > 0 || navigator.maxTouchPoints > 0)
};

/***/ }),
/* 63 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "printKeyboardEvent": () => (/* binding */ printKeyboardEvent),
/* harmony export */   "printStandardKeyboardEvent": () => (/* binding */ printStandardKeyboardEvent),
/* harmony export */   "StandardKeyboardEvent": () => (/* binding */ StandardKeyboardEvent)
/* harmony export */ });
/* harmony import */ var _browser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(50);
/* harmony import */ var _common_keyCodes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(64);
/* harmony import */ var _common_keybindings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(65);
/* harmony import */ var _common_platform__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(58);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





function extractKeyCode(e) {
  if (e.charCode) {
    // "keypress" events mostly
    const char = String.fromCharCode(e.charCode).toUpperCase();
    return _common_keyCodes__WEBPACK_IMPORTED_MODULE_1__.KeyCodeUtils.fromString(char);
  }

  const keyCode = e.keyCode; // browser quirks

  if (keyCode === 3) {
    return _common_keyCodes__WEBPACK_IMPORTED_MODULE_1__.KeyCode.PauseBreak;
  } else if (_browser__WEBPACK_IMPORTED_MODULE_0__.isFirefox) {
    if (keyCode === 59) {
      return _common_keyCodes__WEBPACK_IMPORTED_MODULE_1__.KeyCode.Semicolon;
    } else if (keyCode === 107) {
      return _common_keyCodes__WEBPACK_IMPORTED_MODULE_1__.KeyCode.Equal;
    } else if (keyCode === 109) {
      return _common_keyCodes__WEBPACK_IMPORTED_MODULE_1__.KeyCode.Minus;
    } else if (_common_platform__WEBPACK_IMPORTED_MODULE_3__.isMacintosh && keyCode === 224) {
      return _common_keyCodes__WEBPACK_IMPORTED_MODULE_1__.KeyCode.Meta;
    }
  } else if (_browser__WEBPACK_IMPORTED_MODULE_0__.isWebKit) {
    if (keyCode === 91) {
      return _common_keyCodes__WEBPACK_IMPORTED_MODULE_1__.KeyCode.Meta;
    } else if (_common_platform__WEBPACK_IMPORTED_MODULE_3__.isMacintosh && keyCode === 93) {
      // the two meta keys in the Mac have different key codes (91 and 93)
      return _common_keyCodes__WEBPACK_IMPORTED_MODULE_1__.KeyCode.Meta;
    } else if (!_common_platform__WEBPACK_IMPORTED_MODULE_3__.isMacintosh && keyCode === 92) {
      return _common_keyCodes__WEBPACK_IMPORTED_MODULE_1__.KeyCode.Meta;
    }
  } // cross browser keycodes:


  return _common_keyCodes__WEBPACK_IMPORTED_MODULE_1__.EVENT_KEY_CODE_MAP[keyCode] || _common_keyCodes__WEBPACK_IMPORTED_MODULE_1__.KeyCode.Unknown;
}

const ctrlKeyMod = _common_platform__WEBPACK_IMPORTED_MODULE_3__.isMacintosh ? _common_keyCodes__WEBPACK_IMPORTED_MODULE_1__.KeyMod.WinCtrl : _common_keyCodes__WEBPACK_IMPORTED_MODULE_1__.KeyMod.CtrlCmd;
const altKeyMod = _common_keyCodes__WEBPACK_IMPORTED_MODULE_1__.KeyMod.Alt;
const shiftKeyMod = _common_keyCodes__WEBPACK_IMPORTED_MODULE_1__.KeyMod.Shift;
const metaKeyMod = _common_platform__WEBPACK_IMPORTED_MODULE_3__.isMacintosh ? _common_keyCodes__WEBPACK_IMPORTED_MODULE_1__.KeyMod.CtrlCmd : _common_keyCodes__WEBPACK_IMPORTED_MODULE_1__.KeyMod.WinCtrl;
function printKeyboardEvent(e) {
  const modifiers = [];

  if (e.ctrlKey) {
    modifiers.push(`ctrl`);
  }

  if (e.shiftKey) {
    modifiers.push(`shift`);
  }

  if (e.altKey) {
    modifiers.push(`alt`);
  }

  if (e.metaKey) {
    modifiers.push(`meta`);
  }

  return `modifiers: [${modifiers.join(',')}], code: ${e.code}, keyCode: ${e.keyCode}, key: ${e.key}`;
}
function printStandardKeyboardEvent(e) {
  const modifiers = [];

  if (e.ctrlKey) {
    modifiers.push(`ctrl`);
  }

  if (e.shiftKey) {
    modifiers.push(`shift`);
  }

  if (e.altKey) {
    modifiers.push(`alt`);
  }

  if (e.metaKey) {
    modifiers.push(`meta`);
  }

  return `modifiers: [${modifiers.join(',')}], code: ${e.code}, keyCode: ${e.keyCode} ('${_common_keyCodes__WEBPACK_IMPORTED_MODULE_1__.KeyCodeUtils.toString(e.keyCode)}')`;
}
class StandardKeyboardEvent {
  _standardKeyboardEventBrand = true;

  constructor(source) {
    const e = source;
    this.browserEvent = e;
    this.target = e.target;
    this.ctrlKey = e.ctrlKey;
    this.shiftKey = e.shiftKey;
    this.altKey = e.altKey;
    this.metaKey = e.metaKey;
    this.keyCode = extractKeyCode(e);
    this.code = e.code; // console.info(e.type + ": keyCode: " + e.keyCode + ", which: " + e.which + ", charCode: " + e.charCode + ", detail: " + e.detail + " ====> " + this.keyCode + ' -- ' + KeyCode[this.keyCode]);

    this.ctrlKey = this.ctrlKey || this.keyCode === _common_keyCodes__WEBPACK_IMPORTED_MODULE_1__.KeyCode.Ctrl;
    this.altKey = this.altKey || this.keyCode === _common_keyCodes__WEBPACK_IMPORTED_MODULE_1__.KeyCode.Alt;
    this.shiftKey = this.shiftKey || this.keyCode === _common_keyCodes__WEBPACK_IMPORTED_MODULE_1__.KeyCode.Shift;
    this.metaKey = this.metaKey || this.keyCode === _common_keyCodes__WEBPACK_IMPORTED_MODULE_1__.KeyCode.Meta;
    this._asKeybinding = this._computeKeybinding();
    this._asRuntimeKeybinding = this._computeRuntimeKeybinding(); // console.log(`code: ${e.code}, keyCode: ${e.keyCode}, key: ${e.key}`);
  }

  preventDefault() {
    if (this.browserEvent && this.browserEvent.preventDefault) {
      this.browserEvent.preventDefault();
    }
  }

  stopPropagation() {
    if (this.browserEvent && this.browserEvent.stopPropagation) {
      this.browserEvent.stopPropagation();
    }
  }

  toKeybinding() {
    return this._asRuntimeKeybinding;
  }

  equals(other) {
    return this._asKeybinding === other;
  }

  _computeKeybinding() {
    let key = _common_keyCodes__WEBPACK_IMPORTED_MODULE_1__.KeyCode.Unknown;

    if (this.keyCode !== _common_keyCodes__WEBPACK_IMPORTED_MODULE_1__.KeyCode.Ctrl && this.keyCode !== _common_keyCodes__WEBPACK_IMPORTED_MODULE_1__.KeyCode.Shift && this.keyCode !== _common_keyCodes__WEBPACK_IMPORTED_MODULE_1__.KeyCode.Alt && this.keyCode !== _common_keyCodes__WEBPACK_IMPORTED_MODULE_1__.KeyCode.Meta) {
      key = this.keyCode;
    }

    let result = 0;

    if (this.ctrlKey) {
      result |= ctrlKeyMod;
    }

    if (this.altKey) {
      result |= altKeyMod;
    }

    if (this.shiftKey) {
      result |= shiftKeyMod;
    }

    if (this.metaKey) {
      result |= metaKeyMod;
    }

    result |= key;
    return result;
  }

  _computeRuntimeKeybinding() {
    let key = _common_keyCodes__WEBPACK_IMPORTED_MODULE_1__.KeyCode.Unknown;

    if (this.keyCode !== _common_keyCodes__WEBPACK_IMPORTED_MODULE_1__.KeyCode.Ctrl && this.keyCode !== _common_keyCodes__WEBPACK_IMPORTED_MODULE_1__.KeyCode.Shift && this.keyCode !== _common_keyCodes__WEBPACK_IMPORTED_MODULE_1__.KeyCode.Alt && this.keyCode !== _common_keyCodes__WEBPACK_IMPORTED_MODULE_1__.KeyCode.Meta) {
      key = this.keyCode;
    }

    return new _common_keybindings__WEBPACK_IMPORTED_MODULE_2__.SimpleKeybinding(this.ctrlKey, this.shiftKey, this.altKey, this.metaKey, key);
  }

}

/***/ }),
/* 64 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "KeyCode": () => (/* binding */ KeyCode),
/* harmony export */   "ScanCode": () => (/* binding */ ScanCode),
/* harmony export */   "EVENT_KEY_CODE_MAP": () => (/* binding */ EVENT_KEY_CODE_MAP),
/* harmony export */   "NATIVE_WINDOWS_KEY_CODE_TO_KEY_CODE": () => (/* binding */ NATIVE_WINDOWS_KEY_CODE_TO_KEY_CODE),
/* harmony export */   "ScanCodeUtils": () => (/* binding */ ScanCodeUtils),
/* harmony export */   "IMMUTABLE_CODE_TO_KEY_CODE": () => (/* binding */ IMMUTABLE_CODE_TO_KEY_CODE),
/* harmony export */   "IMMUTABLE_KEY_CODE_TO_CODE": () => (/* binding */ IMMUTABLE_KEY_CODE_TO_CODE),
/* harmony export */   "KeyCodeUtils": () => (/* binding */ KeyCodeUtils),
/* harmony export */   "KeyMod": () => (/* binding */ KeyMod),
/* harmony export */   "KeyChord": () => (/* binding */ KeyChord)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

/**
 * Virtual Key Codes, the value does not hold any inherent meaning.
 * Inspired somewhat from https://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx
 * But these are "more general", as they should work across browsers & OS`s.
 */
let KeyCode;
/**
 * keyboardEvent.code
 */

(function (KeyCode) {
  KeyCode[KeyCode["DependsOnKbLayout"] = -1] = "DependsOnKbLayout";
  KeyCode[KeyCode["Unknown"] = 0] = "Unknown";
  KeyCode[KeyCode["Backspace"] = 1] = "Backspace";
  KeyCode[KeyCode["Tab"] = 2] = "Tab";
  KeyCode[KeyCode["Enter"] = 3] = "Enter";
  KeyCode[KeyCode["Shift"] = 4] = "Shift";
  KeyCode[KeyCode["Ctrl"] = 5] = "Ctrl";
  KeyCode[KeyCode["Alt"] = 6] = "Alt";
  KeyCode[KeyCode["PauseBreak"] = 7] = "PauseBreak";
  KeyCode[KeyCode["CapsLock"] = 8] = "CapsLock";
  KeyCode[KeyCode["Escape"] = 9] = "Escape";
  KeyCode[KeyCode["Space"] = 10] = "Space";
  KeyCode[KeyCode["PageUp"] = 11] = "PageUp";
  KeyCode[KeyCode["PageDown"] = 12] = "PageDown";
  KeyCode[KeyCode["End"] = 13] = "End";
  KeyCode[KeyCode["Home"] = 14] = "Home";
  KeyCode[KeyCode["LeftArrow"] = 15] = "LeftArrow";
  KeyCode[KeyCode["UpArrow"] = 16] = "UpArrow";
  KeyCode[KeyCode["RightArrow"] = 17] = "RightArrow";
  KeyCode[KeyCode["DownArrow"] = 18] = "DownArrow";
  KeyCode[KeyCode["Insert"] = 19] = "Insert";
  KeyCode[KeyCode["Delete"] = 20] = "Delete";
  KeyCode[KeyCode["Digit0"] = 21] = "Digit0";
  KeyCode[KeyCode["Digit1"] = 22] = "Digit1";
  KeyCode[KeyCode["Digit2"] = 23] = "Digit2";
  KeyCode[KeyCode["Digit3"] = 24] = "Digit3";
  KeyCode[KeyCode["Digit4"] = 25] = "Digit4";
  KeyCode[KeyCode["Digit5"] = 26] = "Digit5";
  KeyCode[KeyCode["Digit6"] = 27] = "Digit6";
  KeyCode[KeyCode["Digit7"] = 28] = "Digit7";
  KeyCode[KeyCode["Digit8"] = 29] = "Digit8";
  KeyCode[KeyCode["Digit9"] = 30] = "Digit9";
  KeyCode[KeyCode["KeyA"] = 31] = "KeyA";
  KeyCode[KeyCode["KeyB"] = 32] = "KeyB";
  KeyCode[KeyCode["KeyC"] = 33] = "KeyC";
  KeyCode[KeyCode["KeyD"] = 34] = "KeyD";
  KeyCode[KeyCode["KeyE"] = 35] = "KeyE";
  KeyCode[KeyCode["KeyF"] = 36] = "KeyF";
  KeyCode[KeyCode["KeyG"] = 37] = "KeyG";
  KeyCode[KeyCode["KeyH"] = 38] = "KeyH";
  KeyCode[KeyCode["KeyI"] = 39] = "KeyI";
  KeyCode[KeyCode["KeyJ"] = 40] = "KeyJ";
  KeyCode[KeyCode["KeyK"] = 41] = "KeyK";
  KeyCode[KeyCode["KeyL"] = 42] = "KeyL";
  KeyCode[KeyCode["KeyM"] = 43] = "KeyM";
  KeyCode[KeyCode["KeyN"] = 44] = "KeyN";
  KeyCode[KeyCode["KeyO"] = 45] = "KeyO";
  KeyCode[KeyCode["KeyP"] = 46] = "KeyP";
  KeyCode[KeyCode["KeyQ"] = 47] = "KeyQ";
  KeyCode[KeyCode["KeyR"] = 48] = "KeyR";
  KeyCode[KeyCode["KeyS"] = 49] = "KeyS";
  KeyCode[KeyCode["KeyT"] = 50] = "KeyT";
  KeyCode[KeyCode["KeyU"] = 51] = "KeyU";
  KeyCode[KeyCode["KeyV"] = 52] = "KeyV";
  KeyCode[KeyCode["KeyW"] = 53] = "KeyW";
  KeyCode[KeyCode["KeyX"] = 54] = "KeyX";
  KeyCode[KeyCode["KeyY"] = 55] = "KeyY";
  KeyCode[KeyCode["KeyZ"] = 56] = "KeyZ";
  KeyCode[KeyCode["Meta"] = 57] = "Meta";
  KeyCode[KeyCode["ContextMenu"] = 58] = "ContextMenu";
  KeyCode[KeyCode["F1"] = 59] = "F1";
  KeyCode[KeyCode["F2"] = 60] = "F2";
  KeyCode[KeyCode["F3"] = 61] = "F3";
  KeyCode[KeyCode["F4"] = 62] = "F4";
  KeyCode[KeyCode["F5"] = 63] = "F5";
  KeyCode[KeyCode["F6"] = 64] = "F6";
  KeyCode[KeyCode["F7"] = 65] = "F7";
  KeyCode[KeyCode["F8"] = 66] = "F8";
  KeyCode[KeyCode["F9"] = 67] = "F9";
  KeyCode[KeyCode["F10"] = 68] = "F10";
  KeyCode[KeyCode["F11"] = 69] = "F11";
  KeyCode[KeyCode["F12"] = 70] = "F12";
  KeyCode[KeyCode["F13"] = 71] = "F13";
  KeyCode[KeyCode["F14"] = 72] = "F14";
  KeyCode[KeyCode["F15"] = 73] = "F15";
  KeyCode[KeyCode["F16"] = 74] = "F16";
  KeyCode[KeyCode["F17"] = 75] = "F17";
  KeyCode[KeyCode["F18"] = 76] = "F18";
  KeyCode[KeyCode["F19"] = 77] = "F19";
  KeyCode[KeyCode["NumLock"] = 78] = "NumLock";
  KeyCode[KeyCode["ScrollLock"] = 79] = "ScrollLock";
  KeyCode[KeyCode["Semicolon"] = 80] = "Semicolon";
  KeyCode[KeyCode["Equal"] = 81] = "Equal";
  KeyCode[KeyCode["Comma"] = 82] = "Comma";
  KeyCode[KeyCode["Minus"] = 83] = "Minus";
  KeyCode[KeyCode["Period"] = 84] = "Period";
  KeyCode[KeyCode["Slash"] = 85] = "Slash";
  KeyCode[KeyCode["Backquote"] = 86] = "Backquote";
  KeyCode[KeyCode["BracketLeft"] = 87] = "BracketLeft";
  KeyCode[KeyCode["Backslash"] = 88] = "Backslash";
  KeyCode[KeyCode["BracketRight"] = 89] = "BracketRight";
  KeyCode[KeyCode["Quote"] = 90] = "Quote";
  KeyCode[KeyCode["OEM_8"] = 91] = "OEM_8";
  KeyCode[KeyCode["IntlBackslash"] = 92] = "IntlBackslash";
  KeyCode[KeyCode["Numpad0"] = 93] = "Numpad0";
  KeyCode[KeyCode["Numpad1"] = 94] = "Numpad1";
  KeyCode[KeyCode["Numpad2"] = 95] = "Numpad2";
  KeyCode[KeyCode["Numpad3"] = 96] = "Numpad3";
  KeyCode[KeyCode["Numpad4"] = 97] = "Numpad4";
  KeyCode[KeyCode["Numpad5"] = 98] = "Numpad5";
  KeyCode[KeyCode["Numpad6"] = 99] = "Numpad6";
  KeyCode[KeyCode["Numpad7"] = 100] = "Numpad7";
  KeyCode[KeyCode["Numpad8"] = 101] = "Numpad8";
  KeyCode[KeyCode["Numpad9"] = 102] = "Numpad9";
  KeyCode[KeyCode["NumpadMultiply"] = 103] = "NumpadMultiply";
  KeyCode[KeyCode["NumpadAdd"] = 104] = "NumpadAdd";
  KeyCode[KeyCode["NUMPAD_SEPARATOR"] = 105] = "NUMPAD_SEPARATOR";
  KeyCode[KeyCode["NumpadSubtract"] = 106] = "NumpadSubtract";
  KeyCode[KeyCode["NumpadDecimal"] = 107] = "NumpadDecimal";
  KeyCode[KeyCode["NumpadDivide"] = 108] = "NumpadDivide";
  KeyCode[KeyCode["KEY_IN_COMPOSITION"] = 109] = "KEY_IN_COMPOSITION";
  KeyCode[KeyCode["ABNT_C1"] = 110] = "ABNT_C1";
  KeyCode[KeyCode["ABNT_C2"] = 111] = "ABNT_C2";
  KeyCode[KeyCode["AudioVolumeMute"] = 112] = "AudioVolumeMute";
  KeyCode[KeyCode["AudioVolumeUp"] = 113] = "AudioVolumeUp";
  KeyCode[KeyCode["AudioVolumeDown"] = 114] = "AudioVolumeDown";
  KeyCode[KeyCode["BrowserSearch"] = 115] = "BrowserSearch";
  KeyCode[KeyCode["BrowserHome"] = 116] = "BrowserHome";
  KeyCode[KeyCode["BrowserBack"] = 117] = "BrowserBack";
  KeyCode[KeyCode["BrowserForward"] = 118] = "BrowserForward";
  KeyCode[KeyCode["MediaTrackNext"] = 119] = "MediaTrackNext";
  KeyCode[KeyCode["MediaTrackPrevious"] = 120] = "MediaTrackPrevious";
  KeyCode[KeyCode["MediaStop"] = 121] = "MediaStop";
  KeyCode[KeyCode["MediaPlayPause"] = 122] = "MediaPlayPause";
  KeyCode[KeyCode["LaunchMediaPlayer"] = 123] = "LaunchMediaPlayer";
  KeyCode[KeyCode["LaunchMail"] = 124] = "LaunchMail";
  KeyCode[KeyCode["LaunchApp2"] = 125] = "LaunchApp2";
  KeyCode[KeyCode["Clear"] = 126] = "Clear";
  KeyCode[KeyCode["MAX_VALUE"] = 127] = "MAX_VALUE";
})(KeyCode || (KeyCode = {}));

let ScanCode;

(function (ScanCode) {
  ScanCode[ScanCode["DependsOnKbLayout"] = -1] = "DependsOnKbLayout";
  ScanCode[ScanCode["None"] = 0] = "None";
  ScanCode[ScanCode["Hyper"] = 1] = "Hyper";
  ScanCode[ScanCode["Super"] = 2] = "Super";
  ScanCode[ScanCode["Fn"] = 3] = "Fn";
  ScanCode[ScanCode["FnLock"] = 4] = "FnLock";
  ScanCode[ScanCode["Suspend"] = 5] = "Suspend";
  ScanCode[ScanCode["Resume"] = 6] = "Resume";
  ScanCode[ScanCode["Turbo"] = 7] = "Turbo";
  ScanCode[ScanCode["Sleep"] = 8] = "Sleep";
  ScanCode[ScanCode["WakeUp"] = 9] = "WakeUp";
  ScanCode[ScanCode["KeyA"] = 10] = "KeyA";
  ScanCode[ScanCode["KeyB"] = 11] = "KeyB";
  ScanCode[ScanCode["KeyC"] = 12] = "KeyC";
  ScanCode[ScanCode["KeyD"] = 13] = "KeyD";
  ScanCode[ScanCode["KeyE"] = 14] = "KeyE";
  ScanCode[ScanCode["KeyF"] = 15] = "KeyF";
  ScanCode[ScanCode["KeyG"] = 16] = "KeyG";
  ScanCode[ScanCode["KeyH"] = 17] = "KeyH";
  ScanCode[ScanCode["KeyI"] = 18] = "KeyI";
  ScanCode[ScanCode["KeyJ"] = 19] = "KeyJ";
  ScanCode[ScanCode["KeyK"] = 20] = "KeyK";
  ScanCode[ScanCode["KeyL"] = 21] = "KeyL";
  ScanCode[ScanCode["KeyM"] = 22] = "KeyM";
  ScanCode[ScanCode["KeyN"] = 23] = "KeyN";
  ScanCode[ScanCode["KeyO"] = 24] = "KeyO";
  ScanCode[ScanCode["KeyP"] = 25] = "KeyP";
  ScanCode[ScanCode["KeyQ"] = 26] = "KeyQ";
  ScanCode[ScanCode["KeyR"] = 27] = "KeyR";
  ScanCode[ScanCode["KeyS"] = 28] = "KeyS";
  ScanCode[ScanCode["KeyT"] = 29] = "KeyT";
  ScanCode[ScanCode["KeyU"] = 30] = "KeyU";
  ScanCode[ScanCode["KeyV"] = 31] = "KeyV";
  ScanCode[ScanCode["KeyW"] = 32] = "KeyW";
  ScanCode[ScanCode["KeyX"] = 33] = "KeyX";
  ScanCode[ScanCode["KeyY"] = 34] = "KeyY";
  ScanCode[ScanCode["KeyZ"] = 35] = "KeyZ";
  ScanCode[ScanCode["Digit1"] = 36] = "Digit1";
  ScanCode[ScanCode["Digit2"] = 37] = "Digit2";
  ScanCode[ScanCode["Digit3"] = 38] = "Digit3";
  ScanCode[ScanCode["Digit4"] = 39] = "Digit4";
  ScanCode[ScanCode["Digit5"] = 40] = "Digit5";
  ScanCode[ScanCode["Digit6"] = 41] = "Digit6";
  ScanCode[ScanCode["Digit7"] = 42] = "Digit7";
  ScanCode[ScanCode["Digit8"] = 43] = "Digit8";
  ScanCode[ScanCode["Digit9"] = 44] = "Digit9";
  ScanCode[ScanCode["Digit0"] = 45] = "Digit0";
  ScanCode[ScanCode["Enter"] = 46] = "Enter";
  ScanCode[ScanCode["Escape"] = 47] = "Escape";
  ScanCode[ScanCode["Backspace"] = 48] = "Backspace";
  ScanCode[ScanCode["Tab"] = 49] = "Tab";
  ScanCode[ScanCode["Space"] = 50] = "Space";
  ScanCode[ScanCode["Minus"] = 51] = "Minus";
  ScanCode[ScanCode["Equal"] = 52] = "Equal";
  ScanCode[ScanCode["BracketLeft"] = 53] = "BracketLeft";
  ScanCode[ScanCode["BracketRight"] = 54] = "BracketRight";
  ScanCode[ScanCode["Backslash"] = 55] = "Backslash";
  ScanCode[ScanCode["IntlHash"] = 56] = "IntlHash";
  ScanCode[ScanCode["Semicolon"] = 57] = "Semicolon";
  ScanCode[ScanCode["Quote"] = 58] = "Quote";
  ScanCode[ScanCode["Backquote"] = 59] = "Backquote";
  ScanCode[ScanCode["Comma"] = 60] = "Comma";
  ScanCode[ScanCode["Period"] = 61] = "Period";
  ScanCode[ScanCode["Slash"] = 62] = "Slash";
  ScanCode[ScanCode["CapsLock"] = 63] = "CapsLock";
  ScanCode[ScanCode["F1"] = 64] = "F1";
  ScanCode[ScanCode["F2"] = 65] = "F2";
  ScanCode[ScanCode["F3"] = 66] = "F3";
  ScanCode[ScanCode["F4"] = 67] = "F4";
  ScanCode[ScanCode["F5"] = 68] = "F5";
  ScanCode[ScanCode["F6"] = 69] = "F6";
  ScanCode[ScanCode["F7"] = 70] = "F7";
  ScanCode[ScanCode["F8"] = 71] = "F8";
  ScanCode[ScanCode["F9"] = 72] = "F9";
  ScanCode[ScanCode["F10"] = 73] = "F10";
  ScanCode[ScanCode["F11"] = 74] = "F11";
  ScanCode[ScanCode["F12"] = 75] = "F12";
  ScanCode[ScanCode["PrintScreen"] = 76] = "PrintScreen";
  ScanCode[ScanCode["ScrollLock"] = 77] = "ScrollLock";
  ScanCode[ScanCode["Pause"] = 78] = "Pause";
  ScanCode[ScanCode["Insert"] = 79] = "Insert";
  ScanCode[ScanCode["Home"] = 80] = "Home";
  ScanCode[ScanCode["PageUp"] = 81] = "PageUp";
  ScanCode[ScanCode["Delete"] = 82] = "Delete";
  ScanCode[ScanCode["End"] = 83] = "End";
  ScanCode[ScanCode["PageDown"] = 84] = "PageDown";
  ScanCode[ScanCode["ArrowRight"] = 85] = "ArrowRight";
  ScanCode[ScanCode["ArrowLeft"] = 86] = "ArrowLeft";
  ScanCode[ScanCode["ArrowDown"] = 87] = "ArrowDown";
  ScanCode[ScanCode["ArrowUp"] = 88] = "ArrowUp";
  ScanCode[ScanCode["NumLock"] = 89] = "NumLock";
  ScanCode[ScanCode["NumpadDivide"] = 90] = "NumpadDivide";
  ScanCode[ScanCode["NumpadMultiply"] = 91] = "NumpadMultiply";
  ScanCode[ScanCode["NumpadSubtract"] = 92] = "NumpadSubtract";
  ScanCode[ScanCode["NumpadAdd"] = 93] = "NumpadAdd";
  ScanCode[ScanCode["NumpadEnter"] = 94] = "NumpadEnter";
  ScanCode[ScanCode["Numpad1"] = 95] = "Numpad1";
  ScanCode[ScanCode["Numpad2"] = 96] = "Numpad2";
  ScanCode[ScanCode["Numpad3"] = 97] = "Numpad3";
  ScanCode[ScanCode["Numpad4"] = 98] = "Numpad4";
  ScanCode[ScanCode["Numpad5"] = 99] = "Numpad5";
  ScanCode[ScanCode["Numpad6"] = 100] = "Numpad6";
  ScanCode[ScanCode["Numpad7"] = 101] = "Numpad7";
  ScanCode[ScanCode["Numpad8"] = 102] = "Numpad8";
  ScanCode[ScanCode["Numpad9"] = 103] = "Numpad9";
  ScanCode[ScanCode["Numpad0"] = 104] = "Numpad0";
  ScanCode[ScanCode["NumpadDecimal"] = 105] = "NumpadDecimal";
  ScanCode[ScanCode["IntlBackslash"] = 106] = "IntlBackslash";
  ScanCode[ScanCode["ContextMenu"] = 107] = "ContextMenu";
  ScanCode[ScanCode["Power"] = 108] = "Power";
  ScanCode[ScanCode["NumpadEqual"] = 109] = "NumpadEqual";
  ScanCode[ScanCode["F13"] = 110] = "F13";
  ScanCode[ScanCode["F14"] = 111] = "F14";
  ScanCode[ScanCode["F15"] = 112] = "F15";
  ScanCode[ScanCode["F16"] = 113] = "F16";
  ScanCode[ScanCode["F17"] = 114] = "F17";
  ScanCode[ScanCode["F18"] = 115] = "F18";
  ScanCode[ScanCode["F19"] = 116] = "F19";
  ScanCode[ScanCode["F20"] = 117] = "F20";
  ScanCode[ScanCode["F21"] = 118] = "F21";
  ScanCode[ScanCode["F22"] = 119] = "F22";
  ScanCode[ScanCode["F23"] = 120] = "F23";
  ScanCode[ScanCode["F24"] = 121] = "F24";
  ScanCode[ScanCode["Open"] = 122] = "Open";
  ScanCode[ScanCode["Help"] = 123] = "Help";
  ScanCode[ScanCode["Select"] = 124] = "Select";
  ScanCode[ScanCode["Again"] = 125] = "Again";
  ScanCode[ScanCode["Undo"] = 126] = "Undo";
  ScanCode[ScanCode["Cut"] = 127] = "Cut";
  ScanCode[ScanCode["Copy"] = 128] = "Copy";
  ScanCode[ScanCode["Paste"] = 129] = "Paste";
  ScanCode[ScanCode["Find"] = 130] = "Find";
  ScanCode[ScanCode["AudioVolumeMute"] = 131] = "AudioVolumeMute";
  ScanCode[ScanCode["AudioVolumeUp"] = 132] = "AudioVolumeUp";
  ScanCode[ScanCode["AudioVolumeDown"] = 133] = "AudioVolumeDown";
  ScanCode[ScanCode["NumpadComma"] = 134] = "NumpadComma";
  ScanCode[ScanCode["IntlRo"] = 135] = "IntlRo";
  ScanCode[ScanCode["KanaMode"] = 136] = "KanaMode";
  ScanCode[ScanCode["IntlYen"] = 137] = "IntlYen";
  ScanCode[ScanCode["Convert"] = 138] = "Convert";
  ScanCode[ScanCode["NonConvert"] = 139] = "NonConvert";
  ScanCode[ScanCode["Lang1"] = 140] = "Lang1";
  ScanCode[ScanCode["Lang2"] = 141] = "Lang2";
  ScanCode[ScanCode["Lang3"] = 142] = "Lang3";
  ScanCode[ScanCode["Lang4"] = 143] = "Lang4";
  ScanCode[ScanCode["Lang5"] = 144] = "Lang5";
  ScanCode[ScanCode["Abort"] = 145] = "Abort";
  ScanCode[ScanCode["Props"] = 146] = "Props";
  ScanCode[ScanCode["NumpadParenLeft"] = 147] = "NumpadParenLeft";
  ScanCode[ScanCode["NumpadParenRight"] = 148] = "NumpadParenRight";
  ScanCode[ScanCode["NumpadBackspace"] = 149] = "NumpadBackspace";
  ScanCode[ScanCode["NumpadMemoryStore"] = 150] = "NumpadMemoryStore";
  ScanCode[ScanCode["NumpadMemoryRecall"] = 151] = "NumpadMemoryRecall";
  ScanCode[ScanCode["NumpadMemoryClear"] = 152] = "NumpadMemoryClear";
  ScanCode[ScanCode["NumpadMemoryAdd"] = 153] = "NumpadMemoryAdd";
  ScanCode[ScanCode["NumpadMemorySubtract"] = 154] = "NumpadMemorySubtract";
  ScanCode[ScanCode["NumpadClear"] = 155] = "NumpadClear";
  ScanCode[ScanCode["NumpadClearEntry"] = 156] = "NumpadClearEntry";
  ScanCode[ScanCode["ControlLeft"] = 157] = "ControlLeft";
  ScanCode[ScanCode["ShiftLeft"] = 158] = "ShiftLeft";
  ScanCode[ScanCode["AltLeft"] = 159] = "AltLeft";
  ScanCode[ScanCode["MetaLeft"] = 160] = "MetaLeft";
  ScanCode[ScanCode["ControlRight"] = 161] = "ControlRight";
  ScanCode[ScanCode["ShiftRight"] = 162] = "ShiftRight";
  ScanCode[ScanCode["AltRight"] = 163] = "AltRight";
  ScanCode[ScanCode["MetaRight"] = 164] = "MetaRight";
  ScanCode[ScanCode["BrightnessUp"] = 165] = "BrightnessUp";
  ScanCode[ScanCode["BrightnessDown"] = 166] = "BrightnessDown";
  ScanCode[ScanCode["MediaPlay"] = 167] = "MediaPlay";
  ScanCode[ScanCode["MediaRecord"] = 168] = "MediaRecord";
  ScanCode[ScanCode["MediaFastForward"] = 169] = "MediaFastForward";
  ScanCode[ScanCode["MediaRewind"] = 170] = "MediaRewind";
  ScanCode[ScanCode["MediaTrackNext"] = 171] = "MediaTrackNext";
  ScanCode[ScanCode["MediaTrackPrevious"] = 172] = "MediaTrackPrevious";
  ScanCode[ScanCode["MediaStop"] = 173] = "MediaStop";
  ScanCode[ScanCode["Eject"] = 174] = "Eject";
  ScanCode[ScanCode["MediaPlayPause"] = 175] = "MediaPlayPause";
  ScanCode[ScanCode["MediaSelect"] = 176] = "MediaSelect";
  ScanCode[ScanCode["LaunchMail"] = 177] = "LaunchMail";
  ScanCode[ScanCode["LaunchApp2"] = 178] = "LaunchApp2";
  ScanCode[ScanCode["LaunchApp1"] = 179] = "LaunchApp1";
  ScanCode[ScanCode["SelectTask"] = 180] = "SelectTask";
  ScanCode[ScanCode["LaunchScreenSaver"] = 181] = "LaunchScreenSaver";
  ScanCode[ScanCode["BrowserSearch"] = 182] = "BrowserSearch";
  ScanCode[ScanCode["BrowserHome"] = 183] = "BrowserHome";
  ScanCode[ScanCode["BrowserBack"] = 184] = "BrowserBack";
  ScanCode[ScanCode["BrowserForward"] = 185] = "BrowserForward";
  ScanCode[ScanCode["BrowserStop"] = 186] = "BrowserStop";
  ScanCode[ScanCode["BrowserRefresh"] = 187] = "BrowserRefresh";
  ScanCode[ScanCode["BrowserFavorites"] = 188] = "BrowserFavorites";
  ScanCode[ScanCode["ZoomToggle"] = 189] = "ZoomToggle";
  ScanCode[ScanCode["MailReply"] = 190] = "MailReply";
  ScanCode[ScanCode["MailForward"] = 191] = "MailForward";
  ScanCode[ScanCode["MailSend"] = 192] = "MailSend";
  ScanCode[ScanCode["MAX_VALUE"] = 193] = "MAX_VALUE";
})(ScanCode || (ScanCode = {}));

class KeyCodeStrMap {
  constructor() {
    this._keyCodeToStr = [];
    this._strToKeyCode = Object.create(null);
  }

  define(keyCode, str) {
    this._keyCodeToStr[keyCode] = str;
    this._strToKeyCode[str.toLowerCase()] = keyCode;
  }

  keyCodeToStr(keyCode) {
    return this._keyCodeToStr[keyCode];
  }

  strToKeyCode(str) {
    return this._strToKeyCode[str.toLowerCase()] || KeyCode.Unknown;
  }

}

const uiMap = new KeyCodeStrMap();
const userSettingsUSMap = new KeyCodeStrMap();
const userSettingsGeneralMap = new KeyCodeStrMap();
const EVENT_KEY_CODE_MAP = new Array(230);
const NATIVE_WINDOWS_KEY_CODE_TO_KEY_CODE = {};
const scanCodeIntToStr = [];
const scanCodeStrToInt = Object.create(null);
const scanCodeLowerCaseStrToInt = Object.create(null);
const ScanCodeUtils = {
  lowerCaseToEnum: scanCode => scanCodeLowerCaseStrToInt[scanCode] || ScanCode.None,
  toEnum: scanCode => scanCodeStrToInt[scanCode] || ScanCode.None,
  toString: scanCode => scanCodeIntToStr[scanCode] || 'None'
};
/**
 * -1 if a ScanCode => KeyCode mapping depends on kb layout.
 */

const IMMUTABLE_CODE_TO_KEY_CODE = [];
/**
 * -1 if a KeyCode => ScanCode mapping depends on kb layout.
 */

const IMMUTABLE_KEY_CODE_TO_CODE = [];

for (let i = 0; i <= ScanCode.MAX_VALUE; i++) {
  IMMUTABLE_CODE_TO_KEY_CODE[i] = KeyCode.DependsOnKbLayout;
}

for (let i = 0; i <= KeyCode.MAX_VALUE; i++) {
  IMMUTABLE_KEY_CODE_TO_CODE[i] = ScanCode.DependsOnKbLayout;
}

(function () {
  // See https://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx
  // See https://github.com/microsoft/node-native-keymap/blob/master/deps/chromium/keyboard_codes_win.h
  const empty = '';
  const mappings = [// keyCodeOrd, immutable, scanCode, scanCodeStr, keyCode, keyCodeStr, eventKeyCode, vkey, usUserSettingsLabel, generalUserSettingsLabel
  [0, 1, ScanCode.None, 'None', KeyCode.Unknown, 'unknown', 0, 'VK_UNKNOWN', empty, empty], [0, 1, ScanCode.Hyper, 'Hyper', KeyCode.Unknown, empty, 0, empty, empty, empty], [0, 1, ScanCode.Super, 'Super', KeyCode.Unknown, empty, 0, empty, empty, empty], [0, 1, ScanCode.Fn, 'Fn', KeyCode.Unknown, empty, 0, empty, empty, empty], [0, 1, ScanCode.FnLock, 'FnLock', KeyCode.Unknown, empty, 0, empty, empty, empty], [0, 1, ScanCode.Suspend, 'Suspend', KeyCode.Unknown, empty, 0, empty, empty, empty], [0, 1, ScanCode.Resume, 'Resume', KeyCode.Unknown, empty, 0, empty, empty, empty], [0, 1, ScanCode.Turbo, 'Turbo', KeyCode.Unknown, empty, 0, empty, empty, empty], [0, 1, ScanCode.Sleep, 'Sleep', KeyCode.Unknown, empty, 0, 'VK_SLEEP', empty, empty], [0, 1, ScanCode.WakeUp, 'WakeUp', KeyCode.Unknown, empty, 0, empty, empty, empty], [31, 0, ScanCode.KeyA, 'KeyA', KeyCode.KeyA, 'A', 65, 'VK_A', empty, empty], [32, 0, ScanCode.KeyB, 'KeyB', KeyCode.KeyB, 'B', 66, 'VK_B', empty, empty], [33, 0, ScanCode.KeyC, 'KeyC', KeyCode.KeyC, 'C', 67, 'VK_C', empty, empty], [34, 0, ScanCode.KeyD, 'KeyD', KeyCode.KeyD, 'D', 68, 'VK_D', empty, empty], [35, 0, ScanCode.KeyE, 'KeyE', KeyCode.KeyE, 'E', 69, 'VK_E', empty, empty], [36, 0, ScanCode.KeyF, 'KeyF', KeyCode.KeyF, 'F', 70, 'VK_F', empty, empty], [37, 0, ScanCode.KeyG, 'KeyG', KeyCode.KeyG, 'G', 71, 'VK_G', empty, empty], [38, 0, ScanCode.KeyH, 'KeyH', KeyCode.KeyH, 'H', 72, 'VK_H', empty, empty], [39, 0, ScanCode.KeyI, 'KeyI', KeyCode.KeyI, 'I', 73, 'VK_I', empty, empty], [40, 0, ScanCode.KeyJ, 'KeyJ', KeyCode.KeyJ, 'J', 74, 'VK_J', empty, empty], [41, 0, ScanCode.KeyK, 'KeyK', KeyCode.KeyK, 'K', 75, 'VK_K', empty, empty], [42, 0, ScanCode.KeyL, 'KeyL', KeyCode.KeyL, 'L', 76, 'VK_L', empty, empty], [43, 0, ScanCode.KeyM, 'KeyM', KeyCode.KeyM, 'M', 77, 'VK_M', empty, empty], [44, 0, ScanCode.KeyN, 'KeyN', KeyCode.KeyN, 'N', 78, 'VK_N', empty, empty], [45, 0, ScanCode.KeyO, 'KeyO', KeyCode.KeyO, 'O', 79, 'VK_O', empty, empty], [46, 0, ScanCode.KeyP, 'KeyP', KeyCode.KeyP, 'P', 80, 'VK_P', empty, empty], [47, 0, ScanCode.KeyQ, 'KeyQ', KeyCode.KeyQ, 'Q', 81, 'VK_Q', empty, empty], [48, 0, ScanCode.KeyR, 'KeyR', KeyCode.KeyR, 'R', 82, 'VK_R', empty, empty], [49, 0, ScanCode.KeyS, 'KeyS', KeyCode.KeyS, 'S', 83, 'VK_S', empty, empty], [50, 0, ScanCode.KeyT, 'KeyT', KeyCode.KeyT, 'T', 84, 'VK_T', empty, empty], [51, 0, ScanCode.KeyU, 'KeyU', KeyCode.KeyU, 'U', 85, 'VK_U', empty, empty], [52, 0, ScanCode.KeyV, 'KeyV', KeyCode.KeyV, 'V', 86, 'VK_V', empty, empty], [53, 0, ScanCode.KeyW, 'KeyW', KeyCode.KeyW, 'W', 87, 'VK_W', empty, empty], [54, 0, ScanCode.KeyX, 'KeyX', KeyCode.KeyX, 'X', 88, 'VK_X', empty, empty], [55, 0, ScanCode.KeyY, 'KeyY', KeyCode.KeyY, 'Y', 89, 'VK_Y', empty, empty], [56, 0, ScanCode.KeyZ, 'KeyZ', KeyCode.KeyZ, 'Z', 90, 'VK_Z', empty, empty], [22, 0, ScanCode.Digit1, 'Digit1', KeyCode.Digit1, '1', 49, 'VK_1', empty, empty], [23, 0, ScanCode.Digit2, 'Digit2', KeyCode.Digit2, '2', 50, 'VK_2', empty, empty], [24, 0, ScanCode.Digit3, 'Digit3', KeyCode.Digit3, '3', 51, 'VK_3', empty, empty], [25, 0, ScanCode.Digit4, 'Digit4', KeyCode.Digit4, '4', 52, 'VK_4', empty, empty], [26, 0, ScanCode.Digit5, 'Digit5', KeyCode.Digit5, '5', 53, 'VK_5', empty, empty], [27, 0, ScanCode.Digit6, 'Digit6', KeyCode.Digit6, '6', 54, 'VK_6', empty, empty], [28, 0, ScanCode.Digit7, 'Digit7', KeyCode.Digit7, '7', 55, 'VK_7', empty, empty], [29, 0, ScanCode.Digit8, 'Digit8', KeyCode.Digit8, '8', 56, 'VK_8', empty, empty], [30, 0, ScanCode.Digit9, 'Digit9', KeyCode.Digit9, '9', 57, 'VK_9', empty, empty], [21, 0, ScanCode.Digit0, 'Digit0', KeyCode.Digit0, '0', 48, 'VK_0', empty, empty], [3, 1, ScanCode.Enter, 'Enter', KeyCode.Enter, 'Enter', 13, 'VK_RETURN', empty, empty], [9, 1, ScanCode.Escape, 'Escape', KeyCode.Escape, 'Escape', 27, 'VK_ESCAPE', empty, empty], [1, 1, ScanCode.Backspace, 'Backspace', KeyCode.Backspace, 'Backspace', 8, 'VK_BACK', empty, empty], [2, 1, ScanCode.Tab, 'Tab', KeyCode.Tab, 'Tab', 9, 'VK_TAB', empty, empty], [10, 1, ScanCode.Space, 'Space', KeyCode.Space, 'Space', 32, 'VK_SPACE', empty, empty], [83, 0, ScanCode.Minus, 'Minus', KeyCode.Minus, '-', 189, 'VK_OEM_MINUS', '-', 'OEM_MINUS'], [81, 0, ScanCode.Equal, 'Equal', KeyCode.Equal, '=', 187, 'VK_OEM_PLUS', '=', 'OEM_PLUS'], [87, 0, ScanCode.BracketLeft, 'BracketLeft', KeyCode.BracketLeft, '[', 219, 'VK_OEM_4', '[', 'OEM_4'], [89, 0, ScanCode.BracketRight, 'BracketRight', KeyCode.BracketRight, ']', 221, 'VK_OEM_6', ']', 'OEM_6'], [88, 0, ScanCode.Backslash, 'Backslash', KeyCode.Backslash, '\\', 220, 'VK_OEM_5', '\\', 'OEM_5'], [0, 0, ScanCode.IntlHash, 'IntlHash', KeyCode.Unknown, empty, 0, empty, empty, empty], // has been dropped from the w3c spec
  [80, 0, ScanCode.Semicolon, 'Semicolon', KeyCode.Semicolon, ';', 186, 'VK_OEM_1', ';', 'OEM_1'], [90, 0, ScanCode.Quote, 'Quote', KeyCode.Quote, '\'', 222, 'VK_OEM_7', '\'', 'OEM_7'], [86, 0, ScanCode.Backquote, 'Backquote', KeyCode.Backquote, '`', 192, 'VK_OEM_3', '`', 'OEM_3'], [82, 0, ScanCode.Comma, 'Comma', KeyCode.Comma, ',', 188, 'VK_OEM_COMMA', ',', 'OEM_COMMA'], [84, 0, ScanCode.Period, 'Period', KeyCode.Period, '.', 190, 'VK_OEM_PERIOD', '.', 'OEM_PERIOD'], [85, 0, ScanCode.Slash, 'Slash', KeyCode.Slash, '/', 191, 'VK_OEM_2', '/', 'OEM_2'], [8, 1, ScanCode.CapsLock, 'CapsLock', KeyCode.CapsLock, 'CapsLock', 20, 'VK_CAPITAL', empty, empty], [59, 1, ScanCode.F1, 'F1', KeyCode.F1, 'F1', 112, 'VK_F1', empty, empty], [60, 1, ScanCode.F2, 'F2', KeyCode.F2, 'F2', 113, 'VK_F2', empty, empty], [61, 1, ScanCode.F3, 'F3', KeyCode.F3, 'F3', 114, 'VK_F3', empty, empty], [62, 1, ScanCode.F4, 'F4', KeyCode.F4, 'F4', 115, 'VK_F4', empty, empty], [63, 1, ScanCode.F5, 'F5', KeyCode.F5, 'F5', 116, 'VK_F5', empty, empty], [64, 1, ScanCode.F6, 'F6', KeyCode.F6, 'F6', 117, 'VK_F6', empty, empty], [65, 1, ScanCode.F7, 'F7', KeyCode.F7, 'F7', 118, 'VK_F7', empty, empty], [66, 1, ScanCode.F8, 'F8', KeyCode.F8, 'F8', 119, 'VK_F8', empty, empty], [67, 1, ScanCode.F9, 'F9', KeyCode.F9, 'F9', 120, 'VK_F9', empty, empty], [68, 1, ScanCode.F10, 'F10', KeyCode.F10, 'F10', 121, 'VK_F10', empty, empty], [69, 1, ScanCode.F11, 'F11', KeyCode.F11, 'F11', 122, 'VK_F11', empty, empty], [70, 1, ScanCode.F12, 'F12', KeyCode.F12, 'F12', 123, 'VK_F12', empty, empty], [0, 1, ScanCode.PrintScreen, 'PrintScreen', KeyCode.Unknown, empty, 0, empty, empty, empty], [79, 1, ScanCode.ScrollLock, 'ScrollLock', KeyCode.ScrollLock, 'ScrollLock', 145, 'VK_SCROLL', empty, empty], [7, 1, ScanCode.Pause, 'Pause', KeyCode.PauseBreak, 'PauseBreak', 19, 'VK_PAUSE', empty, empty], [19, 1, ScanCode.Insert, 'Insert', KeyCode.Insert, 'Insert', 45, 'VK_INSERT', empty, empty], [14, 1, ScanCode.Home, 'Home', KeyCode.Home, 'Home', 36, 'VK_HOME', empty, empty], [11, 1, ScanCode.PageUp, 'PageUp', KeyCode.PageUp, 'PageUp', 33, 'VK_PRIOR', empty, empty], [20, 1, ScanCode.Delete, 'Delete', KeyCode.Delete, 'Delete', 46, 'VK_DELETE', empty, empty], [13, 1, ScanCode.End, 'End', KeyCode.End, 'End', 35, 'VK_END', empty, empty], [12, 1, ScanCode.PageDown, 'PageDown', KeyCode.PageDown, 'PageDown', 34, 'VK_NEXT', empty, empty], [17, 1, ScanCode.ArrowRight, 'ArrowRight', KeyCode.RightArrow, 'RightArrow', 39, 'VK_RIGHT', 'Right', empty], [15, 1, ScanCode.ArrowLeft, 'ArrowLeft', KeyCode.LeftArrow, 'LeftArrow', 37, 'VK_LEFT', 'Left', empty], [18, 1, ScanCode.ArrowDown, 'ArrowDown', KeyCode.DownArrow, 'DownArrow', 40, 'VK_DOWN', 'Down', empty], [16, 1, ScanCode.ArrowUp, 'ArrowUp', KeyCode.UpArrow, 'UpArrow', 38, 'VK_UP', 'Up', empty], [78, 1, ScanCode.NumLock, 'NumLock', KeyCode.NumLock, 'NumLock', 144, 'VK_NUMLOCK', empty, empty], [108, 1, ScanCode.NumpadDivide, 'NumpadDivide', KeyCode.NumpadDivide, 'NumPad_Divide', 111, 'VK_DIVIDE', empty, empty], [103, 1, ScanCode.NumpadMultiply, 'NumpadMultiply', KeyCode.NumpadMultiply, 'NumPad_Multiply', 106, 'VK_MULTIPLY', empty, empty], [106, 1, ScanCode.NumpadSubtract, 'NumpadSubtract', KeyCode.NumpadSubtract, 'NumPad_Subtract', 109, 'VK_SUBTRACT', empty, empty], [104, 1, ScanCode.NumpadAdd, 'NumpadAdd', KeyCode.NumpadAdd, 'NumPad_Add', 107, 'VK_ADD', empty, empty], [3, 1, ScanCode.NumpadEnter, 'NumpadEnter', KeyCode.Enter, empty, 0, empty, empty, empty], [94, 1, ScanCode.Numpad1, 'Numpad1', KeyCode.Numpad1, 'NumPad1', 97, 'VK_NUMPAD1', empty, empty], [95, 1, ScanCode.Numpad2, 'Numpad2', KeyCode.Numpad2, 'NumPad2', 98, 'VK_NUMPAD2', empty, empty], [96, 1, ScanCode.Numpad3, 'Numpad3', KeyCode.Numpad3, 'NumPad3', 99, 'VK_NUMPAD3', empty, empty], [97, 1, ScanCode.Numpad4, 'Numpad4', KeyCode.Numpad4, 'NumPad4', 100, 'VK_NUMPAD4', empty, empty], [98, 1, ScanCode.Numpad5, 'Numpad5', KeyCode.Numpad5, 'NumPad5', 101, 'VK_NUMPAD5', empty, empty], [99, 1, ScanCode.Numpad6, 'Numpad6', KeyCode.Numpad6, 'NumPad6', 102, 'VK_NUMPAD6', empty, empty], [100, 1, ScanCode.Numpad7, 'Numpad7', KeyCode.Numpad7, 'NumPad7', 103, 'VK_NUMPAD7', empty, empty], [101, 1, ScanCode.Numpad8, 'Numpad8', KeyCode.Numpad8, 'NumPad8', 104, 'VK_NUMPAD8', empty, empty], [102, 1, ScanCode.Numpad9, 'Numpad9', KeyCode.Numpad9, 'NumPad9', 105, 'VK_NUMPAD9', empty, empty], [93, 1, ScanCode.Numpad0, 'Numpad0', KeyCode.Numpad0, 'NumPad0', 96, 'VK_NUMPAD0', empty, empty], [107, 1, ScanCode.NumpadDecimal, 'NumpadDecimal', KeyCode.NumpadDecimal, 'NumPad_Decimal', 110, 'VK_DECIMAL', empty, empty], [92, 0, ScanCode.IntlBackslash, 'IntlBackslash', KeyCode.IntlBackslash, 'OEM_102', 226, 'VK_OEM_102', empty, empty], [58, 1, ScanCode.ContextMenu, 'ContextMenu', KeyCode.ContextMenu, 'ContextMenu', 93, empty, empty, empty], [0, 1, ScanCode.Power, 'Power', KeyCode.Unknown, empty, 0, empty, empty, empty], [0, 1, ScanCode.NumpadEqual, 'NumpadEqual', KeyCode.Unknown, empty, 0, empty, empty, empty], [71, 1, ScanCode.F13, 'F13', KeyCode.F13, 'F13', 124, 'VK_F13', empty, empty], [72, 1, ScanCode.F14, 'F14', KeyCode.F14, 'F14', 125, 'VK_F14', empty, empty], [73, 1, ScanCode.F15, 'F15', KeyCode.F15, 'F15', 126, 'VK_F15', empty, empty], [74, 1, ScanCode.F16, 'F16', KeyCode.F16, 'F16', 127, 'VK_F16', empty, empty], [75, 1, ScanCode.F17, 'F17', KeyCode.F17, 'F17', 128, 'VK_F17', empty, empty], [76, 1, ScanCode.F18, 'F18', KeyCode.F18, 'F18', 129, 'VK_F18', empty, empty], [77, 1, ScanCode.F19, 'F19', KeyCode.F19, 'F19', 130, 'VK_F19', empty, empty], [0, 1, ScanCode.F20, 'F20', KeyCode.Unknown, empty, 0, 'VK_F20', empty, empty], [0, 1, ScanCode.F21, 'F21', KeyCode.Unknown, empty, 0, 'VK_F21', empty, empty], [0, 1, ScanCode.F22, 'F22', KeyCode.Unknown, empty, 0, 'VK_F22', empty, empty], [0, 1, ScanCode.F23, 'F23', KeyCode.Unknown, empty, 0, 'VK_F23', empty, empty], [0, 1, ScanCode.F24, 'F24', KeyCode.Unknown, empty, 0, 'VK_F24', empty, empty], [0, 1, ScanCode.Open, 'Open', KeyCode.Unknown, empty, 0, empty, empty, empty], [0, 1, ScanCode.Help, 'Help', KeyCode.Unknown, empty, 0, empty, empty, empty], [0, 1, ScanCode.Select, 'Select', KeyCode.Unknown, empty, 0, empty, empty, empty], [0, 1, ScanCode.Again, 'Again', KeyCode.Unknown, empty, 0, empty, empty, empty], [0, 1, ScanCode.Undo, 'Undo', KeyCode.Unknown, empty, 0, empty, empty, empty], [0, 1, ScanCode.Cut, 'Cut', KeyCode.Unknown, empty, 0, empty, empty, empty], [0, 1, ScanCode.Copy, 'Copy', KeyCode.Unknown, empty, 0, empty, empty, empty], [0, 1, ScanCode.Paste, 'Paste', KeyCode.Unknown, empty, 0, empty, empty, empty], [0, 1, ScanCode.Find, 'Find', KeyCode.Unknown, empty, 0, empty, empty, empty], [0, 1, ScanCode.AudioVolumeMute, 'AudioVolumeMute', KeyCode.AudioVolumeMute, 'AudioVolumeMute', 173, 'VK_VOLUME_MUTE', empty, empty], [0, 1, ScanCode.AudioVolumeUp, 'AudioVolumeUp', KeyCode.AudioVolumeUp, 'AudioVolumeUp', 175, 'VK_VOLUME_UP', empty, empty], [0, 1, ScanCode.AudioVolumeDown, 'AudioVolumeDown', KeyCode.AudioVolumeDown, 'AudioVolumeDown', 174, 'VK_VOLUME_DOWN', empty, empty], [105, 1, ScanCode.NumpadComma, 'NumpadComma', KeyCode.NUMPAD_SEPARATOR, 'NumPad_Separator', 108, 'VK_SEPARATOR', empty, empty], [110, 0, ScanCode.IntlRo, 'IntlRo', KeyCode.ABNT_C1, 'ABNT_C1', 193, 'VK_ABNT_C1', empty, empty], [0, 1, ScanCode.KanaMode, 'KanaMode', KeyCode.Unknown, empty, 0, empty, empty, empty], [0, 0, ScanCode.IntlYen, 'IntlYen', KeyCode.Unknown, empty, 0, empty, empty, empty], [0, 1, ScanCode.Convert, 'Convert', KeyCode.Unknown, empty, 0, empty, empty, empty], [0, 1, ScanCode.NonConvert, 'NonConvert', KeyCode.Unknown, empty, 0, empty, empty, empty], [0, 1, ScanCode.Lang1, 'Lang1', KeyCode.Unknown, empty, 0, empty, empty, empty], [0, 1, ScanCode.Lang2, 'Lang2', KeyCode.Unknown, empty, 0, empty, empty, empty], [0, 1, ScanCode.Lang3, 'Lang3', KeyCode.Unknown, empty, 0, empty, empty, empty], [0, 1, ScanCode.Lang4, 'Lang4', KeyCode.Unknown, empty, 0, empty, empty, empty], [0, 1, ScanCode.Lang5, 'Lang5', KeyCode.Unknown, empty, 0, empty, empty, empty], [0, 1, ScanCode.Abort, 'Abort', KeyCode.Unknown, empty, 0, empty, empty, empty], [0, 1, ScanCode.Props, 'Props', KeyCode.Unknown, empty, 0, empty, empty, empty], [0, 1, ScanCode.NumpadParenLeft, 'NumpadParenLeft', KeyCode.Unknown, empty, 0, empty, empty, empty], [0, 1, ScanCode.NumpadParenRight, 'NumpadParenRight', KeyCode.Unknown, empty, 0, empty, empty, empty], [0, 1, ScanCode.NumpadBackspace, 'NumpadBackspace', KeyCode.Unknown, empty, 0, empty, empty, empty], [0, 1, ScanCode.NumpadMemoryStore, 'NumpadMemoryStore', KeyCode.Unknown, empty, 0, empty, empty, empty], [0, 1, ScanCode.NumpadMemoryRecall, 'NumpadMemoryRecall', KeyCode.Unknown, empty, 0, empty, empty, empty], [0, 1, ScanCode.NumpadMemoryClear, 'NumpadMemoryClear', KeyCode.Unknown, empty, 0, empty, empty, empty], [0, 1, ScanCode.NumpadMemoryAdd, 'NumpadMemoryAdd', KeyCode.Unknown, empty, 0, empty, empty, empty], [0, 1, ScanCode.NumpadMemorySubtract, 'NumpadMemorySubtract', KeyCode.Unknown, empty, 0, empty, empty, empty], [0, 1, ScanCode.NumpadClear, 'NumpadClear', KeyCode.Clear, 'Clear', 12, 'VK_CLEAR', empty, empty], [0, 1, ScanCode.NumpadClearEntry, 'NumpadClearEntry', KeyCode.Unknown, empty, 0, empty, empty, empty], [5, 1, ScanCode.None, empty, KeyCode.Ctrl, 'Ctrl', 17, 'VK_CONTROL', empty, empty], [4, 1, ScanCode.None, empty, KeyCode.Shift, 'Shift', 16, 'VK_SHIFT', empty, empty], [6, 1, ScanCode.None, empty, KeyCode.Alt, 'Alt', 18, 'VK_MENU', empty, empty], [57, 1, ScanCode.None, empty, KeyCode.Meta, 'Meta', 0, 'VK_COMMAND', empty, empty], [5, 1, ScanCode.ControlLeft, 'ControlLeft', KeyCode.Ctrl, empty, 0, 'VK_LCONTROL', empty, empty], [4, 1, ScanCode.ShiftLeft, 'ShiftLeft', KeyCode.Shift, empty, 0, 'VK_LSHIFT', empty, empty], [6, 1, ScanCode.AltLeft, 'AltLeft', KeyCode.Alt, empty, 0, 'VK_LMENU', empty, empty], [57, 1, ScanCode.MetaLeft, 'MetaLeft', KeyCode.Meta, empty, 0, 'VK_LWIN', empty, empty], [5, 1, ScanCode.ControlRight, 'ControlRight', KeyCode.Ctrl, empty, 0, 'VK_RCONTROL', empty, empty], [4, 1, ScanCode.ShiftRight, 'ShiftRight', KeyCode.Shift, empty, 0, 'VK_RSHIFT', empty, empty], [6, 1, ScanCode.AltRight, 'AltRight', KeyCode.Alt, empty, 0, 'VK_RMENU', empty, empty], [57, 1, ScanCode.MetaRight, 'MetaRight', KeyCode.Meta, empty, 0, 'VK_RWIN', empty, empty], [0, 1, ScanCode.BrightnessUp, 'BrightnessUp', KeyCode.Unknown, empty, 0, empty, empty, empty], [0, 1, ScanCode.BrightnessDown, 'BrightnessDown', KeyCode.Unknown, empty, 0, empty, empty, empty], [0, 1, ScanCode.MediaPlay, 'MediaPlay', KeyCode.Unknown, empty, 0, empty, empty, empty], [0, 1, ScanCode.MediaRecord, 'MediaRecord', KeyCode.Unknown, empty, 0, empty, empty, empty], [0, 1, ScanCode.MediaFastForward, 'MediaFastForward', KeyCode.Unknown, empty, 0, empty, empty, empty], [0, 1, ScanCode.MediaRewind, 'MediaRewind', KeyCode.Unknown, empty, 0, empty, empty, empty], [114, 1, ScanCode.MediaTrackNext, 'MediaTrackNext', KeyCode.MediaTrackNext, 'MediaTrackNext', 176, 'VK_MEDIA_NEXT_TRACK', empty, empty], [115, 1, ScanCode.MediaTrackPrevious, 'MediaTrackPrevious', KeyCode.MediaTrackPrevious, 'MediaTrackPrevious', 177, 'VK_MEDIA_PREV_TRACK', empty, empty], [116, 1, ScanCode.MediaStop, 'MediaStop', KeyCode.MediaStop, 'MediaStop', 178, 'VK_MEDIA_STOP', empty, empty], [0, 1, ScanCode.Eject, 'Eject', KeyCode.Unknown, empty, 0, empty, empty, empty], [117, 1, ScanCode.MediaPlayPause, 'MediaPlayPause', KeyCode.MediaPlayPause, 'MediaPlayPause', 179, 'VK_MEDIA_PLAY_PAUSE', empty, empty], [0, 1, ScanCode.MediaSelect, 'MediaSelect', KeyCode.LaunchMediaPlayer, 'LaunchMediaPlayer', 181, 'VK_MEDIA_LAUNCH_MEDIA_SELECT', empty, empty], [0, 1, ScanCode.LaunchMail, 'LaunchMail', KeyCode.LaunchMail, 'LaunchMail', 180, 'VK_MEDIA_LAUNCH_MAIL', empty, empty], [0, 1, ScanCode.LaunchApp2, 'LaunchApp2', KeyCode.LaunchApp2, 'LaunchApp2', 183, 'VK_MEDIA_LAUNCH_APP2', empty, empty], [0, 1, ScanCode.LaunchApp1, 'LaunchApp1', KeyCode.Unknown, empty, 0, 'VK_MEDIA_LAUNCH_APP1', empty, empty], [0, 1, ScanCode.SelectTask, 'SelectTask', KeyCode.Unknown, empty, 0, empty, empty, empty], [0, 1, ScanCode.LaunchScreenSaver, 'LaunchScreenSaver', KeyCode.Unknown, empty, 0, empty, empty, empty], [0, 1, ScanCode.BrowserSearch, 'BrowserSearch', KeyCode.BrowserSearch, 'BrowserSearch', 170, 'VK_BROWSER_SEARCH', empty, empty], [0, 1, ScanCode.BrowserHome, 'BrowserHome', KeyCode.BrowserHome, 'BrowserHome', 172, 'VK_BROWSER_HOME', empty, empty], [112, 1, ScanCode.BrowserBack, 'BrowserBack', KeyCode.BrowserBack, 'BrowserBack', 166, 'VK_BROWSER_BACK', empty, empty], [113, 1, ScanCode.BrowserForward, 'BrowserForward', KeyCode.BrowserForward, 'BrowserForward', 167, 'VK_BROWSER_FORWARD', empty, empty], [0, 1, ScanCode.BrowserStop, 'BrowserStop', KeyCode.Unknown, empty, 0, 'VK_BROWSER_STOP', empty, empty], [0, 1, ScanCode.BrowserRefresh, 'BrowserRefresh', KeyCode.Unknown, empty, 0, 'VK_BROWSER_REFRESH', empty, empty], [0, 1, ScanCode.BrowserFavorites, 'BrowserFavorites', KeyCode.Unknown, empty, 0, 'VK_BROWSER_FAVORITES', empty, empty], [0, 1, ScanCode.ZoomToggle, 'ZoomToggle', KeyCode.Unknown, empty, 0, empty, empty, empty], [0, 1, ScanCode.MailReply, 'MailReply', KeyCode.Unknown, empty, 0, empty, empty, empty], [0, 1, ScanCode.MailForward, 'MailForward', KeyCode.Unknown, empty, 0, empty, empty, empty], [0, 1, ScanCode.MailSend, 'MailSend', KeyCode.Unknown, empty, 0, empty, empty, empty], // See https://lists.w3.org/Archives/Public/www-dom/2010JulSep/att-0182/keyCode-spec.html
  // If an Input Method Editor is processing key input and the event is keydown, return 229.
  [109, 1, ScanCode.None, empty, KeyCode.KEY_IN_COMPOSITION, 'KeyInComposition', 229, empty, empty, empty], [111, 1, ScanCode.None, empty, KeyCode.ABNT_C2, 'ABNT_C2', 194, 'VK_ABNT_C2', empty, empty], [91, 1, ScanCode.None, empty, KeyCode.OEM_8, 'OEM_8', 223, 'VK_OEM_8', empty, empty], [0, 1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_KANA', empty, empty], [0, 1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_HANGUL', empty, empty], [0, 1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_JUNJA', empty, empty], [0, 1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_FINAL', empty, empty], [0, 1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_HANJA', empty, empty], [0, 1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_KANJI', empty, empty], [0, 1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_CONVERT', empty, empty], [0, 1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_NONCONVERT', empty, empty], [0, 1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_ACCEPT', empty, empty], [0, 1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_MODECHANGE', empty, empty], [0, 1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_SELECT', empty, empty], [0, 1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_PRINT', empty, empty], [0, 1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_EXECUTE', empty, empty], [0, 1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_SNAPSHOT', empty, empty], [0, 1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_HELP', empty, empty], [0, 1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_APPS', empty, empty], [0, 1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_PROCESSKEY', empty, empty], [0, 1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_PACKET', empty, empty], [0, 1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_DBE_SBCSCHAR', empty, empty], [0, 1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_DBE_DBCSCHAR', empty, empty], [0, 1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_ATTN', empty, empty], [0, 1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_CRSEL', empty, empty], [0, 1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_EXSEL', empty, empty], [0, 1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_EREOF', empty, empty], [0, 1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_PLAY', empty, empty], [0, 1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_ZOOM', empty, empty], [0, 1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_NONAME', empty, empty], [0, 1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_PA1', empty, empty], [0, 1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_OEM_CLEAR', empty, empty]];
  const seenKeyCode = [];
  const seenScanCode = [];

  for (const mapping of mappings) {
    const [_keyCodeOrd, immutable, scanCode, scanCodeStr, keyCode, keyCodeStr, eventKeyCode, vkey, usUserSettingsLabel, generalUserSettingsLabel] = mapping;

    if (!seenScanCode[scanCode]) {
      seenScanCode[scanCode] = true;
      scanCodeIntToStr[scanCode] = scanCodeStr;
      scanCodeStrToInt[scanCodeStr] = scanCode;
      scanCodeLowerCaseStrToInt[scanCodeStr.toLowerCase()] = scanCode;

      if (immutable) {
        IMMUTABLE_CODE_TO_KEY_CODE[scanCode] = keyCode;

        if (keyCode !== KeyCode.Unknown && keyCode !== KeyCode.Enter && keyCode !== KeyCode.Ctrl && keyCode !== KeyCode.Shift && keyCode !== KeyCode.Alt && keyCode !== KeyCode.Meta) {
          IMMUTABLE_KEY_CODE_TO_CODE[keyCode] = scanCode;
        }
      }
    }

    if (!seenKeyCode[keyCode]) {
      seenKeyCode[keyCode] = true;

      if (!keyCodeStr) {
        throw new Error(`String representation missing for key code ${keyCode} around scan code ${scanCodeStr}`);
      }

      uiMap.define(keyCode, keyCodeStr);
      userSettingsUSMap.define(keyCode, usUserSettingsLabel || keyCodeStr);
      userSettingsGeneralMap.define(keyCode, generalUserSettingsLabel || usUserSettingsLabel || keyCodeStr);
    }

    if (eventKeyCode) {
      EVENT_KEY_CODE_MAP[eventKeyCode] = keyCode;
    }

    if (vkey) {
      NATIVE_WINDOWS_KEY_CODE_TO_KEY_CODE[vkey] = keyCode;
    }
  } // Manually added due to the exclusion above (due to duplication with NumpadEnter)


  IMMUTABLE_KEY_CODE_TO_CODE[KeyCode.Enter] = ScanCode.Enter;
})();

let KeyCodeUtils;

(function (_KeyCodeUtils) {
  function toString(keyCode) {
    return uiMap.keyCodeToStr(keyCode);
  }

  _KeyCodeUtils.toString = toString;

  function fromString(key) {
    return uiMap.strToKeyCode(key);
  }

  _KeyCodeUtils.fromString = fromString;

  function toUserSettingsUS(keyCode) {
    return userSettingsUSMap.keyCodeToStr(keyCode);
  }

  _KeyCodeUtils.toUserSettingsUS = toUserSettingsUS;

  function toUserSettingsGeneral(keyCode) {
    return userSettingsGeneralMap.keyCodeToStr(keyCode);
  }

  _KeyCodeUtils.toUserSettingsGeneral = toUserSettingsGeneral;

  function fromUserSettings(key) {
    return userSettingsUSMap.strToKeyCode(key) || userSettingsGeneralMap.strToKeyCode(key);
  }

  _KeyCodeUtils.fromUserSettings = fromUserSettings;

  function toElectronAccelerator(keyCode) {
    if (keyCode >= KeyCode.Numpad0 && keyCode <= KeyCode.NumpadDivide) {
      // [Electron Accelerators] Electron is able to parse numpad keys, but unfortunately it
      // renders them just as regular keys in menus. For example, num0 is rendered as "0",
      // numdiv is rendered as "/", numsub is rendered as "-".
      //
      // This can lead to incredible confusion, as it makes numpad based keybindings indistinguishable
      // from keybindings based on regular keys.
      //
      // We therefore need to fall back to custom rendering for numpad keys.
      return null;
    }

    switch (keyCode) {
      case KeyCode.UpArrow:
        return 'Up';

      case KeyCode.DownArrow:
        return 'Down';

      case KeyCode.LeftArrow:
        return 'Left';

      case KeyCode.RightArrow:
        return 'Right';
    }

    return uiMap.keyCodeToStr(keyCode);
  }

  _KeyCodeUtils.toElectronAccelerator = toElectronAccelerator;
})(KeyCodeUtils || (KeyCodeUtils = {}));

let KeyMod;

(function (KeyMod) {
  KeyMod[KeyMod["CtrlCmd"] = 2048] = "CtrlCmd";
  KeyMod[KeyMod["Shift"] = 1024] = "Shift";
  KeyMod[KeyMod["Alt"] = 512] = "Alt";
  KeyMod[KeyMod["WinCtrl"] = 256] = "WinCtrl";
})(KeyMod || (KeyMod = {}));

function KeyChord(firstPart, secondPart) {
  const chordPart = (secondPart & 0x0000FFFF) << 16 >>> 0;
  return (firstPart | chordPart) >>> 0;
}

/***/ }),
/* 65 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createKeybinding": () => (/* binding */ createKeybinding),
/* harmony export */   "createSimpleKeybinding": () => (/* binding */ createSimpleKeybinding),
/* harmony export */   "SimpleKeybinding": () => (/* binding */ SimpleKeybinding),
/* harmony export */   "ChordKeybinding": () => (/* binding */ ChordKeybinding),
/* harmony export */   "ScanCodeBinding": () => (/* binding */ ScanCodeBinding),
/* harmony export */   "ResolvedKeybindingPart": () => (/* binding */ ResolvedKeybindingPart),
/* harmony export */   "ResolvedKeybinding": () => (/* binding */ ResolvedKeybinding)
/* harmony export */ });
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);
/* harmony import */ var _keyCodes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(64);
/* harmony import */ var _platform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(58);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/



/**
 * Binary encoding strategy:
 * ```
 *    1111 11
 *    5432 1098 7654 3210
 *    ---- CSAW KKKK KKKK
 *  C = bit 11 = ctrlCmd flag
 *  S = bit 10 = shift flag
 *  A = bit 9 = alt flag
 *  W = bit 8 = winCtrl flag
 *  K = bits 0-7 = key code
 * ```
 */

var BinaryKeybindingsMask;

(function (BinaryKeybindingsMask) {
  BinaryKeybindingsMask[BinaryKeybindingsMask["CtrlCmd"] = 2048] = "CtrlCmd";
  BinaryKeybindingsMask[BinaryKeybindingsMask["Shift"] = 1024] = "Shift";
  BinaryKeybindingsMask[BinaryKeybindingsMask["Alt"] = 512] = "Alt";
  BinaryKeybindingsMask[BinaryKeybindingsMask["WinCtrl"] = 256] = "WinCtrl";
  BinaryKeybindingsMask[BinaryKeybindingsMask["KeyCode"] = 255] = "KeyCode";
})(BinaryKeybindingsMask || (BinaryKeybindingsMask = {}));

function createKeybinding(keybinding, OS) {
  if (keybinding === 0) {
    return null;
  }

  const firstPart = (keybinding & 0x0000FFFF) >>> 0;
  const chordPart = (keybinding & 0xFFFF0000) >>> 16;

  if (chordPart !== 0) {
    return new ChordKeybinding([createSimpleKeybinding(firstPart, OS), createSimpleKeybinding(chordPart, OS)]);
  }

  return new ChordKeybinding([createSimpleKeybinding(firstPart, OS)]);
}
function createSimpleKeybinding(keybinding, OS) {
  const ctrlCmd = keybinding & BinaryKeybindingsMask.CtrlCmd ? true : false;
  const winCtrl = keybinding & BinaryKeybindingsMask.WinCtrl ? true : false;
  const ctrlKey = OS === _platform__WEBPACK_IMPORTED_MODULE_2__.OperatingSystem.Macintosh ? winCtrl : ctrlCmd;
  const shiftKey = keybinding & BinaryKeybindingsMask.Shift ? true : false;
  const altKey = keybinding & BinaryKeybindingsMask.Alt ? true : false;
  const metaKey = OS === _platform__WEBPACK_IMPORTED_MODULE_2__.OperatingSystem.Macintosh ? ctrlCmd : winCtrl;
  const keyCode = keybinding & BinaryKeybindingsMask.KeyCode;
  return new SimpleKeybinding(ctrlKey, shiftKey, altKey, metaKey, keyCode);
}
class SimpleKeybinding {
  constructor(ctrlKey, shiftKey, altKey, metaKey, keyCode) {
    this.ctrlKey = ctrlKey;
    this.shiftKey = shiftKey;
    this.altKey = altKey;
    this.metaKey = metaKey;
    this.keyCode = keyCode;
  }

  equals(other) {
    return this.ctrlKey === other.ctrlKey && this.shiftKey === other.shiftKey && this.altKey === other.altKey && this.metaKey === other.metaKey && this.keyCode === other.keyCode;
  }

  getHashCode() {
    const ctrl = this.ctrlKey ? '1' : '0';
    const shift = this.shiftKey ? '1' : '0';
    const alt = this.altKey ? '1' : '0';
    const meta = this.metaKey ? '1' : '0';
    return `${ctrl}${shift}${alt}${meta}${this.keyCode}`;
  }

  isModifierKey() {
    return this.keyCode === _keyCodes__WEBPACK_IMPORTED_MODULE_1__.KeyCode.Unknown || this.keyCode === _keyCodes__WEBPACK_IMPORTED_MODULE_1__.KeyCode.Ctrl || this.keyCode === _keyCodes__WEBPACK_IMPORTED_MODULE_1__.KeyCode.Meta || this.keyCode === _keyCodes__WEBPACK_IMPORTED_MODULE_1__.KeyCode.Alt || this.keyCode === _keyCodes__WEBPACK_IMPORTED_MODULE_1__.KeyCode.Shift;
  }

  toChord() {
    return new ChordKeybinding([this]);
  }
  /**
   * Does this keybinding refer to the key code of a modifier and it also has the modifier flag?
   */


  isDuplicateModifierCase() {
    return this.ctrlKey && this.keyCode === _keyCodes__WEBPACK_IMPORTED_MODULE_1__.KeyCode.Ctrl || this.shiftKey && this.keyCode === _keyCodes__WEBPACK_IMPORTED_MODULE_1__.KeyCode.Shift || this.altKey && this.keyCode === _keyCodes__WEBPACK_IMPORTED_MODULE_1__.KeyCode.Alt || this.metaKey && this.keyCode === _keyCodes__WEBPACK_IMPORTED_MODULE_1__.KeyCode.Meta;
  }

}
class ChordKeybinding {
  constructor(parts) {
    if (parts.length === 0) {
      throw (0,_errors__WEBPACK_IMPORTED_MODULE_0__.illegalArgument)(`parts`);
    }

    this.parts = parts;
  }

  getHashCode() {
    let result = '';

    for (let i = 0, len = this.parts.length; i < len; i++) {
      if (i !== 0) {
        result += ';';
      }

      result += this.parts[i].getHashCode();
    }

    return result;
  }

  equals(other) {
    if (other === null) {
      return false;
    }

    if (this.parts.length !== other.parts.length) {
      return false;
    }

    for (let i = 0; i < this.parts.length; i++) {
      if (!this.parts[i].equals(other.parts[i])) {
        return false;
      }
    }

    return true;
  }

}
class ScanCodeBinding {
  constructor(ctrlKey, shiftKey, altKey, metaKey, scanCode) {
    this.ctrlKey = ctrlKey;
    this.shiftKey = shiftKey;
    this.altKey = altKey;
    this.metaKey = metaKey;
    this.scanCode = scanCode;
  }

  equals(other) {
    return this.ctrlKey === other.ctrlKey && this.shiftKey === other.shiftKey && this.altKey === other.altKey && this.metaKey === other.metaKey && this.scanCode === other.scanCode;
  }
  /**
   * Does this keybinding refer to the key code of a modifier and it also has the modifier flag?
   */


  isDuplicateModifierCase() {
    return this.ctrlKey && (this.scanCode === _keyCodes__WEBPACK_IMPORTED_MODULE_1__.ScanCode.ControlLeft || this.scanCode === _keyCodes__WEBPACK_IMPORTED_MODULE_1__.ScanCode.ControlRight) || this.shiftKey && (this.scanCode === _keyCodes__WEBPACK_IMPORTED_MODULE_1__.ScanCode.ShiftLeft || this.scanCode === _keyCodes__WEBPACK_IMPORTED_MODULE_1__.ScanCode.ShiftRight) || this.altKey && (this.scanCode === _keyCodes__WEBPACK_IMPORTED_MODULE_1__.ScanCode.AltLeft || this.scanCode === _keyCodes__WEBPACK_IMPORTED_MODULE_1__.ScanCode.AltRight) || this.metaKey && (this.scanCode === _keyCodes__WEBPACK_IMPORTED_MODULE_1__.ScanCode.MetaLeft || this.scanCode === _keyCodes__WEBPACK_IMPORTED_MODULE_1__.ScanCode.MetaRight);
  }

}
class ResolvedKeybindingPart {
  constructor(ctrlKey, shiftKey, altKey, metaKey, kbLabel, kbAriaLabel) {
    this.ctrlKey = ctrlKey;
    this.shiftKey = shiftKey;
    this.altKey = altKey;
    this.metaKey = metaKey;
    this.keyLabel = kbLabel;
    this.keyAriaLabel = kbAriaLabel;
  }

}

/**
 * A resolved keybinding. Can be a simple keybinding or a chord keybinding.
 */
class ResolvedKeybinding {}

/***/ }),
/* 66 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StandardMouseEvent": () => (/* binding */ StandardMouseEvent),
/* harmony export */   "DragMouseEvent": () => (/* binding */ DragMouseEvent),
/* harmony export */   "StandardWheelEvent": () => (/* binding */ StandardWheelEvent)
/* harmony export */ });
/* harmony import */ var _browser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(50);
/* harmony import */ var _iframe__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(67);
/* harmony import */ var _common_platform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(58);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/



class StandardMouseEvent {
  constructor(e) {
    this.timestamp = Date.now();
    this.browserEvent = e;
    this.leftButton = e.button === 0;
    this.middleButton = e.button === 1;
    this.rightButton = e.button === 2;
    this.buttons = e.buttons;
    this.target = e.target;
    this.detail = e.detail || 1;

    if (e.type === 'dblclick') {
      this.detail = 2;
    }

    this.ctrlKey = e.ctrlKey;
    this.shiftKey = e.shiftKey;
    this.altKey = e.altKey;
    this.metaKey = e.metaKey;

    if (typeof e.pageX === 'number') {
      this.posx = e.pageX;
      this.posy = e.pageY;
    } else {
      // Probably hit by MSGestureEvent
      this.posx = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
      this.posy = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;
    } // Find the position of the iframe this code is executing in relative to the iframe where the event was captured.


    const iframeOffsets = _iframe__WEBPACK_IMPORTED_MODULE_1__.IframeUtils.getPositionOfChildWindowRelativeToAncestorWindow(self, e.view);
    this.posx -= iframeOffsets.left;
    this.posy -= iframeOffsets.top;
  }

  preventDefault() {
    this.browserEvent.preventDefault();
  }

  stopPropagation() {
    this.browserEvent.stopPropagation();
  }

}
class DragMouseEvent extends StandardMouseEvent {
  constructor(e) {
    super(e);
    this.dataTransfer = e.dataTransfer;
  }

}
class StandardWheelEvent {
  constructor(e, deltaX = 0, deltaY = 0) {
    this.browserEvent = e || null;
    this.target = e ? e.target || e.targetNode || e.srcElement : null;
    this.deltaY = deltaY;
    this.deltaX = deltaX;

    if (e) {
      // Old (deprecated) wheel events
      const e1 = e;
      const e2 = e; // vertical delta scroll

      if (typeof e1.wheelDeltaY !== 'undefined') {
        this.deltaY = e1.wheelDeltaY / 120;
      } else if (typeof e2.VERTICAL_AXIS !== 'undefined' && e2.axis === e2.VERTICAL_AXIS) {
        this.deltaY = -e2.detail / 3;
      } else if (e.type === 'wheel') {
        // Modern wheel event
        // https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent
        const ev = e;

        if (ev.deltaMode === ev.DOM_DELTA_LINE) {
          // the deltas are expressed in lines
          if (_browser__WEBPACK_IMPORTED_MODULE_0__.isFirefox && !_common_platform__WEBPACK_IMPORTED_MODULE_2__.isMacintosh) {
            this.deltaY = -e.deltaY / 3;
          } else {
            this.deltaY = -e.deltaY;
          }
        } else {
          this.deltaY = -e.deltaY / 40;
        }
      } // horizontal delta scroll


      if (typeof e1.wheelDeltaX !== 'undefined') {
        if (_browser__WEBPACK_IMPORTED_MODULE_0__.isSafari && _common_platform__WEBPACK_IMPORTED_MODULE_2__.isWindows) {
          this.deltaX = -(e1.wheelDeltaX / 120);
        } else {
          this.deltaX = e1.wheelDeltaX / 120;
        }
      } else if (typeof e2.HORIZONTAL_AXIS !== 'undefined' && e2.axis === e2.HORIZONTAL_AXIS) {
        this.deltaX = -e.detail / 3;
      } else if (e.type === 'wheel') {
        // Modern wheel event
        // https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent
        const ev = e;

        if (ev.deltaMode === ev.DOM_DELTA_LINE) {
          // the deltas are expressed in lines
          if (_browser__WEBPACK_IMPORTED_MODULE_0__.isFirefox && !_common_platform__WEBPACK_IMPORTED_MODULE_2__.isMacintosh) {
            this.deltaX = -e.deltaX / 3;
          } else {
            this.deltaX = -e.deltaX;
          }
        } else {
          this.deltaX = -e.deltaX / 40;
        }
      } // Assume a vertical scroll if nothing else worked


      if (this.deltaY === 0 && this.deltaX === 0 && e.wheelDelta) {
        this.deltaY = e.wheelDelta / 120;
      }
    }
  }

  preventDefault() {
    this.browserEvent?.preventDefault();
  }

  stopPropagation() {
    this.browserEvent?.stopPropagation();
  }

}

/***/ }),
/* 67 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IframeUtils": () => (/* binding */ IframeUtils)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

/**
 * Represents a window in a possible chain of iframes
 */
let hasDifferentOriginAncestorFlag = false;
let sameOriginWindowChainCache = null;

function getParentWindowIfSameOrigin(w) {
  if (!w.parent || w.parent === w) {
    return null;
  } // Cannot really tell if we have access to the parent window unless we try to access something in it


  try {
    const location = w.location;
    const parentLocation = w.parent.location;

    if (location.origin !== 'null' && parentLocation.origin !== 'null' && location.origin !== parentLocation.origin) {
      hasDifferentOriginAncestorFlag = true;
      return null;
    }
  } catch (e) {
    hasDifferentOriginAncestorFlag = true;
    return null;
  }

  return w.parent;
}

class IframeUtils {
  /**
   * Returns a chain of embedded windows with the same origin (which can be accessed programmatically).
   * Having a chain of length 1 might mean that the current execution environment is running outside of an iframe or inside an iframe embedded in a window with a different origin.
   * To distinguish if at one point the current execution environment is running inside a window with a different origin, see hasDifferentOriginAncestor()
   */
  static getSameOriginWindowChain() {
    if (!sameOriginWindowChainCache) {
      sameOriginWindowChainCache = [];
      let w = window;
      let parent;

      do {
        parent = getParentWindowIfSameOrigin(w);

        if (parent) {
          sameOriginWindowChainCache.push({
            window: w,
            iframeElement: w.frameElement || null
          });
        } else {
          sameOriginWindowChainCache.push({
            window: w,
            iframeElement: null
          });
        }

        w = parent;
      } while (w);
    }

    return sameOriginWindowChainCache.slice(0);
  }
  /**
   * Returns true if the current execution environment is chained in a list of iframes which at one point ends in a window with a different origin.
   * Returns false if the current execution environment is not running inside an iframe or if the entire chain of iframes have the same origin.
   */


  static hasDifferentOriginAncestor() {
    if (!sameOriginWindowChainCache) {
      this.getSameOriginWindowChain();
    }

    return hasDifferentOriginAncestorFlag;
  }
  /**
   * Returns the position of `childWindow` relative to `ancestorWindow`
   */


  static getPositionOfChildWindowRelativeToAncestorWindow(childWindow, ancestorWindow) {
    if (!ancestorWindow || childWindow === ancestorWindow) {
      return {
        top: 0,
        left: 0
      };
    }

    let top = 0,
        left = 0;
    const windowChain = this.getSameOriginWindowChain();

    for (const windowChainEl of windowChain) {
      top += windowChainEl.window.scrollY;
      left += windowChainEl.window.scrollX;

      if (windowChainEl.window === ancestorWindow) {
        break;
      }

      if (!windowChainEl.iframeElement) {
        break;
      }

      const boundingRect = windowChainEl.iframeElement.getBoundingClientRect();
      top += boundingRect.top;
      left += boundingRect.left;
    }

    return {
      top: top,
      left: left
    };
  }

}

/***/ }),
/* 68 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isThenable": () => (/* binding */ isThenable),
/* harmony export */   "createCancelablePromise": () => (/* binding */ createCancelablePromise),
/* harmony export */   "raceCancellation": () => (/* binding */ raceCancellation),
/* harmony export */   "raceCancellationError": () => (/* binding */ raceCancellationError),
/* harmony export */   "raceCancellablePromises": () => (/* binding */ raceCancellablePromises),
/* harmony export */   "raceTimeout": () => (/* binding */ raceTimeout),
/* harmony export */   "asPromise": () => (/* binding */ asPromise),
/* harmony export */   "Throttler": () => (/* binding */ Throttler),
/* harmony export */   "Sequencer": () => (/* binding */ Sequencer),
/* harmony export */   "SequencerByKey": () => (/* binding */ SequencerByKey),
/* harmony export */   "MicrotaskDelay": () => (/* binding */ MicrotaskDelay),
/* harmony export */   "Delayer": () => (/* binding */ Delayer),
/* harmony export */   "ThrottledDelayer": () => (/* binding */ ThrottledDelayer),
/* harmony export */   "Barrier": () => (/* binding */ Barrier),
/* harmony export */   "AutoOpenBarrier": () => (/* binding */ AutoOpenBarrier),
/* harmony export */   "timeout": () => (/* binding */ timeout),
/* harmony export */   "disposableTimeout": () => (/* binding */ disposableTimeout),
/* harmony export */   "sequence": () => (/* binding */ sequence),
/* harmony export */   "first": () => (/* binding */ first),
/* harmony export */   "firstParallel": () => (/* binding */ firstParallel),
/* harmony export */   "Limiter": () => (/* binding */ Limiter),
/* harmony export */   "Queue": () => (/* binding */ Queue),
/* harmony export */   "ResourceQueue": () => (/* binding */ ResourceQueue),
/* harmony export */   "TimeoutTimer": () => (/* binding */ TimeoutTimer),
/* harmony export */   "IntervalTimer": () => (/* binding */ IntervalTimer),
/* harmony export */   "RunOnceScheduler": () => (/* binding */ RunOnceScheduler),
/* harmony export */   "ProcessTimeRunOnceScheduler": () => (/* binding */ ProcessTimeRunOnceScheduler),
/* harmony export */   "RunOnceWorker": () => (/* binding */ RunOnceWorker),
/* harmony export */   "ThrottledWorker": () => (/* binding */ ThrottledWorker),
/* harmony export */   "runWhenIdle": () => (/* binding */ runWhenIdle),
/* harmony export */   "IdleValue": () => (/* binding */ IdleValue),
/* harmony export */   "retry": () => (/* binding */ retry),
/* harmony export */   "TaskSequentializer": () => (/* binding */ TaskSequentializer),
/* harmony export */   "IntervalCounter": () => (/* binding */ IntervalCounter),
/* harmony export */   "DeferredPromise": () => (/* binding */ DeferredPromise),
/* harmony export */   "Promises": () => (/* binding */ Promises),
/* harmony export */   "AsyncIterableObject": () => (/* binding */ AsyncIterableObject),
/* harmony export */   "CancelableAsyncIterableObject": () => (/* binding */ CancelableAsyncIterableObject),
/* harmony export */   "createCancelableAsyncIterable": () => (/* binding */ createCancelableAsyncIterable)
/* harmony export */ });
/* harmony import */ var _cancellation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(69);
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52);
/* harmony import */ var _event__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(51);
/* harmony import */ var _lifecycle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(54);
/* harmony import */ var _resources__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(70);
/* harmony import */ var _platform__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(58);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






function isThenable(obj) {
  return !!obj && typeof obj.then === 'function';
}
function createCancelablePromise(callback) {
  const source = new _cancellation__WEBPACK_IMPORTED_MODULE_0__.CancellationTokenSource();
  const thenable = callback(source.token);
  const promise = new Promise((resolve, reject) => {
    const subscription = source.token.onCancellationRequested(() => {
      subscription.dispose();
      source.dispose();
      reject(new _errors__WEBPACK_IMPORTED_MODULE_1__.CancellationError());
    });
    Promise.resolve(thenable).then(value => {
      subscription.dispose();
      source.dispose();
      resolve(value);
    }, err => {
      subscription.dispose();
      source.dispose();
      reject(err);
    });
  });
  return new class {
    cancel() {
      source.cancel();
    }

    then(resolve, reject) {
      return promise.then(resolve, reject);
    }

    catch(reject) {
      return this.then(undefined, reject);
    }

    finally(onfinally) {
      return promise.finally(onfinally);
    }

  }();
}
/**
 * Returns a promise that resolves with `undefined` as soon as the passed token is cancelled.
 * @see {@link raceCancellationError}
 */

function raceCancellation(promise, token, defaultValue) {
  return new Promise((resolve, reject) => {
    const ref = token.onCancellationRequested(() => {
      ref.dispose();
      resolve(defaultValue);
    });
    promise.then(resolve, reject).finally(() => ref.dispose());
  });
}
/**
 * Returns a promise that rejects with an {@CancellationError} as soon as the passed token is cancelled.
 * @see {@link raceCancellation}
 */

function raceCancellationError(promise, token) {
  return new Promise((resolve, reject) => {
    const ref = token.onCancellationRequested(() => {
      ref.dispose();
      reject(new _errors__WEBPACK_IMPORTED_MODULE_1__.CancellationError());
    });
    promise.then(resolve, reject).finally(() => ref.dispose());
  });
}
/**
 * Returns as soon as one of the promises is resolved and cancels remaining promises
 */

async function raceCancellablePromises(cancellablePromises) {
  let resolvedPromiseIndex = -1;
  const promises = cancellablePromises.map((promise, index) => promise.then(result => {
    resolvedPromiseIndex = index;
    return result;
  }));
  const result = await Promise.race(promises);
  cancellablePromises.forEach((cancellablePromise, index) => {
    if (index !== resolvedPromiseIndex) {
      cancellablePromise.cancel();
    }
  });
  return result;
}
function raceTimeout(promise, timeout, onTimeout) {
  let promiseResolve = undefined;
  const timer = setTimeout(() => {
    promiseResolve?.(undefined);
    onTimeout?.();
  }, timeout);
  return Promise.race([promise.finally(() => clearTimeout(timer)), new Promise(resolve => promiseResolve = resolve)]);
}
function asPromise(callback) {
  return new Promise((resolve, reject) => {
    const item = callback();

    if (isThenable(item)) {
      item.then(resolve, reject);
    } else {
      resolve(item);
    }
  });
}

/**
 * A helper to prevent accumulation of sequential async tasks.
 *
 * Imagine a mail man with the sole task of delivering letters. As soon as
 * a letter submitted for delivery, he drives to the destination, delivers it
 * and returns to his base. Imagine that during the trip, N more letters were submitted.
 * When the mail man returns, he picks those N letters and delivers them all in a
 * single trip. Even though N+1 submissions occurred, only 2 deliveries were made.
 *
 * The throttler implements this via the queue() method, by providing it a task
 * factory. Following the example:
 *
 * 		const throttler = new Throttler();
 * 		const letters = [];
 *
 * 		function deliver() {
 * 			const lettersToDeliver = letters;
 * 			letters = [];
 * 			return makeTheTrip(lettersToDeliver);
 * 		}
 *
 * 		function onLetterReceived(l) {
 * 			letters.push(l);
 * 			throttler.queue(deliver);
 * 		}
 */
class Throttler {
  constructor() {
    this.activePromise = null;
    this.queuedPromise = null;
    this.queuedPromiseFactory = null;
  }

  queue(promiseFactory) {
    if (this.activePromise) {
      this.queuedPromiseFactory = promiseFactory;

      if (!this.queuedPromise) {
        const onComplete = () => {
          this.queuedPromise = null;
          const result = this.queue(this.queuedPromiseFactory);
          this.queuedPromiseFactory = null;
          return result;
        };

        this.queuedPromise = new Promise(resolve => {
          this.activePromise.then(onComplete, onComplete).then(resolve);
        });
      }

      return new Promise((resolve, reject) => {
        this.queuedPromise.then(resolve, reject);
      });
    }

    this.activePromise = promiseFactory();
    return new Promise((resolve, reject) => {
      this.activePromise.then(result => {
        this.activePromise = null;
        resolve(result);
      }, err => {
        this.activePromise = null;
        reject(err);
      });
    });
  }

}
class Sequencer {
  current = Promise.resolve(null);

  queue(promiseTask) {
    return this.current = this.current.then(() => promiseTask(), () => promiseTask());
  }

}
class SequencerByKey {
  promiseMap = new Map();

  queue(key, promiseTask) {
    const runningPromise = this.promiseMap.get(key) ?? Promise.resolve();
    const newPromise = runningPromise.catch(() => {}).then(promiseTask).finally(() => {
      if (this.promiseMap.get(key) === newPromise) {
        this.promiseMap.delete(key);
      }
    });
    this.promiseMap.set(key, newPromise);
    return newPromise;
  }

}

const timeoutDeferred = (timeout, fn) => {
  let scheduled = true;
  const handle = setTimeout(() => {
    scheduled = false;
    fn();
  }, timeout);
  return {
    isTriggered: () => scheduled,
    dispose: () => {
      clearTimeout(handle);
      scheduled = false;
    }
  };
};

const microtaskDeferred = fn => {
  let scheduled = true;
  queueMicrotask(() => {
    if (scheduled) {
      scheduled = false;
      fn();
    }
  });
  return {
    isTriggered: () => scheduled,
    dispose: () => {
      scheduled = false;
    }
  };
};
/** Can be passed into the Delayed to defer using a microtask */


const MicrotaskDelay = Symbol('MicrotaskDelay');
/**
 * A helper to delay (debounce) execution of a task that is being requested often.
 *
 * Following the throttler, now imagine the mail man wants to optimize the number of
 * trips proactively. The trip itself can be long, so he decides not to make the trip
 * as soon as a letter is submitted. Instead he waits a while, in case more
 * letters are submitted. After said waiting period, if no letters were submitted, he
 * decides to make the trip. Imagine that N more letters were submitted after the first
 * one, all within a short period of time between each other. Even though N+1
 * submissions occurred, only 1 delivery was made.
 *
 * The delayer offers this behavior via the trigger() method, into which both the task
 * to be executed and the waiting period (delay) must be passed in as arguments. Following
 * the example:
 *
 * 		const delayer = new Delayer(WAITING_PERIOD);
 * 		const letters = [];
 *
 * 		function letterReceived(l) {
 * 			letters.push(l);
 * 			delayer.trigger(() => { return makeTheTrip(); });
 * 		}
 */

class Delayer {
  constructor(defaultDelay) {
    this.defaultDelay = defaultDelay;
    this.deferred = null;
    this.completionPromise = null;
    this.doResolve = null;
    this.doReject = null;
    this.task = null;
  }

  trigger(task, delay = this.defaultDelay) {
    this.task = task;
    this.cancelTimeout();

    if (!this.completionPromise) {
      this.completionPromise = new Promise((resolve, reject) => {
        this.doResolve = resolve;
        this.doReject = reject;
      }).then(() => {
        this.completionPromise = null;
        this.doResolve = null;

        if (this.task) {
          const task = this.task;
          this.task = null;
          return task();
        }

        return undefined;
      });
    }

    const fn = () => {
      this.deferred = null;
      this.doResolve?.(null);
    };

    this.deferred = delay === MicrotaskDelay ? microtaskDeferred(fn) : timeoutDeferred(delay, fn);
    return this.completionPromise;
  }

  isTriggered() {
    return !!this.deferred?.isTriggered();
  }

  cancel() {
    this.cancelTimeout();

    if (this.completionPromise) {
      this.doReject?.(new _errors__WEBPACK_IMPORTED_MODULE_1__.CancellationError());
      this.completionPromise = null;
    }
  }

  cancelTimeout() {
    this.deferred?.dispose();
    this.deferred = null;
  }

  dispose() {
    this.cancel();
  }

}
/**
 * A helper to delay execution of a task that is being requested often, while
 * preventing accumulation of consecutive executions, while the task runs.
 *
 * The mail man is clever and waits for a certain amount of time, before going
 * out to deliver letters. While the mail man is going out, more letters arrive
 * and can only be delivered once he is back. Once he is back the mail man will
 * do one more trip to deliver the letters that have accumulated while he was out.
 */

class ThrottledDelayer {
  constructor(defaultDelay) {
    this.delayer = new Delayer(defaultDelay);
    this.throttler = new Throttler();
  }

  trigger(promiseFactory, delay) {
    return this.delayer.trigger(() => this.throttler.queue(promiseFactory), delay);
  }

  isTriggered() {
    return this.delayer.isTriggered();
  }

  cancel() {
    this.delayer.cancel();
  }

  dispose() {
    this.delayer.dispose();
  }

}
/**
 * A barrier that is initially closed and then becomes opened permanently.
 */

class Barrier {
  constructor() {
    this._isOpen = false;
    this._promise = new Promise((c, e) => {
      this._completePromise = c;
    });
  }

  isOpen() {
    return this._isOpen;
  }

  open() {
    this._isOpen = true;

    this._completePromise(true);
  }

  wait() {
    return this._promise;
  }

}
/**
 * A barrier that is initially closed and then becomes opened permanently after a certain period of
 * time or when open is called explicitly
 */

class AutoOpenBarrier extends Barrier {
  constructor(autoOpenTimeMs) {
    super();
    this._timeout = setTimeout(() => this.open(), autoOpenTimeMs);
  }

  open() {
    clearTimeout(this._timeout);
    super.open();
  }

}
function timeout(millis, token) {
  if (!token) {
    return createCancelablePromise(token => timeout(millis, token));
  }

  return new Promise((resolve, reject) => {
    const handle = setTimeout(() => {
      disposable.dispose();
      resolve();
    }, millis);
    const disposable = token.onCancellationRequested(() => {
      clearTimeout(handle);
      disposable.dispose();
      reject(new _errors__WEBPACK_IMPORTED_MODULE_1__.CancellationError());
    });
  });
}
function disposableTimeout(handler, timeout = 0) {
  const timer = setTimeout(handler, timeout);
  return (0,_lifecycle__WEBPACK_IMPORTED_MODULE_3__.toDisposable)(() => clearTimeout(timer));
}
/**
 * Runs the provided list of promise factories in sequential order. The returned
 * promise will complete to an array of results from each promise.
 */

function sequence(promiseFactories) {
  const results = [];
  let index = 0;
  const len = promiseFactories.length;

  function next() {
    return index < len ? promiseFactories[index++]() : null;
  }

  function thenHandler(result) {
    if (result !== undefined && result !== null) {
      results.push(result);
    }

    const n = next();

    if (n) {
      return n.then(thenHandler);
    }

    return Promise.resolve(results);
  }

  return Promise.resolve(null).then(thenHandler);
}
function first(promiseFactories, shouldStop = t => !!t, defaultValue = null) {
  let index = 0;
  const len = promiseFactories.length;

  const loop = () => {
    if (index >= len) {
      return Promise.resolve(defaultValue);
    }

    const factory = promiseFactories[index++];
    const promise = Promise.resolve(factory());
    return promise.then(result => {
      if (shouldStop(result)) {
        return Promise.resolve(result);
      }

      return loop();
    });
  };

  return loop();
}
/**
 * Returns the result of the first promise that matches the "shouldStop",
 * running all promises in parallel. Supports cancelable promises.
 */

function firstParallel(promiseList, shouldStop = t => !!t, defaultValue = null) {
  if (promiseList.length === 0) {
    return Promise.resolve(defaultValue);
  }

  let todo = promiseList.length;

  const finish = () => {
    todo = -1;

    for (const promise of promiseList) {
      promise.cancel?.();
    }
  };

  return new Promise((resolve, reject) => {
    for (const promise of promiseList) {
      promise.then(result => {
        if (--todo >= 0 && shouldStop(result)) {
          finish();
          resolve(result);
        } else if (todo === 0) {
          resolve(defaultValue);
        }
      }).catch(err => {
        if (--todo >= 0) {
          finish();
          reject(err);
        }
      });
    }
  });
}

/**
 * A helper to queue N promises and run them all with a max degree of parallelism. The helper
 * ensures that at any time no more than M promises are running at the same time.
 */
class Limiter {
  _size = 0;

  constructor(maxDegreeOfParalellism) {
    this.maxDegreeOfParalellism = maxDegreeOfParalellism;
    this.outstandingPromises = [];
    this.runningPromises = 0;
    this._onDrained = new _event__WEBPACK_IMPORTED_MODULE_2__.Emitter();
  }
  /**
   * An event that fires when every promise in the queue
   * has started to execute. In other words: no work is
   * pending to be scheduled.
   *
   * This is NOT an event that signals when all promises
   * have finished though.
   */


  get onDrained() {
    return this._onDrained.event;
  }

  get size() {
    return this._size;
  }

  queue(factory) {
    this._size++;
    return new Promise((c, e) => {
      this.outstandingPromises.push({
        factory,
        c,
        e
      });
      this.consume();
    });
  }

  consume() {
    while (this.outstandingPromises.length && this.runningPromises < this.maxDegreeOfParalellism) {
      const iLimitedTask = this.outstandingPromises.shift();
      this.runningPromises++;
      const promise = iLimitedTask.factory();
      promise.then(iLimitedTask.c, iLimitedTask.e);
      promise.then(() => this.consumed(), () => this.consumed());
    }
  }

  consumed() {
    this._size--;
    this.runningPromises--;

    if (this.outstandingPromises.length > 0) {
      this.consume();
    } else {
      this._onDrained.fire();
    }
  }

  dispose() {
    this._onDrained.dispose();
  }

}
/**
 * A queue is handles one promise at a time and guarantees that at any time only one promise is executing.
 */

class Queue extends Limiter {
  constructor() {
    super(1);
  }

}
/**
 * A helper to organize queues per resource. The ResourceQueue makes sure to manage queues per resource
 * by disposing them once the queue is empty.
 */

class ResourceQueue {
  queues = new Map();
  drainers = new Set();

  async whenDrained() {
    if (this.isDrained()) {
      return;
    }

    const promise = new DeferredPromise();
    this.drainers.add(promise);
    return promise.p;
  }

  isDrained() {
    for (const [, queue] of this.queues) {
      if (queue.size > 0) {
        return false;
      }
    }

    return true;
  }

  queueFor(resource, extUri = _resources__WEBPACK_IMPORTED_MODULE_4__.extUri) {
    const key = extUri.getComparisonKey(resource);
    let queue = this.queues.get(key);

    if (!queue) {
      queue = new Queue();
      _event__WEBPACK_IMPORTED_MODULE_2__.Event.once(queue.onDrained)(() => {
        queue?.dispose();
        this.queues.delete(key);
        this.onDidQueueDrain();
      });
      this.queues.set(key, queue);
    }

    return queue;
  }

  onDidQueueDrain() {
    if (!this.isDrained()) {
      return; // not done yet
    }

    this.releaseDrainers();
  }

  releaseDrainers() {
    for (const drainer of this.drainers) {
      drainer.complete();
    }

    this.drainers.clear();
  }

  dispose() {
    for (const [, queue] of this.queues) {
      queue.dispose();
    }

    this.queues.clear(); // Even though we might still have pending
    // tasks queued, after the queues have been
    // disposed, we can no longer track them, so
    // we release drainers to prevent hanging
    // promises when the resource queue is being
    // disposed.

    this.releaseDrainers();
  }

}
class TimeoutTimer {
  constructor(runner, timeout) {
    this._token = -1;

    if (typeof runner === 'function' && typeof timeout === 'number') {
      this.setIfNotSet(runner, timeout);
    }
  }

  dispose() {
    this.cancel();
  }

  cancel() {
    if (this._token !== -1) {
      clearTimeout(this._token);
      this._token = -1;
    }
  }

  cancelAndSet(runner, timeout) {
    this.cancel();
    this._token = setTimeout(() => {
      this._token = -1;
      runner();
    }, timeout);
  }

  setIfNotSet(runner, timeout) {
    if (this._token !== -1) {
      // timer is already set
      return;
    }

    this._token = setTimeout(() => {
      this._token = -1;
      runner();
    }, timeout);
  }

}
class IntervalTimer {
  constructor() {
    this._token = -1;
  }

  dispose() {
    this.cancel();
  }

  cancel() {
    if (this._token !== -1) {
      clearInterval(this._token);
      this._token = -1;
    }
  }

  cancelAndSet(runner, interval) {
    this.cancel();
    this._token = setInterval(() => {
      runner();
    }, interval);
  }

}
class RunOnceScheduler {
  constructor(runner, delay) {
    this.timeoutToken = -1;
    this.runner = runner;
    this.timeout = delay;
    this.timeoutHandler = this.onTimeout.bind(this);
  }
  /**
   * Dispose RunOnceScheduler
   */


  dispose() {
    this.cancel();
    this.runner = null;
  }
  /**
   * Cancel current scheduled runner (if any).
   */


  cancel() {
    if (this.isScheduled()) {
      clearTimeout(this.timeoutToken);
      this.timeoutToken = -1;
    }
  }
  /**
   * Cancel previous runner (if any) & schedule a new runner.
   */


  schedule(delay = this.timeout) {
    this.cancel();
    this.timeoutToken = setTimeout(this.timeoutHandler, delay);
  }

  get delay() {
    return this.timeout;
  }

  set delay(value) {
    this.timeout = value;
  }
  /**
   * Returns true if scheduled.
   */


  isScheduled() {
    return this.timeoutToken !== -1;
  }

  onTimeout() {
    this.timeoutToken = -1;

    if (this.runner) {
      this.doRun();
    }
  }

  doRun() {
    this.runner?.();
  }

}
/**
 * Same as `RunOnceScheduler`, but doesn't count the time spent in sleep mode.
 * > **NOTE**: Only offers 1s resolution.
 *
 * When calling `setTimeout` with 3hrs, and putting the computer immediately to sleep
 * for 8hrs, `setTimeout` will fire **as soon as the computer wakes from sleep**. But
 * this scheduler will execute 3hrs **after waking the computer from sleep**.
 */

class ProcessTimeRunOnceScheduler {
  constructor(runner, delay) {
    if (delay % 1000 !== 0) {
      console.warn(`ProcessTimeRunOnceScheduler resolution is 1s, ${delay}ms is not a multiple of 1000ms.`);
    }

    this.runner = runner;
    this.timeout = delay;
    this.counter = 0;
    this.intervalToken = -1;
    this.intervalHandler = this.onInterval.bind(this);
  }

  dispose() {
    this.cancel();
    this.runner = null;
  }

  cancel() {
    if (this.isScheduled()) {
      clearInterval(this.intervalToken);
      this.intervalToken = -1;
    }
  }
  /**
   * Cancel previous runner (if any) & schedule a new runner.
   */


  schedule(delay = this.timeout) {
    if (delay % 1000 !== 0) {
      console.warn(`ProcessTimeRunOnceScheduler resolution is 1s, ${delay}ms is not a multiple of 1000ms.`);
    }

    this.cancel();
    this.counter = Math.ceil(delay / 1000);
    this.intervalToken = setInterval(this.intervalHandler, 1000);
  }
  /**
   * Returns true if scheduled.
   */


  isScheduled() {
    return this.intervalToken !== -1;
  }

  onInterval() {
    this.counter--;

    if (this.counter > 0) {
      // still need to wait
      return;
    } // time elapsed


    clearInterval(this.intervalToken);
    this.intervalToken = -1;
    this.runner?.();
  }

}
class RunOnceWorker extends RunOnceScheduler {
  units = [];

  constructor(runner, timeout) {
    super(runner, timeout);
  }

  work(unit) {
    this.units.push(unit);

    if (!this.isScheduled()) {
      this.schedule();
    }
  }

  doRun() {
    const units = this.units;
    this.units = [];
    this.runner?.(units);
  }

  dispose() {
    this.units = [];
    super.dispose();
  }

}

/**
 * The `ThrottledWorker` will accept units of work `T`
 * to handle. The contract is:
 * * there is a maximum of units the worker can handle at once (via `maxWorkChunkSize`)
 * * there is a maximum of units the worker will keep in memory for processing (via `maxBufferedWork`)
 * * after having handled `maxWorkChunkSize` units, the worker needs to rest (via `throttleDelay`)
 */
class ThrottledWorker extends _lifecycle__WEBPACK_IMPORTED_MODULE_3__.Disposable {
  pendingWork = [];
  throttler = this._register(new _lifecycle__WEBPACK_IMPORTED_MODULE_3__.MutableDisposable());
  disposed = false;

  constructor(options, handler) {
    super();
    this.options = options;
    this.handler = handler;
  }
  /**
   * The number of work units that are pending to be processed.
   */


  get pending() {
    return this.pendingWork.length;
  }
  /**
   * Add units to be worked on. Use `pending` to figure out
   * how many units are not yet processed after this method
   * was called.
   *
   * @returns whether the work was accepted or not. If the
   * worker is disposed, it will not accept any more work.
   * If the number of pending units would become larger
   * than `maxPendingWork`, more work will also not be accepted.
   */


  work(units) {
    if (this.disposed) {
      return false; // work not accepted: disposed
    } // Check for reaching maximum of pending work


    if (typeof this.options.maxBufferedWork === 'number') {
      // Throttled: simple check if pending + units exceeds max pending
      if (this.throttler.value) {
        if (this.pending + units.length > this.options.maxBufferedWork) {
          return false; // work not accepted: too much pending work
        }
      } // Unthrottled: same as throttled, but account for max chunk getting
      // worked on directly without being pending
      else {
        if (this.pending + units.length - this.options.maxWorkChunkSize > this.options.maxBufferedWork) {
          return false; // work not accepted: too much pending work
        }
      }
    } // Add to pending units first


    this.pendingWork.push(...units); // If not throttled, start working directly
    // Otherwise, when the throttle delay has
    // past, pending work will be worked again.

    if (!this.throttler.value) {
      this.doWork();
    }

    return true; // work accepted
  }

  doWork() {
    // Extract chunk to handle and handle it
    this.handler(this.pendingWork.splice(0, this.options.maxWorkChunkSize)); // If we have remaining work, schedule it after a delay

    if (this.pendingWork.length > 0) {
      this.throttler.value = new RunOnceScheduler(() => {
        this.throttler.clear();
        this.doWork();
      }, this.options.throttleDelay);
      this.throttler.value.schedule();
    }
  }

  dispose() {
    super.dispose();
    this.disposed = true;
  }

} //#region -- run on idle tricks ------------

/**
 * Execute the callback the next time the browser is idle
 */
let runWhenIdle;

(function () {
  if (typeof requestIdleCallback !== 'function' || typeof cancelIdleCallback !== 'function') {
    runWhenIdle = runner => {
      (0,_platform__WEBPACK_IMPORTED_MODULE_5__.setTimeout0)(() => {
        if (disposed) {
          return;
        }

        const end = Date.now() + 15; // one frame at 64fps

        runner(Object.freeze({
          didTimeout: true,

          timeRemaining() {
            return Math.max(0, end - Date.now());
          }

        }));
      });
      let disposed = false;
      return {
        dispose() {
          if (disposed) {
            return;
          }

          disposed = true;
        }

      };
    };
  } else {
    runWhenIdle = (runner, timeout) => {
      const handle = requestIdleCallback(runner, typeof timeout === 'number' ? {
        timeout
      } : undefined);
      let disposed = false;
      return {
        dispose() {
          if (disposed) {
            return;
          }

          disposed = true;
          cancelIdleCallback(handle);
        }

      };
    };
  }
})();
/**
 * An implementation of the "idle-until-urgent"-strategy as introduced
 * here: https://philipwalton.com/articles/idle-until-urgent/
 */


class IdleValue {
  _didRun = false;

  constructor(executor) {
    this._executor = () => {
      try {
        this._value = executor();
      } catch (err) {
        this._error = err;
      } finally {
        this._didRun = true;
      }
    };

    this._handle = runWhenIdle(() => this._executor());
  }

  dispose() {
    this._handle.dispose();
  }

  get value() {
    if (!this._didRun) {
      this._handle.dispose();

      this._executor();
    }

    if (this._error) {
      throw this._error;
    }

    return this._value;
  }

  get isInitialized() {
    return this._didRun;
  }

} //#endregion

async function retry(task, delay, retries) {
  let lastError;

  for (let i = 0; i < retries; i++) {
    try {
      return await task();
    } catch (error) {
      lastError = error;
      await timeout(delay);
    }
  }

  throw lastError;
} //#region Task Sequentializer

class TaskSequentializer {
  hasPending(taskId) {
    if (!this._pending) {
      return false;
    }

    if (typeof taskId === 'number') {
      return this._pending.taskId === taskId;
    }

    return !!this._pending;
  }

  get pending() {
    return this._pending?.promise;
  }

  cancelPending() {
    this._pending?.cancel();
  }

  setPending(taskId, promise, onCancel) {
    this._pending = {
      taskId,
      cancel: () => onCancel?.(),
      promise
    };
    promise.then(() => this.donePending(taskId), () => this.donePending(taskId));
    return promise;
  }

  donePending(taskId) {
    if (this._pending && taskId === this._pending.taskId) {
      // only set pending to done if the promise finished that is associated with that taskId
      this._pending = undefined; // schedule the next task now that we are free if we have any

      this.triggerNext();
    }
  }

  triggerNext() {
    if (this._next) {
      const next = this._next;
      this._next = undefined; // Run next task and complete on the associated promise

      next.run().then(next.promiseResolve, next.promiseReject);
    }
  }

  setNext(run) {
    // this is our first next task, so we create associated promise with it
    // so that we can return a promise that completes when the task has
    // completed.
    if (!this._next) {
      let promiseResolve;
      let promiseReject;
      const promise = new Promise((resolve, reject) => {
        promiseResolve = resolve;
        promiseReject = reject;
      });
      this._next = {
        run,
        promise,
        promiseResolve: promiseResolve,
        promiseReject: promiseReject
      };
    } // we have a previous next task, just overwrite it
    else {
      this._next.run = run;
    }

    return this._next.promise;
  }

  hasNext() {
    return !!this._next;
  }

  async join() {
    return this._next?.promise ?? this._pending?.promise;
  }

} //#endregion
//#region

/**
 * The `IntervalCounter` allows to count the number
 * of calls to `increment()` over a duration of
 * `interval`. This utility can be used to conditionally
 * throttle a frequent task when a certain threshold
 * is reached.
 */

class IntervalCounter {
  lastIncrementTime = 0;
  value = 0;

  constructor(interval, nowFn = () => Date.now()) {
    this.interval = interval;
    this.nowFn = nowFn;
  }

  increment() {
    const now = this.nowFn(); // We are outside of the range of `interval` and as such
    // start counting from 0 and remember the time

    if (now - this.lastIncrementTime > this.interval) {
      this.lastIncrementTime = now;
      this.value = 0;
    }

    this.value++;
    return this.value;
  }

} //#endregion
//#region

/**
 * Creates a promise whose resolution or rejection can be controlled imperatively.
 */
class DeferredPromise {
  rejected = false;
  resolved = false;

  get isRejected() {
    return this.rejected;
  }

  get isResolved() {
    return this.resolved;
  }

  get isSettled() {
    return this.rejected || this.resolved;
  }

  constructor() {
    this.p = new Promise((c, e) => {
      this.completeCallback = c;
      this.errorCallback = e;
    });
  }

  complete(value) {
    return new Promise(resolve => {
      this.completeCallback(value);
      this.resolved = true;
      resolve();
    });
  }

  error(err) {
    return new Promise(resolve => {
      this.errorCallback(err);
      this.rejected = true;
      resolve();
    });
  }

  cancel() {
    new Promise(resolve => {
      this.errorCallback(new _errors__WEBPACK_IMPORTED_MODULE_1__.CancellationError());
      this.rejected = true;
      resolve();
    });
  }

} //#endregion
//#region Promises

let Promises; //#endregion
//#region

(function (_Promises) {
  async function settled(promises) {
    let firstError = undefined;
    const result = await Promise.all(promises.map(promise => promise.then(value => value, error => {
      if (!firstError) {
        firstError = error;
      }

      return undefined; // do not rethrow so that other promises can settle
    })));

    if (typeof firstError !== 'undefined') {
      throw firstError;
    }

    return result; // cast is needed and protected by the `throw` above
  }

  _Promises.settled = settled;

  function withAsyncBody(bodyFn) {
    // eslint-disable-next-line no-async-promise-executor
    return new Promise(async (resolve, reject) => {
      try {
        await bodyFn(resolve, reject);
      } catch (error) {
        reject(error);
      }
    });
  }

  _Promises.withAsyncBody = withAsyncBody;
})(Promises || (Promises = {}));

var AsyncIterableSourceState;
/**
 * An object that allows to emit async values asynchronously or bring the iterable to an error state using `reject()`.
 * This emitter is valid only for the duration of the executor (until the promise returned by the executor settles).
 */

(function (AsyncIterableSourceState) {
  AsyncIterableSourceState[AsyncIterableSourceState["Initial"] = 0] = "Initial";
  AsyncIterableSourceState[AsyncIterableSourceState["DoneOK"] = 1] = "DoneOK";
  AsyncIterableSourceState[AsyncIterableSourceState["DoneError"] = 2] = "DoneError";
})(AsyncIterableSourceState || (AsyncIterableSourceState = {}));

/**
 * A rich implementation for an `AsyncIterable<T>`.
 */
class AsyncIterableObject {
  static fromArray(items) {
    return new AsyncIterableObject(writer => {
      writer.emitMany(items);
    });
  }

  static fromPromise(promise) {
    return new AsyncIterableObject(async emitter => {
      emitter.emitMany(await promise);
    });
  }

  static fromPromises(promises) {
    return new AsyncIterableObject(async emitter => {
      await Promise.all(promises.map(async p => emitter.emitOne(await p)));
    });
  }

  static merge(iterables) {
    return new AsyncIterableObject(async emitter => {
      await Promise.all(iterables.map(async iterable => {
        for await (const item of iterable) {
          emitter.emitOne(item);
        }
      }));
    });
  }

  static EMPTY = AsyncIterableObject.fromArray([]);

  constructor(executor) {
    this._state = AsyncIterableSourceState.Initial;
    this._results = [];
    this._error = null;
    this._onStateChanged = new _event__WEBPACK_IMPORTED_MODULE_2__.Emitter();
    queueMicrotask(async () => {
      const writer = {
        emitOne: item => this.emitOne(item),
        emitMany: items => this.emitMany(items),
        reject: error => this.reject(error)
      };

      try {
        await Promise.resolve(executor(writer));
        this.resolve();
      } catch (err) {
        this.reject(err);
      } finally {
        writer.emitOne = undefined;
        writer.emitMany = undefined;
        writer.reject = undefined;
      }
    });
  }

  [Symbol.asyncIterator]() {
    let i = 0;
    return {
      next: async () => {
        do {
          if (this._state === AsyncIterableSourceState.DoneError) {
            throw this._error;
          }

          if (i < this._results.length) {
            return {
              done: false,
              value: this._results[i++]
            };
          }

          if (this._state === AsyncIterableSourceState.DoneOK) {
            return {
              done: true,
              value: undefined
            };
          }

          await _event__WEBPACK_IMPORTED_MODULE_2__.Event.toPromise(this._onStateChanged.event);
        } while (true);
      }
    };
  }

  static map(iterable, mapFn) {
    return new AsyncIterableObject(async emitter => {
      for await (const item of iterable) {
        emitter.emitOne(mapFn(item));
      }
    });
  }

  map(mapFn) {
    return AsyncIterableObject.map(this, mapFn);
  }

  static filter(iterable, filterFn) {
    return new AsyncIterableObject(async emitter => {
      for await (const item of iterable) {
        if (filterFn(item)) {
          emitter.emitOne(item);
        }
      }
    });
  }

  filter(filterFn) {
    return AsyncIterableObject.filter(this, filterFn);
  }

  static coalesce(iterable) {
    return AsyncIterableObject.filter(iterable, item => !!item);
  }

  coalesce() {
    return AsyncIterableObject.coalesce(this);
  }

  static async toPromise(iterable) {
    const result = [];

    for await (const item of iterable) {
      result.push(item);
    }

    return result;
  }

  toPromise() {
    return AsyncIterableObject.toPromise(this);
  }
  /**
   * The value will be appended at the end.
   *
   * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.
   */


  emitOne(value) {
    if (this._state !== AsyncIterableSourceState.Initial) {
      return;
    } // it is important to add new values at the end,
    // as we may have iterators already running on the array


    this._results.push(value);

    this._onStateChanged.fire();
  }
  /**
   * The values will be appended at the end.
   *
   * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.
   */


  emitMany(values) {
    if (this._state !== AsyncIterableSourceState.Initial) {
      return;
    } // it is important to add new values at the end,
    // as we may have iterators already running on the array


    this._results = this._results.concat(values);

    this._onStateChanged.fire();
  }
  /**
   * Calling `resolve()` will mark the result array as complete.
   *
   * **NOTE** `resolve()` must be called, otherwise all consumers of this iterable will hang indefinitely, similar to a non-resolved promise.
   * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.
   */


  resolve() {
    if (this._state !== AsyncIterableSourceState.Initial) {
      return;
    }

    this._state = AsyncIterableSourceState.DoneOK;

    this._onStateChanged.fire();
  }
  /**
   * Writing an error will permanently invalidate this iterable.
   * The current users will receive an error thrown, as will all future users.
   *
   * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.
   */


  reject(error) {
    if (this._state !== AsyncIterableSourceState.Initial) {
      return;
    }

    this._state = AsyncIterableSourceState.DoneError;
    this._error = error;

    this._onStateChanged.fire();
  }

}
class CancelableAsyncIterableObject extends AsyncIterableObject {
  constructor(_source, executor) {
    super(executor);
    this._source = _source;
  }

  cancel() {
    this._source.cancel();
  }

}
function createCancelableAsyncIterable(callback) {
  const source = new _cancellation__WEBPACK_IMPORTED_MODULE_0__.CancellationTokenSource();
  const innerIterable = callback(source.token);
  return new CancelableAsyncIterableObject(source, async emitter => {
    const subscription = source.token.onCancellationRequested(() => {
      subscription.dispose();
      source.dispose();
      emitter.reject(new _errors__WEBPACK_IMPORTED_MODULE_1__.CancellationError());
    });

    try {
      for await (const item of innerIterable) {
        if (source.token.isCancellationRequested) {
          // canceled in the meantime
          return;
        }

        emitter.emitOne(item);
      }

      subscription.dispose();
      source.dispose();
    } catch (err) {
      subscription.dispose();
      source.dispose();
      emitter.reject(err);
    }
  });
} //#endregion

/***/ }),
/* 69 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CancellationToken": () => (/* binding */ CancellationToken),
/* harmony export */   "CancellationTokenSource": () => (/* binding */ CancellationTokenSource)
/* harmony export */ });
/* harmony import */ var _event__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(51);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

const shortcutEvent = Object.freeze(function (callback, context) {
  const handle = setTimeout(callback.bind(context), 0);
  return {
    dispose() {
      clearTimeout(handle);
    }

  };
});
let CancellationToken;

(function (_CancellationToken) {
  function isCancellationToken(thing) {
    if (thing === CancellationToken.None || thing === CancellationToken.Cancelled) {
      return true;
    }

    if (thing instanceof MutableToken) {
      return true;
    }

    if (!thing || typeof thing !== 'object') {
      return false;
    }

    return typeof thing.isCancellationRequested === 'boolean' && typeof thing.onCancellationRequested === 'function';
  }

  _CancellationToken.isCancellationToken = isCancellationToken;
  const None = _CancellationToken.None = Object.freeze({
    isCancellationRequested: false,
    onCancellationRequested: _event__WEBPACK_IMPORTED_MODULE_0__.Event.None
  });
  const Cancelled = _CancellationToken.Cancelled = Object.freeze({
    isCancellationRequested: true,
    onCancellationRequested: shortcutEvent
  });
})(CancellationToken || (CancellationToken = {}));

class MutableToken {
  _isCancelled = false;
  _emitter = null;

  cancel() {
    if (!this._isCancelled) {
      this._isCancelled = true;

      if (this._emitter) {
        this._emitter.fire(undefined);

        this.dispose();
      }
    }
  }

  get isCancellationRequested() {
    return this._isCancelled;
  }

  get onCancellationRequested() {
    if (this._isCancelled) {
      return shortcutEvent;
    }

    if (!this._emitter) {
      this._emitter = new _event__WEBPACK_IMPORTED_MODULE_0__.Emitter();
    }

    return this._emitter.event;
  }

  dispose() {
    if (this._emitter) {
      this._emitter.dispose();

      this._emitter = null;
    }
  }

}

class CancellationTokenSource {
  _token = undefined;
  _parentListener = undefined;

  constructor(parent) {
    this._parentListener = parent && parent.onCancellationRequested(this.cancel, this);
  }

  get token() {
    if (!this._token) {
      // be lazy and create the token only when
      // actually needed
      this._token = new MutableToken();
    }

    return this._token;
  }

  cancel() {
    if (!this._token) {
      // save an object by returning the default
      // cancelled token when cancellation happens
      // before someone asks for the token
      this._token = CancellationToken.Cancelled;
    } else if (this._token instanceof MutableToken) {
      // actually cancel
      this._token.cancel();
    }
  }

  dispose(cancel = false) {
    if (cancel) {
      this.cancel();
    }

    this._parentListener?.dispose();

    if (!this._token) {
      // ensure to initialize with an empty token if we had none
      this._token = CancellationToken.None;
    } else if (this._token instanceof MutableToken) {
      // actually dispose
      this._token.dispose();
    }
  }

}

/***/ }),
/* 70 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "originalFSPath": () => (/* binding */ originalFSPath),
/* harmony export */   "ExtUri": () => (/* binding */ ExtUri),
/* harmony export */   "extUri": () => (/* binding */ extUri),
/* harmony export */   "extUriBiasedIgnorePathCase": () => (/* binding */ extUriBiasedIgnorePathCase),
/* harmony export */   "extUriIgnorePathCase": () => (/* binding */ extUriIgnorePathCase),
/* harmony export */   "isEqual": () => (/* binding */ isEqual),
/* harmony export */   "isEqualOrParent": () => (/* binding */ isEqualOrParent),
/* harmony export */   "getComparisonKey": () => (/* binding */ getComparisonKey),
/* harmony export */   "basenameOrAuthority": () => (/* binding */ basenameOrAuthority),
/* harmony export */   "basename": () => (/* binding */ basename),
/* harmony export */   "extname": () => (/* binding */ extname),
/* harmony export */   "dirname": () => (/* binding */ dirname),
/* harmony export */   "joinPath": () => (/* binding */ joinPath),
/* harmony export */   "normalizePath": () => (/* binding */ normalizePath),
/* harmony export */   "relativePath": () => (/* binding */ relativePath),
/* harmony export */   "resolvePath": () => (/* binding */ resolvePath),
/* harmony export */   "isAbsolutePath": () => (/* binding */ isAbsolutePath),
/* harmony export */   "isEqualAuthority": () => (/* binding */ isEqualAuthority),
/* harmony export */   "hasTrailingPathSeparator": () => (/* binding */ hasTrailingPathSeparator),
/* harmony export */   "removeTrailingPathSeparator": () => (/* binding */ removeTrailingPathSeparator),
/* harmony export */   "addTrailingPathSeparator": () => (/* binding */ addTrailingPathSeparator),
/* harmony export */   "distinctParents": () => (/* binding */ distinctParents),
/* harmony export */   "DataUri": () => (/* binding */ DataUri),
/* harmony export */   "toLocalResource": () => (/* binding */ toLocalResource)
/* harmony export */ });
/* harmony import */ var _charCode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(71);
/* harmony import */ var _extpath__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(72);
/* harmony import */ var _network__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(80);
/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(73);
/* harmony import */ var _platform__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(58);
/* harmony import */ var _strings__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(75);
/* harmony import */ var _uri__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(81);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/







function originalFSPath(uri) {
  return (0,_uri__WEBPACK_IMPORTED_MODULE_6__.uriToFsPath)(uri, true);
} //#region IExtUri

class ExtUri {
  constructor(_ignorePathCasing) {
    this._ignorePathCasing = _ignorePathCasing;
  }

  compare(uri1, uri2, ignoreFragment = false) {
    if (uri1 === uri2) {
      return 0;
    }

    return (0,_strings__WEBPACK_IMPORTED_MODULE_5__.compare)(this.getComparisonKey(uri1, ignoreFragment), this.getComparisonKey(uri2, ignoreFragment));
  }

  isEqual(uri1, uri2, ignoreFragment = false) {
    if (uri1 === uri2) {
      return true;
    }

    if (!uri1 || !uri2) {
      return false;
    }

    return this.getComparisonKey(uri1, ignoreFragment) === this.getComparisonKey(uri2, ignoreFragment);
  }

  getComparisonKey(uri, ignoreFragment = false) {
    return uri.with({
      path: this._ignorePathCasing(uri) ? uri.path.toLowerCase() : undefined,
      fragment: ignoreFragment ? null : undefined
    }).toString();
  }

  ignorePathCasing(uri) {
    return this._ignorePathCasing(uri);
  }

  isEqualOrParent(base, parentCandidate, ignoreFragment = false) {
    if (base.scheme === parentCandidate.scheme) {
      if (base.scheme === _network__WEBPACK_IMPORTED_MODULE_2__.Schemas.file) {
        return _extpath__WEBPACK_IMPORTED_MODULE_1__.isEqualOrParent(originalFSPath(base), originalFSPath(parentCandidate), this._ignorePathCasing(base)) && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);
      }

      if (isEqualAuthority(base.authority, parentCandidate.authority)) {
        return _extpath__WEBPACK_IMPORTED_MODULE_1__.isEqualOrParent(base.path, parentCandidate.path, this._ignorePathCasing(base), '/') && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);
      }
    }

    return false;
  } // --- path math


  joinPath(resource, ...pathFragment) {
    return _uri__WEBPACK_IMPORTED_MODULE_6__.URI.joinPath(resource, ...pathFragment);
  }

  basenameOrAuthority(resource) {
    return basename(resource) || resource.authority;
  }

  basename(resource) {
    return _path__WEBPACK_IMPORTED_MODULE_3__.posix.basename(resource.path);
  }

  extname(resource) {
    return _path__WEBPACK_IMPORTED_MODULE_3__.posix.extname(resource.path);
  }

  dirname(resource) {
    if (resource.path.length === 0) {
      return resource;
    }

    let dirname;

    if (resource.scheme === _network__WEBPACK_IMPORTED_MODULE_2__.Schemas.file) {
      dirname = _uri__WEBPACK_IMPORTED_MODULE_6__.URI.file(_path__WEBPACK_IMPORTED_MODULE_3__.dirname(originalFSPath(resource))).path;
    } else {
      dirname = _path__WEBPACK_IMPORTED_MODULE_3__.posix.dirname(resource.path);

      if (resource.authority && dirname.length && dirname.charCodeAt(0) !== _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Slash) {
        console.error(`dirname("${resource.toString})) resulted in a relative path`);
        dirname = '/'; // If a URI contains an authority component, then the path component must either be empty or begin with a CharCode.Slash ("/") character
      }
    }

    return resource.with({
      path: dirname
    });
  }

  normalizePath(resource) {
    if (!resource.path.length) {
      return resource;
    }

    let normalizedPath;

    if (resource.scheme === _network__WEBPACK_IMPORTED_MODULE_2__.Schemas.file) {
      normalizedPath = _uri__WEBPACK_IMPORTED_MODULE_6__.URI.file(_path__WEBPACK_IMPORTED_MODULE_3__.normalize(originalFSPath(resource))).path;
    } else {
      normalizedPath = _path__WEBPACK_IMPORTED_MODULE_3__.posix.normalize(resource.path);
    }

    return resource.with({
      path: normalizedPath
    });
  }

  relativePath(from, to) {
    if (from.scheme !== to.scheme || !isEqualAuthority(from.authority, to.authority)) {
      return undefined;
    }

    if (from.scheme === _network__WEBPACK_IMPORTED_MODULE_2__.Schemas.file) {
      const relativePath = _path__WEBPACK_IMPORTED_MODULE_3__.relative(originalFSPath(from), originalFSPath(to));
      return _platform__WEBPACK_IMPORTED_MODULE_4__.isWindows ? _extpath__WEBPACK_IMPORTED_MODULE_1__.toSlashes(relativePath) : relativePath;
    }

    let fromPath = from.path || '/';
    const toPath = to.path || '/';

    if (this._ignorePathCasing(from)) {
      // make casing of fromPath match toPath
      let i = 0;

      for (const len = Math.min(fromPath.length, toPath.length); i < len; i++) {
        if (fromPath.charCodeAt(i) !== toPath.charCodeAt(i)) {
          if (fromPath.charAt(i).toLowerCase() !== toPath.charAt(i).toLowerCase()) {
            break;
          }
        }
      }

      fromPath = toPath.substr(0, i) + fromPath.substr(i);
    }

    return _path__WEBPACK_IMPORTED_MODULE_3__.posix.relative(fromPath, toPath);
  }

  resolvePath(base, path) {
    if (base.scheme === _network__WEBPACK_IMPORTED_MODULE_2__.Schemas.file) {
      const newURI = _uri__WEBPACK_IMPORTED_MODULE_6__.URI.file(_path__WEBPACK_IMPORTED_MODULE_3__.resolve(originalFSPath(base), path));
      return base.with({
        authority: newURI.authority,
        path: newURI.path
      });
    }

    path = _extpath__WEBPACK_IMPORTED_MODULE_1__.toPosixPath(path); // we allow path to be a windows path

    return base.with({
      path: _path__WEBPACK_IMPORTED_MODULE_3__.posix.resolve(base.path, path)
    });
  } // --- misc


  isAbsolutePath(resource) {
    return !!resource.path && resource.path[0] === '/';
  }

  isEqualAuthority(a1, a2) {
    return a1 === a2 || a1 !== undefined && a2 !== undefined && (0,_strings__WEBPACK_IMPORTED_MODULE_5__.equalsIgnoreCase)(a1, a2);
  }

  hasTrailingPathSeparator(resource, sep = _path__WEBPACK_IMPORTED_MODULE_3__.sep) {
    if (resource.scheme === _network__WEBPACK_IMPORTED_MODULE_2__.Schemas.file) {
      const fsp = originalFSPath(resource);
      return fsp.length > _extpath__WEBPACK_IMPORTED_MODULE_1__.getRoot(fsp).length && fsp[fsp.length - 1] === sep;
    } else {
      const p = resource.path;
      return p.length > 1 && p.charCodeAt(p.length - 1) === _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Slash && !/^[a-zA-Z]:(\/$|\\$)/.test(resource.fsPath); // ignore the slash at offset 0
    }
  }

  removeTrailingPathSeparator(resource, sep = _path__WEBPACK_IMPORTED_MODULE_3__.sep) {
    // Make sure that the path isn't a drive letter. A trailing separator there is not removable.
    if (hasTrailingPathSeparator(resource, sep)) {
      return resource.with({
        path: resource.path.substr(0, resource.path.length - 1)
      });
    }

    return resource;
  }

  addTrailingPathSeparator(resource, sep = _path__WEBPACK_IMPORTED_MODULE_3__.sep) {
    let isRootSep = false;

    if (resource.scheme === _network__WEBPACK_IMPORTED_MODULE_2__.Schemas.file) {
      const fsp = originalFSPath(resource);
      isRootSep = fsp !== undefined && fsp.length === _extpath__WEBPACK_IMPORTED_MODULE_1__.getRoot(fsp).length && fsp[fsp.length - 1] === sep;
    } else {
      sep = '/';
      const p = resource.path;
      isRootSep = p.length === 1 && p.charCodeAt(p.length - 1) === _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Slash;
    }

    if (!isRootSep && !hasTrailingPathSeparator(resource, sep)) {
      return resource.with({
        path: resource.path + '/'
      });
    }

    return resource;
  }

}
/**
 * Unbiased utility that takes uris "as they are". This means it can be interchanged with
 * uri#toString() usages. The following is true
 * ```
 * assertEqual(aUri.toString() === bUri.toString(), exturi.isEqual(aUri, bUri))
 * ```
 */

const extUri = new ExtUri(() => false);
/**
 * BIASED utility that _mostly_ ignored the case of urs paths. ONLY use this util if you
 * understand what you are doing.
 *
 * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.
 *
 * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient
 * because those uris come from a "trustworthy source". When creating unknown uris it's always
 * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path
 * casing matters.
 */

const extUriBiasedIgnorePathCase = new ExtUri(uri => {
  // A file scheme resource is in the same platform as code, so ignore case for non linux platforms
  // Resource can be from another platform. Lowering the case as an hack. Should come from File system provider
  return uri.scheme === _network__WEBPACK_IMPORTED_MODULE_2__.Schemas.file ? !_platform__WEBPACK_IMPORTED_MODULE_4__.isLinux : true;
});
/**
 * BIASED utility that always ignores the casing of uris paths. ONLY use this util if you
 * understand what you are doing.
 *
 * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.
 *
 * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient
 * because those uris come from a "trustworthy source". When creating unknown uris it's always
 * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path
 * casing matters.
 */

const extUriIgnorePathCase = new ExtUri(_ => true);
const isEqual = extUri.isEqual.bind(extUri);
const isEqualOrParent = extUri.isEqualOrParent.bind(extUri);
const getComparisonKey = extUri.getComparisonKey.bind(extUri);
const basenameOrAuthority = extUri.basenameOrAuthority.bind(extUri);
const basename = extUri.basename.bind(extUri);
const extname = extUri.extname.bind(extUri);
const dirname = extUri.dirname.bind(extUri);
const joinPath = extUri.joinPath.bind(extUri);
const normalizePath = extUri.normalizePath.bind(extUri);
const relativePath = extUri.relativePath.bind(extUri);
const resolvePath = extUri.resolvePath.bind(extUri);
const isAbsolutePath = extUri.isAbsolutePath.bind(extUri);
const isEqualAuthority = extUri.isEqualAuthority.bind(extUri);
const hasTrailingPathSeparator = extUri.hasTrailingPathSeparator.bind(extUri);
const removeTrailingPathSeparator = extUri.removeTrailingPathSeparator.bind(extUri);
const addTrailingPathSeparator = extUri.addTrailingPathSeparator.bind(extUri); //#endregion

function distinctParents(items, resourceAccessor) {
  const distinctParents = [];

  for (let i = 0; i < items.length; i++) {
    const candidateResource = resourceAccessor(items[i]);

    if (items.some((otherItem, index) => {
      if (index === i) {
        return false;
      }

      return isEqualOrParent(candidateResource, resourceAccessor(otherItem));
    })) {
      continue;
    }

    distinctParents.push(items[i]);
  }

  return distinctParents;
}
/**
 * Data URI related helpers.
 */

let DataUri;

(function (_DataUri) {
  const META_DATA_LABEL = _DataUri.META_DATA_LABEL = 'label';
  const META_DATA_DESCRIPTION = _DataUri.META_DATA_DESCRIPTION = 'description';
  const META_DATA_SIZE = _DataUri.META_DATA_SIZE = 'size';
  const META_DATA_MIME = _DataUri.META_DATA_MIME = 'mime';

  function parseMetaData(dataUri) {
    const metadata = new Map(); // Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...
    // the metadata is: size:2313;label:SomeLabel;description:SomeDescription

    const meta = dataUri.path.substring(dataUri.path.indexOf(';') + 1, dataUri.path.lastIndexOf(';'));
    meta.split(';').forEach(property => {
      const [key, value] = property.split(':');

      if (key && value) {
        metadata.set(key, value);
      }
    }); // Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...
    // the mime is: image/png

    const mime = dataUri.path.substring(0, dataUri.path.indexOf(';'));

    if (mime) {
      metadata.set(META_DATA_MIME, mime);
    }

    return metadata;
  }

  _DataUri.parseMetaData = parseMetaData;
})(DataUri || (DataUri = {}));

function toLocalResource(resource, authority, localScheme) {
  if (authority) {
    let path = resource.path;

    if (path && path[0] !== _path__WEBPACK_IMPORTED_MODULE_3__.posix.sep) {
      path = _path__WEBPACK_IMPORTED_MODULE_3__.posix.sep + path;
    }

    return resource.with({
      scheme: localScheme,
      authority,
      path
    });
  }

  return resource.with({
    scheme: localScheme
  });
}

/***/ }),
/* 71 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CharCode": () => (/* binding */ CharCode)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// Names from https://blog.codinghorror.com/ascii-pronunciation-rules-for-programmers/

/**
 * An inlined enum containing useful character codes (to be used with String.charCodeAt).
 * Please leave the const keyword such that it gets inlined when compiled to JavaScript!
 */
let CharCode;

(function (CharCode) {
  CharCode[CharCode["Null"] = 0] = "Null";
  CharCode[CharCode["Backspace"] = 8] = "Backspace";
  CharCode[CharCode["Tab"] = 9] = "Tab";
  CharCode[CharCode["LineFeed"] = 10] = "LineFeed";
  CharCode[CharCode["CarriageReturn"] = 13] = "CarriageReturn";
  CharCode[CharCode["Space"] = 32] = "Space";
  CharCode[CharCode["ExclamationMark"] = 33] = "ExclamationMark";
  CharCode[CharCode["DoubleQuote"] = 34] = "DoubleQuote";
  CharCode[CharCode["Hash"] = 35] = "Hash";
  CharCode[CharCode["DollarSign"] = 36] = "DollarSign";
  CharCode[CharCode["PercentSign"] = 37] = "PercentSign";
  CharCode[CharCode["Ampersand"] = 38] = "Ampersand";
  CharCode[CharCode["SingleQuote"] = 39] = "SingleQuote";
  CharCode[CharCode["OpenParen"] = 40] = "OpenParen";
  CharCode[CharCode["CloseParen"] = 41] = "CloseParen";
  CharCode[CharCode["Asterisk"] = 42] = "Asterisk";
  CharCode[CharCode["Plus"] = 43] = "Plus";
  CharCode[CharCode["Comma"] = 44] = "Comma";
  CharCode[CharCode["Dash"] = 45] = "Dash";
  CharCode[CharCode["Period"] = 46] = "Period";
  CharCode[CharCode["Slash"] = 47] = "Slash";
  CharCode[CharCode["Digit0"] = 48] = "Digit0";
  CharCode[CharCode["Digit1"] = 49] = "Digit1";
  CharCode[CharCode["Digit2"] = 50] = "Digit2";
  CharCode[CharCode["Digit3"] = 51] = "Digit3";
  CharCode[CharCode["Digit4"] = 52] = "Digit4";
  CharCode[CharCode["Digit5"] = 53] = "Digit5";
  CharCode[CharCode["Digit6"] = 54] = "Digit6";
  CharCode[CharCode["Digit7"] = 55] = "Digit7";
  CharCode[CharCode["Digit8"] = 56] = "Digit8";
  CharCode[CharCode["Digit9"] = 57] = "Digit9";
  CharCode[CharCode["Colon"] = 58] = "Colon";
  CharCode[CharCode["Semicolon"] = 59] = "Semicolon";
  CharCode[CharCode["LessThan"] = 60] = "LessThan";
  CharCode[CharCode["Equals"] = 61] = "Equals";
  CharCode[CharCode["GreaterThan"] = 62] = "GreaterThan";
  CharCode[CharCode["QuestionMark"] = 63] = "QuestionMark";
  CharCode[CharCode["AtSign"] = 64] = "AtSign";
  CharCode[CharCode["A"] = 65] = "A";
  CharCode[CharCode["B"] = 66] = "B";
  CharCode[CharCode["C"] = 67] = "C";
  CharCode[CharCode["D"] = 68] = "D";
  CharCode[CharCode["E"] = 69] = "E";
  CharCode[CharCode["F"] = 70] = "F";
  CharCode[CharCode["G"] = 71] = "G";
  CharCode[CharCode["H"] = 72] = "H";
  CharCode[CharCode["I"] = 73] = "I";
  CharCode[CharCode["J"] = 74] = "J";
  CharCode[CharCode["K"] = 75] = "K";
  CharCode[CharCode["L"] = 76] = "L";
  CharCode[CharCode["M"] = 77] = "M";
  CharCode[CharCode["N"] = 78] = "N";
  CharCode[CharCode["O"] = 79] = "O";
  CharCode[CharCode["P"] = 80] = "P";
  CharCode[CharCode["Q"] = 81] = "Q";
  CharCode[CharCode["R"] = 82] = "R";
  CharCode[CharCode["S"] = 83] = "S";
  CharCode[CharCode["T"] = 84] = "T";
  CharCode[CharCode["U"] = 85] = "U";
  CharCode[CharCode["V"] = 86] = "V";
  CharCode[CharCode["W"] = 87] = "W";
  CharCode[CharCode["X"] = 88] = "X";
  CharCode[CharCode["Y"] = 89] = "Y";
  CharCode[CharCode["Z"] = 90] = "Z";
  CharCode[CharCode["OpenSquareBracket"] = 91] = "OpenSquareBracket";
  CharCode[CharCode["Backslash"] = 92] = "Backslash";
  CharCode[CharCode["CloseSquareBracket"] = 93] = "CloseSquareBracket";
  CharCode[CharCode["Caret"] = 94] = "Caret";
  CharCode[CharCode["Underline"] = 95] = "Underline";
  CharCode[CharCode["BackTick"] = 96] = "BackTick";
  CharCode[CharCode["a"] = 97] = "a";
  CharCode[CharCode["b"] = 98] = "b";
  CharCode[CharCode["c"] = 99] = "c";
  CharCode[CharCode["d"] = 100] = "d";
  CharCode[CharCode["e"] = 101] = "e";
  CharCode[CharCode["f"] = 102] = "f";
  CharCode[CharCode["g"] = 103] = "g";
  CharCode[CharCode["h"] = 104] = "h";
  CharCode[CharCode["i"] = 105] = "i";
  CharCode[CharCode["j"] = 106] = "j";
  CharCode[CharCode["k"] = 107] = "k";
  CharCode[CharCode["l"] = 108] = "l";
  CharCode[CharCode["m"] = 109] = "m";
  CharCode[CharCode["n"] = 110] = "n";
  CharCode[CharCode["o"] = 111] = "o";
  CharCode[CharCode["p"] = 112] = "p";
  CharCode[CharCode["q"] = 113] = "q";
  CharCode[CharCode["r"] = 114] = "r";
  CharCode[CharCode["s"] = 115] = "s";
  CharCode[CharCode["t"] = 116] = "t";
  CharCode[CharCode["u"] = 117] = "u";
  CharCode[CharCode["v"] = 118] = "v";
  CharCode[CharCode["w"] = 119] = "w";
  CharCode[CharCode["x"] = 120] = "x";
  CharCode[CharCode["y"] = 121] = "y";
  CharCode[CharCode["z"] = 122] = "z";
  CharCode[CharCode["OpenCurlyBrace"] = 123] = "OpenCurlyBrace";
  CharCode[CharCode["Pipe"] = 124] = "Pipe";
  CharCode[CharCode["CloseCurlyBrace"] = 125] = "CloseCurlyBrace";
  CharCode[CharCode["Tilde"] = 126] = "Tilde";
  CharCode[CharCode["U_Combining_Grave_Accent"] = 768] = "U_Combining_Grave_Accent";
  CharCode[CharCode["U_Combining_Acute_Accent"] = 769] = "U_Combining_Acute_Accent";
  CharCode[CharCode["U_Combining_Circumflex_Accent"] = 770] = "U_Combining_Circumflex_Accent";
  CharCode[CharCode["U_Combining_Tilde"] = 771] = "U_Combining_Tilde";
  CharCode[CharCode["U_Combining_Macron"] = 772] = "U_Combining_Macron";
  CharCode[CharCode["U_Combining_Overline"] = 773] = "U_Combining_Overline";
  CharCode[CharCode["U_Combining_Breve"] = 774] = "U_Combining_Breve";
  CharCode[CharCode["U_Combining_Dot_Above"] = 775] = "U_Combining_Dot_Above";
  CharCode[CharCode["U_Combining_Diaeresis"] = 776] = "U_Combining_Diaeresis";
  CharCode[CharCode["U_Combining_Hook_Above"] = 777] = "U_Combining_Hook_Above";
  CharCode[CharCode["U_Combining_Ring_Above"] = 778] = "U_Combining_Ring_Above";
  CharCode[CharCode["U_Combining_Double_Acute_Accent"] = 779] = "U_Combining_Double_Acute_Accent";
  CharCode[CharCode["U_Combining_Caron"] = 780] = "U_Combining_Caron";
  CharCode[CharCode["U_Combining_Vertical_Line_Above"] = 781] = "U_Combining_Vertical_Line_Above";
  CharCode[CharCode["U_Combining_Double_Vertical_Line_Above"] = 782] = "U_Combining_Double_Vertical_Line_Above";
  CharCode[CharCode["U_Combining_Double_Grave_Accent"] = 783] = "U_Combining_Double_Grave_Accent";
  CharCode[CharCode["U_Combining_Candrabindu"] = 784] = "U_Combining_Candrabindu";
  CharCode[CharCode["U_Combining_Inverted_Breve"] = 785] = "U_Combining_Inverted_Breve";
  CharCode[CharCode["U_Combining_Turned_Comma_Above"] = 786] = "U_Combining_Turned_Comma_Above";
  CharCode[CharCode["U_Combining_Comma_Above"] = 787] = "U_Combining_Comma_Above";
  CharCode[CharCode["U_Combining_Reversed_Comma_Above"] = 788] = "U_Combining_Reversed_Comma_Above";
  CharCode[CharCode["U_Combining_Comma_Above_Right"] = 789] = "U_Combining_Comma_Above_Right";
  CharCode[CharCode["U_Combining_Grave_Accent_Below"] = 790] = "U_Combining_Grave_Accent_Below";
  CharCode[CharCode["U_Combining_Acute_Accent_Below"] = 791] = "U_Combining_Acute_Accent_Below";
  CharCode[CharCode["U_Combining_Left_Tack_Below"] = 792] = "U_Combining_Left_Tack_Below";
  CharCode[CharCode["U_Combining_Right_Tack_Below"] = 793] = "U_Combining_Right_Tack_Below";
  CharCode[CharCode["U_Combining_Left_Angle_Above"] = 794] = "U_Combining_Left_Angle_Above";
  CharCode[CharCode["U_Combining_Horn"] = 795] = "U_Combining_Horn";
  CharCode[CharCode["U_Combining_Left_Half_Ring_Below"] = 796] = "U_Combining_Left_Half_Ring_Below";
  CharCode[CharCode["U_Combining_Up_Tack_Below"] = 797] = "U_Combining_Up_Tack_Below";
  CharCode[CharCode["U_Combining_Down_Tack_Below"] = 798] = "U_Combining_Down_Tack_Below";
  CharCode[CharCode["U_Combining_Plus_Sign_Below"] = 799] = "U_Combining_Plus_Sign_Below";
  CharCode[CharCode["U_Combining_Minus_Sign_Below"] = 800] = "U_Combining_Minus_Sign_Below";
  CharCode[CharCode["U_Combining_Palatalized_Hook_Below"] = 801] = "U_Combining_Palatalized_Hook_Below";
  CharCode[CharCode["U_Combining_Retroflex_Hook_Below"] = 802] = "U_Combining_Retroflex_Hook_Below";
  CharCode[CharCode["U_Combining_Dot_Below"] = 803] = "U_Combining_Dot_Below";
  CharCode[CharCode["U_Combining_Diaeresis_Below"] = 804] = "U_Combining_Diaeresis_Below";
  CharCode[CharCode["U_Combining_Ring_Below"] = 805] = "U_Combining_Ring_Below";
  CharCode[CharCode["U_Combining_Comma_Below"] = 806] = "U_Combining_Comma_Below";
  CharCode[CharCode["U_Combining_Cedilla"] = 807] = "U_Combining_Cedilla";
  CharCode[CharCode["U_Combining_Ogonek"] = 808] = "U_Combining_Ogonek";
  CharCode[CharCode["U_Combining_Vertical_Line_Below"] = 809] = "U_Combining_Vertical_Line_Below";
  CharCode[CharCode["U_Combining_Bridge_Below"] = 810] = "U_Combining_Bridge_Below";
  CharCode[CharCode["U_Combining_Inverted_Double_Arch_Below"] = 811] = "U_Combining_Inverted_Double_Arch_Below";
  CharCode[CharCode["U_Combining_Caron_Below"] = 812] = "U_Combining_Caron_Below";
  CharCode[CharCode["U_Combining_Circumflex_Accent_Below"] = 813] = "U_Combining_Circumflex_Accent_Below";
  CharCode[CharCode["U_Combining_Breve_Below"] = 814] = "U_Combining_Breve_Below";
  CharCode[CharCode["U_Combining_Inverted_Breve_Below"] = 815] = "U_Combining_Inverted_Breve_Below";
  CharCode[CharCode["U_Combining_Tilde_Below"] = 816] = "U_Combining_Tilde_Below";
  CharCode[CharCode["U_Combining_Macron_Below"] = 817] = "U_Combining_Macron_Below";
  CharCode[CharCode["U_Combining_Low_Line"] = 818] = "U_Combining_Low_Line";
  CharCode[CharCode["U_Combining_Double_Low_Line"] = 819] = "U_Combining_Double_Low_Line";
  CharCode[CharCode["U_Combining_Tilde_Overlay"] = 820] = "U_Combining_Tilde_Overlay";
  CharCode[CharCode["U_Combining_Short_Stroke_Overlay"] = 821] = "U_Combining_Short_Stroke_Overlay";
  CharCode[CharCode["U_Combining_Long_Stroke_Overlay"] = 822] = "U_Combining_Long_Stroke_Overlay";
  CharCode[CharCode["U_Combining_Short_Solidus_Overlay"] = 823] = "U_Combining_Short_Solidus_Overlay";
  CharCode[CharCode["U_Combining_Long_Solidus_Overlay"] = 824] = "U_Combining_Long_Solidus_Overlay";
  CharCode[CharCode["U_Combining_Right_Half_Ring_Below"] = 825] = "U_Combining_Right_Half_Ring_Below";
  CharCode[CharCode["U_Combining_Inverted_Bridge_Below"] = 826] = "U_Combining_Inverted_Bridge_Below";
  CharCode[CharCode["U_Combining_Square_Below"] = 827] = "U_Combining_Square_Below";
  CharCode[CharCode["U_Combining_Seagull_Below"] = 828] = "U_Combining_Seagull_Below";
  CharCode[CharCode["U_Combining_X_Above"] = 829] = "U_Combining_X_Above";
  CharCode[CharCode["U_Combining_Vertical_Tilde"] = 830] = "U_Combining_Vertical_Tilde";
  CharCode[CharCode["U_Combining_Double_Overline"] = 831] = "U_Combining_Double_Overline";
  CharCode[CharCode["U_Combining_Grave_Tone_Mark"] = 832] = "U_Combining_Grave_Tone_Mark";
  CharCode[CharCode["U_Combining_Acute_Tone_Mark"] = 833] = "U_Combining_Acute_Tone_Mark";
  CharCode[CharCode["U_Combining_Greek_Perispomeni"] = 834] = "U_Combining_Greek_Perispomeni";
  CharCode[CharCode["U_Combining_Greek_Koronis"] = 835] = "U_Combining_Greek_Koronis";
  CharCode[CharCode["U_Combining_Greek_Dialytika_Tonos"] = 836] = "U_Combining_Greek_Dialytika_Tonos";
  CharCode[CharCode["U_Combining_Greek_Ypogegrammeni"] = 837] = "U_Combining_Greek_Ypogegrammeni";
  CharCode[CharCode["U_Combining_Bridge_Above"] = 838] = "U_Combining_Bridge_Above";
  CharCode[CharCode["U_Combining_Equals_Sign_Below"] = 839] = "U_Combining_Equals_Sign_Below";
  CharCode[CharCode["U_Combining_Double_Vertical_Line_Below"] = 840] = "U_Combining_Double_Vertical_Line_Below";
  CharCode[CharCode["U_Combining_Left_Angle_Below"] = 841] = "U_Combining_Left_Angle_Below";
  CharCode[CharCode["U_Combining_Not_Tilde_Above"] = 842] = "U_Combining_Not_Tilde_Above";
  CharCode[CharCode["U_Combining_Homothetic_Above"] = 843] = "U_Combining_Homothetic_Above";
  CharCode[CharCode["U_Combining_Almost_Equal_To_Above"] = 844] = "U_Combining_Almost_Equal_To_Above";
  CharCode[CharCode["U_Combining_Left_Right_Arrow_Below"] = 845] = "U_Combining_Left_Right_Arrow_Below";
  CharCode[CharCode["U_Combining_Upwards_Arrow_Below"] = 846] = "U_Combining_Upwards_Arrow_Below";
  CharCode[CharCode["U_Combining_Grapheme_Joiner"] = 847] = "U_Combining_Grapheme_Joiner";
  CharCode[CharCode["U_Combining_Right_Arrowhead_Above"] = 848] = "U_Combining_Right_Arrowhead_Above";
  CharCode[CharCode["U_Combining_Left_Half_Ring_Above"] = 849] = "U_Combining_Left_Half_Ring_Above";
  CharCode[CharCode["U_Combining_Fermata"] = 850] = "U_Combining_Fermata";
  CharCode[CharCode["U_Combining_X_Below"] = 851] = "U_Combining_X_Below";
  CharCode[CharCode["U_Combining_Left_Arrowhead_Below"] = 852] = "U_Combining_Left_Arrowhead_Below";
  CharCode[CharCode["U_Combining_Right_Arrowhead_Below"] = 853] = "U_Combining_Right_Arrowhead_Below";
  CharCode[CharCode["U_Combining_Right_Arrowhead_And_Up_Arrowhead_Below"] = 854] = "U_Combining_Right_Arrowhead_And_Up_Arrowhead_Below";
  CharCode[CharCode["U_Combining_Right_Half_Ring_Above"] = 855] = "U_Combining_Right_Half_Ring_Above";
  CharCode[CharCode["U_Combining_Dot_Above_Right"] = 856] = "U_Combining_Dot_Above_Right";
  CharCode[CharCode["U_Combining_Asterisk_Below"] = 857] = "U_Combining_Asterisk_Below";
  CharCode[CharCode["U_Combining_Double_Ring_Below"] = 858] = "U_Combining_Double_Ring_Below";
  CharCode[CharCode["U_Combining_Zigzag_Above"] = 859] = "U_Combining_Zigzag_Above";
  CharCode[CharCode["U_Combining_Double_Breve_Below"] = 860] = "U_Combining_Double_Breve_Below";
  CharCode[CharCode["U_Combining_Double_Breve"] = 861] = "U_Combining_Double_Breve";
  CharCode[CharCode["U_Combining_Double_Macron"] = 862] = "U_Combining_Double_Macron";
  CharCode[CharCode["U_Combining_Double_Macron_Below"] = 863] = "U_Combining_Double_Macron_Below";
  CharCode[CharCode["U_Combining_Double_Tilde"] = 864] = "U_Combining_Double_Tilde";
  CharCode[CharCode["U_Combining_Double_Inverted_Breve"] = 865] = "U_Combining_Double_Inverted_Breve";
  CharCode[CharCode["U_Combining_Double_Rightwards_Arrow_Below"] = 866] = "U_Combining_Double_Rightwards_Arrow_Below";
  CharCode[CharCode["U_Combining_Latin_Small_Letter_A"] = 867] = "U_Combining_Latin_Small_Letter_A";
  CharCode[CharCode["U_Combining_Latin_Small_Letter_E"] = 868] = "U_Combining_Latin_Small_Letter_E";
  CharCode[CharCode["U_Combining_Latin_Small_Letter_I"] = 869] = "U_Combining_Latin_Small_Letter_I";
  CharCode[CharCode["U_Combining_Latin_Small_Letter_O"] = 870] = "U_Combining_Latin_Small_Letter_O";
  CharCode[CharCode["U_Combining_Latin_Small_Letter_U"] = 871] = "U_Combining_Latin_Small_Letter_U";
  CharCode[CharCode["U_Combining_Latin_Small_Letter_C"] = 872] = "U_Combining_Latin_Small_Letter_C";
  CharCode[CharCode["U_Combining_Latin_Small_Letter_D"] = 873] = "U_Combining_Latin_Small_Letter_D";
  CharCode[CharCode["U_Combining_Latin_Small_Letter_H"] = 874] = "U_Combining_Latin_Small_Letter_H";
  CharCode[CharCode["U_Combining_Latin_Small_Letter_M"] = 875] = "U_Combining_Latin_Small_Letter_M";
  CharCode[CharCode["U_Combining_Latin_Small_Letter_R"] = 876] = "U_Combining_Latin_Small_Letter_R";
  CharCode[CharCode["U_Combining_Latin_Small_Letter_T"] = 877] = "U_Combining_Latin_Small_Letter_T";
  CharCode[CharCode["U_Combining_Latin_Small_Letter_V"] = 878] = "U_Combining_Latin_Small_Letter_V";
  CharCode[CharCode["U_Combining_Latin_Small_Letter_X"] = 879] = "U_Combining_Latin_Small_Letter_X";
  CharCode[CharCode["LINE_SEPARATOR"] = 8232] = "LINE_SEPARATOR";
  CharCode[CharCode["PARAGRAPH_SEPARATOR"] = 8233] = "PARAGRAPH_SEPARATOR";
  CharCode[CharCode["NEXT_LINE"] = 133] = "NEXT_LINE";
  CharCode[CharCode["U_CIRCUMFLEX"] = 94] = "U_CIRCUMFLEX";
  CharCode[CharCode["U_GRAVE_ACCENT"] = 96] = "U_GRAVE_ACCENT";
  CharCode[CharCode["U_DIAERESIS"] = 168] = "U_DIAERESIS";
  CharCode[CharCode["U_MACRON"] = 175] = "U_MACRON";
  CharCode[CharCode["U_ACUTE_ACCENT"] = 180] = "U_ACUTE_ACCENT";
  CharCode[CharCode["U_CEDILLA"] = 184] = "U_CEDILLA";
  CharCode[CharCode["U_MODIFIER_LETTER_LEFT_ARROWHEAD"] = 706] = "U_MODIFIER_LETTER_LEFT_ARROWHEAD";
  CharCode[CharCode["U_MODIFIER_LETTER_RIGHT_ARROWHEAD"] = 707] = "U_MODIFIER_LETTER_RIGHT_ARROWHEAD";
  CharCode[CharCode["U_MODIFIER_LETTER_UP_ARROWHEAD"] = 708] = "U_MODIFIER_LETTER_UP_ARROWHEAD";
  CharCode[CharCode["U_MODIFIER_LETTER_DOWN_ARROWHEAD"] = 709] = "U_MODIFIER_LETTER_DOWN_ARROWHEAD";
  CharCode[CharCode["U_MODIFIER_LETTER_CENTRED_RIGHT_HALF_RING"] = 722] = "U_MODIFIER_LETTER_CENTRED_RIGHT_HALF_RING";
  CharCode[CharCode["U_MODIFIER_LETTER_CENTRED_LEFT_HALF_RING"] = 723] = "U_MODIFIER_LETTER_CENTRED_LEFT_HALF_RING";
  CharCode[CharCode["U_MODIFIER_LETTER_UP_TACK"] = 724] = "U_MODIFIER_LETTER_UP_TACK";
  CharCode[CharCode["U_MODIFIER_LETTER_DOWN_TACK"] = 725] = "U_MODIFIER_LETTER_DOWN_TACK";
  CharCode[CharCode["U_MODIFIER_LETTER_PLUS_SIGN"] = 726] = "U_MODIFIER_LETTER_PLUS_SIGN";
  CharCode[CharCode["U_MODIFIER_LETTER_MINUS_SIGN"] = 727] = "U_MODIFIER_LETTER_MINUS_SIGN";
  CharCode[CharCode["U_BREVE"] = 728] = "U_BREVE";
  CharCode[CharCode["U_DOT_ABOVE"] = 729] = "U_DOT_ABOVE";
  CharCode[CharCode["U_RING_ABOVE"] = 730] = "U_RING_ABOVE";
  CharCode[CharCode["U_OGONEK"] = 731] = "U_OGONEK";
  CharCode[CharCode["U_SMALL_TILDE"] = 732] = "U_SMALL_TILDE";
  CharCode[CharCode["U_DOUBLE_ACUTE_ACCENT"] = 733] = "U_DOUBLE_ACUTE_ACCENT";
  CharCode[CharCode["U_MODIFIER_LETTER_RHOTIC_HOOK"] = 734] = "U_MODIFIER_LETTER_RHOTIC_HOOK";
  CharCode[CharCode["U_MODIFIER_LETTER_CROSS_ACCENT"] = 735] = "U_MODIFIER_LETTER_CROSS_ACCENT";
  CharCode[CharCode["U_MODIFIER_LETTER_EXTRA_HIGH_TONE_BAR"] = 741] = "U_MODIFIER_LETTER_EXTRA_HIGH_TONE_BAR";
  CharCode[CharCode["U_MODIFIER_LETTER_HIGH_TONE_BAR"] = 742] = "U_MODIFIER_LETTER_HIGH_TONE_BAR";
  CharCode[CharCode["U_MODIFIER_LETTER_MID_TONE_BAR"] = 743] = "U_MODIFIER_LETTER_MID_TONE_BAR";
  CharCode[CharCode["U_MODIFIER_LETTER_LOW_TONE_BAR"] = 744] = "U_MODIFIER_LETTER_LOW_TONE_BAR";
  CharCode[CharCode["U_MODIFIER_LETTER_EXTRA_LOW_TONE_BAR"] = 745] = "U_MODIFIER_LETTER_EXTRA_LOW_TONE_BAR";
  CharCode[CharCode["U_MODIFIER_LETTER_YIN_DEPARTING_TONE_MARK"] = 746] = "U_MODIFIER_LETTER_YIN_DEPARTING_TONE_MARK";
  CharCode[CharCode["U_MODIFIER_LETTER_YANG_DEPARTING_TONE_MARK"] = 747] = "U_MODIFIER_LETTER_YANG_DEPARTING_TONE_MARK";
  CharCode[CharCode["U_MODIFIER_LETTER_UNASPIRATED"] = 749] = "U_MODIFIER_LETTER_UNASPIRATED";
  CharCode[CharCode["U_MODIFIER_LETTER_LOW_DOWN_ARROWHEAD"] = 751] = "U_MODIFIER_LETTER_LOW_DOWN_ARROWHEAD";
  CharCode[CharCode["U_MODIFIER_LETTER_LOW_UP_ARROWHEAD"] = 752] = "U_MODIFIER_LETTER_LOW_UP_ARROWHEAD";
  CharCode[CharCode["U_MODIFIER_LETTER_LOW_LEFT_ARROWHEAD"] = 753] = "U_MODIFIER_LETTER_LOW_LEFT_ARROWHEAD";
  CharCode[CharCode["U_MODIFIER_LETTER_LOW_RIGHT_ARROWHEAD"] = 754] = "U_MODIFIER_LETTER_LOW_RIGHT_ARROWHEAD";
  CharCode[CharCode["U_MODIFIER_LETTER_LOW_RING"] = 755] = "U_MODIFIER_LETTER_LOW_RING";
  CharCode[CharCode["U_MODIFIER_LETTER_MIDDLE_GRAVE_ACCENT"] = 756] = "U_MODIFIER_LETTER_MIDDLE_GRAVE_ACCENT";
  CharCode[CharCode["U_MODIFIER_LETTER_MIDDLE_DOUBLE_GRAVE_ACCENT"] = 757] = "U_MODIFIER_LETTER_MIDDLE_DOUBLE_GRAVE_ACCENT";
  CharCode[CharCode["U_MODIFIER_LETTER_MIDDLE_DOUBLE_ACUTE_ACCENT"] = 758] = "U_MODIFIER_LETTER_MIDDLE_DOUBLE_ACUTE_ACCENT";
  CharCode[CharCode["U_MODIFIER_LETTER_LOW_TILDE"] = 759] = "U_MODIFIER_LETTER_LOW_TILDE";
  CharCode[CharCode["U_MODIFIER_LETTER_RAISED_COLON"] = 760] = "U_MODIFIER_LETTER_RAISED_COLON";
  CharCode[CharCode["U_MODIFIER_LETTER_BEGIN_HIGH_TONE"] = 761] = "U_MODIFIER_LETTER_BEGIN_HIGH_TONE";
  CharCode[CharCode["U_MODIFIER_LETTER_END_HIGH_TONE"] = 762] = "U_MODIFIER_LETTER_END_HIGH_TONE";
  CharCode[CharCode["U_MODIFIER_LETTER_BEGIN_LOW_TONE"] = 763] = "U_MODIFIER_LETTER_BEGIN_LOW_TONE";
  CharCode[CharCode["U_MODIFIER_LETTER_END_LOW_TONE"] = 764] = "U_MODIFIER_LETTER_END_LOW_TONE";
  CharCode[CharCode["U_MODIFIER_LETTER_SHELF"] = 765] = "U_MODIFIER_LETTER_SHELF";
  CharCode[CharCode["U_MODIFIER_LETTER_OPEN_SHELF"] = 766] = "U_MODIFIER_LETTER_OPEN_SHELF";
  CharCode[CharCode["U_MODIFIER_LETTER_LOW_LEFT_ARROW"] = 767] = "U_MODIFIER_LETTER_LOW_LEFT_ARROW";
  CharCode[CharCode["U_GREEK_LOWER_NUMERAL_SIGN"] = 885] = "U_GREEK_LOWER_NUMERAL_SIGN";
  CharCode[CharCode["U_GREEK_TONOS"] = 900] = "U_GREEK_TONOS";
  CharCode[CharCode["U_GREEK_DIALYTIKA_TONOS"] = 901] = "U_GREEK_DIALYTIKA_TONOS";
  CharCode[CharCode["U_GREEK_KORONIS"] = 8125] = "U_GREEK_KORONIS";
  CharCode[CharCode["U_GREEK_PSILI"] = 8127] = "U_GREEK_PSILI";
  CharCode[CharCode["U_GREEK_PERISPOMENI"] = 8128] = "U_GREEK_PERISPOMENI";
  CharCode[CharCode["U_GREEK_DIALYTIKA_AND_PERISPOMENI"] = 8129] = "U_GREEK_DIALYTIKA_AND_PERISPOMENI";
  CharCode[CharCode["U_GREEK_PSILI_AND_VARIA"] = 8141] = "U_GREEK_PSILI_AND_VARIA";
  CharCode[CharCode["U_GREEK_PSILI_AND_OXIA"] = 8142] = "U_GREEK_PSILI_AND_OXIA";
  CharCode[CharCode["U_GREEK_PSILI_AND_PERISPOMENI"] = 8143] = "U_GREEK_PSILI_AND_PERISPOMENI";
  CharCode[CharCode["U_GREEK_DASIA_AND_VARIA"] = 8157] = "U_GREEK_DASIA_AND_VARIA";
  CharCode[CharCode["U_GREEK_DASIA_AND_OXIA"] = 8158] = "U_GREEK_DASIA_AND_OXIA";
  CharCode[CharCode["U_GREEK_DASIA_AND_PERISPOMENI"] = 8159] = "U_GREEK_DASIA_AND_PERISPOMENI";
  CharCode[CharCode["U_GREEK_DIALYTIKA_AND_VARIA"] = 8173] = "U_GREEK_DIALYTIKA_AND_VARIA";
  CharCode[CharCode["U_GREEK_DIALYTIKA_AND_OXIA"] = 8174] = "U_GREEK_DIALYTIKA_AND_OXIA";
  CharCode[CharCode["U_GREEK_VARIA"] = 8175] = "U_GREEK_VARIA";
  CharCode[CharCode["U_GREEK_OXIA"] = 8189] = "U_GREEK_OXIA";
  CharCode[CharCode["U_GREEK_DASIA"] = 8190] = "U_GREEK_DASIA";
  CharCode[CharCode["U_IDEOGRAPHIC_FULL_STOP"] = 12290] = "U_IDEOGRAPHIC_FULL_STOP";
  CharCode[CharCode["U_LEFT_CORNER_BRACKET"] = 12300] = "U_LEFT_CORNER_BRACKET";
  CharCode[CharCode["U_RIGHT_CORNER_BRACKET"] = 12301] = "U_RIGHT_CORNER_BRACKET";
  CharCode[CharCode["U_LEFT_BLACK_LENTICULAR_BRACKET"] = 12304] = "U_LEFT_BLACK_LENTICULAR_BRACKET";
  CharCode[CharCode["U_RIGHT_BLACK_LENTICULAR_BRACKET"] = 12305] = "U_RIGHT_BLACK_LENTICULAR_BRACKET";
  CharCode[CharCode["U_OVERLINE"] = 8254] = "U_OVERLINE";
  CharCode[CharCode["UTF8_BOM"] = 65279] = "UTF8_BOM";
  CharCode[CharCode["U_FULLWIDTH_SEMICOLON"] = 65307] = "U_FULLWIDTH_SEMICOLON";
  CharCode[CharCode["U_FULLWIDTH_COMMA"] = 65292] = "U_FULLWIDTH_COMMA";
})(CharCode || (CharCode = {}));

/***/ }),
/* 72 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isPathSeparator": () => (/* binding */ isPathSeparator),
/* harmony export */   "toSlashes": () => (/* binding */ toSlashes),
/* harmony export */   "toPosixPath": () => (/* binding */ toPosixPath),
/* harmony export */   "getRoot": () => (/* binding */ getRoot),
/* harmony export */   "isUNC": () => (/* binding */ isUNC),
/* harmony export */   "isValidBasename": () => (/* binding */ isValidBasename),
/* harmony export */   "isEqual": () => (/* binding */ isEqual),
/* harmony export */   "isEqualOrParent": () => (/* binding */ isEqualOrParent),
/* harmony export */   "isWindowsDriveLetter": () => (/* binding */ isWindowsDriveLetter),
/* harmony export */   "sanitizeFilePath": () => (/* binding */ sanitizeFilePath),
/* harmony export */   "isRootOrDriveLetter": () => (/* binding */ isRootOrDriveLetter),
/* harmony export */   "hasDriveLetter": () => (/* binding */ hasDriveLetter),
/* harmony export */   "getDriveLetter": () => (/* binding */ getDriveLetter),
/* harmony export */   "indexOfPath": () => (/* binding */ indexOfPath),
/* harmony export */   "parseLineAndColumnAware": () => (/* binding */ parseLineAndColumnAware),
/* harmony export */   "randomPath": () => (/* binding */ randomPath)
/* harmony export */ });
/* harmony import */ var _charCode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(71);
/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(73);
/* harmony import */ var _platform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(58);
/* harmony import */ var _strings__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(75);
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(79);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





function isPathSeparator(code) {
  return code === _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Slash || code === _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Backslash;
}
/**
 * Takes a Windows OS path and changes backward slashes to forward slashes.
 * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).
 * Using it on a Linux or MaxOS path might change it.
 */

function toSlashes(osPath) {
  return osPath.replace(/[\\/]/g, _path__WEBPACK_IMPORTED_MODULE_1__.posix.sep);
}
/**
 * Takes a Windows OS path (using backward or forward slashes) and turns it into a posix path:
 * - turns backward slashes into forward slashes
 * - makes it absolute if it starts with a drive letter
 * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).
 * Using it on a Linux or MaxOS path might change it.
 */

function toPosixPath(osPath) {
  if (osPath.indexOf('/') === -1) {
    osPath = toSlashes(osPath);
  }

  if (/^[a-zA-Z]:(\/|$)/.test(osPath)) {
    // starts with a drive letter
    osPath = '/' + osPath;
  }

  return osPath;
}
/**
 * Computes the _root_ this path, like `getRoot('c:\files') === c:\`,
 * `getRoot('files:///files/path') === files:///`,
 * or `getRoot('\\server\shares\path') === \\server\shares\`
 */

function getRoot(path, sep = _path__WEBPACK_IMPORTED_MODULE_1__.posix.sep) {
  if (!path) {
    return '';
  }

  const len = path.length;
  const firstLetter = path.charCodeAt(0);

  if (isPathSeparator(firstLetter)) {
    if (isPathSeparator(path.charCodeAt(1))) {
      // UNC candidate \\localhost\shares\ddd
      //               ^^^^^^^^^^^^^^^^^^^
      if (!isPathSeparator(path.charCodeAt(2))) {
        let pos = 3;
        const start = pos;

        for (; pos < len; pos++) {
          if (isPathSeparator(path.charCodeAt(pos))) {
            break;
          }
        }

        if (start !== pos && !isPathSeparator(path.charCodeAt(pos + 1))) {
          pos += 1;

          for (; pos < len; pos++) {
            if (isPathSeparator(path.charCodeAt(pos))) {
              return path.slice(0, pos + 1) // consume this separator
              .replace(/[\\/]/g, sep);
            }
          }
        }
      }
    } // /user/far
    // ^


    return sep;
  } else if (isWindowsDriveLetter(firstLetter)) {
    // check for windows drive letter c:\ or c:
    if (path.charCodeAt(1) === _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Colon) {
      if (isPathSeparator(path.charCodeAt(2))) {
        // C:\fff
        // ^^^
        return path.slice(0, 2) + sep;
      } else {
        // C:
        // ^^
        return path.slice(0, 2);
      }
    }
  } // check for URI
  // scheme://authority/path
  // ^^^^^^^^^^^^^^^^^^^


  let pos = path.indexOf('://');

  if (pos !== -1) {
    pos += 3; // 3 -> "://".length

    for (; pos < len; pos++) {
      if (isPathSeparator(path.charCodeAt(pos))) {
        return path.slice(0, pos + 1); // consume this separator
      }
    }
  }

  return '';
}
/**
 * Check if the path follows this pattern: `\\hostname\sharename`.
 *
 * @see https://msdn.microsoft.com/en-us/library/gg465305.aspx
 * @return A boolean indication if the path is a UNC path, on none-windows
 * always false.
 */

function isUNC(path) {
  if (!_platform__WEBPACK_IMPORTED_MODULE_2__.isWindows) {
    // UNC is a windows concept
    return false;
  }

  if (!path || path.length < 5) {
    // at least \\a\b
    return false;
  }

  let code = path.charCodeAt(0);

  if (code !== _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Backslash) {
    return false;
  }

  code = path.charCodeAt(1);

  if (code !== _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Backslash) {
    return false;
  }

  let pos = 2;
  const start = pos;

  for (; pos < path.length; pos++) {
    code = path.charCodeAt(pos);

    if (code === _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Backslash) {
      break;
    }
  }

  if (start === pos) {
    return false;
  }

  code = path.charCodeAt(pos + 1);

  if (isNaN(code) || code === _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Backslash) {
    return false;
  }

  return true;
} // Reference: https://en.wikipedia.org/wiki/Filename

const WINDOWS_INVALID_FILE_CHARS = /[\\/:\*\?"<>\|]/g;
const UNIX_INVALID_FILE_CHARS = /[\\/]/g;
const WINDOWS_FORBIDDEN_NAMES = /^(con|prn|aux|clock\$|nul|lpt[0-9]|com[0-9])(\.(.*?))?$/i;
function isValidBasename(name, isWindowsOS = _platform__WEBPACK_IMPORTED_MODULE_2__.isWindows) {
  const invalidFileChars = isWindowsOS ? WINDOWS_INVALID_FILE_CHARS : UNIX_INVALID_FILE_CHARS;

  if (!name || name.length === 0 || /^\s+$/.test(name)) {
    return false; // require a name that is not just whitespace
  }

  invalidFileChars.lastIndex = 0; // the holy grail of software development

  if (invalidFileChars.test(name)) {
    return false; // check for certain invalid file characters
  }

  if (isWindowsOS && WINDOWS_FORBIDDEN_NAMES.test(name)) {
    return false; // check for certain invalid file names
  }

  if (name === '.' || name === '..') {
    return false; // check for reserved values
  }

  if (isWindowsOS && name[name.length - 1] === '.') {
    return false; // Windows: file cannot end with a "."
  }

  if (isWindowsOS && name.length !== name.trim().length) {
    return false; // Windows: file cannot end with a whitespace
  }

  if (name.length > 255) {
    return false; // most file systems do not allow files > 255 length
  }

  return true;
}
/**
 * @deprecated please use `IUriIdentityService.extUri.isEqual` instead. If you are
 * in a context without services, consider to pass down the `extUri` from the outside
 * or use `extUriBiasedIgnorePathCase` if you know what you are doing.
 */

function isEqual(pathA, pathB, ignoreCase) {
  const identityEquals = pathA === pathB;

  if (!ignoreCase || identityEquals) {
    return identityEquals;
  }

  if (!pathA || !pathB) {
    return false;
  }

  return (0,_strings__WEBPACK_IMPORTED_MODULE_3__.equalsIgnoreCase)(pathA, pathB);
}
/**
 * @deprecated please use `IUriIdentityService.extUri.isEqualOrParent` instead. If
 * you are in a context without services, consider to pass down the `extUri` from the
 * outside, or use `extUriBiasedIgnorePathCase` if you know what you are doing.
 */

function isEqualOrParent(base, parentCandidate, ignoreCase, separator = _path__WEBPACK_IMPORTED_MODULE_1__.sep) {
  if (base === parentCandidate) {
    return true;
  }

  if (!base || !parentCandidate) {
    return false;
  }

  if (parentCandidate.length > base.length) {
    return false;
  }

  if (ignoreCase) {
    const beginsWith = (0,_strings__WEBPACK_IMPORTED_MODULE_3__.startsWithIgnoreCase)(base, parentCandidate);

    if (!beginsWith) {
      return false;
    }

    if (parentCandidate.length === base.length) {
      return true; // same path, different casing
    }

    let sepOffset = parentCandidate.length;

    if (parentCandidate.charAt(parentCandidate.length - 1) === separator) {
      sepOffset--; // adjust the expected sep offset in case our candidate already ends in separator character
    }

    return base.charAt(sepOffset) === separator;
  }

  if (parentCandidate.charAt(parentCandidate.length - 1) !== separator) {
    parentCandidate += separator;
  }

  return base.indexOf(parentCandidate) === 0;
}
function isWindowsDriveLetter(char0) {
  return char0 >= _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.A && char0 <= _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Z || char0 >= _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.a && char0 <= _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.z;
}
function sanitizeFilePath(candidate, cwd) {
  // Special case: allow to open a drive letter without trailing backslash
  if (_platform__WEBPACK_IMPORTED_MODULE_2__.isWindows && candidate.endsWith(':')) {
    candidate += _path__WEBPACK_IMPORTED_MODULE_1__.sep;
  } // Ensure absolute


  if (!(0,_path__WEBPACK_IMPORTED_MODULE_1__.isAbsolute)(candidate)) {
    candidate = (0,_path__WEBPACK_IMPORTED_MODULE_1__.join)(cwd, candidate);
  } // Ensure normalized


  candidate = (0,_path__WEBPACK_IMPORTED_MODULE_1__.normalize)(candidate); // Ensure no trailing slash/backslash

  if (_platform__WEBPACK_IMPORTED_MODULE_2__.isWindows) {
    candidate = (0,_strings__WEBPACK_IMPORTED_MODULE_3__.rtrim)(candidate, _path__WEBPACK_IMPORTED_MODULE_1__.sep); // Special case: allow to open drive root ('C:\')

    if (candidate.endsWith(':')) {
      candidate += _path__WEBPACK_IMPORTED_MODULE_1__.sep;
    }
  } else {
    candidate = (0,_strings__WEBPACK_IMPORTED_MODULE_3__.rtrim)(candidate, _path__WEBPACK_IMPORTED_MODULE_1__.sep); // Special case: allow to open root ('/')

    if (!candidate) {
      candidate = _path__WEBPACK_IMPORTED_MODULE_1__.sep;
    }
  }

  return candidate;
}
function isRootOrDriveLetter(path) {
  const pathNormalized = (0,_path__WEBPACK_IMPORTED_MODULE_1__.normalize)(path);

  if (_platform__WEBPACK_IMPORTED_MODULE_2__.isWindows) {
    if (path.length > 3) {
      return false;
    }

    return hasDriveLetter(pathNormalized) && (path.length === 2 || pathNormalized.charCodeAt(2) === _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Backslash);
  }

  return pathNormalized === _path__WEBPACK_IMPORTED_MODULE_1__.posix.sep;
}
function hasDriveLetter(path, isWindowsOS = _platform__WEBPACK_IMPORTED_MODULE_2__.isWindows) {
  if (isWindowsOS) {
    return isWindowsDriveLetter(path.charCodeAt(0)) && path.charCodeAt(1) === _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Colon;
  }

  return false;
}
function getDriveLetter(path) {
  return hasDriveLetter(path) ? path[0] : undefined;
}
function indexOfPath(path, candidate, ignoreCase) {
  if (candidate.length > path.length) {
    return -1;
  }

  if (path === candidate) {
    return 0;
  }

  if (ignoreCase) {
    path = path.toLowerCase();
    candidate = candidate.toLowerCase();
  }

  return path.indexOf(candidate);
}
function parseLineAndColumnAware(rawPath) {
  const segments = rawPath.split(':'); // C:\file.txt:<line>:<column>

  let path = undefined;
  let line = undefined;
  let column = undefined;

  for (const segment of segments) {
    const segmentAsNumber = Number(segment);

    if (!(0,_types__WEBPACK_IMPORTED_MODULE_4__.isNumber)(segmentAsNumber)) {
      path = !!path ? [path, segment].join(':') : segment; // a colon can well be part of a path (e.g. C:\...)
    } else if (line === undefined) {
      line = segmentAsNumber;
    } else if (column === undefined) {
      column = segmentAsNumber;
    }
  }

  if (!path) {
    throw new Error('Format for `--goto` should be: `FILE:LINE(:COLUMN)`');
  }

  return {
    path,
    line: line !== undefined ? line : undefined,
    column: column !== undefined ? column : line !== undefined ? 1 : undefined // if we have a line, make sure column is also set

  };
}
const pathChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
function randomPath(parent, prefix, randomLength = 8) {
  let suffix = '';

  for (let i = 0; i < randomLength; i++) {
    suffix += pathChars.charAt(Math.floor(Math.random() * pathChars.length));
  }

  let randomFileName;

  if (prefix) {
    randomFileName = `${prefix}-${suffix}`;
  } else {
    randomFileName = suffix;
  }

  if (parent) {
    return (0,_path__WEBPACK_IMPORTED_MODULE_1__.join)(parent, randomFileName);
  }

  return randomFileName;
}

/***/ }),
/* 73 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "win32": () => (/* binding */ win32),
/* harmony export */   "posix": () => (/* binding */ posix),
/* harmony export */   "normalize": () => (/* binding */ normalize),
/* harmony export */   "isAbsolute": () => (/* binding */ isAbsolute),
/* harmony export */   "join": () => (/* binding */ join),
/* harmony export */   "resolve": () => (/* binding */ resolve),
/* harmony export */   "relative": () => (/* binding */ relative),
/* harmony export */   "dirname": () => (/* binding */ dirname),
/* harmony export */   "basename": () => (/* binding */ basename),
/* harmony export */   "extname": () => (/* binding */ extname),
/* harmony export */   "format": () => (/* binding */ format),
/* harmony export */   "parse": () => (/* binding */ parse),
/* harmony export */   "toNamespacedPath": () => (/* binding */ toNamespacedPath),
/* harmony export */   "sep": () => (/* binding */ sep),
/* harmony export */   "delimiter": () => (/* binding */ delimiter)
/* harmony export */ });
/* harmony import */ var _process__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// NOTE: VSCode's copy of nodejs path library to be usable in common (non-node) namespace
// Copied from: https://github.com/nodejs/node/blob/v14.16.0/lib/path.js

/**
 * Copyright Joyent, Inc. and other Node contributors.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to permit
 * persons to whom the Software is furnished to do so, subject to the
 * following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
 * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

const CHAR_UPPERCASE_A = 65;
/* A */

const CHAR_LOWERCASE_A = 97;
/* a */

const CHAR_UPPERCASE_Z = 90;
/* Z */

const CHAR_LOWERCASE_Z = 122;
/* z */

const CHAR_DOT = 46;
/* . */

const CHAR_FORWARD_SLASH = 47;
/* / */

const CHAR_BACKWARD_SLASH = 92;
/* \ */

const CHAR_COLON = 58;
/* : */

const CHAR_QUESTION_MARK = 63;
/* ? */

class ErrorInvalidArgType extends Error {
  constructor(name, expected, actual) {
    // determiner: 'must be' or 'must not be'
    let determiner;

    if (typeof expected === 'string' && expected.indexOf('not ') === 0) {
      determiner = 'must not be';
      expected = expected.replace(/^not /, '');
    } else {
      determiner = 'must be';
    }

    const type = name.indexOf('.') !== -1 ? 'property' : 'argument';
    let msg = `The "${name}" ${type} ${determiner} of type ${expected}`;
    msg += `. Received type ${typeof actual}`;
    super(msg);
    this.code = 'ERR_INVALID_ARG_TYPE';
  }

}

function validateString(value, name) {
  if (typeof value !== 'string') {
    throw new ErrorInvalidArgType(name, 'string', value);
  }
}

function isPathSeparator(code) {
  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
}

function isPosixPathSeparator(code) {
  return code === CHAR_FORWARD_SLASH;
}

function isWindowsDeviceRoot(code) {
  return code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z || code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z;
} // Resolves . and .. elements in a path with directory names


function normalizeString(path, allowAboveRoot, separator, isPathSeparator) {
  let res = '';
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let code = 0;

  for (let i = 0; i <= path.length; ++i) {
    if (i < path.length) {
      code = path.charCodeAt(i);
    } else if (isPathSeparator(code)) {
      break;
    } else {
      code = CHAR_FORWARD_SLASH;
    }

    if (isPathSeparator(code)) {
      if (lastSlash === i - 1 || dots === 1) {// NOOP
      } else if (dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== CHAR_DOT || res.charCodeAt(res.length - 2) !== CHAR_DOT) {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf(separator);

            if (lastSlashIndex === -1) {
              res = '';
              lastSegmentLength = 0;
            } else {
              res = res.slice(0, lastSlashIndex);
              lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
            }

            lastSlash = i;
            dots = 0;
            continue;
          } else if (res.length !== 0) {
            res = '';
            lastSegmentLength = 0;
            lastSlash = i;
            dots = 0;
            continue;
          }
        }

        if (allowAboveRoot) {
          res += res.length > 0 ? `${separator}..` : '..';
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) {
          res += `${separator}${path.slice(lastSlash + 1, i)}`;
        } else {
          res = path.slice(lastSlash + 1, i);
        }

        lastSegmentLength = i - lastSlash - 1;
      }

      lastSlash = i;
      dots = 0;
    } else if (code === CHAR_DOT && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }

  return res;
}

function _format(sep, pathObject) {
  if (pathObject === null || typeof pathObject !== 'object') {
    throw new ErrorInvalidArgType('pathObject', 'Object', pathObject);
  }

  const dir = pathObject.dir || pathObject.root;
  const base = pathObject.base || `${pathObject.name || ''}${pathObject.ext || ''}`;

  if (!dir) {
    return base;
  }

  return dir === pathObject.root ? `${dir}${base}` : `${dir}${sep}${base}`;
}

const win32 = {
  // path.resolve([from ...], to)
  resolve(...pathSegments) {
    let resolvedDevice = '';
    let resolvedTail = '';
    let resolvedAbsolute = false;

    for (let i = pathSegments.length - 1; i >= -1; i--) {
      let path;

      if (i >= 0) {
        path = pathSegments[i];
        validateString(path, 'path'); // Skip empty entries

        if (path.length === 0) {
          continue;
        }
      } else if (resolvedDevice.length === 0) {
        path = _process__WEBPACK_IMPORTED_MODULE_0__.cwd();
      } else {
        // Windows has the concept of drive-specific current working
        // directories. If we've resolved a drive letter but not yet an
        // absolute path, get cwd for that drive, or the process cwd if
        // the drive cwd is not available. We're sure the device is not
        // a UNC path at this points, because UNC paths are always absolute.
        path = _process__WEBPACK_IMPORTED_MODULE_0__.env[`=${resolvedDevice}`] || _process__WEBPACK_IMPORTED_MODULE_0__.cwd(); // Verify that a cwd was found and that it actually points
        // to our drive. If not, default to the drive's root.

        if (path === undefined || path.slice(0, 2).toLowerCase() !== resolvedDevice.toLowerCase() && path.charCodeAt(2) === CHAR_BACKWARD_SLASH) {
          path = `${resolvedDevice}\\`;
        }
      }

      const len = path.length;
      let rootEnd = 0;
      let device = '';
      let isAbsolute = false;
      const code = path.charCodeAt(0); // Try to match a root

      if (len === 1) {
        if (isPathSeparator(code)) {
          // `path` contains just a path separator
          rootEnd = 1;
          isAbsolute = true;
        }
      } else if (isPathSeparator(code)) {
        // Possible UNC root
        // If we started with a separator, we know we at least have an
        // absolute path of some kind (UNC or otherwise)
        isAbsolute = true;

        if (isPathSeparator(path.charCodeAt(1))) {
          // Matched double path separator at beginning
          let j = 2;
          let last = j; // Match 1 or more non-path separators

          while (j < len && !isPathSeparator(path.charCodeAt(j))) {
            j++;
          }

          if (j < len && j !== last) {
            const firstPart = path.slice(last, j); // Matched!

            last = j; // Match 1 or more path separators

            while (j < len && isPathSeparator(path.charCodeAt(j))) {
              j++;
            }

            if (j < len && j !== last) {
              // Matched!
              last = j; // Match 1 or more non-path separators

              while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                j++;
              }

              if (j === len || j !== last) {
                // We matched a UNC root
                device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                rootEnd = j;
              }
            }
          }
        } else {
          rootEnd = 1;
        }
      } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {
        // Possible device root
        device = path.slice(0, 2);
        rootEnd = 2;

        if (len > 2 && isPathSeparator(path.charCodeAt(2))) {
          // Treat separator following drive name as an absolute path
          // indicator
          isAbsolute = true;
          rootEnd = 3;
        }
      }

      if (device.length > 0) {
        if (resolvedDevice.length > 0) {
          if (device.toLowerCase() !== resolvedDevice.toLowerCase()) {
            // This path points to another device so it is not applicable
            continue;
          }
        } else {
          resolvedDevice = device;
        }
      }

      if (resolvedAbsolute) {
        if (resolvedDevice.length > 0) {
          break;
        }
      } else {
        resolvedTail = `${path.slice(rootEnd)}\\${resolvedTail}`;
        resolvedAbsolute = isAbsolute;

        if (isAbsolute && resolvedDevice.length > 0) {
          break;
        }
      }
    } // At this point the path should be resolved to a full absolute path,
    // but handle relative paths to be safe (might happen when process.cwd()
    // fails)
    // Normalize the tail path


    resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, '\\', isPathSeparator);
    return resolvedAbsolute ? `${resolvedDevice}\\${resolvedTail}` : `${resolvedDevice}${resolvedTail}` || '.';
  },

  normalize(path) {
    validateString(path, 'path');
    const len = path.length;

    if (len === 0) {
      return '.';
    }

    let rootEnd = 0;
    let device;
    let isAbsolute = false;
    const code = path.charCodeAt(0); // Try to match a root

    if (len === 1) {
      // `path` contains just a single char, exit early to avoid
      // unnecessary work
      return isPosixPathSeparator(code) ? '\\' : path;
    }

    if (isPathSeparator(code)) {
      // Possible UNC root
      // If we started with a separator, we know we at least have an absolute
      // path of some kind (UNC or otherwise)
      isAbsolute = true;

      if (isPathSeparator(path.charCodeAt(1))) {
        // Matched double path separator at beginning
        let j = 2;
        let last = j; // Match 1 or more non-path separators

        while (j < len && !isPathSeparator(path.charCodeAt(j))) {
          j++;
        }

        if (j < len && j !== last) {
          const firstPart = path.slice(last, j); // Matched!

          last = j; // Match 1 or more path separators

          while (j < len && isPathSeparator(path.charCodeAt(j))) {
            j++;
          }

          if (j < len && j !== last) {
            // Matched!
            last = j; // Match 1 or more non-path separators

            while (j < len && !isPathSeparator(path.charCodeAt(j))) {
              j++;
            }

            if (j === len) {
              // We matched a UNC root only
              // Return the normalized version of the UNC root since there
              // is nothing left to process
              return `\\\\${firstPart}\\${path.slice(last)}\\`;
            }

            if (j !== last) {
              // We matched a UNC root with leftovers
              device = `\\\\${firstPart}\\${path.slice(last, j)}`;
              rootEnd = j;
            }
          }
        }
      } else {
        rootEnd = 1;
      }
    } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {
      // Possible device root
      device = path.slice(0, 2);
      rootEnd = 2;

      if (len > 2 && isPathSeparator(path.charCodeAt(2))) {
        // Treat separator following drive name as an absolute path
        // indicator
        isAbsolute = true;
        rootEnd = 3;
      }
    }

    let tail = rootEnd < len ? normalizeString(path.slice(rootEnd), !isAbsolute, '\\', isPathSeparator) : '';

    if (tail.length === 0 && !isAbsolute) {
      tail = '.';
    }

    if (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {
      tail += '\\';
    }

    if (device === undefined) {
      return isAbsolute ? `\\${tail}` : tail;
    }

    return isAbsolute ? `${device}\\${tail}` : `${device}${tail}`;
  },

  isAbsolute(path) {
    validateString(path, 'path');
    const len = path.length;

    if (len === 0) {
      return false;
    }

    const code = path.charCodeAt(0);
    return isPathSeparator(code) || // Possible device root
    len > 2 && isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON && isPathSeparator(path.charCodeAt(2));
  },

  join(...paths) {
    if (paths.length === 0) {
      return '.';
    }

    let joined;
    let firstPart;

    for (let i = 0; i < paths.length; ++i) {
      const arg = paths[i];
      validateString(arg, 'path');

      if (arg.length > 0) {
        if (joined === undefined) {
          joined = firstPart = arg;
        } else {
          joined += `\\${arg}`;
        }
      }
    }

    if (joined === undefined) {
      return '.';
    } // Make sure that the joined path doesn't start with two slashes, because
    // normalize() will mistake it for a UNC path then.
    //
    // This step is skipped when it is very clear that the user actually
    // intended to point at a UNC path. This is assumed when the first
    // non-empty string arguments starts with exactly two slashes followed by
    // at least one more non-slash character.
    //
    // Note that for normalize() to treat a path as a UNC path it needs to
    // have at least 2 components, so we don't filter for that here.
    // This means that the user can use join to construct UNC paths from
    // a server name and a share name; for example:
    //   path.join('//server', 'share') -> '\\\\server\\share\\')


    let needsReplace = true;
    let slashCount = 0;

    if (typeof firstPart === 'string' && isPathSeparator(firstPart.charCodeAt(0))) {
      ++slashCount;
      const firstLen = firstPart.length;

      if (firstLen > 1 && isPathSeparator(firstPart.charCodeAt(1))) {
        ++slashCount;

        if (firstLen > 2) {
          if (isPathSeparator(firstPart.charCodeAt(2))) {
            ++slashCount;
          } else {
            // We matched a UNC path in the first part
            needsReplace = false;
          }
        }
      }
    }

    if (needsReplace) {
      // Find any more consecutive slashes we need to replace
      while (slashCount < joined.length && isPathSeparator(joined.charCodeAt(slashCount))) {
        slashCount++;
      } // Replace the slashes if needed


      if (slashCount >= 2) {
        joined = `\\${joined.slice(slashCount)}`;
      }
    }

    return win32.normalize(joined);
  },

  // It will solve the relative path from `from` to `to`, for instance:
  //  from = 'C:\\orandea\\test\\aaa'
  //  to = 'C:\\orandea\\impl\\bbb'
  // The output of the function should be: '..\\..\\impl\\bbb'
  relative(from, to) {
    validateString(from, 'from');
    validateString(to, 'to');

    if (from === to) {
      return '';
    }

    const fromOrig = win32.resolve(from);
    const toOrig = win32.resolve(to);

    if (fromOrig === toOrig) {
      return '';
    }

    from = fromOrig.toLowerCase();
    to = toOrig.toLowerCase();

    if (from === to) {
      return '';
    } // Trim any leading backslashes


    let fromStart = 0;

    while (fromStart < from.length && from.charCodeAt(fromStart) === CHAR_BACKWARD_SLASH) {
      fromStart++;
    } // Trim trailing backslashes (applicable to UNC paths only)


    let fromEnd = from.length;

    while (fromEnd - 1 > fromStart && from.charCodeAt(fromEnd - 1) === CHAR_BACKWARD_SLASH) {
      fromEnd--;
    }

    const fromLen = fromEnd - fromStart; // Trim any leading backslashes

    let toStart = 0;

    while (toStart < to.length && to.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {
      toStart++;
    } // Trim trailing backslashes (applicable to UNC paths only)


    let toEnd = to.length;

    while (toEnd - 1 > toStart && to.charCodeAt(toEnd - 1) === CHAR_BACKWARD_SLASH) {
      toEnd--;
    }

    const toLen = toEnd - toStart; // Compare paths to find the longest common path from root

    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;

    for (; i < length; i++) {
      const fromCode = from.charCodeAt(fromStart + i);

      if (fromCode !== to.charCodeAt(toStart + i)) {
        break;
      } else if (fromCode === CHAR_BACKWARD_SLASH) {
        lastCommonSep = i;
      }
    } // We found a mismatch before the first common path separator was seen, so
    // return the original `to`.


    if (i !== length) {
      if (lastCommonSep === -1) {
        return toOrig;
      }
    } else {
      if (toLen > length) {
        if (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {
          // We get here if `from` is the exact base path for `to`.
          // For example: from='C:\\foo\\bar'; to='C:\\foo\\bar\\baz'
          return toOrig.slice(toStart + i + 1);
        }

        if (i === 2) {
          // We get here if `from` is the device root.
          // For example: from='C:\\'; to='C:\\foo'
          return toOrig.slice(toStart + i);
        }
      }

      if (fromLen > length) {
        if (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {
          // We get here if `to` is the exact base path for `from`.
          // For example: from='C:\\foo\\bar'; to='C:\\foo'
          lastCommonSep = i;
        } else if (i === 2) {
          // We get here if `to` is the device root.
          // For example: from='C:\\foo\\bar'; to='C:\\'
          lastCommonSep = 3;
        }
      }

      if (lastCommonSep === -1) {
        lastCommonSep = 0;
      }
    }

    let out = ''; // Generate the relative path based on the path difference between `to` and
    // `from`

    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
      if (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {
        out += out.length === 0 ? '..' : '\\..';
      }
    }

    toStart += lastCommonSep; // Lastly, append the rest of the destination (`to`) path that comes after
    // the common path parts

    if (out.length > 0) {
      return `${out}${toOrig.slice(toStart, toEnd)}`;
    }

    if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {
      ++toStart;
    }

    return toOrig.slice(toStart, toEnd);
  },

  toNamespacedPath(path) {
    // Note: this will *probably* throw somewhere.
    if (typeof path !== 'string') {
      return path;
    }

    if (path.length === 0) {
      return '';
    }

    const resolvedPath = win32.resolve(path);

    if (resolvedPath.length <= 2) {
      return path;
    }

    if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {
      // Possible UNC root
      if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {
        const code = resolvedPath.charCodeAt(2);

        if (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {
          // Matched non-long UNC root, convert the path to a long UNC path
          return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
        }
      }
    } else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0)) && resolvedPath.charCodeAt(1) === CHAR_COLON && resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {
      // Matched device root, convert the path to a long UNC path
      return `\\\\?\\${resolvedPath}`;
    }

    return path;
  },

  dirname(path) {
    validateString(path, 'path');
    const len = path.length;

    if (len === 0) {
      return '.';
    }

    let rootEnd = -1;
    let offset = 0;
    const code = path.charCodeAt(0);

    if (len === 1) {
      // `path` contains just a path separator, exit early to avoid
      // unnecessary work or a dot.
      return isPathSeparator(code) ? path : '.';
    } // Try to match a root


    if (isPathSeparator(code)) {
      // Possible UNC root
      rootEnd = offset = 1;

      if (isPathSeparator(path.charCodeAt(1))) {
        // Matched double path separator at beginning
        let j = 2;
        let last = j; // Match 1 or more non-path separators

        while (j < len && !isPathSeparator(path.charCodeAt(j))) {
          j++;
        }

        if (j < len && j !== last) {
          // Matched!
          last = j; // Match 1 or more path separators

          while (j < len && isPathSeparator(path.charCodeAt(j))) {
            j++;
          }

          if (j < len && j !== last) {
            // Matched!
            last = j; // Match 1 or more non-path separators

            while (j < len && !isPathSeparator(path.charCodeAt(j))) {
              j++;
            }

            if (j === len) {
              // We matched a UNC root only
              return path;
            }

            if (j !== last) {
              // We matched a UNC root with leftovers
              // Offset by 1 to include the separator after the UNC root to
              // treat it as a "normal root" on top of a (UNC) root
              rootEnd = offset = j + 1;
            }
          }
        }
      } // Possible device root

    } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {
      rootEnd = len > 2 && isPathSeparator(path.charCodeAt(2)) ? 3 : 2;
      offset = rootEnd;
    }

    let end = -1;
    let matchedSlash = true;

    for (let i = len - 1; i >= offset; --i) {
      if (isPathSeparator(path.charCodeAt(i))) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
        // We saw the first non-path separator
        matchedSlash = false;
      }
    }

    if (end === -1) {
      if (rootEnd === -1) {
        return '.';
      }

      end = rootEnd;
    }

    return path.slice(0, end);
  },

  basename(path, ext) {
    if (ext !== undefined) {
      validateString(ext, 'ext');
    }

    validateString(path, 'path');
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i; // Check for a drive letter prefix so as not to mistake the following
    // path separator as an extra separator at the end of the path that can be
    // disregarded

    if (path.length >= 2 && isWindowsDeviceRoot(path.charCodeAt(0)) && path.charCodeAt(1) === CHAR_COLON) {
      start = 2;
    }

    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
      if (ext === path) {
        return '';
      }

      let extIdx = ext.length - 1;
      let firstNonSlashEnd = -1;

      for (i = path.length - 1; i >= start; --i) {
        const code = path.charCodeAt(i);

        if (isPathSeparator(code)) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            start = i + 1;
            break;
          }
        } else {
          if (firstNonSlashEnd === -1) {
            // We saw the first non-path separator, remember this index in case
            // we need it if the extension ends up not matching
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }

          if (extIdx >= 0) {
            // Try to match the explicit extension
            if (code === ext.charCodeAt(extIdx)) {
              if (--extIdx === -1) {
                // We matched the extension, so mark this as the end of our path
                // component
                end = i;
              }
            } else {
              // Extension does not match, so our result is the entire path
              // component
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }

      if (start === end) {
        end = firstNonSlashEnd;
      } else if (end === -1) {
        end = path.length;
      }

      return path.slice(start, end);
    }

    for (i = path.length - 1; i >= start; --i) {
      if (isPathSeparator(path.charCodeAt(i))) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // path component
        matchedSlash = false;
        end = i + 1;
      }
    }

    if (end === -1) {
      return '';
    }

    return path.slice(start, end);
  },

  extname(path) {
    validateString(path, 'path');
    let start = 0;
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true; // Track the state of characters (if any) we see before our first dot and
    // after any path separator we find

    let preDotState = 0; // Check for a drive letter prefix so as not to mistake the following
    // path separator as an extra separator at the end of the path that can be
    // disregarded

    if (path.length >= 2 && path.charCodeAt(1) === CHAR_COLON && isWindowsDeviceRoot(path.charCodeAt(0))) {
      start = startPart = 2;
    }

    for (let i = path.length - 1; i >= start; --i) {
      const code = path.charCodeAt(i);

      if (isPathSeparator(code)) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }

        continue;
      }

      if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // extension
        matchedSlash = false;
        end = i + 1;
      }

      if (code === CHAR_DOT) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1) {
          startDot = i;
        } else if (preDotState !== 1) {
          preDotState = 1;
        }
      } else if (startDot !== -1) {
        // We saw a non-dot and non-path separator before our dot, so we should
        // have a good chance at having a non-empty extension
        preDotState = -1;
      }
    }

    if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
    preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      return '';
    }

    return path.slice(startDot, end);
  },

  format: _format.bind(null, '\\'),

  parse(path) {
    validateString(path, 'path');
    const ret = {
      root: '',
      dir: '',
      base: '',
      ext: '',
      name: ''
    };

    if (path.length === 0) {
      return ret;
    }

    const len = path.length;
    let rootEnd = 0;
    let code = path.charCodeAt(0);

    if (len === 1) {
      if (isPathSeparator(code)) {
        // `path` contains just a path separator, exit early to avoid
        // unnecessary work
        ret.root = ret.dir = path;
        return ret;
      }

      ret.base = ret.name = path;
      return ret;
    } // Try to match a root


    if (isPathSeparator(code)) {
      // Possible UNC root
      rootEnd = 1;

      if (isPathSeparator(path.charCodeAt(1))) {
        // Matched double path separator at beginning
        let j = 2;
        let last = j; // Match 1 or more non-path separators

        while (j < len && !isPathSeparator(path.charCodeAt(j))) {
          j++;
        }

        if (j < len && j !== last) {
          // Matched!
          last = j; // Match 1 or more path separators

          while (j < len && isPathSeparator(path.charCodeAt(j))) {
            j++;
          }

          if (j < len && j !== last) {
            // Matched!
            last = j; // Match 1 or more non-path separators

            while (j < len && !isPathSeparator(path.charCodeAt(j))) {
              j++;
            }

            if (j === len) {
              // We matched a UNC root only
              rootEnd = j;
            } else if (j !== last) {
              // We matched a UNC root with leftovers
              rootEnd = j + 1;
            }
          }
        }
      }
    } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {
      // Possible device root
      if (len <= 2) {
        // `path` contains just a drive root, exit early to avoid
        // unnecessary work
        ret.root = ret.dir = path;
        return ret;
      }

      rootEnd = 2;

      if (isPathSeparator(path.charCodeAt(2))) {
        if (len === 3) {
          // `path` contains just a drive root, exit early to avoid
          // unnecessary work
          ret.root = ret.dir = path;
          return ret;
        }

        rootEnd = 3;
      }
    }

    if (rootEnd > 0) {
      ret.root = path.slice(0, rootEnd);
    }

    let startDot = -1;
    let startPart = rootEnd;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1; // Track the state of characters (if any) we see before our first dot and
    // after any path separator we find

    let preDotState = 0; // Get non-dir info

    for (; i >= rootEnd; --i) {
      code = path.charCodeAt(i);

      if (isPathSeparator(code)) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }

        continue;
      }

      if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // extension
        matchedSlash = false;
        end = i + 1;
      }

      if (code === CHAR_DOT) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1) {
          startDot = i;
        } else if (preDotState !== 1) {
          preDotState = 1;
        }
      } else if (startDot !== -1) {
        // We saw a non-dot and non-path separator before our dot, so we should
        // have a good chance at having a non-empty extension
        preDotState = -1;
      }
    }

    if (end !== -1) {
      if (startDot === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        ret.base = ret.name = path.slice(startPart, end);
      } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end);
        ret.ext = path.slice(startDot, end);
      }
    } // If the directory is the root, use the entire root as the `dir` including
    // the trailing slash if any (`C:\abc` -> `C:\`). Otherwise, strip out the
    // trailing slash (`C:\abc\def` -> `C:\abc`).


    if (startPart > 0 && startPart !== rootEnd) {
      ret.dir = path.slice(0, startPart - 1);
    } else {
      ret.dir = ret.root;
    }

    return ret;
  },

  sep: '\\',
  delimiter: ';',
  win32: null,
  posix: null
};
const posix = {
  // path.resolve([from ...], to)
  resolve(...pathSegments) {
    let resolvedPath = '';
    let resolvedAbsolute = false;

    for (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
      const path = i >= 0 ? pathSegments[i] : _process__WEBPACK_IMPORTED_MODULE_0__.cwd();
      validateString(path, 'path'); // Skip empty entries

      if (path.length === 0) {
        continue;
      }

      resolvedPath = `${path}/${resolvedPath}`;
      resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
    } // At this point the path should be resolved to a full absolute path, but
    // handle relative paths to be safe (might happen when process.cwd() fails)
    // Normalize the path


    resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, '/', isPosixPathSeparator);

    if (resolvedAbsolute) {
      return `/${resolvedPath}`;
    }

    return resolvedPath.length > 0 ? resolvedPath : '.';
  },

  normalize(path) {
    validateString(path, 'path');

    if (path.length === 0) {
      return '.';
    }

    const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
    const trailingSeparator = path.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH; // Normalize the path

    path = normalizeString(path, !isAbsolute, '/', isPosixPathSeparator);

    if (path.length === 0) {
      if (isAbsolute) {
        return '/';
      }

      return trailingSeparator ? './' : '.';
    }

    if (trailingSeparator) {
      path += '/';
    }

    return isAbsolute ? `/${path}` : path;
  },

  isAbsolute(path) {
    validateString(path, 'path');
    return path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;
  },

  join(...paths) {
    if (paths.length === 0) {
      return '.';
    }

    let joined;

    for (let i = 0; i < paths.length; ++i) {
      const arg = paths[i];
      validateString(arg, 'path');

      if (arg.length > 0) {
        if (joined === undefined) {
          joined = arg;
        } else {
          joined += `/${arg}`;
        }
      }
    }

    if (joined === undefined) {
      return '.';
    }

    return posix.normalize(joined);
  },

  relative(from, to) {
    validateString(from, 'from');
    validateString(to, 'to');

    if (from === to) {
      return '';
    } // Trim leading forward slashes.


    from = posix.resolve(from);
    to = posix.resolve(to);

    if (from === to) {
      return '';
    }

    const fromStart = 1;
    const fromEnd = from.length;
    const fromLen = fromEnd - fromStart;
    const toStart = 1;
    const toLen = to.length - toStart; // Compare paths to find the longest common path from root

    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;

    for (; i < length; i++) {
      const fromCode = from.charCodeAt(fromStart + i);

      if (fromCode !== to.charCodeAt(toStart + i)) {
        break;
      } else if (fromCode === CHAR_FORWARD_SLASH) {
        lastCommonSep = i;
      }
    }

    if (i === length) {
      if (toLen > length) {
        if (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {
          // We get here if `from` is the exact base path for `to`.
          // For example: from='/foo/bar'; to='/foo/bar/baz'
          return to.slice(toStart + i + 1);
        }

        if (i === 0) {
          // We get here if `from` is the root
          // For example: from='/'; to='/foo'
          return to.slice(toStart + i);
        }
      } else if (fromLen > length) {
        if (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {
          // We get here if `to` is the exact base path for `from`.
          // For example: from='/foo/bar/baz'; to='/foo/bar'
          lastCommonSep = i;
        } else if (i === 0) {
          // We get here if `to` is the root.
          // For example: from='/foo/bar'; to='/'
          lastCommonSep = 0;
        }
      }
    }

    let out = ''; // Generate the relative path based on the path difference between `to`
    // and `from`.

    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
      if (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {
        out += out.length === 0 ? '..' : '/..';
      }
    } // Lastly, append the rest of the destination (`to`) path that comes after
    // the common path parts.


    return `${out}${to.slice(toStart + lastCommonSep)}`;
  },

  toNamespacedPath(path) {
    // Non-op on posix systems
    return path;
  },

  dirname(path) {
    validateString(path, 'path');

    if (path.length === 0) {
      return '.';
    }

    const hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
    let end = -1;
    let matchedSlash = true;

    for (let i = path.length - 1; i >= 1; --i) {
      if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
        // We saw the first non-path separator
        matchedSlash = false;
      }
    }

    if (end === -1) {
      return hasRoot ? '/' : '.';
    }

    if (hasRoot && end === 1) {
      return '//';
    }

    return path.slice(0, end);
  },

  basename(path, ext) {
    if (ext !== undefined) {
      validateString(ext, 'ext');
    }

    validateString(path, 'path');
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i;

    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
      if (ext === path) {
        return '';
      }

      let extIdx = ext.length - 1;
      let firstNonSlashEnd = -1;

      for (i = path.length - 1; i >= 0; --i) {
        const code = path.charCodeAt(i);

        if (code === CHAR_FORWARD_SLASH) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            start = i + 1;
            break;
          }
        } else {
          if (firstNonSlashEnd === -1) {
            // We saw the first non-path separator, remember this index in case
            // we need it if the extension ends up not matching
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }

          if (extIdx >= 0) {
            // Try to match the explicit extension
            if (code === ext.charCodeAt(extIdx)) {
              if (--extIdx === -1) {
                // We matched the extension, so mark this as the end of our path
                // component
                end = i;
              }
            } else {
              // Extension does not match, so our result is the entire path
              // component
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }

      if (start === end) {
        end = firstNonSlashEnd;
      } else if (end === -1) {
        end = path.length;
      }

      return path.slice(start, end);
    }

    for (i = path.length - 1; i >= 0; --i) {
      if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // path component
        matchedSlash = false;
        end = i + 1;
      }
    }

    if (end === -1) {
      return '';
    }

    return path.slice(start, end);
  },

  extname(path) {
    validateString(path, 'path');
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true; // Track the state of characters (if any) we see before our first dot and
    // after any path separator we find

    let preDotState = 0;

    for (let i = path.length - 1; i >= 0; --i) {
      const code = path.charCodeAt(i);

      if (code === CHAR_FORWARD_SLASH) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }

        continue;
      }

      if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // extension
        matchedSlash = false;
        end = i + 1;
      }

      if (code === CHAR_DOT) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1) {
          startDot = i;
        } else if (preDotState !== 1) {
          preDotState = 1;
        }
      } else if (startDot !== -1) {
        // We saw a non-dot and non-path separator before our dot, so we should
        // have a good chance at having a non-empty extension
        preDotState = -1;
      }
    }

    if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
    preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      return '';
    }

    return path.slice(startDot, end);
  },

  format: _format.bind(null, '/'),

  parse(path) {
    validateString(path, 'path');
    const ret = {
      root: '',
      dir: '',
      base: '',
      ext: '',
      name: ''
    };

    if (path.length === 0) {
      return ret;
    }

    const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
    let start;

    if (isAbsolute) {
      ret.root = '/';
      start = 1;
    } else {
      start = 0;
    }

    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1; // Track the state of characters (if any) we see before our first dot and
    // after any path separator we find

    let preDotState = 0; // Get non-dir info

    for (; i >= start; --i) {
      const code = path.charCodeAt(i);

      if (code === CHAR_FORWARD_SLASH) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }

        continue;
      }

      if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // extension
        matchedSlash = false;
        end = i + 1;
      }

      if (code === CHAR_DOT) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1) {
          startDot = i;
        } else if (preDotState !== 1) {
          preDotState = 1;
        }
      } else if (startDot !== -1) {
        // We saw a non-dot and non-path separator before our dot, so we should
        // have a good chance at having a non-empty extension
        preDotState = -1;
      }
    }

    if (end !== -1) {
      const start = startPart === 0 && isAbsolute ? 1 : startPart;

      if (startDot === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        ret.base = ret.name = path.slice(start, end);
      } else {
        ret.name = path.slice(start, startDot);
        ret.base = path.slice(start, end);
        ret.ext = path.slice(startDot, end);
      }
    }

    if (startPart > 0) {
      ret.dir = path.slice(0, startPart - 1);
    } else if (isAbsolute) {
      ret.dir = '/';
    }

    return ret;
  },

  sep: '/',
  delimiter: ':',
  win32: null,
  posix: null
};
posix.win32 = win32.win32 = win32;
posix.posix = win32.posix = posix;
const normalize = _process__WEBPACK_IMPORTED_MODULE_0__.platform === 'win32' ? win32.normalize : posix.normalize;
const isAbsolute = _process__WEBPACK_IMPORTED_MODULE_0__.platform === 'win32' ? win32.isAbsolute : posix.isAbsolute;
const join = _process__WEBPACK_IMPORTED_MODULE_0__.platform === 'win32' ? win32.join : posix.join;
const resolve = _process__WEBPACK_IMPORTED_MODULE_0__.platform === 'win32' ? win32.resolve : posix.resolve;
const relative = _process__WEBPACK_IMPORTED_MODULE_0__.platform === 'win32' ? win32.relative : posix.relative;
const dirname = _process__WEBPACK_IMPORTED_MODULE_0__.platform === 'win32' ? win32.dirname : posix.dirname;
const basename = _process__WEBPACK_IMPORTED_MODULE_0__.platform === 'win32' ? win32.basename : posix.basename;
const extname = _process__WEBPACK_IMPORTED_MODULE_0__.platform === 'win32' ? win32.extname : posix.extname;
const format = _process__WEBPACK_IMPORTED_MODULE_0__.platform === 'win32' ? win32.format : posix.format;
const parse = _process__WEBPACK_IMPORTED_MODULE_0__.platform === 'win32' ? win32.parse : posix.parse;
const toNamespacedPath = _process__WEBPACK_IMPORTED_MODULE_0__.platform === 'win32' ? win32.toNamespacedPath : posix.toNamespacedPath;
const sep = _process__WEBPACK_IMPORTED_MODULE_0__.platform === 'win32' ? win32.sep : posix.sep;
const delimiter = _process__WEBPACK_IMPORTED_MODULE_0__.platform === 'win32' ? win32.delimiter : posix.delimiter;

/***/ }),
/* 74 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cwd": () => (/* binding */ cwd),
/* harmony export */   "env": () => (/* binding */ env),
/* harmony export */   "platform": () => (/* binding */ platform),
/* harmony export */   "arch": () => (/* binding */ arch)
/* harmony export */ });
/* harmony import */ var _platform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(58);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

let safeProcess;

// Native sandbox environment
if (typeof _platform__WEBPACK_IMPORTED_MODULE_0__.globals.vscode !== 'undefined' && typeof _platform__WEBPACK_IMPORTED_MODULE_0__.globals.vscode.process !== 'undefined') {
  const sandboxProcess = _platform__WEBPACK_IMPORTED_MODULE_0__.globals.vscode.process;
  safeProcess = {
    get platform() {
      return sandboxProcess.platform;
    },

    get arch() {
      return sandboxProcess.arch;
    },

    get env() {
      return sandboxProcess.env;
    },

    cwd() {
      return sandboxProcess.cwd();
    }

  };
} // Native node.js environment
else if (typeof process !== 'undefined') {
  safeProcess = {
    get platform() {
      return process.platform;
    },

    get arch() {
      return process.arch;
    },

    get env() {
      return process.env;
    },

    cwd() {
      return process.env['VSCODE_CWD'] || process.cwd();
    }

  };
} // Web environment
else {
  safeProcess = {
    // Supported
    get platform() {
      return _platform__WEBPACK_IMPORTED_MODULE_0__.isWindows ? 'win32' : _platform__WEBPACK_IMPORTED_MODULE_0__.isMacintosh ? 'darwin' : 'linux';
    },

    get arch() {
      return undefined;
      /* arch is undefined in web */
    },

    // Unsupported
    get env() {
      return {};
    },

    cwd() {
      return '/';
    }

  };
}
/**
 * Provides safe access to the `cwd` property in node.js, sandboxed or web
 * environments.
 *
 * Note: in web, this property is hardcoded to be `/`.
 */


const cwd = safeProcess.cwd;
/**
 * Provides safe access to the `env` property in node.js, sandboxed or web
 * environments.
 *
 * Note: in web, this property is hardcoded to be `{}`.
 */

const env = safeProcess.env;
/**
 * Provides safe access to the `platform` property in node.js, sandboxed or web
 * environments.
 */

const platform = safeProcess.platform;
/**
 * Provides safe access to the `arch` method in node.js, sandboxed or web
 * environments.
 * Note: `arch` is `undefined` in web
 */

const arch = safeProcess.arch;

/***/ }),
/* 75 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isFalsyOrWhitespace": () => (/* binding */ isFalsyOrWhitespace),
/* harmony export */   "format": () => (/* binding */ format),
/* harmony export */   "format2": () => (/* binding */ format2),
/* harmony export */   "escape": () => (/* binding */ escape),
/* harmony export */   "escapeRegExpCharacters": () => (/* binding */ escapeRegExpCharacters),
/* harmony export */   "count": () => (/* binding */ count),
/* harmony export */   "truncate": () => (/* binding */ truncate),
/* harmony export */   "trim": () => (/* binding */ trim),
/* harmony export */   "ltrim": () => (/* binding */ ltrim),
/* harmony export */   "rtrim": () => (/* binding */ rtrim),
/* harmony export */   "convertSimple2RegExpPattern": () => (/* binding */ convertSimple2RegExpPattern),
/* harmony export */   "stripWildcards": () => (/* binding */ stripWildcards),
/* harmony export */   "createRegExp": () => (/* binding */ createRegExp),
/* harmony export */   "regExpLeadsToEndlessLoop": () => (/* binding */ regExpLeadsToEndlessLoop),
/* harmony export */   "regExpContainsBackreference": () => (/* binding */ regExpContainsBackreference),
/* harmony export */   "regExpFlags": () => (/* binding */ regExpFlags),
/* harmony export */   "splitLines": () => (/* binding */ splitLines),
/* harmony export */   "firstNonWhitespaceIndex": () => (/* binding */ firstNonWhitespaceIndex),
/* harmony export */   "getLeadingWhitespace": () => (/* binding */ getLeadingWhitespace),
/* harmony export */   "lastNonWhitespaceIndex": () => (/* binding */ lastNonWhitespaceIndex),
/* harmony export */   "replaceAsync": () => (/* binding */ replaceAsync),
/* harmony export */   "compare": () => (/* binding */ compare),
/* harmony export */   "compareSubstring": () => (/* binding */ compareSubstring),
/* harmony export */   "compareIgnoreCase": () => (/* binding */ compareIgnoreCase),
/* harmony export */   "compareSubstringIgnoreCase": () => (/* binding */ compareSubstringIgnoreCase),
/* harmony export */   "isAsciiDigit": () => (/* binding */ isAsciiDigit),
/* harmony export */   "isLowerAsciiLetter": () => (/* binding */ isLowerAsciiLetter),
/* harmony export */   "isUpperAsciiLetter": () => (/* binding */ isUpperAsciiLetter),
/* harmony export */   "equalsIgnoreCase": () => (/* binding */ equalsIgnoreCase),
/* harmony export */   "startsWithIgnoreCase": () => (/* binding */ startsWithIgnoreCase),
/* harmony export */   "commonPrefixLength": () => (/* binding */ commonPrefixLength),
/* harmony export */   "commonSuffixLength": () => (/* binding */ commonSuffixLength),
/* harmony export */   "isHighSurrogate": () => (/* binding */ isHighSurrogate),
/* harmony export */   "isLowSurrogate": () => (/* binding */ isLowSurrogate),
/* harmony export */   "computeCodePoint": () => (/* binding */ computeCodePoint),
/* harmony export */   "getNextCodePoint": () => (/* binding */ getNextCodePoint),
/* harmony export */   "CodePointIterator": () => (/* binding */ CodePointIterator),
/* harmony export */   "GraphemeIterator": () => (/* binding */ GraphemeIterator),
/* harmony export */   "nextCharLength": () => (/* binding */ nextCharLength),
/* harmony export */   "prevCharLength": () => (/* binding */ prevCharLength),
/* harmony export */   "getCharContainingOffset": () => (/* binding */ getCharContainingOffset),
/* harmony export */   "charCount": () => (/* binding */ charCount),
/* harmony export */   "containsRTL": () => (/* binding */ containsRTL),
/* harmony export */   "isBasicASCII": () => (/* binding */ isBasicASCII),
/* harmony export */   "UNUSUAL_LINE_TERMINATORS": () => (/* binding */ UNUSUAL_LINE_TERMINATORS),
/* harmony export */   "containsUnusualLineTerminators": () => (/* binding */ containsUnusualLineTerminators),
/* harmony export */   "isFullWidthCharacter": () => (/* binding */ isFullWidthCharacter),
/* harmony export */   "isEmojiImprecise": () => (/* binding */ isEmojiImprecise),
/* harmony export */   "lcut": () => (/* binding */ lcut),
/* harmony export */   "removeAnsiEscapeCodes": () => (/* binding */ removeAnsiEscapeCodes),
/* harmony export */   "UTF8_BOM_CHARACTER": () => (/* binding */ UTF8_BOM_CHARACTER),
/* harmony export */   "startsWithUTF8BOM": () => (/* binding */ startsWithUTF8BOM),
/* harmony export */   "stripUTF8BOM": () => (/* binding */ stripUTF8BOM),
/* harmony export */   "fuzzyContains": () => (/* binding */ fuzzyContains),
/* harmony export */   "containsUppercaseCharacter": () => (/* binding */ containsUppercaseCharacter),
/* harmony export */   "uppercaseFirstLetter": () => (/* binding */ uppercaseFirstLetter),
/* harmony export */   "getNLines": () => (/* binding */ getNLines),
/* harmony export */   "singleLetterHash": () => (/* binding */ singleLetterHash),
/* harmony export */   "getGraphemeBreakType": () => (/* binding */ getGraphemeBreakType),
/* harmony export */   "GraphemeBreakType": () => (/* binding */ GraphemeBreakType),
/* harmony export */   "getLeftDeleteOffset": () => (/* binding */ getLeftDeleteOffset),
/* harmony export */   "noBreakWhitespace": () => (/* binding */ noBreakWhitespace),
/* harmony export */   "AmbiguousCharacters": () => (/* binding */ AmbiguousCharacters),
/* harmony export */   "InvisibleCharacters": () => (/* binding */ InvisibleCharacters)
/* harmony export */ });
/* harmony import */ var _cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(76);
/* harmony import */ var _charCode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(71);
/* harmony import */ var _lazy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(77);
/* harmony import */ var _uint__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(78);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/




function isFalsyOrWhitespace(str) {
  if (!str || typeof str !== 'string') {
    return true;
  }

  return str.trim().length === 0;
}
const _formatRegexp = /{(\d+)}/g;
/**
 * Helper to produce a string with a variable number of arguments. Insert variable segments
 * into the string using the {n} notation where N is the index of the argument following the string.
 * @param value string to which formatting is applied
 * @param args replacements for {n}-entries
 */

function format(value, ...args) {
  if (args.length === 0) {
    return value;
  }

  return value.replace(_formatRegexp, function (match, group) {
    const idx = parseInt(group, 10);
    return isNaN(idx) || idx < 0 || idx >= args.length ? match : args[idx];
  });
}
const _format2Regexp = /{([^}]+)}/g;
/**
 * Helper to create a string from a template and a string record.
 * Similar to `format` but with objects instead of positional arguments.
 */

function format2(template, values) {
  return template.replace(_format2Regexp, (match, group) => values[group] ?? match);
}
/**
 * Converts HTML characters inside the string to use entities instead. Makes the string safe from
 * being used e.g. in HTMLElement.innerHTML.
 */

function escape(html) {
  return html.replace(/[<>&]/g, function (match) {
    switch (match) {
      case '<':
        return '&lt;';

      case '>':
        return '&gt;';

      case '&':
        return '&amp;';

      default:
        return match;
    }
  });
}
/**
 * Escapes regular expression characters in a given string
 */

function escapeRegExpCharacters(value) {
  return value.replace(/[\\\{\}\*\+\?\|\^\$\.\[\]\(\)]/g, '\\$&');
}
/**
 * Counts how often `character` occurs inside `value`.
 */

function count(value, character) {
  let result = 0;
  const ch = character.charCodeAt(0);

  for (let i = value.length - 1; i >= 0; i--) {
    if (value.charCodeAt(i) === ch) {
      result++;
    }
  }

  return result;
}
function truncate(value, maxLength, suffix = '') {
  if (value.length <= maxLength) {
    return value;
  }

  return `${value.substr(0, maxLength)}${suffix}`;
}
/**
 * Removes all occurrences of needle from the beginning and end of haystack.
 * @param haystack string to trim
 * @param needle the thing to trim (default is a blank)
 */

function trim(haystack, needle = ' ') {
  const trimmed = ltrim(haystack, needle);
  return rtrim(trimmed, needle);
}
/**
 * Removes all occurrences of needle from the beginning of haystack.
 * @param haystack string to trim
 * @param needle the thing to trim
 */

function ltrim(haystack, needle) {
  if (!haystack || !needle) {
    return haystack;
  }

  const needleLen = needle.length;

  if (needleLen === 0 || haystack.length === 0) {
    return haystack;
  }

  let offset = 0;

  while (haystack.indexOf(needle, offset) === offset) {
    offset = offset + needleLen;
  }

  return haystack.substring(offset);
}
/**
 * Removes all occurrences of needle from the end of haystack.
 * @param haystack string to trim
 * @param needle the thing to trim
 */

function rtrim(haystack, needle) {
  if (!haystack || !needle) {
    return haystack;
  }

  const needleLen = needle.length,
        haystackLen = haystack.length;

  if (needleLen === 0 || haystackLen === 0) {
    return haystack;
  }

  let offset = haystackLen,
      idx = -1;

  while (true) {
    idx = haystack.lastIndexOf(needle, offset - 1);

    if (idx === -1 || idx + needleLen !== offset) {
      break;
    }

    if (idx === 0) {
      return '';
    }

    offset = idx;
  }

  return haystack.substring(0, offset);
}
function convertSimple2RegExpPattern(pattern) {
  return pattern.replace(/[\-\\\{\}\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, '\\$&').replace(/[\*]/g, '.*');
}
function stripWildcards(pattern) {
  return pattern.replace(/\*/g, '');
}
function createRegExp(searchString, isRegex, options = {}) {
  if (!searchString) {
    throw new Error('Cannot create regex from empty string');
  }

  if (!isRegex) {
    searchString = escapeRegExpCharacters(searchString);
  }

  if (options.wholeWord) {
    if (!/\B/.test(searchString.charAt(0))) {
      searchString = '\\b' + searchString;
    }

    if (!/\B/.test(searchString.charAt(searchString.length - 1))) {
      searchString = searchString + '\\b';
    }
  }

  let modifiers = '';

  if (options.global) {
    modifiers += 'g';
  }

  if (!options.matchCase) {
    modifiers += 'i';
  }

  if (options.multiline) {
    modifiers += 'm';
  }

  if (options.unicode) {
    modifiers += 'u';
  }

  return new RegExp(searchString, modifiers);
}
function regExpLeadsToEndlessLoop(regexp) {
  // Exit early if it's one of these special cases which are meant to match
  // against an empty string
  if (regexp.source === '^' || regexp.source === '^$' || regexp.source === '$' || regexp.source === '^\\s*$') {
    return false;
  } // We check against an empty string. If the regular expression doesn't advance
  // (e.g. ends in an endless loop) it will match an empty string.


  const match = regexp.exec('');
  return !!(match && regexp.lastIndex === 0);
}
function regExpContainsBackreference(regexpValue) {
  return !!regexpValue.match(/([^\\]|^)(\\\\)*\\\d+/);
}
function regExpFlags(regexp) {
  return (regexp.global ? 'g' : '') + (regexp.ignoreCase ? 'i' : '') + (regexp.multiline ? 'm' : '') + (regexp
  /* standalone editor compilation */
  .unicode ? 'u' : '');
}
function splitLines(str) {
  return str.split(/\r\n|\r|\n/);
}
/**
 * Returns first index of the string that is not whitespace.
 * If string is empty or contains only whitespaces, returns -1
 */

function firstNonWhitespaceIndex(str) {
  for (let i = 0, len = str.length; i < len; i++) {
    const chCode = str.charCodeAt(i);

    if (chCode !== _charCode__WEBPACK_IMPORTED_MODULE_1__.CharCode.Space && chCode !== _charCode__WEBPACK_IMPORTED_MODULE_1__.CharCode.Tab) {
      return i;
    }
  }

  return -1;
}
/**
 * Returns the leading whitespace of the string.
 * If the string contains only whitespaces, returns entire string
 */

function getLeadingWhitespace(str, start = 0, end = str.length) {
  for (let i = start; i < end; i++) {
    const chCode = str.charCodeAt(i);

    if (chCode !== _charCode__WEBPACK_IMPORTED_MODULE_1__.CharCode.Space && chCode !== _charCode__WEBPACK_IMPORTED_MODULE_1__.CharCode.Tab) {
      return str.substring(start, i);
    }
  }

  return str.substring(start, end);
}
/**
 * Returns last index of the string that is not whitespace.
 * If string is empty or contains only whitespaces, returns -1
 */

function lastNonWhitespaceIndex(str, startIndex = str.length - 1) {
  for (let i = startIndex; i >= 0; i--) {
    const chCode = str.charCodeAt(i);

    if (chCode !== _charCode__WEBPACK_IMPORTED_MODULE_1__.CharCode.Space && chCode !== _charCode__WEBPACK_IMPORTED_MODULE_1__.CharCode.Tab) {
      return i;
    }
  }

  return -1;
}
/**
 * Function that works identically to String.prototype.replace, except, the
 * replace function is allowed to be async and return a Promise.
 */

function replaceAsync(str, search, replacer) {
  const parts = [];
  let last = 0;

  for (const match of str.matchAll(search)) {
    parts.push(str.slice(last, match.index));

    if (match.index === undefined) {
      throw new Error('match.index should be defined');
    }

    last = match.index + match[0].length;
    parts.push(replacer(match[0], ...match.slice(1), match.index, str, match.groups));
  }

  parts.push(str.slice(last));
  return Promise.all(parts).then(p => p.join(''));
}
function compare(a, b) {
  if (a < b) {
    return -1;
  } else if (a > b) {
    return 1;
  } else {
    return 0;
  }
}
function compareSubstring(a, b, aStart = 0, aEnd = a.length, bStart = 0, bEnd = b.length) {
  for (; aStart < aEnd && bStart < bEnd; aStart++, bStart++) {
    const codeA = a.charCodeAt(aStart);
    const codeB = b.charCodeAt(bStart);

    if (codeA < codeB) {
      return -1;
    } else if (codeA > codeB) {
      return 1;
    }
  }

  const aLen = aEnd - aStart;
  const bLen = bEnd - bStart;

  if (aLen < bLen) {
    return -1;
  } else if (aLen > bLen) {
    return 1;
  }

  return 0;
}
function compareIgnoreCase(a, b) {
  return compareSubstringIgnoreCase(a, b, 0, a.length, 0, b.length);
}
function compareSubstringIgnoreCase(a, b, aStart = 0, aEnd = a.length, bStart = 0, bEnd = b.length) {
  for (; aStart < aEnd && bStart < bEnd; aStart++, bStart++) {
    let codeA = a.charCodeAt(aStart);
    let codeB = b.charCodeAt(bStart);

    if (codeA === codeB) {
      // equal
      continue;
    }

    if (codeA >= 128 || codeB >= 128) {
      // not ASCII letters -> fallback to lower-casing strings
      return compareSubstring(a.toLowerCase(), b.toLowerCase(), aStart, aEnd, bStart, bEnd);
    } // mapper lower-case ascii letter onto upper-case varinats
    // [97-122] (lower ascii) --> [65-90] (upper ascii)


    if (isLowerAsciiLetter(codeA)) {
      codeA -= 32;
    }

    if (isLowerAsciiLetter(codeB)) {
      codeB -= 32;
    } // compare both code points


    const diff = codeA - codeB;

    if (diff === 0) {
      continue;
    }

    return diff;
  }

  const aLen = aEnd - aStart;
  const bLen = bEnd - bStart;

  if (aLen < bLen) {
    return -1;
  } else if (aLen > bLen) {
    return 1;
  }

  return 0;
}
function isAsciiDigit(code) {
  return code >= _charCode__WEBPACK_IMPORTED_MODULE_1__.CharCode.Digit0 && code <= _charCode__WEBPACK_IMPORTED_MODULE_1__.CharCode.Digit9;
}
function isLowerAsciiLetter(code) {
  return code >= _charCode__WEBPACK_IMPORTED_MODULE_1__.CharCode.a && code <= _charCode__WEBPACK_IMPORTED_MODULE_1__.CharCode.z;
}
function isUpperAsciiLetter(code) {
  return code >= _charCode__WEBPACK_IMPORTED_MODULE_1__.CharCode.A && code <= _charCode__WEBPACK_IMPORTED_MODULE_1__.CharCode.Z;
}
function equalsIgnoreCase(a, b) {
  return a.length === b.length && compareSubstringIgnoreCase(a, b) === 0;
}
function startsWithIgnoreCase(str, candidate) {
  const candidateLength = candidate.length;

  if (candidate.length > str.length) {
    return false;
  }

  return compareSubstringIgnoreCase(str, candidate, 0, candidateLength) === 0;
}
/**
 * @returns the length of the common prefix of the two strings.
 */

function commonPrefixLength(a, b) {
  const len = Math.min(a.length, b.length);
  let i;

  for (i = 0; i < len; i++) {
    if (a.charCodeAt(i) !== b.charCodeAt(i)) {
      return i;
    }
  }

  return len;
}
/**
 * @returns the length of the common suffix of the two strings.
 */

function commonSuffixLength(a, b) {
  const len = Math.min(a.length, b.length);
  let i;
  const aLastIndex = a.length - 1;
  const bLastIndex = b.length - 1;

  for (i = 0; i < len; i++) {
    if (a.charCodeAt(aLastIndex - i) !== b.charCodeAt(bLastIndex - i)) {
      return i;
    }
  }

  return len;
}
/**
 * See http://en.wikipedia.org/wiki/Surrogate_pair
 */

function isHighSurrogate(charCode) {
  return 0xD800 <= charCode && charCode <= 0xDBFF;
}
/**
 * See http://en.wikipedia.org/wiki/Surrogate_pair
 */

function isLowSurrogate(charCode) {
  return 0xDC00 <= charCode && charCode <= 0xDFFF;
}
/**
 * See http://en.wikipedia.org/wiki/Surrogate_pair
 */

function computeCodePoint(highSurrogate, lowSurrogate) {
  return (highSurrogate - 0xD800 << 10) + (lowSurrogate - 0xDC00) + 0x10000;
}
/**
 * get the code point that begins at offset `offset`
 */

function getNextCodePoint(str, len, offset) {
  const charCode = str.charCodeAt(offset);

  if (isHighSurrogate(charCode) && offset + 1 < len) {
    const nextCharCode = str.charCodeAt(offset + 1);

    if (isLowSurrogate(nextCharCode)) {
      return computeCodePoint(charCode, nextCharCode);
    }
  }

  return charCode;
}
/**
 * get the code point that ends right before offset `offset`
 */

function getPrevCodePoint(str, offset) {
  const charCode = str.charCodeAt(offset - 1);

  if (isLowSurrogate(charCode) && offset > 1) {
    const prevCharCode = str.charCodeAt(offset - 2);

    if (isHighSurrogate(prevCharCode)) {
      return computeCodePoint(prevCharCode, charCode);
    }
  }

  return charCode;
}

class CodePointIterator {
  get offset() {
    return this._offset;
  }

  constructor(str, offset = 0) {
    this._str = str;
    this._len = str.length;
    this._offset = offset;
  }

  setOffset(offset) {
    this._offset = offset;
  }

  prevCodePoint() {
    const codePoint = getPrevCodePoint(this._str, this._offset);
    this._offset -= codePoint >= _uint__WEBPACK_IMPORTED_MODULE_3__.Constants.UNICODE_SUPPLEMENTARY_PLANE_BEGIN ? 2 : 1;
    return codePoint;
  }

  nextCodePoint() {
    const codePoint = getNextCodePoint(this._str, this._len, this._offset);
    this._offset += codePoint >= _uint__WEBPACK_IMPORTED_MODULE_3__.Constants.UNICODE_SUPPLEMENTARY_PLANE_BEGIN ? 2 : 1;
    return codePoint;
  }

  eol() {
    return this._offset >= this._len;
  }

}
class GraphemeIterator {
  get offset() {
    return this._iterator.offset;
  }

  constructor(str, offset = 0) {
    this._iterator = new CodePointIterator(str, offset);
  }

  nextGraphemeLength() {
    const graphemeBreakTree = GraphemeBreakTree.getInstance();
    const iterator = this._iterator;
    const initialOffset = iterator.offset;
    let graphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.nextCodePoint());

    while (!iterator.eol()) {
      const offset = iterator.offset;
      const nextGraphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.nextCodePoint());

      if (breakBetweenGraphemeBreakType(graphemeBreakType, nextGraphemeBreakType)) {
        // move iterator back
        iterator.setOffset(offset);
        break;
      }

      graphemeBreakType = nextGraphemeBreakType;
    }

    return iterator.offset - initialOffset;
  }

  prevGraphemeLength() {
    const graphemeBreakTree = GraphemeBreakTree.getInstance();
    const iterator = this._iterator;
    const initialOffset = iterator.offset;
    let graphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.prevCodePoint());

    while (iterator.offset > 0) {
      const offset = iterator.offset;
      const prevGraphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.prevCodePoint());

      if (breakBetweenGraphemeBreakType(prevGraphemeBreakType, graphemeBreakType)) {
        // move iterator back
        iterator.setOffset(offset);
        break;
      }

      graphemeBreakType = prevGraphemeBreakType;
    }

    return initialOffset - iterator.offset;
  }

  eol() {
    return this._iterator.eol();
  }

}
function nextCharLength(str, initialOffset) {
  const iterator = new GraphemeIterator(str, initialOffset);
  return iterator.nextGraphemeLength();
}
function prevCharLength(str, initialOffset) {
  const iterator = new GraphemeIterator(str, initialOffset);
  return iterator.prevGraphemeLength();
}
function getCharContainingOffset(str, offset) {
  if (offset > 0 && isLowSurrogate(str.charCodeAt(offset))) {
    offset--;
  }

  const endOffset = offset + nextCharLength(str, offset);
  const startOffset = endOffset - prevCharLength(str, endOffset);
  return [startOffset, endOffset];
}
function charCount(str) {
  const iterator = new GraphemeIterator(str);
  let length = 0;

  while (!iterator.eol()) {
    length++;
    iterator.nextGraphemeLength();
  }

  return length;
}
let CONTAINS_RTL = undefined;

function makeContainsRtl() {
  // Generated using https://github.com/alexdima/unicode-utils/blob/main/rtl-test.js
  return /(?:[\u05BE\u05C0\u05C3\u05C6\u05D0-\u05F4\u0608\u060B\u060D\u061B-\u064A\u066D-\u066F\u0671-\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u0710\u0712-\u072F\u074D-\u07A5\u07B1-\u07EA\u07F4\u07F5\u07FA\u07FE-\u0815\u081A\u0824\u0828\u0830-\u0858\u085E-\u088E\u08A0-\u08C9\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFD3D\uFD50-\uFDC7\uFDF0-\uFDFC\uFE70-\uFEFC]|\uD802[\uDC00-\uDD1B\uDD20-\uDE00\uDE10-\uDE35\uDE40-\uDEE4\uDEEB-\uDF35\uDF40-\uDFFF]|\uD803[\uDC00-\uDD23\uDE80-\uDEA9\uDEAD-\uDF45\uDF51-\uDF81\uDF86-\uDFF6]|\uD83A[\uDC00-\uDCCF\uDD00-\uDD43\uDD4B-\uDFFF]|\uD83B[\uDC00-\uDEBB])/;
}
/**
 * Returns true if `str` contains any Unicode character that is classified as "R" or "AL".
 */


function containsRTL(str) {
  if (!CONTAINS_RTL) {
    CONTAINS_RTL = makeContainsRtl();
  }

  return CONTAINS_RTL.test(str);
}
const IS_BASIC_ASCII = /^[\t\n\r\x20-\x7E]*$/;
/**
 * Returns true if `str` contains only basic ASCII characters in the range 32 - 126 (including 32 and 126) or \n, \r, \t
 */

function isBasicASCII(str) {
  return IS_BASIC_ASCII.test(str);
}
const UNUSUAL_LINE_TERMINATORS = /[\u2028\u2029]/; // LINE SEPARATOR (LS) or PARAGRAPH SEPARATOR (PS)

/**
 * Returns true if `str` contains unusual line terminators, like LS or PS
 */

function containsUnusualLineTerminators(str) {
  return UNUSUAL_LINE_TERMINATORS.test(str);
}
function isFullWidthCharacter(charCode) {
  // Do a cheap trick to better support wrapping of wide characters, treat them as 2 columns
  // http://jrgraphix.net/research/unicode_blocks.php
  //          2E80 - 2EFF   CJK Radicals Supplement
  //          2F00 - 2FDF   Kangxi Radicals
  //          2FF0 - 2FFF   Ideographic Description Characters
  //          3000 - 303F   CJK Symbols and Punctuation
  //          3040 - 309F   Hiragana
  //          30A0 - 30FF   Katakana
  //          3100 - 312F   Bopomofo
  //          3130 - 318F   Hangul Compatibility Jamo
  //          3190 - 319F   Kanbun
  //          31A0 - 31BF   Bopomofo Extended
  //          31F0 - 31FF   Katakana Phonetic Extensions
  //          3200 - 32FF   Enclosed CJK Letters and Months
  //          3300 - 33FF   CJK Compatibility
  //          3400 - 4DBF   CJK Unified Ideographs Extension A
  //          4DC0 - 4DFF   Yijing Hexagram Symbols
  //          4E00 - 9FFF   CJK Unified Ideographs
  //          A000 - A48F   Yi Syllables
  //          A490 - A4CF   Yi Radicals
  //          AC00 - D7AF   Hangul Syllables
  // [IGNORE] D800 - DB7F   High Surrogates
  // [IGNORE] DB80 - DBFF   High Private Use Surrogates
  // [IGNORE] DC00 - DFFF   Low Surrogates
  // [IGNORE] E000 - F8FF   Private Use Area
  //          F900 - FAFF   CJK Compatibility Ideographs
  // [IGNORE] FB00 - FB4F   Alphabetic Presentation Forms
  // [IGNORE] FB50 - FDFF   Arabic Presentation Forms-A
  // [IGNORE] FE00 - FE0F   Variation Selectors
  // [IGNORE] FE20 - FE2F   Combining Half Marks
  // [IGNORE] FE30 - FE4F   CJK Compatibility Forms
  // [IGNORE] FE50 - FE6F   Small Form Variants
  // [IGNORE] FE70 - FEFF   Arabic Presentation Forms-B
  //          FF00 - FFEF   Halfwidth and Fullwidth Forms
  //               [https://en.wikipedia.org/wiki/Halfwidth_and_fullwidth_forms]
  //               of which FF01 - FF5E fullwidth ASCII of 21 to 7E
  // [IGNORE]    and FF65 - FFDC halfwidth of Katakana and Hangul
  // [IGNORE] FFF0 - FFFF   Specials
  return charCode >= 0x2E80 && charCode <= 0xD7AF || charCode >= 0xF900 && charCode <= 0xFAFF || charCode >= 0xFF01 && charCode <= 0xFF5E;
}
/**
 * A fast function (therefore imprecise) to check if code points are emojis.
 * Generated using https://github.com/alexdima/unicode-utils/blob/main/emoji-test.js
 */

function isEmojiImprecise(x) {
  return x >= 0x1F1E6 && x <= 0x1F1FF || x === 8986 || x === 8987 || x === 9200 || x === 9203 || x >= 9728 && x <= 10175 || x === 11088 || x === 11093 || x >= 127744 && x <= 128591 || x >= 128640 && x <= 128764 || x >= 128992 && x <= 129008 || x >= 129280 && x <= 129535 || x >= 129648 && x <= 129782;
}
/**
 * Given a string and a max length returns a shorted version. Shorting
 * happens at favorable positions - such as whitespace or punctuation characters.
 */

function lcut(text, n) {
  if (text.length < n) {
    return text;
  }

  const re = /\b/g;
  let i = 0;

  while (re.test(text)) {
    if (text.length - re.lastIndex < n) {
      break;
    }

    i = re.lastIndex;
    re.lastIndex += 1;
  }

  return text.substring(i).replace(/^\s/, '');
} // Escape codes
// http://en.wikipedia.org/wiki/ANSI_escape_code

const EL = /\x1B\x5B[12]?K/g; // Erase in line

const COLOR_START = /\x1b\[\d+m/g; // Color

const COLOR_END = /\x1b\[0?m/g; // Color

function removeAnsiEscapeCodes(str) {
  if (str) {
    str = str.replace(EL, '');
    str = str.replace(COLOR_START, '');
    str = str.replace(COLOR_END, '');
  }

  return str;
} // -- UTF-8 BOM

const UTF8_BOM_CHARACTER = String.fromCharCode(_charCode__WEBPACK_IMPORTED_MODULE_1__.CharCode.UTF8_BOM);
function startsWithUTF8BOM(str) {
  return !!(str && str.length > 0 && str.charCodeAt(0) === _charCode__WEBPACK_IMPORTED_MODULE_1__.CharCode.UTF8_BOM);
}
function stripUTF8BOM(str) {
  return startsWithUTF8BOM(str) ? str.substr(1) : str;
}
/**
 * Checks if the characters of the provided query string are included in the
 * target string. The characters do not have to be contiguous within the string.
 */

function fuzzyContains(target, query) {
  if (!target || !query) {
    return false; // return early if target or query are undefined
  }

  if (target.length < query.length) {
    return false; // impossible for query to be contained in target
  }

  const queryLen = query.length;
  const targetLower = target.toLowerCase();
  let index = 0;
  let lastIndexOf = -1;

  while (index < queryLen) {
    const indexOf = targetLower.indexOf(query[index], lastIndexOf + 1);

    if (indexOf < 0) {
      return false;
    }

    lastIndexOf = indexOf;
    index++;
  }

  return true;
}
function containsUppercaseCharacter(target, ignoreEscapedChars = false) {
  if (!target) {
    return false;
  }

  if (ignoreEscapedChars) {
    target = target.replace(/\\./g, '');
  }

  return target.toLowerCase() !== target;
}
function uppercaseFirstLetter(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
function getNLines(str, n = 1) {
  if (n === 0) {
    return '';
  }

  let idx = -1;

  do {
    idx = str.indexOf('\n', idx + 1);
    n--;
  } while (n > 0 && idx >= 0);

  if (idx === -1) {
    return str;
  }

  if (str[idx - 1] === '\r') {
    idx--;
  }

  return str.substr(0, idx);
}
/**
 * Produces 'a'-'z', followed by 'A'-'Z'... followed by 'a'-'z', etc.
 */

function singleLetterHash(n) {
  const LETTERS_CNT = _charCode__WEBPACK_IMPORTED_MODULE_1__.CharCode.Z - _charCode__WEBPACK_IMPORTED_MODULE_1__.CharCode.A + 1;
  n = n % (2 * LETTERS_CNT);

  if (n < LETTERS_CNT) {
    return String.fromCharCode(_charCode__WEBPACK_IMPORTED_MODULE_1__.CharCode.a + n);
  }

  return String.fromCharCode(_charCode__WEBPACK_IMPORTED_MODULE_1__.CharCode.A + n - LETTERS_CNT);
} //#region Unicode Grapheme Break

function getGraphemeBreakType(codePoint) {
  const graphemeBreakTree = GraphemeBreakTree.getInstance();
  return graphemeBreakTree.getGraphemeBreakType(codePoint);
}

function breakBetweenGraphemeBreakType(breakTypeA, breakTypeB) {
  // http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundary_Rules
  // !!! Let's make the common case a bit faster
  if (breakTypeA === GraphemeBreakType.Other) {
    // see https://www.unicode.org/Public/13.0.0/ucd/auxiliary/GraphemeBreakTest-13.0.0d10.html#table
    return breakTypeB !== GraphemeBreakType.Extend && breakTypeB !== GraphemeBreakType.SpacingMark;
  } // Do not break between a CR and LF. Otherwise, break before and after controls.
  // GB3                                        CR  LF
  // GB4                       (Control | CR | LF) 
  // GB5                                            (Control | CR | LF)


  if (breakTypeA === GraphemeBreakType.CR) {
    if (breakTypeB === GraphemeBreakType.LF) {
      return false; // GB3
    }
  }

  if (breakTypeA === GraphemeBreakType.Control || breakTypeA === GraphemeBreakType.CR || breakTypeA === GraphemeBreakType.LF) {
    return true; // GB4
  }

  if (breakTypeB === GraphemeBreakType.Control || breakTypeB === GraphemeBreakType.CR || breakTypeB === GraphemeBreakType.LF) {
    return true; // GB5
  } // Do not break Hangul syllable sequences.
  // GB6                                         L  (L | V | LV | LVT)
  // GB7                                  (LV | V)  (V | T)
  // GB8                                 (LVT | T)  T


  if (breakTypeA === GraphemeBreakType.L) {
    if (breakTypeB === GraphemeBreakType.L || breakTypeB === GraphemeBreakType.V || breakTypeB === GraphemeBreakType.LV || breakTypeB === GraphemeBreakType.LVT) {
      return false; // GB6
    }
  }

  if (breakTypeA === GraphemeBreakType.LV || breakTypeA === GraphemeBreakType.V) {
    if (breakTypeB === GraphemeBreakType.V || breakTypeB === GraphemeBreakType.T) {
      return false; // GB7
    }
  }

  if (breakTypeA === GraphemeBreakType.LVT || breakTypeA === GraphemeBreakType.T) {
    if (breakTypeB === GraphemeBreakType.T) {
      return false; // GB8
    }
  } // Do not break before extending characters or ZWJ.
  // GB9                                            (Extend | ZWJ)


  if (breakTypeB === GraphemeBreakType.Extend || breakTypeB === GraphemeBreakType.ZWJ) {
    return false; // GB9
  } // The GB9a and GB9b rules only apply to extended grapheme clusters:
  // Do not break before SpacingMarks, or after Prepend characters.
  // GB9a                                           SpacingMark
  // GB9b                                  Prepend 


  if (breakTypeB === GraphemeBreakType.SpacingMark) {
    return false; // GB9a
  }

  if (breakTypeA === GraphemeBreakType.Prepend) {
    return false; // GB9b
  } // Do not break within emoji modifier sequences or emoji zwj sequences.
  // GB11    \p{Extended_Pictographic} Extend* ZWJ  \p{Extended_Pictographic}


  if (breakTypeA === GraphemeBreakType.ZWJ && breakTypeB === GraphemeBreakType.Extended_Pictographic) {
    // Note: we are not implementing the rule entirely here to avoid introducing states
    return false; // GB11
  } // GB12                          sot (RI RI)* RI  RI
  // GB13                        [^RI] (RI RI)* RI  RI


  if (breakTypeA === GraphemeBreakType.Regional_Indicator && breakTypeB === GraphemeBreakType.Regional_Indicator) {
    // Note: we are not implementing the rule entirely here to avoid introducing states
    return false; // GB12 & GB13
  } // GB999                                     Any  Any


  return true;
}

let GraphemeBreakType;

(function (GraphemeBreakType) {
  GraphemeBreakType[GraphemeBreakType["Other"] = 0] = "Other";
  GraphemeBreakType[GraphemeBreakType["Prepend"] = 1] = "Prepend";
  GraphemeBreakType[GraphemeBreakType["CR"] = 2] = "CR";
  GraphemeBreakType[GraphemeBreakType["LF"] = 3] = "LF";
  GraphemeBreakType[GraphemeBreakType["Control"] = 4] = "Control";
  GraphemeBreakType[GraphemeBreakType["Extend"] = 5] = "Extend";
  GraphemeBreakType[GraphemeBreakType["Regional_Indicator"] = 6] = "Regional_Indicator";
  GraphemeBreakType[GraphemeBreakType["SpacingMark"] = 7] = "SpacingMark";
  GraphemeBreakType[GraphemeBreakType["L"] = 8] = "L";
  GraphemeBreakType[GraphemeBreakType["V"] = 9] = "V";
  GraphemeBreakType[GraphemeBreakType["T"] = 10] = "T";
  GraphemeBreakType[GraphemeBreakType["LV"] = 11] = "LV";
  GraphemeBreakType[GraphemeBreakType["LVT"] = 12] = "LVT";
  GraphemeBreakType[GraphemeBreakType["ZWJ"] = 13] = "ZWJ";
  GraphemeBreakType[GraphemeBreakType["Extended_Pictographic"] = 14] = "Extended_Pictographic";
})(GraphemeBreakType || (GraphemeBreakType = {}));

class GraphemeBreakTree {
  static _INSTANCE = null;

  static getInstance() {
    if (!GraphemeBreakTree._INSTANCE) {
      GraphemeBreakTree._INSTANCE = new GraphemeBreakTree();
    }

    return GraphemeBreakTree._INSTANCE;
  }

  constructor() {
    this._data = getGraphemeBreakRawData();
  }

  getGraphemeBreakType(codePoint) {
    // !!! Let's make 7bit ASCII a bit faster: 0..31
    if (codePoint < 32) {
      if (codePoint === _charCode__WEBPACK_IMPORTED_MODULE_1__.CharCode.LineFeed) {
        return GraphemeBreakType.LF;
      }

      if (codePoint === _charCode__WEBPACK_IMPORTED_MODULE_1__.CharCode.CarriageReturn) {
        return GraphemeBreakType.CR;
      }

      return GraphemeBreakType.Control;
    } // !!! Let's make 7bit ASCII a bit faster: 32..126


    if (codePoint < 127) {
      return GraphemeBreakType.Other;
    }

    const data = this._data;
    const nodeCount = data.length / 3;
    let nodeIndex = 1;

    while (nodeIndex <= nodeCount) {
      if (codePoint < data[3 * nodeIndex]) {
        // go left
        nodeIndex = 2 * nodeIndex;
      } else if (codePoint > data[3 * nodeIndex + 1]) {
        // go right
        nodeIndex = 2 * nodeIndex + 1;
      } else {
        // hit
        return data[3 * nodeIndex + 2];
      }
    }

    return GraphemeBreakType.Other;
  }

}

function getGraphemeBreakRawData() {
  // generated using https://github.com/alexdima/unicode-utils/blob/main/grapheme-break.js
  return JSON.parse('[0,0,0,51229,51255,12,44061,44087,12,127462,127487,6,7083,7085,5,47645,47671,12,54813,54839,12,128678,128678,14,3270,3270,5,9919,9923,14,45853,45879,12,49437,49463,12,53021,53047,12,71216,71218,7,128398,128399,14,129360,129374,14,2519,2519,5,4448,4519,9,9742,9742,14,12336,12336,14,44957,44983,12,46749,46775,12,48541,48567,12,50333,50359,12,52125,52151,12,53917,53943,12,69888,69890,5,73018,73018,5,127990,127990,14,128558,128559,14,128759,128760,14,129653,129655,14,2027,2035,5,2891,2892,7,3761,3761,5,6683,6683,5,8293,8293,4,9825,9826,14,9999,9999,14,43452,43453,5,44509,44535,12,45405,45431,12,46301,46327,12,47197,47223,12,48093,48119,12,48989,49015,12,49885,49911,12,50781,50807,12,51677,51703,12,52573,52599,12,53469,53495,12,54365,54391,12,65279,65279,4,70471,70472,7,72145,72147,7,119173,119179,5,127799,127818,14,128240,128244,14,128512,128512,14,128652,128652,14,128721,128722,14,129292,129292,14,129445,129450,14,129734,129743,14,1476,1477,5,2366,2368,7,2750,2752,7,3076,3076,5,3415,3415,5,4141,4144,5,6109,6109,5,6964,6964,5,7394,7400,5,9197,9198,14,9770,9770,14,9877,9877,14,9968,9969,14,10084,10084,14,43052,43052,5,43713,43713,5,44285,44311,12,44733,44759,12,45181,45207,12,45629,45655,12,46077,46103,12,46525,46551,12,46973,46999,12,47421,47447,12,47869,47895,12,48317,48343,12,48765,48791,12,49213,49239,12,49661,49687,12,50109,50135,12,50557,50583,12,51005,51031,12,51453,51479,12,51901,51927,12,52349,52375,12,52797,52823,12,53245,53271,12,53693,53719,12,54141,54167,12,54589,54615,12,55037,55063,12,69506,69509,5,70191,70193,5,70841,70841,7,71463,71467,5,72330,72342,5,94031,94031,5,123628,123631,5,127763,127765,14,127941,127941,14,128043,128062,14,128302,128317,14,128465,128467,14,128539,128539,14,128640,128640,14,128662,128662,14,128703,128703,14,128745,128745,14,129004,129007,14,129329,129330,14,129402,129402,14,129483,129483,14,129686,129704,14,130048,131069,14,173,173,4,1757,1757,1,2200,2207,5,2434,2435,7,2631,2632,5,2817,2817,5,3008,3008,5,3201,3201,5,3387,3388,5,3542,3542,5,3902,3903,7,4190,4192,5,6002,6003,5,6439,6440,5,6765,6770,7,7019,7027,5,7154,7155,7,8205,8205,13,8505,8505,14,9654,9654,14,9757,9757,14,9792,9792,14,9852,9853,14,9890,9894,14,9937,9937,14,9981,9981,14,10035,10036,14,11035,11036,14,42654,42655,5,43346,43347,7,43587,43587,5,44006,44007,7,44173,44199,12,44397,44423,12,44621,44647,12,44845,44871,12,45069,45095,12,45293,45319,12,45517,45543,12,45741,45767,12,45965,45991,12,46189,46215,12,46413,46439,12,46637,46663,12,46861,46887,12,47085,47111,12,47309,47335,12,47533,47559,12,47757,47783,12,47981,48007,12,48205,48231,12,48429,48455,12,48653,48679,12,48877,48903,12,49101,49127,12,49325,49351,12,49549,49575,12,49773,49799,12,49997,50023,12,50221,50247,12,50445,50471,12,50669,50695,12,50893,50919,12,51117,51143,12,51341,51367,12,51565,51591,12,51789,51815,12,52013,52039,12,52237,52263,12,52461,52487,12,52685,52711,12,52909,52935,12,53133,53159,12,53357,53383,12,53581,53607,12,53805,53831,12,54029,54055,12,54253,54279,12,54477,54503,12,54701,54727,12,54925,54951,12,55149,55175,12,68101,68102,5,69762,69762,7,70067,70069,7,70371,70378,5,70720,70721,7,71087,71087,5,71341,71341,5,71995,71996,5,72249,72249,7,72850,72871,5,73109,73109,5,118576,118598,5,121505,121519,5,127245,127247,14,127568,127569,14,127777,127777,14,127872,127891,14,127956,127967,14,128015,128016,14,128110,128172,14,128259,128259,14,128367,128368,14,128424,128424,14,128488,128488,14,128530,128532,14,128550,128551,14,128566,128566,14,128647,128647,14,128656,128656,14,128667,128673,14,128691,128693,14,128715,128715,14,128728,128732,14,128752,128752,14,128765,128767,14,129096,129103,14,129311,129311,14,129344,129349,14,129394,129394,14,129413,129425,14,129466,129471,14,129511,129535,14,129664,129666,14,129719,129722,14,129760,129767,14,917536,917631,5,13,13,2,1160,1161,5,1564,1564,4,1807,1807,1,2085,2087,5,2307,2307,7,2382,2383,7,2497,2500,5,2563,2563,7,2677,2677,5,2763,2764,7,2879,2879,5,2914,2915,5,3021,3021,5,3142,3144,5,3263,3263,5,3285,3286,5,3398,3400,7,3530,3530,5,3633,3633,5,3864,3865,5,3974,3975,5,4155,4156,7,4229,4230,5,5909,5909,7,6078,6085,7,6277,6278,5,6451,6456,7,6744,6750,5,6846,6846,5,6972,6972,5,7074,7077,5,7146,7148,7,7222,7223,5,7416,7417,5,8234,8238,4,8417,8417,5,9000,9000,14,9203,9203,14,9730,9731,14,9748,9749,14,9762,9763,14,9776,9783,14,9800,9811,14,9831,9831,14,9872,9873,14,9882,9882,14,9900,9903,14,9929,9933,14,9941,9960,14,9974,9974,14,9989,9989,14,10006,10006,14,10062,10062,14,10160,10160,14,11647,11647,5,12953,12953,14,43019,43019,5,43232,43249,5,43443,43443,5,43567,43568,7,43696,43696,5,43765,43765,7,44013,44013,5,44117,44143,12,44229,44255,12,44341,44367,12,44453,44479,12,44565,44591,12,44677,44703,12,44789,44815,12,44901,44927,12,45013,45039,12,45125,45151,12,45237,45263,12,45349,45375,12,45461,45487,12,45573,45599,12,45685,45711,12,45797,45823,12,45909,45935,12,46021,46047,12,46133,46159,12,46245,46271,12,46357,46383,12,46469,46495,12,46581,46607,12,46693,46719,12,46805,46831,12,46917,46943,12,47029,47055,12,47141,47167,12,47253,47279,12,47365,47391,12,47477,47503,12,47589,47615,12,47701,47727,12,47813,47839,12,47925,47951,12,48037,48063,12,48149,48175,12,48261,48287,12,48373,48399,12,48485,48511,12,48597,48623,12,48709,48735,12,48821,48847,12,48933,48959,12,49045,49071,12,49157,49183,12,49269,49295,12,49381,49407,12,49493,49519,12,49605,49631,12,49717,49743,12,49829,49855,12,49941,49967,12,50053,50079,12,50165,50191,12,50277,50303,12,50389,50415,12,50501,50527,12,50613,50639,12,50725,50751,12,50837,50863,12,50949,50975,12,51061,51087,12,51173,51199,12,51285,51311,12,51397,51423,12,51509,51535,12,51621,51647,12,51733,51759,12,51845,51871,12,51957,51983,12,52069,52095,12,52181,52207,12,52293,52319,12,52405,52431,12,52517,52543,12,52629,52655,12,52741,52767,12,52853,52879,12,52965,52991,12,53077,53103,12,53189,53215,12,53301,53327,12,53413,53439,12,53525,53551,12,53637,53663,12,53749,53775,12,53861,53887,12,53973,53999,12,54085,54111,12,54197,54223,12,54309,54335,12,54421,54447,12,54533,54559,12,54645,54671,12,54757,54783,12,54869,54895,12,54981,55007,12,55093,55119,12,55243,55291,10,66045,66045,5,68325,68326,5,69688,69702,5,69817,69818,5,69957,69958,7,70089,70092,5,70198,70199,5,70462,70462,5,70502,70508,5,70750,70750,5,70846,70846,7,71100,71101,5,71230,71230,7,71351,71351,5,71737,71738,5,72000,72000,7,72160,72160,5,72273,72278,5,72752,72758,5,72882,72883,5,73031,73031,5,73461,73462,7,94192,94193,7,119149,119149,7,121403,121452,5,122915,122916,5,126980,126980,14,127358,127359,14,127535,127535,14,127759,127759,14,127771,127771,14,127792,127793,14,127825,127867,14,127897,127899,14,127945,127945,14,127985,127986,14,128000,128007,14,128021,128021,14,128066,128100,14,128184,128235,14,128249,128252,14,128266,128276,14,128335,128335,14,128379,128390,14,128407,128419,14,128444,128444,14,128481,128481,14,128499,128499,14,128526,128526,14,128536,128536,14,128543,128543,14,128556,128556,14,128564,128564,14,128577,128580,14,128643,128645,14,128649,128649,14,128654,128654,14,128660,128660,14,128664,128664,14,128675,128675,14,128686,128689,14,128695,128696,14,128705,128709,14,128717,128719,14,128725,128725,14,128736,128741,14,128747,128748,14,128755,128755,14,128762,128762,14,128981,128991,14,129009,129023,14,129160,129167,14,129296,129304,14,129320,129327,14,129340,129342,14,129356,129356,14,129388,129392,14,129399,129400,14,129404,129407,14,129432,129442,14,129454,129455,14,129473,129474,14,129485,129487,14,129648,129651,14,129659,129660,14,129671,129679,14,129709,129711,14,129728,129730,14,129751,129753,14,129776,129782,14,917505,917505,4,917760,917999,5,10,10,3,127,159,4,768,879,5,1471,1471,5,1536,1541,1,1648,1648,5,1767,1768,5,1840,1866,5,2070,2073,5,2137,2139,5,2274,2274,1,2363,2363,7,2377,2380,7,2402,2403,5,2494,2494,5,2507,2508,7,2558,2558,5,2622,2624,7,2641,2641,5,2691,2691,7,2759,2760,5,2786,2787,5,2876,2876,5,2881,2884,5,2901,2902,5,3006,3006,5,3014,3016,7,3072,3072,5,3134,3136,5,3157,3158,5,3260,3260,5,3266,3266,5,3274,3275,7,3328,3329,5,3391,3392,7,3405,3405,5,3457,3457,5,3536,3537,7,3551,3551,5,3636,3642,5,3764,3772,5,3895,3895,5,3967,3967,7,3993,4028,5,4146,4151,5,4182,4183,7,4226,4226,5,4253,4253,5,4957,4959,5,5940,5940,7,6070,6070,7,6087,6088,7,6158,6158,4,6432,6434,5,6448,6449,7,6679,6680,5,6742,6742,5,6754,6754,5,6783,6783,5,6912,6915,5,6966,6970,5,6978,6978,5,7042,7042,7,7080,7081,5,7143,7143,7,7150,7150,7,7212,7219,5,7380,7392,5,7412,7412,5,8203,8203,4,8232,8232,4,8265,8265,14,8400,8412,5,8421,8432,5,8617,8618,14,9167,9167,14,9200,9200,14,9410,9410,14,9723,9726,14,9733,9733,14,9745,9745,14,9752,9752,14,9760,9760,14,9766,9766,14,9774,9774,14,9786,9786,14,9794,9794,14,9823,9823,14,9828,9828,14,9833,9850,14,9855,9855,14,9875,9875,14,9880,9880,14,9885,9887,14,9896,9897,14,9906,9916,14,9926,9927,14,9935,9935,14,9939,9939,14,9962,9962,14,9972,9972,14,9978,9978,14,9986,9986,14,9997,9997,14,10002,10002,14,10017,10017,14,10055,10055,14,10071,10071,14,10133,10135,14,10548,10549,14,11093,11093,14,12330,12333,5,12441,12442,5,42608,42610,5,43010,43010,5,43045,43046,5,43188,43203,7,43302,43309,5,43392,43394,5,43446,43449,5,43493,43493,5,43571,43572,7,43597,43597,7,43703,43704,5,43756,43757,5,44003,44004,7,44009,44010,7,44033,44059,12,44089,44115,12,44145,44171,12,44201,44227,12,44257,44283,12,44313,44339,12,44369,44395,12,44425,44451,12,44481,44507,12,44537,44563,12,44593,44619,12,44649,44675,12,44705,44731,12,44761,44787,12,44817,44843,12,44873,44899,12,44929,44955,12,44985,45011,12,45041,45067,12,45097,45123,12,45153,45179,12,45209,45235,12,45265,45291,12,45321,45347,12,45377,45403,12,45433,45459,12,45489,45515,12,45545,45571,12,45601,45627,12,45657,45683,12,45713,45739,12,45769,45795,12,45825,45851,12,45881,45907,12,45937,45963,12,45993,46019,12,46049,46075,12,46105,46131,12,46161,46187,12,46217,46243,12,46273,46299,12,46329,46355,12,46385,46411,12,46441,46467,12,46497,46523,12,46553,46579,12,46609,46635,12,46665,46691,12,46721,46747,12,46777,46803,12,46833,46859,12,46889,46915,12,46945,46971,12,47001,47027,12,47057,47083,12,47113,47139,12,47169,47195,12,47225,47251,12,47281,47307,12,47337,47363,12,47393,47419,12,47449,47475,12,47505,47531,12,47561,47587,12,47617,47643,12,47673,47699,12,47729,47755,12,47785,47811,12,47841,47867,12,47897,47923,12,47953,47979,12,48009,48035,12,48065,48091,12,48121,48147,12,48177,48203,12,48233,48259,12,48289,48315,12,48345,48371,12,48401,48427,12,48457,48483,12,48513,48539,12,48569,48595,12,48625,48651,12,48681,48707,12,48737,48763,12,48793,48819,12,48849,48875,12,48905,48931,12,48961,48987,12,49017,49043,12,49073,49099,12,49129,49155,12,49185,49211,12,49241,49267,12,49297,49323,12,49353,49379,12,49409,49435,12,49465,49491,12,49521,49547,12,49577,49603,12,49633,49659,12,49689,49715,12,49745,49771,12,49801,49827,12,49857,49883,12,49913,49939,12,49969,49995,12,50025,50051,12,50081,50107,12,50137,50163,12,50193,50219,12,50249,50275,12,50305,50331,12,50361,50387,12,50417,50443,12,50473,50499,12,50529,50555,12,50585,50611,12,50641,50667,12,50697,50723,12,50753,50779,12,50809,50835,12,50865,50891,12,50921,50947,12,50977,51003,12,51033,51059,12,51089,51115,12,51145,51171,12,51201,51227,12,51257,51283,12,51313,51339,12,51369,51395,12,51425,51451,12,51481,51507,12,51537,51563,12,51593,51619,12,51649,51675,12,51705,51731,12,51761,51787,12,51817,51843,12,51873,51899,12,51929,51955,12,51985,52011,12,52041,52067,12,52097,52123,12,52153,52179,12,52209,52235,12,52265,52291,12,52321,52347,12,52377,52403,12,52433,52459,12,52489,52515,12,52545,52571,12,52601,52627,12,52657,52683,12,52713,52739,12,52769,52795,12,52825,52851,12,52881,52907,12,52937,52963,12,52993,53019,12,53049,53075,12,53105,53131,12,53161,53187,12,53217,53243,12,53273,53299,12,53329,53355,12,53385,53411,12,53441,53467,12,53497,53523,12,53553,53579,12,53609,53635,12,53665,53691,12,53721,53747,12,53777,53803,12,53833,53859,12,53889,53915,12,53945,53971,12,54001,54027,12,54057,54083,12,54113,54139,12,54169,54195,12,54225,54251,12,54281,54307,12,54337,54363,12,54393,54419,12,54449,54475,12,54505,54531,12,54561,54587,12,54617,54643,12,54673,54699,12,54729,54755,12,54785,54811,12,54841,54867,12,54897,54923,12,54953,54979,12,55009,55035,12,55065,55091,12,55121,55147,12,55177,55203,12,65024,65039,5,65520,65528,4,66422,66426,5,68152,68154,5,69291,69292,5,69633,69633,5,69747,69748,5,69811,69814,5,69826,69826,5,69932,69932,7,70016,70017,5,70079,70080,7,70095,70095,5,70196,70196,5,70367,70367,5,70402,70403,7,70464,70464,5,70487,70487,5,70709,70711,7,70725,70725,7,70833,70834,7,70843,70844,7,70849,70849,7,71090,71093,5,71103,71104,5,71227,71228,7,71339,71339,5,71344,71349,5,71458,71461,5,71727,71735,5,71985,71989,7,71998,71998,5,72002,72002,7,72154,72155,5,72193,72202,5,72251,72254,5,72281,72283,5,72344,72345,5,72766,72766,7,72874,72880,5,72885,72886,5,73023,73029,5,73104,73105,5,73111,73111,5,92912,92916,5,94095,94098,5,113824,113827,4,119142,119142,7,119155,119162,4,119362,119364,5,121476,121476,5,122888,122904,5,123184,123190,5,125252,125258,5,127183,127183,14,127340,127343,14,127377,127386,14,127491,127503,14,127548,127551,14,127744,127756,14,127761,127761,14,127769,127769,14,127773,127774,14,127780,127788,14,127796,127797,14,127820,127823,14,127869,127869,14,127894,127895,14,127902,127903,14,127943,127943,14,127947,127950,14,127972,127972,14,127988,127988,14,127992,127994,14,128009,128011,14,128019,128019,14,128023,128041,14,128064,128064,14,128102,128107,14,128174,128181,14,128238,128238,14,128246,128247,14,128254,128254,14,128264,128264,14,128278,128299,14,128329,128330,14,128348,128359,14,128371,128377,14,128392,128393,14,128401,128404,14,128421,128421,14,128433,128434,14,128450,128452,14,128476,128478,14,128483,128483,14,128495,128495,14,128506,128506,14,128519,128520,14,128528,128528,14,128534,128534,14,128538,128538,14,128540,128542,14,128544,128549,14,128552,128555,14,128557,128557,14,128560,128563,14,128565,128565,14,128567,128576,14,128581,128591,14,128641,128642,14,128646,128646,14,128648,128648,14,128650,128651,14,128653,128653,14,128655,128655,14,128657,128659,14,128661,128661,14,128663,128663,14,128665,128666,14,128674,128674,14,128676,128677,14,128679,128685,14,128690,128690,14,128694,128694,14,128697,128702,14,128704,128704,14,128710,128714,14,128716,128716,14,128720,128720,14,128723,128724,14,128726,128727,14,128733,128735,14,128742,128744,14,128746,128746,14,128749,128751,14,128753,128754,14,128756,128758,14,128761,128761,14,128763,128764,14,128884,128895,14,128992,129003,14,129008,129008,14,129036,129039,14,129114,129119,14,129198,129279,14,129293,129295,14,129305,129310,14,129312,129319,14,129328,129328,14,129331,129338,14,129343,129343,14,129351,129355,14,129357,129359,14,129375,129387,14,129393,129393,14,129395,129398,14,129401,129401,14,129403,129403,14,129408,129412,14,129426,129431,14,129443,129444,14,129451,129453,14,129456,129465,14,129472,129472,14,129475,129482,14,129484,129484,14,129488,129510,14,129536,129647,14,129652,129652,14,129656,129658,14,129661,129663,14,129667,129670,14,129680,129685,14,129705,129708,14,129712,129718,14,129723,129727,14,129731,129733,14,129744,129750,14,129754,129759,14,129768,129775,14,129783,129791,14,917504,917504,4,917506,917535,4,917632,917759,4,918000,921599,4,0,9,4,11,12,4,14,31,4,169,169,14,174,174,14,1155,1159,5,1425,1469,5,1473,1474,5,1479,1479,5,1552,1562,5,1611,1631,5,1750,1756,5,1759,1764,5,1770,1773,5,1809,1809,5,1958,1968,5,2045,2045,5,2075,2083,5,2089,2093,5,2192,2193,1,2250,2273,5,2275,2306,5,2362,2362,5,2364,2364,5,2369,2376,5,2381,2381,5,2385,2391,5,2433,2433,5,2492,2492,5,2495,2496,7,2503,2504,7,2509,2509,5,2530,2531,5,2561,2562,5,2620,2620,5,2625,2626,5,2635,2637,5,2672,2673,5,2689,2690,5,2748,2748,5,2753,2757,5,2761,2761,7,2765,2765,5,2810,2815,5,2818,2819,7,2878,2878,5,2880,2880,7,2887,2888,7,2893,2893,5,2903,2903,5,2946,2946,5,3007,3007,7,3009,3010,7,3018,3020,7,3031,3031,5,3073,3075,7,3132,3132,5,3137,3140,7,3146,3149,5,3170,3171,5,3202,3203,7,3262,3262,7,3264,3265,7,3267,3268,7,3271,3272,7,3276,3277,5,3298,3299,5,3330,3331,7,3390,3390,5,3393,3396,5,3402,3404,7,3406,3406,1,3426,3427,5,3458,3459,7,3535,3535,5,3538,3540,5,3544,3550,7,3570,3571,7,3635,3635,7,3655,3662,5,3763,3763,7,3784,3789,5,3893,3893,5,3897,3897,5,3953,3966,5,3968,3972,5,3981,3991,5,4038,4038,5,4145,4145,7,4153,4154,5,4157,4158,5,4184,4185,5,4209,4212,5,4228,4228,7,4237,4237,5,4352,4447,8,4520,4607,10,5906,5908,5,5938,5939,5,5970,5971,5,6068,6069,5,6071,6077,5,6086,6086,5,6089,6099,5,6155,6157,5,6159,6159,5,6313,6313,5,6435,6438,7,6441,6443,7,6450,6450,5,6457,6459,5,6681,6682,7,6741,6741,7,6743,6743,7,6752,6752,5,6757,6764,5,6771,6780,5,6832,6845,5,6847,6862,5,6916,6916,7,6965,6965,5,6971,6971,7,6973,6977,7,6979,6980,7,7040,7041,5,7073,7073,7,7078,7079,7,7082,7082,7,7142,7142,5,7144,7145,5,7149,7149,5,7151,7153,5,7204,7211,7,7220,7221,7,7376,7378,5,7393,7393,7,7405,7405,5,7415,7415,7,7616,7679,5,8204,8204,5,8206,8207,4,8233,8233,4,8252,8252,14,8288,8292,4,8294,8303,4,8413,8416,5,8418,8420,5,8482,8482,14,8596,8601,14,8986,8987,14,9096,9096,14,9193,9196,14,9199,9199,14,9201,9202,14,9208,9210,14,9642,9643,14,9664,9664,14,9728,9729,14,9732,9732,14,9735,9741,14,9743,9744,14,9746,9746,14,9750,9751,14,9753,9756,14,9758,9759,14,9761,9761,14,9764,9765,14,9767,9769,14,9771,9773,14,9775,9775,14,9784,9785,14,9787,9791,14,9793,9793,14,9795,9799,14,9812,9822,14,9824,9824,14,9827,9827,14,9829,9830,14,9832,9832,14,9851,9851,14,9854,9854,14,9856,9861,14,9874,9874,14,9876,9876,14,9878,9879,14,9881,9881,14,9883,9884,14,9888,9889,14,9895,9895,14,9898,9899,14,9904,9905,14,9917,9918,14,9924,9925,14,9928,9928,14,9934,9934,14,9936,9936,14,9938,9938,14,9940,9940,14,9961,9961,14,9963,9967,14,9970,9971,14,9973,9973,14,9975,9977,14,9979,9980,14,9982,9985,14,9987,9988,14,9992,9996,14,9998,9998,14,10000,10001,14,10004,10004,14,10013,10013,14,10024,10024,14,10052,10052,14,10060,10060,14,10067,10069,14,10083,10083,14,10085,10087,14,10145,10145,14,10175,10175,14,11013,11015,14,11088,11088,14,11503,11505,5,11744,11775,5,12334,12335,5,12349,12349,14,12951,12951,14,42607,42607,5,42612,42621,5,42736,42737,5,43014,43014,5,43043,43044,7,43047,43047,7,43136,43137,7,43204,43205,5,43263,43263,5,43335,43345,5,43360,43388,8,43395,43395,7,43444,43445,7,43450,43451,7,43454,43456,7,43561,43566,5,43569,43570,5,43573,43574,5,43596,43596,5,43644,43644,5,43698,43700,5,43710,43711,5,43755,43755,7,43758,43759,7,43766,43766,5,44005,44005,5,44008,44008,5,44012,44012,7,44032,44032,11,44060,44060,11,44088,44088,11,44116,44116,11,44144,44144,11,44172,44172,11,44200,44200,11,44228,44228,11,44256,44256,11,44284,44284,11,44312,44312,11,44340,44340,11,44368,44368,11,44396,44396,11,44424,44424,11,44452,44452,11,44480,44480,11,44508,44508,11,44536,44536,11,44564,44564,11,44592,44592,11,44620,44620,11,44648,44648,11,44676,44676,11,44704,44704,11,44732,44732,11,44760,44760,11,44788,44788,11,44816,44816,11,44844,44844,11,44872,44872,11,44900,44900,11,44928,44928,11,44956,44956,11,44984,44984,11,45012,45012,11,45040,45040,11,45068,45068,11,45096,45096,11,45124,45124,11,45152,45152,11,45180,45180,11,45208,45208,11,45236,45236,11,45264,45264,11,45292,45292,11,45320,45320,11,45348,45348,11,45376,45376,11,45404,45404,11,45432,45432,11,45460,45460,11,45488,45488,11,45516,45516,11,45544,45544,11,45572,45572,11,45600,45600,11,45628,45628,11,45656,45656,11,45684,45684,11,45712,45712,11,45740,45740,11,45768,45768,11,45796,45796,11,45824,45824,11,45852,45852,11,45880,45880,11,45908,45908,11,45936,45936,11,45964,45964,11,45992,45992,11,46020,46020,11,46048,46048,11,46076,46076,11,46104,46104,11,46132,46132,11,46160,46160,11,46188,46188,11,46216,46216,11,46244,46244,11,46272,46272,11,46300,46300,11,46328,46328,11,46356,46356,11,46384,46384,11,46412,46412,11,46440,46440,11,46468,46468,11,46496,46496,11,46524,46524,11,46552,46552,11,46580,46580,11,46608,46608,11,46636,46636,11,46664,46664,11,46692,46692,11,46720,46720,11,46748,46748,11,46776,46776,11,46804,46804,11,46832,46832,11,46860,46860,11,46888,46888,11,46916,46916,11,46944,46944,11,46972,46972,11,47000,47000,11,47028,47028,11,47056,47056,11,47084,47084,11,47112,47112,11,47140,47140,11,47168,47168,11,47196,47196,11,47224,47224,11,47252,47252,11,47280,47280,11,47308,47308,11,47336,47336,11,47364,47364,11,47392,47392,11,47420,47420,11,47448,47448,11,47476,47476,11,47504,47504,11,47532,47532,11,47560,47560,11,47588,47588,11,47616,47616,11,47644,47644,11,47672,47672,11,47700,47700,11,47728,47728,11,47756,47756,11,47784,47784,11,47812,47812,11,47840,47840,11,47868,47868,11,47896,47896,11,47924,47924,11,47952,47952,11,47980,47980,11,48008,48008,11,48036,48036,11,48064,48064,11,48092,48092,11,48120,48120,11,48148,48148,11,48176,48176,11,48204,48204,11,48232,48232,11,48260,48260,11,48288,48288,11,48316,48316,11,48344,48344,11,48372,48372,11,48400,48400,11,48428,48428,11,48456,48456,11,48484,48484,11,48512,48512,11,48540,48540,11,48568,48568,11,48596,48596,11,48624,48624,11,48652,48652,11,48680,48680,11,48708,48708,11,48736,48736,11,48764,48764,11,48792,48792,11,48820,48820,11,48848,48848,11,48876,48876,11,48904,48904,11,48932,48932,11,48960,48960,11,48988,48988,11,49016,49016,11,49044,49044,11,49072,49072,11,49100,49100,11,49128,49128,11,49156,49156,11,49184,49184,11,49212,49212,11,49240,49240,11,49268,49268,11,49296,49296,11,49324,49324,11,49352,49352,11,49380,49380,11,49408,49408,11,49436,49436,11,49464,49464,11,49492,49492,11,49520,49520,11,49548,49548,11,49576,49576,11,49604,49604,11,49632,49632,11,49660,49660,11,49688,49688,11,49716,49716,11,49744,49744,11,49772,49772,11,49800,49800,11,49828,49828,11,49856,49856,11,49884,49884,11,49912,49912,11,49940,49940,11,49968,49968,11,49996,49996,11,50024,50024,11,50052,50052,11,50080,50080,11,50108,50108,11,50136,50136,11,50164,50164,11,50192,50192,11,50220,50220,11,50248,50248,11,50276,50276,11,50304,50304,11,50332,50332,11,50360,50360,11,50388,50388,11,50416,50416,11,50444,50444,11,50472,50472,11,50500,50500,11,50528,50528,11,50556,50556,11,50584,50584,11,50612,50612,11,50640,50640,11,50668,50668,11,50696,50696,11,50724,50724,11,50752,50752,11,50780,50780,11,50808,50808,11,50836,50836,11,50864,50864,11,50892,50892,11,50920,50920,11,50948,50948,11,50976,50976,11,51004,51004,11,51032,51032,11,51060,51060,11,51088,51088,11,51116,51116,11,51144,51144,11,51172,51172,11,51200,51200,11,51228,51228,11,51256,51256,11,51284,51284,11,51312,51312,11,51340,51340,11,51368,51368,11,51396,51396,11,51424,51424,11,51452,51452,11,51480,51480,11,51508,51508,11,51536,51536,11,51564,51564,11,51592,51592,11,51620,51620,11,51648,51648,11,51676,51676,11,51704,51704,11,51732,51732,11,51760,51760,11,51788,51788,11,51816,51816,11,51844,51844,11,51872,51872,11,51900,51900,11,51928,51928,11,51956,51956,11,51984,51984,11,52012,52012,11,52040,52040,11,52068,52068,11,52096,52096,11,52124,52124,11,52152,52152,11,52180,52180,11,52208,52208,11,52236,52236,11,52264,52264,11,52292,52292,11,52320,52320,11,52348,52348,11,52376,52376,11,52404,52404,11,52432,52432,11,52460,52460,11,52488,52488,11,52516,52516,11,52544,52544,11,52572,52572,11,52600,52600,11,52628,52628,11,52656,52656,11,52684,52684,11,52712,52712,11,52740,52740,11,52768,52768,11,52796,52796,11,52824,52824,11,52852,52852,11,52880,52880,11,52908,52908,11,52936,52936,11,52964,52964,11,52992,52992,11,53020,53020,11,53048,53048,11,53076,53076,11,53104,53104,11,53132,53132,11,53160,53160,11,53188,53188,11,53216,53216,11,53244,53244,11,53272,53272,11,53300,53300,11,53328,53328,11,53356,53356,11,53384,53384,11,53412,53412,11,53440,53440,11,53468,53468,11,53496,53496,11,53524,53524,11,53552,53552,11,53580,53580,11,53608,53608,11,53636,53636,11,53664,53664,11,53692,53692,11,53720,53720,11,53748,53748,11,53776,53776,11,53804,53804,11,53832,53832,11,53860,53860,11,53888,53888,11,53916,53916,11,53944,53944,11,53972,53972,11,54000,54000,11,54028,54028,11,54056,54056,11,54084,54084,11,54112,54112,11,54140,54140,11,54168,54168,11,54196,54196,11,54224,54224,11,54252,54252,11,54280,54280,11,54308,54308,11,54336,54336,11,54364,54364,11,54392,54392,11,54420,54420,11,54448,54448,11,54476,54476,11,54504,54504,11,54532,54532,11,54560,54560,11,54588,54588,11,54616,54616,11,54644,54644,11,54672,54672,11,54700,54700,11,54728,54728,11,54756,54756,11,54784,54784,11,54812,54812,11,54840,54840,11,54868,54868,11,54896,54896,11,54924,54924,11,54952,54952,11,54980,54980,11,55008,55008,11,55036,55036,11,55064,55064,11,55092,55092,11,55120,55120,11,55148,55148,11,55176,55176,11,55216,55238,9,64286,64286,5,65056,65071,5,65438,65439,5,65529,65531,4,66272,66272,5,68097,68099,5,68108,68111,5,68159,68159,5,68900,68903,5,69446,69456,5,69632,69632,7,69634,69634,7,69744,69744,5,69759,69761,5,69808,69810,7,69815,69816,7,69821,69821,1,69837,69837,1,69927,69931,5,69933,69940,5,70003,70003,5,70018,70018,7,70070,70078,5,70082,70083,1,70094,70094,7,70188,70190,7,70194,70195,7,70197,70197,7,70206,70206,5,70368,70370,7,70400,70401,5,70459,70460,5,70463,70463,7,70465,70468,7,70475,70477,7,70498,70499,7,70512,70516,5,70712,70719,5,70722,70724,5,70726,70726,5,70832,70832,5,70835,70840,5,70842,70842,5,70845,70845,5,70847,70848,5,70850,70851,5,71088,71089,7,71096,71099,7,71102,71102,7,71132,71133,5,71219,71226,5,71229,71229,5,71231,71232,5,71340,71340,7,71342,71343,7,71350,71350,7,71453,71455,5,71462,71462,7,71724,71726,7,71736,71736,7,71984,71984,5,71991,71992,7,71997,71997,7,71999,71999,1,72001,72001,1,72003,72003,5,72148,72151,5,72156,72159,7,72164,72164,7,72243,72248,5,72250,72250,1,72263,72263,5,72279,72280,7,72324,72329,1,72343,72343,7,72751,72751,7,72760,72765,5,72767,72767,5,72873,72873,7,72881,72881,7,72884,72884,7,73009,73014,5,73020,73021,5,73030,73030,1,73098,73102,7,73107,73108,7,73110,73110,7,73459,73460,5,78896,78904,4,92976,92982,5,94033,94087,7,94180,94180,5,113821,113822,5,118528,118573,5,119141,119141,5,119143,119145,5,119150,119154,5,119163,119170,5,119210,119213,5,121344,121398,5,121461,121461,5,121499,121503,5,122880,122886,5,122907,122913,5,122918,122922,5,123566,123566,5,125136,125142,5,126976,126979,14,126981,127182,14,127184,127231,14,127279,127279,14,127344,127345,14,127374,127374,14,127405,127461,14,127489,127490,14,127514,127514,14,127538,127546,14,127561,127567,14,127570,127743,14,127757,127758,14,127760,127760,14,127762,127762,14,127766,127768,14,127770,127770,14,127772,127772,14,127775,127776,14,127778,127779,14,127789,127791,14,127794,127795,14,127798,127798,14,127819,127819,14,127824,127824,14,127868,127868,14,127870,127871,14,127892,127893,14,127896,127896,14,127900,127901,14,127904,127940,14,127942,127942,14,127944,127944,14,127946,127946,14,127951,127955,14,127968,127971,14,127973,127984,14,127987,127987,14,127989,127989,14,127991,127991,14,127995,127999,5,128008,128008,14,128012,128014,14,128017,128018,14,128020,128020,14,128022,128022,14,128042,128042,14,128063,128063,14,128065,128065,14,128101,128101,14,128108,128109,14,128173,128173,14,128182,128183,14,128236,128237,14,128239,128239,14,128245,128245,14,128248,128248,14,128253,128253,14,128255,128258,14,128260,128263,14,128265,128265,14,128277,128277,14,128300,128301,14,128326,128328,14,128331,128334,14,128336,128347,14,128360,128366,14,128369,128370,14,128378,128378,14,128391,128391,14,128394,128397,14,128400,128400,14,128405,128406,14,128420,128420,14,128422,128423,14,128425,128432,14,128435,128443,14,128445,128449,14,128453,128464,14,128468,128475,14,128479,128480,14,128482,128482,14,128484,128487,14,128489,128494,14,128496,128498,14,128500,128505,14,128507,128511,14,128513,128518,14,128521,128525,14,128527,128527,14,128529,128529,14,128533,128533,14,128535,128535,14,128537,128537,14]');
} //#endregion

/**
 * Computes the offset after performing a left delete on the given string,
 * while considering unicode grapheme/emoji rules.
*/


function getLeftDeleteOffset(offset, str) {
  if (offset === 0) {
    return 0;
  } // Try to delete emoji part.


  const emojiOffset = getOffsetBeforeLastEmojiComponent(offset, str);

  if (emojiOffset !== undefined) {
    return emojiOffset;
  } // Otherwise, just skip a single code point.


  const iterator = new CodePointIterator(str, offset);
  iterator.prevCodePoint();
  return iterator.offset;
}

function getOffsetBeforeLastEmojiComponent(initialOffset, str) {
  // See https://www.unicode.org/reports/tr51/tr51-14.html#EBNF_and_Regex for the
  // structure of emojis.
  const iterator = new CodePointIterator(str, initialOffset);
  let codePoint = iterator.prevCodePoint(); // Skip modifiers

  while (isEmojiModifier(codePoint) || codePoint === CodePoint.emojiVariantSelector || codePoint === CodePoint.enclosingKeyCap) {
    if (iterator.offset === 0) {
      // Cannot skip modifier, no preceding emoji base.
      return undefined;
    }

    codePoint = iterator.prevCodePoint();
  } // Expect base emoji


  if (!isEmojiImprecise(codePoint)) {
    // Unexpected code point, not a valid emoji.
    return undefined;
  }

  let resultOffset = iterator.offset;

  if (resultOffset > 0) {
    // Skip optional ZWJ code points that combine multiple emojis.
    // In theory, we should check if that ZWJ actually combines multiple emojis
    // to prevent deleting ZWJs in situations we didn't account for.
    const optionalZwjCodePoint = iterator.prevCodePoint();

    if (optionalZwjCodePoint === CodePoint.zwj) {
      resultOffset = iterator.offset;
    }
  }

  return resultOffset;
}

function isEmojiModifier(codePoint) {
  return 0x1F3FB <= codePoint && codePoint <= 0x1F3FF;
}

var CodePoint;

(function (CodePoint) {
  CodePoint[CodePoint["zwj"] = 8205] = "zwj";
  CodePoint[CodePoint["emojiVariantSelector"] = 65039] = "emojiVariantSelector";
  CodePoint[CodePoint["enclosingKeyCap"] = 8419] = "enclosingKeyCap";
})(CodePoint || (CodePoint = {}));

const noBreakWhitespace = '\xa0';
class AmbiguousCharacters {
  static ambiguousCharacterData = new _lazy__WEBPACK_IMPORTED_MODULE_2__.Lazy(() => {
    // Generated using https://github.com/hediet/vscode-unicode-data
    // Stored as key1, value1, key2, value2, ...
    return JSON.parse('{\"_common\":[8232,32,8233,32,5760,32,8192,32,8193,32,8194,32,8195,32,8196,32,8197,32,8198,32,8200,32,8201,32,8202,32,8287,32,8199,32,8239,32,2042,95,65101,95,65102,95,65103,95,8208,45,8209,45,8210,45,65112,45,1748,45,8259,45,727,45,8722,45,10134,45,11450,45,1549,44,1643,44,8218,44,184,44,42233,44,894,59,2307,58,2691,58,1417,58,1795,58,1796,58,5868,58,65072,58,6147,58,6153,58,8282,58,1475,58,760,58,42889,58,8758,58,720,58,42237,58,451,33,11601,33,660,63,577,63,2429,63,5038,63,42731,63,119149,46,8228,46,1793,46,1794,46,42510,46,68176,46,1632,46,1776,46,42232,46,1373,96,65287,96,8219,96,8242,96,1370,96,1523,96,8175,96,65344,96,900,96,8189,96,8125,96,8127,96,8190,96,697,96,884,96,712,96,714,96,715,96,756,96,699,96,701,96,700,96,702,96,42892,96,1497,96,2036,96,2037,96,5194,96,5836,96,94033,96,94034,96,65339,91,10088,40,10098,40,12308,40,64830,40,65341,93,10089,41,10099,41,12309,41,64831,41,10100,123,119060,123,10101,125,65342,94,8270,42,1645,42,8727,42,66335,42,5941,47,8257,47,8725,47,8260,47,9585,47,10187,47,10744,47,119354,47,12755,47,12339,47,11462,47,20031,47,12035,47,65340,92,65128,92,8726,92,10189,92,10741,92,10745,92,119311,92,119355,92,12756,92,20022,92,12034,92,42872,38,708,94,710,94,5869,43,10133,43,66203,43,8249,60,10094,60,706,60,119350,60,5176,60,5810,60,5120,61,11840,61,12448,61,42239,61,8250,62,10095,62,707,62,119351,62,5171,62,94015,62,8275,126,732,126,8128,126,8764,126,65372,124,65293,45,120784,50,120794,50,120804,50,120814,50,120824,50,130034,50,42842,50,423,50,1000,50,42564,50,5311,50,42735,50,119302,51,120785,51,120795,51,120805,51,120815,51,120825,51,130035,51,42923,51,540,51,439,51,42858,51,11468,51,1248,51,94011,51,71882,51,120786,52,120796,52,120806,52,120816,52,120826,52,130036,52,5070,52,71855,52,120787,53,120797,53,120807,53,120817,53,120827,53,130037,53,444,53,71867,53,120788,54,120798,54,120808,54,120818,54,120828,54,130038,54,11474,54,5102,54,71893,54,119314,55,120789,55,120799,55,120809,55,120819,55,120829,55,130039,55,66770,55,71878,55,2819,56,2538,56,2666,56,125131,56,120790,56,120800,56,120810,56,120820,56,120830,56,130040,56,547,56,546,56,66330,56,2663,57,2920,57,2541,57,3437,57,120791,57,120801,57,120811,57,120821,57,120831,57,130041,57,42862,57,11466,57,71884,57,71852,57,71894,57,9082,97,65345,97,119834,97,119886,97,119938,97,119990,97,120042,97,120094,97,120146,97,120198,97,120250,97,120302,97,120354,97,120406,97,120458,97,593,97,945,97,120514,97,120572,97,120630,97,120688,97,120746,97,65313,65,119808,65,119860,65,119912,65,119964,65,120016,65,120068,65,120120,65,120172,65,120224,65,120276,65,120328,65,120380,65,120432,65,913,65,120488,65,120546,65,120604,65,120662,65,120720,65,5034,65,5573,65,42222,65,94016,65,66208,65,119835,98,119887,98,119939,98,119991,98,120043,98,120095,98,120147,98,120199,98,120251,98,120303,98,120355,98,120407,98,120459,98,388,98,5071,98,5234,98,5551,98,65314,66,8492,66,119809,66,119861,66,119913,66,120017,66,120069,66,120121,66,120173,66,120225,66,120277,66,120329,66,120381,66,120433,66,42932,66,914,66,120489,66,120547,66,120605,66,120663,66,120721,66,5108,66,5623,66,42192,66,66178,66,66209,66,66305,66,65347,99,8573,99,119836,99,119888,99,119940,99,119992,99,120044,99,120096,99,120148,99,120200,99,120252,99,120304,99,120356,99,120408,99,120460,99,7428,99,1010,99,11429,99,43951,99,66621,99,128844,67,71922,67,71913,67,65315,67,8557,67,8450,67,8493,67,119810,67,119862,67,119914,67,119966,67,120018,67,120174,67,120226,67,120278,67,120330,67,120382,67,120434,67,1017,67,11428,67,5087,67,42202,67,66210,67,66306,67,66581,67,66844,67,8574,100,8518,100,119837,100,119889,100,119941,100,119993,100,120045,100,120097,100,120149,100,120201,100,120253,100,120305,100,120357,100,120409,100,120461,100,1281,100,5095,100,5231,100,42194,100,8558,68,8517,68,119811,68,119863,68,119915,68,119967,68,120019,68,120071,68,120123,68,120175,68,120227,68,120279,68,120331,68,120383,68,120435,68,5024,68,5598,68,5610,68,42195,68,8494,101,65349,101,8495,101,8519,101,119838,101,119890,101,119942,101,120046,101,120098,101,120150,101,120202,101,120254,101,120306,101,120358,101,120410,101,120462,101,43826,101,1213,101,8959,69,65317,69,8496,69,119812,69,119864,69,119916,69,120020,69,120072,69,120124,69,120176,69,120228,69,120280,69,120332,69,120384,69,120436,69,917,69,120492,69,120550,69,120608,69,120666,69,120724,69,11577,69,5036,69,42224,69,71846,69,71854,69,66182,69,119839,102,119891,102,119943,102,119995,102,120047,102,120099,102,120151,102,120203,102,120255,102,120307,102,120359,102,120411,102,120463,102,43829,102,42905,102,383,102,7837,102,1412,102,119315,70,8497,70,119813,70,119865,70,119917,70,120021,70,120073,70,120125,70,120177,70,120229,70,120281,70,120333,70,120385,70,120437,70,42904,70,988,70,120778,70,5556,70,42205,70,71874,70,71842,70,66183,70,66213,70,66853,70,65351,103,8458,103,119840,103,119892,103,119944,103,120048,103,120100,103,120152,103,120204,103,120256,103,120308,103,120360,103,120412,103,120464,103,609,103,7555,103,397,103,1409,103,119814,71,119866,71,119918,71,119970,71,120022,71,120074,71,120126,71,120178,71,120230,71,120282,71,120334,71,120386,71,120438,71,1292,71,5056,71,5107,71,42198,71,65352,104,8462,104,119841,104,119945,104,119997,104,120049,104,120101,104,120153,104,120205,104,120257,104,120309,104,120361,104,120413,104,120465,104,1211,104,1392,104,5058,104,65320,72,8459,72,8460,72,8461,72,119815,72,119867,72,119919,72,120023,72,120179,72,120231,72,120283,72,120335,72,120387,72,120439,72,919,72,120494,72,120552,72,120610,72,120668,72,120726,72,11406,72,5051,72,5500,72,42215,72,66255,72,731,105,9075,105,65353,105,8560,105,8505,105,8520,105,119842,105,119894,105,119946,105,119998,105,120050,105,120102,105,120154,105,120206,105,120258,105,120310,105,120362,105,120414,105,120466,105,120484,105,618,105,617,105,953,105,8126,105,890,105,120522,105,120580,105,120638,105,120696,105,120754,105,1110,105,42567,105,1231,105,43893,105,5029,105,71875,105,65354,106,8521,106,119843,106,119895,106,119947,106,119999,106,120051,106,120103,106,120155,106,120207,106,120259,106,120311,106,120363,106,120415,106,120467,106,1011,106,1112,106,65322,74,119817,74,119869,74,119921,74,119973,74,120025,74,120077,74,120129,74,120181,74,120233,74,120285,74,120337,74,120389,74,120441,74,42930,74,895,74,1032,74,5035,74,5261,74,42201,74,119844,107,119896,107,119948,107,120000,107,120052,107,120104,107,120156,107,120208,107,120260,107,120312,107,120364,107,120416,107,120468,107,8490,75,65323,75,119818,75,119870,75,119922,75,119974,75,120026,75,120078,75,120130,75,120182,75,120234,75,120286,75,120338,75,120390,75,120442,75,922,75,120497,75,120555,75,120613,75,120671,75,120729,75,11412,75,5094,75,5845,75,42199,75,66840,75,1472,108,8739,73,9213,73,65512,73,1633,108,1777,73,66336,108,125127,108,120783,73,120793,73,120803,73,120813,73,120823,73,130033,73,65321,73,8544,73,8464,73,8465,73,119816,73,119868,73,119920,73,120024,73,120128,73,120180,73,120232,73,120284,73,120336,73,120388,73,120440,73,65356,108,8572,73,8467,108,119845,108,119897,108,119949,108,120001,108,120053,108,120105,73,120157,73,120209,73,120261,73,120313,73,120365,73,120417,73,120469,73,448,73,120496,73,120554,73,120612,73,120670,73,120728,73,11410,73,1030,73,1216,73,1493,108,1503,108,1575,108,126464,108,126592,108,65166,108,65165,108,1994,108,11599,73,5825,73,42226,73,93992,73,66186,124,66313,124,119338,76,8556,76,8466,76,119819,76,119871,76,119923,76,120027,76,120079,76,120131,76,120183,76,120235,76,120287,76,120339,76,120391,76,120443,76,11472,76,5086,76,5290,76,42209,76,93974,76,71843,76,71858,76,66587,76,66854,76,65325,77,8559,77,8499,77,119820,77,119872,77,119924,77,120028,77,120080,77,120132,77,120184,77,120236,77,120288,77,120340,77,120392,77,120444,77,924,77,120499,77,120557,77,120615,77,120673,77,120731,77,1018,77,11416,77,5047,77,5616,77,5846,77,42207,77,66224,77,66321,77,119847,110,119899,110,119951,110,120003,110,120055,110,120107,110,120159,110,120211,110,120263,110,120315,110,120367,110,120419,110,120471,110,1400,110,1404,110,65326,78,8469,78,119821,78,119873,78,119925,78,119977,78,120029,78,120081,78,120185,78,120237,78,120289,78,120341,78,120393,78,120445,78,925,78,120500,78,120558,78,120616,78,120674,78,120732,78,11418,78,42208,78,66835,78,3074,111,3202,111,3330,111,3458,111,2406,111,2662,111,2790,111,3046,111,3174,111,3302,111,3430,111,3664,111,3792,111,4160,111,1637,111,1781,111,65359,111,8500,111,119848,111,119900,111,119952,111,120056,111,120108,111,120160,111,120212,111,120264,111,120316,111,120368,111,120420,111,120472,111,7439,111,7441,111,43837,111,959,111,120528,111,120586,111,120644,111,120702,111,120760,111,963,111,120532,111,120590,111,120648,111,120706,111,120764,111,11423,111,4351,111,1413,111,1505,111,1607,111,126500,111,126564,111,126596,111,65259,111,65260,111,65258,111,65257,111,1726,111,64428,111,64429,111,64427,111,64426,111,1729,111,64424,111,64425,111,64423,111,64422,111,1749,111,3360,111,4125,111,66794,111,71880,111,71895,111,66604,111,1984,79,2534,79,2918,79,12295,79,70864,79,71904,79,120782,79,120792,79,120802,79,120812,79,120822,79,130032,79,65327,79,119822,79,119874,79,119926,79,119978,79,120030,79,120082,79,120134,79,120186,79,120238,79,120290,79,120342,79,120394,79,120446,79,927,79,120502,79,120560,79,120618,79,120676,79,120734,79,11422,79,1365,79,11604,79,4816,79,2848,79,66754,79,42227,79,71861,79,66194,79,66219,79,66564,79,66838,79,9076,112,65360,112,119849,112,119901,112,119953,112,120005,112,120057,112,120109,112,120161,112,120213,112,120265,112,120317,112,120369,112,120421,112,120473,112,961,112,120530,112,120544,112,120588,112,120602,112,120646,112,120660,112,120704,112,120718,112,120762,112,120776,112,11427,112,65328,80,8473,80,119823,80,119875,80,119927,80,119979,80,120031,80,120083,80,120187,80,120239,80,120291,80,120343,80,120395,80,120447,80,929,80,120504,80,120562,80,120620,80,120678,80,120736,80,11426,80,5090,80,5229,80,42193,80,66197,80,119850,113,119902,113,119954,113,120006,113,120058,113,120110,113,120162,113,120214,113,120266,113,120318,113,120370,113,120422,113,120474,113,1307,113,1379,113,1382,113,8474,81,119824,81,119876,81,119928,81,119980,81,120032,81,120084,81,120188,81,120240,81,120292,81,120344,81,120396,81,120448,81,11605,81,119851,114,119903,114,119955,114,120007,114,120059,114,120111,114,120163,114,120215,114,120267,114,120319,114,120371,114,120423,114,120475,114,43847,114,43848,114,7462,114,11397,114,43905,114,119318,82,8475,82,8476,82,8477,82,119825,82,119877,82,119929,82,120033,82,120189,82,120241,82,120293,82,120345,82,120397,82,120449,82,422,82,5025,82,5074,82,66740,82,5511,82,42211,82,94005,82,65363,115,119852,115,119904,115,119956,115,120008,115,120060,115,120112,115,120164,115,120216,115,120268,115,120320,115,120372,115,120424,115,120476,115,42801,115,445,115,1109,115,43946,115,71873,115,66632,115,65331,83,119826,83,119878,83,119930,83,119982,83,120034,83,120086,83,120138,83,120190,83,120242,83,120294,83,120346,83,120398,83,120450,83,1029,83,1359,83,5077,83,5082,83,42210,83,94010,83,66198,83,66592,83,119853,116,119905,116,119957,116,120009,116,120061,116,120113,116,120165,116,120217,116,120269,116,120321,116,120373,116,120425,116,120477,116,8868,84,10201,84,128872,84,65332,84,119827,84,119879,84,119931,84,119983,84,120035,84,120087,84,120139,84,120191,84,120243,84,120295,84,120347,84,120399,84,120451,84,932,84,120507,84,120565,84,120623,84,120681,84,120739,84,11430,84,5026,84,42196,84,93962,84,71868,84,66199,84,66225,84,66325,84,119854,117,119906,117,119958,117,120010,117,120062,117,120114,117,120166,117,120218,117,120270,117,120322,117,120374,117,120426,117,120478,117,42911,117,7452,117,43854,117,43858,117,651,117,965,117,120534,117,120592,117,120650,117,120708,117,120766,117,1405,117,66806,117,71896,117,8746,85,8899,85,119828,85,119880,85,119932,85,119984,85,120036,85,120088,85,120140,85,120192,85,120244,85,120296,85,120348,85,120400,85,120452,85,1357,85,4608,85,66766,85,5196,85,42228,85,94018,85,71864,85,8744,118,8897,118,65366,118,8564,118,119855,118,119907,118,119959,118,120011,118,120063,118,120115,118,120167,118,120219,118,120271,118,120323,118,120375,118,120427,118,120479,118,7456,118,957,118,120526,118,120584,118,120642,118,120700,118,120758,118,1141,118,1496,118,71430,118,43945,118,71872,118,119309,86,1639,86,1783,86,8548,86,119829,86,119881,86,119933,86,119985,86,120037,86,120089,86,120141,86,120193,86,120245,86,120297,86,120349,86,120401,86,120453,86,1140,86,11576,86,5081,86,5167,86,42719,86,42214,86,93960,86,71840,86,66845,86,623,119,119856,119,119908,119,119960,119,120012,119,120064,119,120116,119,120168,119,120220,119,120272,119,120324,119,120376,119,120428,119,120480,119,7457,119,1121,119,1309,119,1377,119,71434,119,71438,119,71439,119,43907,119,71919,87,71910,87,119830,87,119882,87,119934,87,119986,87,120038,87,120090,87,120142,87,120194,87,120246,87,120298,87,120350,87,120402,87,120454,87,1308,87,5043,87,5076,87,42218,87,5742,120,10539,120,10540,120,10799,120,65368,120,8569,120,119857,120,119909,120,119961,120,120013,120,120065,120,120117,120,120169,120,120221,120,120273,120,120325,120,120377,120,120429,120,120481,120,5441,120,5501,120,5741,88,9587,88,66338,88,71916,88,65336,88,8553,88,119831,88,119883,88,119935,88,119987,88,120039,88,120091,88,120143,88,120195,88,120247,88,120299,88,120351,88,120403,88,120455,88,42931,88,935,88,120510,88,120568,88,120626,88,120684,88,120742,88,11436,88,11613,88,5815,88,42219,88,66192,88,66228,88,66327,88,66855,88,611,121,7564,121,65369,121,119858,121,119910,121,119962,121,120014,121,120066,121,120118,121,120170,121,120222,121,120274,121,120326,121,120378,121,120430,121,120482,121,655,121,7935,121,43866,121,947,121,8509,121,120516,121,120574,121,120632,121,120690,121,120748,121,1199,121,4327,121,71900,121,65337,89,119832,89,119884,89,119936,89,119988,89,120040,89,120092,89,120144,89,120196,89,120248,89,120300,89,120352,89,120404,89,120456,89,933,89,978,89,120508,89,120566,89,120624,89,120682,89,120740,89,11432,89,1198,89,5033,89,5053,89,42220,89,94019,89,71844,89,66226,89,119859,122,119911,122,119963,122,120015,122,120067,122,120119,122,120171,122,120223,122,120275,122,120327,122,120379,122,120431,122,120483,122,7458,122,43923,122,71876,122,66293,90,71909,90,65338,90,8484,90,8488,90,119833,90,119885,90,119937,90,119989,90,120041,90,120197,90,120249,90,120301,90,120353,90,120405,90,120457,90,918,90,120493,90,120551,90,120609,90,120667,90,120725,90,5059,90,42204,90,71849,90,65282,34,65284,36,65285,37,65286,38,65290,42,65291,43,65294,46,65295,47,65296,48,65297,49,65298,50,65299,51,65300,52,65301,53,65302,54,65303,55,65304,56,65305,57,65308,60,65309,61,65310,62,65312,64,65316,68,65318,70,65319,71,65324,76,65329,81,65330,82,65333,85,65334,86,65335,87,65343,95,65346,98,65348,100,65350,102,65355,107,65357,109,65358,110,65361,113,65362,114,65364,116,65365,117,65367,119,65370,122,65371,123,65373,125],\"_default\":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"cs\":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"de\":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"es\":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"fr\":[65374,126,65306,58,65281,33,8216,96,8245,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"it\":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"ja\":[8211,45,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65292,44,65307,59],\"ko\":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"pl\":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"pt-BR\":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"qps-ploc\":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"ru\":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,305,105,921,73,1009,112,215,120,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"tr\":[160,32,8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"zh-hans\":[65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41],\"zh-hant\":[8211,45,65374,126,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65307,59]}');
  });
  static cache = new _cache__WEBPACK_IMPORTED_MODULE_0__.LRUCachedFunction(locales => {
    function arrayToMap(arr) {
      const result = new Map();

      for (let i = 0; i < arr.length; i += 2) {
        result.set(arr[i], arr[i + 1]);
      }

      return result;
    }

    function mergeMaps(map1, map2) {
      const result = new Map(map1);

      for (const [key, value] of map2) {
        result.set(key, value);
      }

      return result;
    }

    function intersectMaps(map1, map2) {
      if (!map1) {
        return map2;
      }

      const result = new Map();

      for (const [key, value] of map1) {
        if (map2.has(key)) {
          result.set(key, value);
        }
      }

      return result;
    }

    const data = this.ambiguousCharacterData.getValue();
    let filteredLocales = locales.filter(l => !l.startsWith('_') && l in data);

    if (filteredLocales.length === 0) {
      filteredLocales = ['_default'];
    }

    let languageSpecificMap = undefined;

    for (const locale of filteredLocales) {
      const map = arrayToMap(data[locale]);
      languageSpecificMap = intersectMaps(languageSpecificMap, map);
    }

    const commonMap = arrayToMap(data['_common']);
    const map = mergeMaps(commonMap, languageSpecificMap);
    return new AmbiguousCharacters(map);
  });

  static getInstance(locales) {
    return AmbiguousCharacters.cache.get(Array.from(locales));
  }

  static _locales = new _lazy__WEBPACK_IMPORTED_MODULE_2__.Lazy(() => Object.keys(AmbiguousCharacters.ambiguousCharacterData.getValue()).filter(k => !k.startsWith('_')));

  static getLocales() {
    return AmbiguousCharacters._locales.getValue();
  }

  constructor(confusableDictionary) {
    this.confusableDictionary = confusableDictionary;
  }

  isAmbiguous(codePoint) {
    return this.confusableDictionary.has(codePoint);
  }
  /**
   * Returns the non basic ASCII code point that the given code point can be confused,
   * or undefined if such code point does note exist.
   */


  getPrimaryConfusable(codePoint) {
    return this.confusableDictionary.get(codePoint);
  }

  getConfusableCodePoints() {
    return new Set(this.confusableDictionary.keys());
  }

}
class InvisibleCharacters {
  static getRawData() {
    // Generated using https://github.com/hediet/vscode-unicode-data
    return JSON.parse('[9,10,11,12,13,32,127,160,173,847,1564,4447,4448,6068,6069,6155,6156,6157,6158,7355,7356,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8203,8204,8205,8206,8207,8234,8235,8236,8237,8238,8239,8287,8288,8289,8290,8291,8292,8293,8294,8295,8296,8297,8298,8299,8300,8301,8302,8303,10240,12288,12644,65024,65025,65026,65027,65028,65029,65030,65031,65032,65033,65034,65035,65036,65037,65038,65039,65279,65440,65520,65521,65522,65523,65524,65525,65526,65527,65528,65532,78844,119155,119156,119157,119158,119159,119160,119161,119162,917504,917505,917506,917507,917508,917509,917510,917511,917512,917513,917514,917515,917516,917517,917518,917519,917520,917521,917522,917523,917524,917525,917526,917527,917528,917529,917530,917531,917532,917533,917534,917535,917536,917537,917538,917539,917540,917541,917542,917543,917544,917545,917546,917547,917548,917549,917550,917551,917552,917553,917554,917555,917556,917557,917558,917559,917560,917561,917562,917563,917564,917565,917566,917567,917568,917569,917570,917571,917572,917573,917574,917575,917576,917577,917578,917579,917580,917581,917582,917583,917584,917585,917586,917587,917588,917589,917590,917591,917592,917593,917594,917595,917596,917597,917598,917599,917600,917601,917602,917603,917604,917605,917606,917607,917608,917609,917610,917611,917612,917613,917614,917615,917616,917617,917618,917619,917620,917621,917622,917623,917624,917625,917626,917627,917628,917629,917630,917631,917760,917761,917762,917763,917764,917765,917766,917767,917768,917769,917770,917771,917772,917773,917774,917775,917776,917777,917778,917779,917780,917781,917782,917783,917784,917785,917786,917787,917788,917789,917790,917791,917792,917793,917794,917795,917796,917797,917798,917799,917800,917801,917802,917803,917804,917805,917806,917807,917808,917809,917810,917811,917812,917813,917814,917815,917816,917817,917818,917819,917820,917821,917822,917823,917824,917825,917826,917827,917828,917829,917830,917831,917832,917833,917834,917835,917836,917837,917838,917839,917840,917841,917842,917843,917844,917845,917846,917847,917848,917849,917850,917851,917852,917853,917854,917855,917856,917857,917858,917859,917860,917861,917862,917863,917864,917865,917866,917867,917868,917869,917870,917871,917872,917873,917874,917875,917876,917877,917878,917879,917880,917881,917882,917883,917884,917885,917886,917887,917888,917889,917890,917891,917892,917893,917894,917895,917896,917897,917898,917899,917900,917901,917902,917903,917904,917905,917906,917907,917908,917909,917910,917911,917912,917913,917914,917915,917916,917917,917918,917919,917920,917921,917922,917923,917924,917925,917926,917927,917928,917929,917930,917931,917932,917933,917934,917935,917936,917937,917938,917939,917940,917941,917942,917943,917944,917945,917946,917947,917948,917949,917950,917951,917952,917953,917954,917955,917956,917957,917958,917959,917960,917961,917962,917963,917964,917965,917966,917967,917968,917969,917970,917971,917972,917973,917974,917975,917976,917977,917978,917979,917980,917981,917982,917983,917984,917985,917986,917987,917988,917989,917990,917991,917992,917993,917994,917995,917996,917997,917998,917999]');
  }

  static _data = undefined;

  static getData() {
    if (!this._data) {
      this._data = new Set(InvisibleCharacters.getRawData());
    }

    return this._data;
  }

  static isInvisibleCharacter(codePoint) {
    return InvisibleCharacters.getData().has(codePoint);
  }

  static get codePoints() {
    return InvisibleCharacters.getData();
  }

}

/***/ }),
/* 76 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Cache": () => (/* binding */ Cache),
/* harmony export */   "LRUCachedFunction": () => (/* binding */ LRUCachedFunction),
/* harmony export */   "CachedFunction": () => (/* binding */ CachedFunction)
/* harmony export */ });
/* harmony import */ var _cancellation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(69);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

class Cache {
  result = null;

  constructor(task) {
    this.task = task;
  }

  get() {
    if (this.result) {
      return this.result;
    }

    const cts = new _cancellation__WEBPACK_IMPORTED_MODULE_0__.CancellationTokenSource();
    const promise = this.task(cts.token);
    this.result = {
      promise,
      dispose: () => {
        this.result = null;
        cts.cancel();
        cts.dispose();
      }
    };
    return this.result;
  }

}
/**
 * Uses a LRU cache to make a given parametrized function cached.
 * Caches just the last value.
 * The key must be JSON serializable.
*/

class LRUCachedFunction {
  lastCache = undefined;
  lastArgKey = undefined;

  constructor(fn) {
    this.fn = fn;
  }

  get(arg) {
    const key = JSON.stringify(arg);

    if (this.lastArgKey !== key) {
      this.lastArgKey = key;
      this.lastCache = this.fn(arg);
    }

    return this.lastCache;
  }

}
/**
 * Uses an unbounded cache (referential equality) to memoize the results of the given function.
*/

class CachedFunction {
  _map = new Map();

  get cachedValues() {
    return this._map;
  }

  constructor(fn) {
    this.fn = fn;
  }

  get(arg) {
    if (this._map.has(arg)) {
      return this._map.get(arg);
    }

    const value = this.fn(arg);

    this._map.set(arg, value);

    return value;
  }

}

/***/ }),
/* 77 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Lazy": () => (/* binding */ Lazy)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

/**
 * A value that is resolved synchronously when it is first needed.
 */
class Lazy {
  _didRun = false;

  constructor(executor) {
    this.executor = executor;
  }
  /**
   * True if the lazy value has been resolved.
   */


  hasValue() {
    return this._didRun;
  }
  /**
   * Get the wrapped value.
   *
   * This will force evaluation of the lazy value if it has not been resolved yet. Lazy values are only
   * resolved once. `getValue` will re-throw exceptions that are hit while resolving the value
   */


  getValue() {
    if (!this._didRun) {
      try {
        this._value = this.executor();
      } catch (err) {
        this._error = err;
      } finally {
        this._didRun = true;
      }
    }

    if (this._error) {
      throw this._error;
    }

    return this._value;
  }
  /**
   * Get the wrapped value without forcing evaluation.
   */


  get rawValue() {
    return this._value;
  }
  /**
   * Create a new lazy value that is the result of applying `f` to the wrapped value.
   *
   * This does not force the evaluation of the current lazy value.
   */


  map(f) {
    return new Lazy(() => f(this.getValue()));
  }

}

/***/ }),
/* 78 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Constants": () => (/* binding */ Constants),
/* harmony export */   "toUint8": () => (/* binding */ toUint8),
/* harmony export */   "toUint32": () => (/* binding */ toUint32)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
let Constants;

(function (Constants) {
  Constants[Constants["MAX_SAFE_SMALL_INTEGER"] = 1073741824] = "MAX_SAFE_SMALL_INTEGER";
  Constants[Constants["MIN_SAFE_SMALL_INTEGER"] = -1073741824] = "MIN_SAFE_SMALL_INTEGER";
  Constants[Constants["MAX_UINT_8"] = 255] = "MAX_UINT_8";
  Constants[Constants["MAX_UINT_16"] = 65535] = "MAX_UINT_16";
  Constants[Constants["MAX_UINT_32"] = 4294967295] = "MAX_UINT_32";
  Constants[Constants["UNICODE_SUPPLEMENTARY_PLANE_BEGIN"] = 65536] = "UNICODE_SUPPLEMENTARY_PLANE_BEGIN";
})(Constants || (Constants = {}));

function toUint8(v) {
  if (v < 0) {
    return 0;
  }

  if (v > Constants.MAX_UINT_8) {
    return Constants.MAX_UINT_8;
  }

  return v | 0;
}
function toUint32(v) {
  if (v < 0) {
    return 0;
  }

  if (v > Constants.MAX_UINT_32) {
    return Constants.MAX_UINT_32;
  }

  return v | 0;
}

/***/ }),
/* 79 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isString": () => (/* binding */ isString),
/* harmony export */   "isStringArray": () => (/* binding */ isStringArray),
/* harmony export */   "isObject": () => (/* binding */ isObject),
/* harmony export */   "isTypedArray": () => (/* binding */ isTypedArray),
/* harmony export */   "isNumber": () => (/* binding */ isNumber),
/* harmony export */   "isIterable": () => (/* binding */ isIterable),
/* harmony export */   "isBoolean": () => (/* binding */ isBoolean),
/* harmony export */   "isUndefined": () => (/* binding */ isUndefined),
/* harmony export */   "isDefined": () => (/* binding */ isDefined),
/* harmony export */   "isUndefinedOrNull": () => (/* binding */ isUndefinedOrNull),
/* harmony export */   "assertType": () => (/* binding */ assertType),
/* harmony export */   "assertIsDefined": () => (/* binding */ assertIsDefined),
/* harmony export */   "assertAllDefined": () => (/* binding */ assertAllDefined),
/* harmony export */   "isEmptyObject": () => (/* binding */ isEmptyObject),
/* harmony export */   "isFunction": () => (/* binding */ isFunction),
/* harmony export */   "areFunctions": () => (/* binding */ areFunctions),
/* harmony export */   "validateConstraints": () => (/* binding */ validateConstraints),
/* harmony export */   "validateConstraint": () => (/* binding */ validateConstraint),
/* harmony export */   "withNullAsUndefined": () => (/* binding */ withNullAsUndefined),
/* harmony export */   "withUndefinedAsNull": () => (/* binding */ withUndefinedAsNull)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

/**
 * @returns whether the provided parameter is a JavaScript String or not.
 */
function isString(str) {
  return typeof str === 'string';
}
/**
 * @returns whether the provided parameter is a JavaScript Array and each element in the array is a string.
 */

function isStringArray(value) {
  return Array.isArray(value) && value.every(elem => isString(elem));
}
/**
 * @returns whether the provided parameter is of type `object` but **not**
 *	`null`, an `array`, a `regexp`, nor a `date`.
 */

function isObject(obj) {
  // The method can't do a type cast since there are type (like strings) which
  // are subclasses of any put not positvely matched by the function. Hence type
  // narrowing results in wrong results.
  return typeof obj === 'object' && obj !== null && !Array.isArray(obj) && !(obj instanceof RegExp) && !(obj instanceof Date);
}
/**
 * @returns whether the provided parameter is of type `Buffer` or Uint8Array dervived type
 */

function isTypedArray(obj) {
  const TypedArray = Object.getPrototypeOf(Uint8Array);
  return typeof obj === 'object' && obj instanceof TypedArray;
}
/**
 * In **contrast** to just checking `typeof` this will return `false` for `NaN`.
 * @returns whether the provided parameter is a JavaScript Number or not.
 */

function isNumber(obj) {
  return typeof obj === 'number' && !isNaN(obj);
}
/**
 * @returns whether the provided parameter is an Iterable, casting to the given generic
 */

function isIterable(obj) {
  return !!obj && typeof obj[Symbol.iterator] === 'function';
}
/**
 * @returns whether the provided parameter is a JavaScript Boolean or not.
 */

function isBoolean(obj) {
  return obj === true || obj === false;
}
/**
 * @returns whether the provided parameter is undefined.
 */

function isUndefined(obj) {
  return typeof obj === 'undefined';
}
/**
 * @returns whether the provided parameter is defined.
 */

function isDefined(arg) {
  return !isUndefinedOrNull(arg);
}
/**
 * @returns whether the provided parameter is undefined or null.
 */

function isUndefinedOrNull(obj) {
  return isUndefined(obj) || obj === null;
}
function assertType(condition, type) {
  if (!condition) {
    throw new Error(type ? `Unexpected type, expected '${type}'` : 'Unexpected type');
  }
}
/**
 * Asserts that the argument passed in is neither undefined nor null.
 */

function assertIsDefined(arg) {
  if (isUndefinedOrNull(arg)) {
    throw new Error('Assertion Failed: argument is undefined or null');
  }

  return arg;
}
/**
 * Asserts that each argument passed in is neither undefined nor null.
 */

function assertAllDefined(...args) {
  const result = [];

  for (let i = 0; i < args.length; i++) {
    const arg = args[i];

    if (isUndefinedOrNull(arg)) {
      throw new Error(`Assertion Failed: argument at index ${i} is undefined or null`);
    }

    result.push(arg);
  }

  return result;
}
const hasOwnProperty = Object.prototype.hasOwnProperty;
/**
 * @returns whether the provided parameter is an empty JavaScript Object or not.
 */

function isEmptyObject(obj) {
  if (!isObject(obj)) {
    return false;
  }

  for (const key in obj) {
    if (hasOwnProperty.call(obj, key)) {
      return false;
    }
  }

  return true;
}
/**
 * @returns whether the provided parameter is a JavaScript Function or not.
 */

function isFunction(obj) {
  return typeof obj === 'function';
}
/**
 * @returns whether the provided parameters is are JavaScript Function or not.
 */

function areFunctions(...objects) {
  return objects.length > 0 && objects.every(isFunction);
}
function validateConstraints(args, constraints) {
  const len = Math.min(args.length, constraints.length);

  for (let i = 0; i < len; i++) {
    validateConstraint(args[i], constraints[i]);
  }
}
function validateConstraint(arg, constraint) {
  if (isString(constraint)) {
    if (typeof arg !== constraint) {
      throw new Error(`argument does not match constraint: typeof ${constraint}`);
    }
  } else if (isFunction(constraint)) {
    try {
      if (arg instanceof constraint) {
        return;
      }
    } catch {// ignore
    }

    if (!isUndefinedOrNull(arg) && arg.constructor === constraint) {
      return;
    }

    if (constraint.length === 1 && constraint.call(undefined, arg) === true) {
      return;
    }

    throw new Error(`argument does not match one of these constraints: arg instanceof constraint, arg.constructor === constraint, nor constraint(arg) === true`);
  }
}
/**
 * Converts null to undefined, passes all other values through.
 */

function withNullAsUndefined(x) {
  return x === null ? undefined : x;
}
/**
 * Converts undefined to null, passes all other values through.
 */

function withUndefinedAsNull(x) {
  return typeof x === 'undefined' ? null : x;
}

/***/ }),
/* 80 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Schemas": () => (/* binding */ Schemas),
/* harmony export */   "connectionTokenCookieName": () => (/* binding */ connectionTokenCookieName),
/* harmony export */   "connectionTokenQueryName": () => (/* binding */ connectionTokenQueryName),
/* harmony export */   "RemoteAuthorities": () => (/* binding */ RemoteAuthorities),
/* harmony export */   "FileAccess": () => (/* binding */ FileAccess),
/* harmony export */   "COI": () => (/* binding */ COI)
/* harmony export */ });
/* harmony import */ var _platform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(58);
/* harmony import */ var _uri__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(81);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


let Schemas;

(function (_Schemas) {
  const inMemory = _Schemas.inMemory = 'inmemory';
  const vscode = _Schemas.vscode = 'vscode';
  const internal = _Schemas.internal = 'private';
  const walkThrough = _Schemas.walkThrough = 'walkThrough';
  const walkThroughSnippet = _Schemas.walkThroughSnippet = 'walkThroughSnippet';
  const http = _Schemas.http = 'http';
  const https = _Schemas.https = 'https';
  const file = _Schemas.file = 'file';
  const mailto = _Schemas.mailto = 'mailto';
  const untitled = _Schemas.untitled = 'untitled';
  const data = _Schemas.data = 'data';
  const command = _Schemas.command = 'command';
  const vscodeRemote = _Schemas.vscodeRemote = 'vscode-remote';
  const vscodeRemoteResource = _Schemas.vscodeRemoteResource = 'vscode-remote-resource';
  const vscodeUserData = _Schemas.vscodeUserData = 'vscode-userdata';
  const vscodeCustomEditor = _Schemas.vscodeCustomEditor = 'vscode-custom-editor';
  const vscodeNotebook = _Schemas.vscodeNotebook = 'vscode-notebook';
  const vscodeNotebookCell = _Schemas.vscodeNotebookCell = 'vscode-notebook-cell';
  const vscodeNotebookCellMetadata = _Schemas.vscodeNotebookCellMetadata = 'vscode-notebook-cell-metadata';
  const vscodeNotebookCellOutput = _Schemas.vscodeNotebookCellOutput = 'vscode-notebook-cell-output';
  const vscodeInteractive = _Schemas.vscodeInteractive = 'vscode-interactive';
  const vscodeInteractiveInput = _Schemas.vscodeInteractiveInput = 'vscode-interactive-input';
  const vscodeSettings = _Schemas.vscodeSettings = 'vscode-settings';
  const vscodeWorkspaceTrust = _Schemas.vscodeWorkspaceTrust = 'vscode-workspace-trust';
  const vscodeTerminal = _Schemas.vscodeTerminal = 'vscode-terminal';
  const webviewPanel = _Schemas.webviewPanel = 'webview-panel';
  const vscodeWebview = _Schemas.vscodeWebview = 'vscode-webview';
  const extension = _Schemas.extension = 'extension';
  const vscodeFileResource = _Schemas.vscodeFileResource = 'vscode-file';
  const tmp = _Schemas.tmp = 'tmp';
  const vsls = _Schemas.vsls = 'vsls';
  const vscodeSourceControl = _Schemas.vscodeSourceControl = 'vscode-scm';
})(Schemas || (Schemas = {}));

const connectionTokenCookieName = 'vscode-tkn';
const connectionTokenQueryName = 'tkn';

class RemoteAuthoritiesImpl {
  _hosts = Object.create(null);
  _ports = Object.create(null);
  _connectionTokens = Object.create(null);
  _preferredWebSchema = 'http';
  _delegate = null;
  _remoteResourcesPath = `/${Schemas.vscodeRemoteResource}`;

  setPreferredWebSchema(schema) {
    this._preferredWebSchema = schema;
  }

  setDelegate(delegate) {
    this._delegate = delegate;
  }

  setServerRootPath(serverRootPath) {
    this._remoteResourcesPath = `${serverRootPath}/${Schemas.vscodeRemoteResource}`;
  }

  set(authority, host, port) {
    this._hosts[authority] = host;
    this._ports[authority] = port;
  }

  setConnectionToken(authority, connectionToken) {
    this._connectionTokens[authority] = connectionToken;
  }

  getPreferredWebSchema() {
    return this._preferredWebSchema;
  }

  rewrite(uri) {
    if (this._delegate) {
      return this._delegate(uri);
    }

    const authority = uri.authority;
    let host = this._hosts[authority];

    if (host && host.indexOf(':') !== -1) {
      host = `[${host}]`;
    }

    const port = this._ports[authority];
    const connectionToken = this._connectionTokens[authority];
    let query = `path=${encodeURIComponent(uri.path)}`;

    if (typeof connectionToken === 'string') {
      query += `&${connectionTokenQueryName}=${encodeURIComponent(connectionToken)}`;
    }

    return _uri__WEBPACK_IMPORTED_MODULE_1__.URI.from({
      scheme: _platform__WEBPACK_IMPORTED_MODULE_0__.isWeb ? this._preferredWebSchema : Schemas.vscodeRemoteResource,
      authority: `${host}:${port}`,
      path: this._remoteResourcesPath,
      query
    });
  }

}

const RemoteAuthorities = new RemoteAuthoritiesImpl();

class FileAccessImpl {
  static FALLBACK_AUTHORITY = 'vscode-app';
  /**
   * Returns a URI to use in contexts where the browser is responsible
   * for loading (e.g. fetch()) or when used within the DOM.
   *
   * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.
   */

  asBrowserUri(uriOrModule, moduleIdToUrl) {
    const uri = this.toUri(uriOrModule, moduleIdToUrl); // Handle remote URIs via `RemoteAuthorities`

    if (uri.scheme === Schemas.vscodeRemote) {
      return RemoteAuthorities.rewrite(uri);
    } // Convert to `vscode-file` resource..


    if ( // ...only ever for `file` resources
    uri.scheme === Schemas.file && ( // ...and we run in native environments
    _platform__WEBPACK_IMPORTED_MODULE_0__.isNative || // ...or web worker extensions on desktop
    _platform__WEBPACK_IMPORTED_MODULE_0__.isWebWorker && _platform__WEBPACK_IMPORTED_MODULE_0__.globals.origin === `${Schemas.vscodeFileResource}://${FileAccessImpl.FALLBACK_AUTHORITY}`)) {
      return uri.with({
        scheme: Schemas.vscodeFileResource,
        // We need to provide an authority here so that it can serve
        // as origin for network and loading matters in chromium.
        // If the URI is not coming with an authority already, we
        // add our own
        authority: uri.authority || FileAccessImpl.FALLBACK_AUTHORITY,
        query: null,
        fragment: null
      });
    }

    return uri;
  }
  /**
   * Returns the `file` URI to use in contexts where node.js
   * is responsible for loading.
   */


  asFileUri(uriOrModule, moduleIdToUrl) {
    const uri = this.toUri(uriOrModule, moduleIdToUrl); // Only convert the URI if it is `vscode-file:` scheme

    if (uri.scheme === Schemas.vscodeFileResource) {
      return uri.with({
        scheme: Schemas.file,
        // Only preserve the `authority` if it is different from
        // our fallback authority. This ensures we properly preserve
        // Windows UNC paths that come with their own authority.
        authority: uri.authority !== FileAccessImpl.FALLBACK_AUTHORITY ? uri.authority : null,
        query: null,
        fragment: null
      });
    }

    return uri;
  }

  toUri(uriOrModule, moduleIdToUrl) {
    if (_uri__WEBPACK_IMPORTED_MODULE_1__.URI.isUri(uriOrModule)) {
      return uriOrModule;
    }

    return _uri__WEBPACK_IMPORTED_MODULE_1__.URI.parse(moduleIdToUrl.toUrl(uriOrModule));
  }

}

const FileAccess = new FileAccessImpl();
let COI;

(function (_COI) {
  const coiHeaders = new Map([['1', {
    'Cross-Origin-Opener-Policy': 'same-origin'
  }], ['2', {
    'Cross-Origin-Embedder-Policy': 'require-corp'
  }], ['3', {
    'Cross-Origin-Opener-Policy': 'same-origin',
    'Cross-Origin-Embedder-Policy': 'require-corp'
  }]]);
  const CoopAndCoep = _COI.CoopAndCoep = Object.freeze(coiHeaders.get('3'));
  const coiSearchParamName = 'vscode-coi';
  /**
   * Extract desired headers from `vscode-coi` invocation
   */

  function getHeadersFromQuery(url) {
    let params;

    if (typeof url === 'string') {
      params = new URL(url).searchParams;
    } else if (url instanceof URL) {
      params = url.searchParams;
    } else if (_uri__WEBPACK_IMPORTED_MODULE_1__.URI.isUri(url)) {
      params = new URL(url.toString(true)).searchParams;
    }

    const value = params?.get(coiSearchParamName);

    if (!value) {
      return undefined;
    }

    return coiHeaders.get(value);
  }

  _COI.getHeadersFromQuery = getHeadersFromQuery;

  function addSearchParam(urlOrSearch, coop, coep) {
    if (!globalThis.crossOriginIsolated) {
      // depends on the current context being COI
      return;
    }

    const value = coop && coep ? '3' : coep ? '2' : '1';

    if (urlOrSearch instanceof URLSearchParams) {
      urlOrSearch.set(coiSearchParamName, value);
    } else {
      urlOrSearch[coiSearchParamName] = value;
    }
  }

  _COI.addSearchParam = addSearchParam;
})(COI || (COI = {}));

/***/ }),
/* 81 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "URI": () => (/* binding */ URI),
/* harmony export */   "uriToFsPath": () => (/* binding */ uriToFsPath)
/* harmony export */ });
/* harmony import */ var _charCode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(71);
/* harmony import */ var _marshallingIds__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(82);
/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(73);
/* harmony import */ var _platform__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(58);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/




const _schemePattern = /^\w[\w\d+.-]*$/;
const _singleSlashStart = /^\//;
const _doubleSlashStart = /^\/\//;

function _validateUri(ret, _strict) {
  // scheme, must be set
  if (!ret.scheme && _strict) {
    throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${ret.authority}", path: "${ret.path}", query: "${ret.query}", fragment: "${ret.fragment}"}`);
  } // scheme, https://tools.ietf.org/html/rfc3986#section-3.1
  // ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )


  if (ret.scheme && !_schemePattern.test(ret.scheme)) {
    throw new Error('[UriError]: Scheme contains illegal characters.');
  } // path, http://tools.ietf.org/html/rfc3986#section-3.3
  // If a URI contains an authority component, then the path component
  // must either be empty or begin with a slash ("/") character.  If a URI
  // does not contain an authority component, then the path cannot begin
  // with two slash characters ("//").


  if (ret.path) {
    if (ret.authority) {
      if (!_singleSlashStart.test(ret.path)) {
        throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
      }
    } else {
      if (_doubleSlashStart.test(ret.path)) {
        throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
      }
    }
  }
} // for a while we allowed uris *without* schemes and this is the migration
// for them, e.g. an uri without scheme and without strict-mode warns and falls
// back to the file-scheme. that should cause the least carnage and still be a
// clear warning


function _schemeFix(scheme, _strict) {
  if (!scheme && !_strict) {
    return 'file';
  }

  return scheme;
} // implements a bit of https://tools.ietf.org/html/rfc3986#section-5


function _referenceResolution(scheme, path) {
  // the slash-character is our 'default base' as we don't
  // support constructing URIs relative to other URIs. This
  // also means that we alter and potentially break paths.
  // see https://tools.ietf.org/html/rfc3986#section-5.1.4
  switch (scheme) {
    case 'https':
    case 'http':
    case 'file':
      if (!path) {
        path = _slash;
      } else if (path[0] !== _slash) {
        path = _slash + path;
      }

      break;
  }

  return path;
}

const _empty = '';
const _slash = '/';
const _regexp = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
/**
 * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.
 * This class is a simple parser which creates the basic component parts
 * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation
 * and encoding.
 *
 * ```txt
 *       foo://example.com:8042/over/there?name=ferret#nose
 *       \_/   \______________/\_________/ \_________/ \__/
 *        |           |            |            |        |
 *     scheme     authority       path        query   fragment
 *        |   _____________________|__
 *       / \ /                        \
 *       urn:example:animal:ferret:nose
 * ```
 */

class URI {
  static isUri(thing) {
    if (thing instanceof URI) {
      return true;
    }

    if (!thing) {
      return false;
    }

    return typeof thing.authority === 'string' && typeof thing.fragment === 'string' && typeof thing.path === 'string' && typeof thing.query === 'string' && typeof thing.scheme === 'string' && typeof thing.fsPath === 'string' && typeof thing.with === 'function' && typeof thing.toString === 'function';
  }
  /**
   * scheme is the 'http' part of 'http://www.example.com/some/path?query#fragment'.
   * The part before the first colon.
   */


  /**
   * @internal
   */
  constructor(schemeOrData, authority, path, query, fragment, _strict = false) {
    if (typeof schemeOrData === 'object') {
      this.scheme = schemeOrData.scheme || _empty;
      this.authority = schemeOrData.authority || _empty;
      this.path = schemeOrData.path || _empty;
      this.query = schemeOrData.query || _empty;
      this.fragment = schemeOrData.fragment || _empty; // no validation because it's this URI
      // that creates uri components.
      // _validateUri(this);
    } else {
      this.scheme = _schemeFix(schemeOrData, _strict);
      this.authority = authority || _empty;
      this.path = _referenceResolution(this.scheme, path || _empty);
      this.query = query || _empty;
      this.fragment = fragment || _empty;

      _validateUri(this, _strict);
    }
  } // ---- filesystem path -----------------------

  /**
   * Returns a string representing the corresponding file system path of this URI.
   * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the
   * platform specific path separator.
   *
   * * Will *not* validate the path for invalid characters and semantics.
   * * Will *not* look at the scheme of this URI.
   * * The result shall *not* be used for display purposes but for accessing a file on disk.
   *
   *
   * The *difference* to `URI#path` is the use of the platform specific separator and the handling
   * of UNC paths. See the below sample of a file-uri with an authority (UNC path).
   *
   * ```ts
  	const u = URI.parse('file://server/c$/folder/file.txt')
  	u.authority === 'server'
  	u.path === '/shares/c$/file.txt'
  	u.fsPath === '\\server\c$\folder\file.txt'
  ```
   *
   * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,
   * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working
   * with URIs that represent files on disk (`file` scheme).
   */


  get fsPath() {
    // if (this.scheme !== 'file') {
    // 	console.warn(`[UriError] calling fsPath with scheme ${this.scheme}`);
    // }
    return uriToFsPath(this, false);
  } // ---- modify to new -------------------------


  with(change) {
    if (!change) {
      return this;
    }

    let {
      scheme,
      authority,
      path,
      query,
      fragment
    } = change;

    if (scheme === undefined) {
      scheme = this.scheme;
    } else if (scheme === null) {
      scheme = _empty;
    }

    if (authority === undefined) {
      authority = this.authority;
    } else if (authority === null) {
      authority = _empty;
    }

    if (path === undefined) {
      path = this.path;
    } else if (path === null) {
      path = _empty;
    }

    if (query === undefined) {
      query = this.query;
    } else if (query === null) {
      query = _empty;
    }

    if (fragment === undefined) {
      fragment = this.fragment;
    } else if (fragment === null) {
      fragment = _empty;
    }

    if (scheme === this.scheme && authority === this.authority && path === this.path && query === this.query && fragment === this.fragment) {
      return this;
    }

    return new Uri(scheme, authority, path, query, fragment);
  } // ---- parse & validate ------------------------

  /**
   * Creates a new URI from a string, e.g. `http://www.example.com/some/path`,
   * `file:///usr/home`, or `scheme:with/path`.
   *
   * @param value A string which represents an URI (see `URI#toString`).
   */


  static parse(value, _strict = false) {
    const match = _regexp.exec(value);

    if (!match) {
      return new Uri(_empty, _empty, _empty, _empty, _empty);
    }

    return new Uri(match[2] || _empty, percentDecode(match[4] || _empty), percentDecode(match[5] || _empty), percentDecode(match[7] || _empty), percentDecode(match[9] || _empty), _strict);
  }
  /**
   * Creates a new URI from a file system path, e.g. `c:\my\files`,
   * `/usr/home`, or `\\server\share\some\path`.
   *
   * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument
   * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**
   * `URI.parse('file://' + path)` because the path might contain characters that are
   * interpreted (# and ?). See the following sample:
   * ```ts
  const good = URI.file('/coding/c#/project1');
  good.scheme === 'file';
  good.path === '/coding/c#/project1';
  good.fragment === '';
  const bad = URI.parse('file://' + '/coding/c#/project1');
  bad.scheme === 'file';
  bad.path === '/coding/c'; // path is now broken
  bad.fragment === '/project1';
  ```
   *
   * @param path A file system path (see `URI#fsPath`)
   */


  static file(path) {
    let authority = _empty; // normalize to fwd-slashes on windows,
    // on other systems bwd-slashes are valid
    // filename character, eg /f\oo/ba\r.txt

    if (_platform__WEBPACK_IMPORTED_MODULE_3__.isWindows) {
      path = path.replace(/\\/g, _slash);
    } // check for authority as used in UNC shares
    // or use the path as given


    if (path[0] === _slash && path[1] === _slash) {
      const idx = path.indexOf(_slash, 2);

      if (idx === -1) {
        authority = path.substring(2);
        path = _slash;
      } else {
        authority = path.substring(2, idx);
        path = path.substring(idx) || _slash;
      }
    }

    return new Uri('file', authority, path, _empty, _empty);
  }

  static from(components) {
    const result = new Uri(components.scheme, components.authority, components.path, components.query, components.fragment);

    _validateUri(result, true);

    return result;
  }
  /**
   * Join a URI path with path fragments and normalizes the resulting path.
   *
   * @param uri The input URI.
   * @param pathFragment The path fragment to add to the URI path.
   * @returns The resulting URI.
   */


  static joinPath(uri, ...pathFragment) {
    if (!uri.path) {
      throw new Error(`[UriError]: cannot call joinPath on URI without path`);
    }

    let newPath;

    if (_platform__WEBPACK_IMPORTED_MODULE_3__.isWindows && uri.scheme === 'file') {
      newPath = URI.file(_path__WEBPACK_IMPORTED_MODULE_2__.win32.join(uriToFsPath(uri, true), ...pathFragment)).path;
    } else {
      newPath = _path__WEBPACK_IMPORTED_MODULE_2__.posix.join(uri.path, ...pathFragment);
    }

    return uri.with({
      path: newPath
    });
  } // ---- printing/externalize ---------------------------

  /**
   * Creates a string representation for this URI. It's guaranteed that calling
   * `URI.parse` with the result of this function creates an URI which is equal
   * to this URI.
   *
   * * The result shall *not* be used for display purposes but for externalization or transport.
   * * The result will be encoded using the percentage encoding and encoding happens mostly
   * ignore the scheme-specific encoding rules.
   *
   * @param skipEncoding Do not encode the result, default is `false`
   */


  toString(skipEncoding = false) {
    return _asFormatted(this, skipEncoding);
  }

  toJSON() {
    return this;
  }

  static revive(data) {
    if (!data) {
      return data;
    } else if (data instanceof URI) {
      return data;
    } else {
      const result = new Uri(data);
      result._formatted = data.external;
      result._fsPath = data._sep === _pathSepMarker ? data.fsPath : null;
      return result;
    }
  }

}

const _pathSepMarker = _platform__WEBPACK_IMPORTED_MODULE_3__.isWindows ? 1 : undefined; // This class exists so that URI is compatible with vscode.Uri (API).


class Uri extends URI {
  _formatted = null;
  _fsPath = null;

  get fsPath() {
    if (!this._fsPath) {
      this._fsPath = uriToFsPath(this, false);
    }

    return this._fsPath;
  }

  toString(skipEncoding = false) {
    if (!skipEncoding) {
      if (!this._formatted) {
        this._formatted = _asFormatted(this, false);
      }

      return this._formatted;
    } else {
      // we don't cache that
      return _asFormatted(this, true);
    }
  }

  toJSON() {
    const res = {
      $mid: _marshallingIds__WEBPACK_IMPORTED_MODULE_1__.MarshalledId.Uri
    }; // cached state

    if (this._fsPath) {
      res.fsPath = this._fsPath;
      res._sep = _pathSepMarker;
    }

    if (this._formatted) {
      res.external = this._formatted;
    } // uri components


    if (this.path) {
      res.path = this.path;
    }

    if (this.scheme) {
      res.scheme = this.scheme;
    }

    if (this.authority) {
      res.authority = this.authority;
    }

    if (this.query) {
      res.query = this.query;
    }

    if (this.fragment) {
      res.fragment = this.fragment;
    }

    return res;
  }

} // reserved characters: https://tools.ietf.org/html/rfc3986#section-2.2


const encodeTable = {
  [_charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Colon]: '%3A',
  // gen-delims
  [_charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Slash]: '%2F',
  [_charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.QuestionMark]: '%3F',
  [_charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Hash]: '%23',
  [_charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.OpenSquareBracket]: '%5B',
  [_charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.CloseSquareBracket]: '%5D',
  [_charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.AtSign]: '%40',
  [_charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.ExclamationMark]: '%21',
  // sub-delims
  [_charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.DollarSign]: '%24',
  [_charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Ampersand]: '%26',
  [_charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.SingleQuote]: '%27',
  [_charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.OpenParen]: '%28',
  [_charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.CloseParen]: '%29',
  [_charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Asterisk]: '%2A',
  [_charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Plus]: '%2B',
  [_charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Comma]: '%2C',
  [_charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Semicolon]: '%3B',
  [_charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Equals]: '%3D',
  [_charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Space]: '%20'
};

function encodeURIComponentFast(uriComponent, allowSlash) {
  let res = undefined;
  let nativeEncodePos = -1;

  for (let pos = 0; pos < uriComponent.length; pos++) {
    const code = uriComponent.charCodeAt(pos); // unreserved characters: https://tools.ietf.org/html/rfc3986#section-2.3

    if (code >= _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.a && code <= _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.z || code >= _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.A && code <= _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Z || code >= _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Digit0 && code <= _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Digit9 || code === _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Dash || code === _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Period || code === _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Underline || code === _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Tilde || allowSlash && code === _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Slash) {
      // check if we are delaying native encode
      if (nativeEncodePos !== -1) {
        res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
        nativeEncodePos = -1;
      } // check if we write into a new string (by default we try to return the param)


      if (res !== undefined) {
        res += uriComponent.charAt(pos);
      }
    } else {
      // encoding needed, we need to allocate a new string
      if (res === undefined) {
        res = uriComponent.substr(0, pos);
      } // check with default table first


      const escaped = encodeTable[code];

      if (escaped !== undefined) {
        // check if we are delaying native encode
        if (nativeEncodePos !== -1) {
          res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
          nativeEncodePos = -1;
        } // append escaped variant to result


        res += escaped;
      } else if (nativeEncodePos === -1) {
        // use native encode only when needed
        nativeEncodePos = pos;
      }
    }
  }

  if (nativeEncodePos !== -1) {
    res += encodeURIComponent(uriComponent.substring(nativeEncodePos));
  }

  return res !== undefined ? res : uriComponent;
}

function encodeURIComponentMinimal(path) {
  let res = undefined;

  for (let pos = 0; pos < path.length; pos++) {
    const code = path.charCodeAt(pos);

    if (code === _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Hash || code === _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.QuestionMark) {
      if (res === undefined) {
        res = path.substr(0, pos);
      }

      res += encodeTable[code];
    } else {
      if (res !== undefined) {
        res += path[pos];
      }
    }
  }

  return res !== undefined ? res : path;
}
/**
 * Compute `fsPath` for the given uri
 */


function uriToFsPath(uri, keepDriveLetterCasing) {
  let value;

  if (uri.authority && uri.path.length > 1 && uri.scheme === 'file') {
    // unc path: file://shares/c$/far/boo
    value = `//${uri.authority}${uri.path}`;
  } else if (uri.path.charCodeAt(0) === _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Slash && (uri.path.charCodeAt(1) >= _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.A && uri.path.charCodeAt(1) <= _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Z || uri.path.charCodeAt(1) >= _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.a && uri.path.charCodeAt(1) <= _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.z) && uri.path.charCodeAt(2) === _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Colon) {
    if (!keepDriveLetterCasing) {
      // windows drive letter: file:///c:/far/boo
      value = uri.path[1].toLowerCase() + uri.path.substr(2);
    } else {
      value = uri.path.substr(1);
    }
  } else {
    // other path
    value = uri.path;
  }

  if (_platform__WEBPACK_IMPORTED_MODULE_3__.isWindows) {
    value = value.replace(/\//g, '\\');
  }

  return value;
}
/**
 * Create the external version of a uri
 */

function _asFormatted(uri, skipEncoding) {
  const encoder = !skipEncoding ? encodeURIComponentFast : encodeURIComponentMinimal;
  let res = '';
  let {
    scheme,
    authority,
    path,
    query,
    fragment
  } = uri;

  if (scheme) {
    res += scheme;
    res += ':';
  }

  if (authority || scheme === 'file') {
    res += _slash;
    res += _slash;
  }

  if (authority) {
    let idx = authority.indexOf('@');

    if (idx !== -1) {
      // <user>@<auth>
      const userinfo = authority.substr(0, idx);
      authority = authority.substr(idx + 1);
      idx = userinfo.indexOf(':');

      if (idx === -1) {
        res += encoder(userinfo, false);
      } else {
        // <user>:<pass>@<auth>
        res += encoder(userinfo.substr(0, idx), false);
        res += ':';
        res += encoder(userinfo.substr(idx + 1), false);
      }

      res += '@';
    }

    authority = authority.toLowerCase();
    idx = authority.indexOf(':');

    if (idx === -1) {
      res += encoder(authority, false);
    } else {
      // <auth>:<port>
      res += encoder(authority.substr(0, idx), false);
      res += authority.substr(idx);
    }
  }

  if (path) {
    // lower-case windows drive letters in /C:/fff or C:/fff
    if (path.length >= 3 && path.charCodeAt(0) === _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Slash && path.charCodeAt(2) === _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Colon) {
      const code = path.charCodeAt(1);

      if (code >= _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.A && code <= _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Z) {
        path = `/${String.fromCharCode(code + 32)}:${path.substr(3)}`; // "/c:".length === 3
      }
    } else if (path.length >= 2 && path.charCodeAt(1) === _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Colon) {
      const code = path.charCodeAt(0);

      if (code >= _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.A && code <= _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Z) {
        path = `${String.fromCharCode(code + 32)}:${path.substr(2)}`; // "/c:".length === 3
      }
    } // encode the rest of the path


    res += encoder(path, true);
  }

  if (query) {
    res += '?';
    res += encoder(query, false);
  }

  if (fragment) {
    res += '#';
    res += !skipEncoding ? encodeURIComponentFast(fragment, false) : fragment;
  }

  return res;
} // --- decode


function decodeURIComponentGraceful(str) {
  try {
    return decodeURIComponent(str);
  } catch {
    if (str.length > 3) {
      return str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));
    } else {
      return str;
    }
  }
}

const _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;

function percentDecode(str) {
  if (!str.match(_rEncodedAsHex)) {
    return str;
  }

  return str.replace(_rEncodedAsHex, match => decodeURIComponentGraceful(match));
}
/**
 * Mapped-type that replaces all occurrences of URI with UriComponents
 */

/***/ }),
/* 82 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MarshalledId": () => (/* binding */ MarshalledId)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
let MarshalledId;

(function (MarshalledId) {
  MarshalledId[MarshalledId["Uri"] = 1] = "Uri";
  MarshalledId[MarshalledId["Regexp"] = 2] = "Regexp";
  MarshalledId[MarshalledId["ScmResource"] = 3] = "ScmResource";
  MarshalledId[MarshalledId["ScmResourceGroup"] = 4] = "ScmResourceGroup";
  MarshalledId[MarshalledId["ScmProvider"] = 5] = "ScmProvider";
  MarshalledId[MarshalledId["CommentController"] = 6] = "CommentController";
  MarshalledId[MarshalledId["CommentThread"] = 7] = "CommentThread";
  MarshalledId[MarshalledId["CommentThreadReply"] = 8] = "CommentThreadReply";
  MarshalledId[MarshalledId["CommentNode"] = 9] = "CommentNode";
  MarshalledId[MarshalledId["CommentThreadNode"] = 10] = "CommentThreadNode";
  MarshalledId[MarshalledId["TimelineActionContext"] = 11] = "TimelineActionContext";
  MarshalledId[MarshalledId["NotebookCellActionContext"] = 12] = "NotebookCellActionContext";
  MarshalledId[MarshalledId["TestItemContext"] = 13] = "TestItemContext";
  MarshalledId[MarshalledId["Date"] = 14] = "Date";
})(MarshalledId || (MarshalledId = {}));

/***/ }),
/* 83 */
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_RESULT__;/*! @license DOMPurify 2.3.1 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.3.1/LICENSE */

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var hasOwnProperty = Object.hasOwnProperty,
    setPrototypeOf = Object.setPrototypeOf,
    isFrozen = Object.isFrozen,
    getPrototypeOf = Object.getPrototypeOf,
    getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var freeze = Object.freeze,
    seal = Object.seal,
    create = Object.create; // eslint-disable-line import/no-mutable-exports

var _ref = typeof Reflect !== 'undefined' && Reflect,
    apply = _ref.apply,
    construct = _ref.construct;

if (!apply) {
  apply = function apply(fun, thisValue, args) {
    return fun.apply(thisValue, args);
  };
}

if (!freeze) {
  freeze = function freeze(x) {
    return x;
  };
}

if (!seal) {
  seal = function seal(x) {
    return x;
  };
}

if (!construct) {
  construct = function construct(Func, args) {
    return new (Function.prototype.bind.apply(Func, [null].concat(_toConsumableArray(args))))();
  };
}

var arrayForEach = unapply(Array.prototype.forEach);
var arrayPop = unapply(Array.prototype.pop);
var arrayPush = unapply(Array.prototype.push);

var stringToLowerCase = unapply(String.prototype.toLowerCase);
var stringMatch = unapply(String.prototype.match);
var stringReplace = unapply(String.prototype.replace);
var stringIndexOf = unapply(String.prototype.indexOf);
var stringTrim = unapply(String.prototype.trim);

var regExpTest = unapply(RegExp.prototype.test);

var typeErrorCreate = unconstruct(TypeError);

function unapply(func) {
  return function (thisArg) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    return apply(func, thisArg, args);
  };
}

function unconstruct(func) {
  return function () {
    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return construct(func, args);
  };
}

/* Add properties to a lookup table */
function addToSet(set, array) {
  if (setPrototypeOf) {
    // Make 'in' and truthy checks like Boolean(set.constructor)
    // independent of any properties defined on Object.prototype.
    // Prevent prototype setters from intercepting set as a this value.
    setPrototypeOf(set, null);
  }

  var l = array.length;
  while (l--) {
    var element = array[l];
    if (typeof element === 'string') {
      var lcElement = stringToLowerCase(element);
      if (lcElement !== element) {
        // Config presets (e.g. tags.js, attrs.js) are immutable.
        if (!isFrozen(array)) {
          array[l] = lcElement;
        }

        element = lcElement;
      }
    }

    set[element] = true;
  }

  return set;
}

/* Shallow clone an object */
function clone(object) {
  var newObject = create(null);

  var property = void 0;
  for (property in object) {
    if (apply(hasOwnProperty, object, [property])) {
      newObject[property] = object[property];
    }
  }

  return newObject;
}

/* IE10 doesn't support __lookupGetter__ so lets'
 * simulate it. It also automatically checks
 * if the prop is function or getter and behaves
 * accordingly. */
function lookupGetter(object, prop) {
  while (object !== null) {
    var desc = getOwnPropertyDescriptor(object, prop);
    if (desc) {
      if (desc.get) {
        return unapply(desc.get);
      }

      if (typeof desc.value === 'function') {
        return unapply(desc.value);
      }
    }

    object = getPrototypeOf(object);
  }

  function fallbackValue(element) {
    console.warn('fallback value for', element);
    return null;
  }

  return fallbackValue;
}

var html = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']);

// SVG
var svg = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);

var svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']);

// List of SVG elements that are disallowed by default.
// We still need to know them so that we can do namespace
// checks properly in case one wants to add them to
// allow-list.
var svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'fedropshadow', 'feimage', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);

var mathMl = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover']);

// Similarly to SVG, we want to know all MathML elements,
// even those that we disallow by default.
var mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);

var text = freeze(['#text']);

var html$1 = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns', 'slot']);

var svg$1 = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'targetx', 'targety', 'transform', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);

var mathMl$1 = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);

var xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);

// eslint-disable-next-line unicorn/better-regex
var MUSTACHE_EXPR = seal(/\{\{[\s\S]*|[\s\S]*\}\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode
var ERB_EXPR = seal(/<%[\s\S]*|[\s\S]*%>/gm);
var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/); // eslint-disable-line no-useless-escape
var ARIA_ATTR = seal(/^aria-[\-\w]+$/); // eslint-disable-line no-useless-escape
var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i // eslint-disable-line no-useless-escape
);
var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
var ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g // eslint-disable-line no-control-regex
);

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _toConsumableArray$1(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var getGlobal = function getGlobal() {
  return typeof window === 'undefined' ? null : window;
};

/**
 * Creates a no-op policy for internal use only.
 * Don't export this function outside this module!
 * @param {?TrustedTypePolicyFactory} trustedTypes The policy factory.
 * @param {Document} document The document object (to determine policy name suffix)
 * @return {?TrustedTypePolicy} The policy created (or null, if Trusted Types
 * are not supported).
 */
var _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, document) {
  if ((typeof trustedTypes === 'undefined' ? 'undefined' : _typeof(trustedTypes)) !== 'object' || typeof trustedTypes.createPolicy !== 'function') {
    return null;
  }

  // Allow the callers to control the unique policy name
  // by adding a data-tt-policy-suffix to the script element with the DOMPurify.
  // Policy creation with duplicate names throws in Trusted Types.
  var suffix = null;
  var ATTR_NAME = 'data-tt-policy-suffix';
  if (document.currentScript && document.currentScript.hasAttribute(ATTR_NAME)) {
    suffix = document.currentScript.getAttribute(ATTR_NAME);
  }

  var policyName = 'dompurify' + (suffix ? '#' + suffix : '');

  try {
    return trustedTypes.createPolicy(policyName, {
      createHTML: function createHTML(html$$1) {
        return html$$1;
      }
    });
  } catch (_) {
    // Policy creation failed (most likely another DOMPurify script has
    // already run). Skip creating the policy, as this will only cause errors
    // if TT are enforced.
    console.warn('TrustedTypes policy ' + policyName + ' could not be created.');
    return null;
  }
};

function createDOMPurify() {
  var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();

  var DOMPurify = function DOMPurify(root) {
    return createDOMPurify(root);
  };

  /**
   * Version label, exposed for easier checks
   * if DOMPurify is up to date or not
   */
  DOMPurify.version = '2.3.1';

  /**
   * Array of elements that DOMPurify removed during sanitation.
   * Empty if nothing was removed.
   */
  DOMPurify.removed = [];

  if (!window || !window.document || window.document.nodeType !== 9) {
    // Not running in a browser, provide a factory function
    // so that you can pass your own Window
    DOMPurify.isSupported = false;

    return DOMPurify;
  }

  var originalDocument = window.document;

  var document = window.document;
  var DocumentFragment = window.DocumentFragment,
      HTMLTemplateElement = window.HTMLTemplateElement,
      Node = window.Node,
      Element = window.Element,
      NodeFilter = window.NodeFilter,
      _window$NamedNodeMap = window.NamedNodeMap,
      NamedNodeMap = _window$NamedNodeMap === undefined ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap,
      Text = window.Text,
      Comment = window.Comment,
      DOMParser = window.DOMParser,
      trustedTypes = window.trustedTypes;


  var ElementPrototype = Element.prototype;

  var cloneNode = lookupGetter(ElementPrototype, 'cloneNode');
  var getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');
  var getChildNodes = lookupGetter(ElementPrototype, 'childNodes');
  var getParentNode = lookupGetter(ElementPrototype, 'parentNode');

  // As per issue #47, the web-components registry is inherited by a
  // new document created via createHTMLDocument. As per the spec
  // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)
  // a new empty registry is used when creating a template contents owner
  // document, so we use that as our parent document to ensure nothing
  // is inherited.
  if (typeof HTMLTemplateElement === 'function') {
    var template = document.createElement('template');
    if (template.content && template.content.ownerDocument) {
      document = template.content.ownerDocument;
    }
  }

  var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);
  var emptyHTML = trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML('') : '';

  var _document = document,
      implementation = _document.implementation,
      createNodeIterator = _document.createNodeIterator,
      createDocumentFragment = _document.createDocumentFragment,
      getElementsByTagName = _document.getElementsByTagName;
  var importNode = originalDocument.importNode;


  var documentMode = {};
  try {
    documentMode = clone(document).documentMode ? document.documentMode : {};
  } catch (_) {}

  var hooks = {};

  /**
   * Expose whether this browser supports running the full DOMPurify.
   */
  DOMPurify.isSupported = typeof getParentNode === 'function' && implementation && typeof implementation.createHTMLDocument !== 'undefined' && documentMode !== 9;

  var MUSTACHE_EXPR$$1 = MUSTACHE_EXPR,
      ERB_EXPR$$1 = ERB_EXPR,
      DATA_ATTR$$1 = DATA_ATTR,
      ARIA_ATTR$$1 = ARIA_ATTR,
      IS_SCRIPT_OR_DATA$$1 = IS_SCRIPT_OR_DATA,
      ATTR_WHITESPACE$$1 = ATTR_WHITESPACE;
  var IS_ALLOWED_URI$$1 = IS_ALLOWED_URI;

  /**
   * We consider the elements and attributes below to be safe. Ideally
   * don't add any new ones but feel free to remove unwanted ones.
   */

  /* allowed element names */

  var ALLOWED_TAGS = null;
  var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(html), _toConsumableArray$1(svg), _toConsumableArray$1(svgFilters), _toConsumableArray$1(mathMl), _toConsumableArray$1(text)));

  /* Allowed attribute names */
  var ALLOWED_ATTR = null;
  var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray$1(html$1), _toConsumableArray$1(svg$1), _toConsumableArray$1(mathMl$1), _toConsumableArray$1(xml)));

  /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */
  var FORBID_TAGS = null;

  /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */
  var FORBID_ATTR = null;

  /* Decide if ARIA attributes are okay */
  var ALLOW_ARIA_ATTR = true;

  /* Decide if custom data attributes are okay */
  var ALLOW_DATA_ATTR = true;

  /* Decide if unknown protocols are okay */
  var ALLOW_UNKNOWN_PROTOCOLS = false;

  /* Output should be safe for common template engines.
   * This means, DOMPurify removes data attributes, mustaches and ERB
   */
  var SAFE_FOR_TEMPLATES = false;

  /* Decide if document with <html>... should be returned */
  var WHOLE_DOCUMENT = false;

  /* Track whether config is already set on this instance of DOMPurify. */
  var SET_CONFIG = false;

  /* Decide if all elements (e.g. style, script) must be children of
   * document.body. By default, browsers might move them to document.head */
  var FORCE_BODY = false;

  /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html
   * string (or a TrustedHTML object if Trusted Types are supported).
   * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead
   */
  var RETURN_DOM = false;

  /* Decide if a DOM `DocumentFragment` should be returned, instead of a html
   * string  (or a TrustedHTML object if Trusted Types are supported) */
  var RETURN_DOM_FRAGMENT = false;

  /* If `RETURN_DOM` or `RETURN_DOM_FRAGMENT` is enabled, decide if the returned DOM
   * `Node` is imported into the current `Document`. If this flag is not enabled the
   * `Node` will belong (its ownerDocument) to a fresh `HTMLDocument`, created by
   * DOMPurify.
   *
   * This defaults to `true` starting DOMPurify 2.2.0. Note that setting it to `false`
   * might cause XSS from attacks hidden in closed shadowroots in case the browser
   * supports Declarative Shadow: DOM https://web.dev/declarative-shadow-dom/
   */
  var RETURN_DOM_IMPORT = true;

  /* Try to return a Trusted Type object instead of a string, return a string in
   * case Trusted Types are not supported  */
  var RETURN_TRUSTED_TYPE = false;

  /* Output should be free from DOM clobbering attacks? */
  var SANITIZE_DOM = true;

  /* Keep element content when removing element? */
  var KEEP_CONTENT = true;

  /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead
   * of importing it into a new Document and returning a sanitized copy */
  var IN_PLACE = false;

  /* Allow usage of profiles like html, svg and mathMl */
  var USE_PROFILES = {};

  /* Tags to ignore content of when KEEP_CONTENT is true */
  var FORBID_CONTENTS = null;
  var DEFAULT_FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);

  /* Tags that are safe for data: URIs */
  var DATA_URI_TAGS = null;
  var DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);

  /* Attributes safe for values like "javascript:" */
  var URI_SAFE_ATTRIBUTES = null;
  var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'role', 'summary', 'title', 'value', 'style', 'xmlns']);

  var MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
  var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
  var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';
  /* Document namespace */
  var NAMESPACE = HTML_NAMESPACE;
  var IS_EMPTY_INPUT = false;

  /* Keep a reference to config to pass to hooks */
  var CONFIG = null;

  /* Ideally, do not touch anything below this line */
  /* ______________________________________________ */

  var formElement = document.createElement('form');

  /**
   * _parseConfig
   *
   * @param  {Object} cfg optional config literal
   */
  // eslint-disable-next-line complexity
  var _parseConfig = function _parseConfig(cfg) {
    if (CONFIG && CONFIG === cfg) {
      return;
    }

    /* Shield configuration object from tampering */
    if (!cfg || (typeof cfg === 'undefined' ? 'undefined' : _typeof(cfg)) !== 'object') {
      cfg = {};
    }

    /* Shield configuration object from prototype pollution */
    cfg = clone(cfg);

    /* Set configuration parameters */
    ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;
    ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;
    URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR) : DEFAULT_URI_SAFE_ATTRIBUTES;
    DATA_URI_TAGS = 'ADD_DATA_URI_TAGS' in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS) : DEFAULT_DATA_URI_TAGS;
    FORBID_CONTENTS = 'FORBID_CONTENTS' in cfg ? addToSet({}, cfg.FORBID_CONTENTS) : DEFAULT_FORBID_CONTENTS;
    FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS) : {};
    FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR) : {};
    USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;
    ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true
    ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true
    ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false
    SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false
    WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false
    RETURN_DOM = cfg.RETURN_DOM || false; // Default false
    RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false
    RETURN_DOM_IMPORT = cfg.RETURN_DOM_IMPORT !== false; // Default true
    RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false
    FORCE_BODY = cfg.FORCE_BODY || false; // Default false
    SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true
    KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true
    IN_PLACE = cfg.IN_PLACE || false; // Default false
    IS_ALLOWED_URI$$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$$1;
    NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
    if (SAFE_FOR_TEMPLATES) {
      ALLOW_DATA_ATTR = false;
    }

    if (RETURN_DOM_FRAGMENT) {
      RETURN_DOM = true;
    }

    /* Parse profile info */
    if (USE_PROFILES) {
      ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(text)));
      ALLOWED_ATTR = [];
      if (USE_PROFILES.html === true) {
        addToSet(ALLOWED_TAGS, html);
        addToSet(ALLOWED_ATTR, html$1);
      }

      if (USE_PROFILES.svg === true) {
        addToSet(ALLOWED_TAGS, svg);
        addToSet(ALLOWED_ATTR, svg$1);
        addToSet(ALLOWED_ATTR, xml);
      }

      if (USE_PROFILES.svgFilters === true) {
        addToSet(ALLOWED_TAGS, svgFilters);
        addToSet(ALLOWED_ATTR, svg$1);
        addToSet(ALLOWED_ATTR, xml);
      }

      if (USE_PROFILES.mathMl === true) {
        addToSet(ALLOWED_TAGS, mathMl);
        addToSet(ALLOWED_ATTR, mathMl$1);
        addToSet(ALLOWED_ATTR, xml);
      }
    }

    /* Merge configuration parameters */
    if (cfg.ADD_TAGS) {
      if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
        ALLOWED_TAGS = clone(ALLOWED_TAGS);
      }

      addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);
    }

    if (cfg.ADD_ATTR) {
      if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
        ALLOWED_ATTR = clone(ALLOWED_ATTR);
      }

      addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);
    }

    if (cfg.ADD_URI_SAFE_ATTR) {
      addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);
    }

    if (cfg.FORBID_CONTENTS) {
      if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
        FORBID_CONTENTS = clone(FORBID_CONTENTS);
      }

      addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS);
    }

    /* Add #text in case KEEP_CONTENT is set to true */
    if (KEEP_CONTENT) {
      ALLOWED_TAGS['#text'] = true;
    }

    /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */
    if (WHOLE_DOCUMENT) {
      addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);
    }

    /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */
    if (ALLOWED_TAGS.table) {
      addToSet(ALLOWED_TAGS, ['tbody']);
      delete FORBID_TAGS.tbody;
    }

    // Prevent further manipulation of configuration.
    // Not available in IE8, Safari 5, etc.
    if (freeze) {
      freeze(cfg);
    }

    CONFIG = cfg;
  };

  var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);

  var HTML_INTEGRATION_POINTS = addToSet({}, ['foreignobject', 'desc', 'title', 'annotation-xml']);

  /* Keep track of all possible SVG and MathML tags
   * so that we can perform the namespace checks
   * correctly. */
  var ALL_SVG_TAGS = addToSet({}, svg);
  addToSet(ALL_SVG_TAGS, svgFilters);
  addToSet(ALL_SVG_TAGS, svgDisallowed);

  var ALL_MATHML_TAGS = addToSet({}, mathMl);
  addToSet(ALL_MATHML_TAGS, mathMlDisallowed);

  /**
   *
   *
   * @param  {Element} element a DOM element whose namespace is being checked
   * @returns {boolean} Return false if the element has a
   *  namespace that a spec-compliant parser would never
   *  return. Return true otherwise.
   */
  var _checkValidNamespace = function _checkValidNamespace(element) {
    var parent = getParentNode(element);

    // In JSDOM, if we're inside shadow DOM, then parentNode
    // can be null. We just simulate parent in this case.
    if (!parent || !parent.tagName) {
      parent = {
        namespaceURI: HTML_NAMESPACE,
        tagName: 'template'
      };
    }

    var tagName = stringToLowerCase(element.tagName);
    var parentTagName = stringToLowerCase(parent.tagName);

    if (element.namespaceURI === SVG_NAMESPACE) {
      // The only way to switch from HTML namespace to SVG
      // is via <svg>. If it happens via any other tag, then
      // it should be killed.
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === 'svg';
      }

      // The only way to switch from MathML to SVG is via
      // svg if parent is either <annotation-xml> or MathML
      // text integration points.
      if (parent.namespaceURI === MATHML_NAMESPACE) {
        return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
      }

      // We only allow elements that are defined in SVG
      // spec. All others are disallowed in SVG namespace.
      return Boolean(ALL_SVG_TAGS[tagName]);
    }

    if (element.namespaceURI === MATHML_NAMESPACE) {
      // The only way to switch from HTML namespace to MathML
      // is via <math>. If it happens via any other tag, then
      // it should be killed.
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === 'math';
      }

      // The only way to switch from SVG to MathML is via
      // <math> and HTML integration points
      if (parent.namespaceURI === SVG_NAMESPACE) {
        return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];
      }

      // We only allow elements that are defined in MathML
      // spec. All others are disallowed in MathML namespace.
      return Boolean(ALL_MATHML_TAGS[tagName]);
    }

    if (element.namespaceURI === HTML_NAMESPACE) {
      // The only way to switch from SVG to HTML is via
      // HTML integration points, and from MathML to HTML
      // is via MathML text integration points
      if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }

      if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }

      // Certain elements are allowed in both SVG and HTML
      // namespace. We need to specify them explicitly
      // so that they don't get erronously deleted from
      // HTML namespace.
      var commonSvgAndHTMLElements = addToSet({}, ['title', 'style', 'font', 'a', 'script']);

      // We disallow tags that are specific for MathML
      // or SVG and should never appear in HTML namespace
      return !ALL_MATHML_TAGS[tagName] && (commonSvgAndHTMLElements[tagName] || !ALL_SVG_TAGS[tagName]);
    }

    // The code should never reach this place (this means
    // that the element somehow got namespace that is not
    // HTML, SVG or MathML). Return false just in case.
    return false;
  };

  /**
   * _forceRemove
   *
   * @param  {Node} node a DOM node
   */
  var _forceRemove = function _forceRemove(node) {
    arrayPush(DOMPurify.removed, { element: node });
    try {
      // eslint-disable-next-line unicorn/prefer-dom-node-remove
      node.parentNode.removeChild(node);
    } catch (_) {
      try {
        node.outerHTML = emptyHTML;
      } catch (_) {
        node.remove();
      }
    }
  };

  /**
   * _removeAttribute
   *
   * @param  {String} name an Attribute name
   * @param  {Node} node a DOM node
   */
  var _removeAttribute = function _removeAttribute(name, node) {
    try {
      arrayPush(DOMPurify.removed, {
        attribute: node.getAttributeNode(name),
        from: node
      });
    } catch (_) {
      arrayPush(DOMPurify.removed, {
        attribute: null,
        from: node
      });
    }

    node.removeAttribute(name);

    // We void attribute values for unremovable "is"" attributes
    if (name === 'is' && !ALLOWED_ATTR[name]) {
      if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
        try {
          _forceRemove(node);
        } catch (_) {}
      } else {
        try {
          node.setAttribute(name, '');
        } catch (_) {}
      }
    }
  };

  /**
   * _initDocument
   *
   * @param  {String} dirty a string of dirty markup
   * @return {Document} a DOM, filled with the dirty markup
   */
  var _initDocument = function _initDocument(dirty) {
    /* Create a HTML document */
    var doc = void 0;
    var leadingWhitespace = void 0;

    if (FORCE_BODY) {
      dirty = '<remove></remove>' + dirty;
    } else {
      /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */
      var matches = stringMatch(dirty, /^[\r\n\t ]+/);
      leadingWhitespace = matches && matches[0];
    }

    var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
    /*
     * Use the DOMParser API by default, fallback later if needs be
     * DOMParser not work for svg when has multiple root element.
     */
    if (NAMESPACE === HTML_NAMESPACE) {
      try {
        doc = new DOMParser().parseFromString(dirtyPayload, 'text/html');
      } catch (_) {}
    }

    /* Use createHTMLDocument in case DOMParser is not available */
    if (!doc || !doc.documentElement) {
      doc = implementation.createDocument(NAMESPACE, 'template', null);
      try {
        doc.documentElement.innerHTML = IS_EMPTY_INPUT ? '' : dirtyPayload;
      } catch (_) {
        // Syntax error if dirtyPayload is invalid xml
      }
    }

    var body = doc.body || doc.documentElement;

    if (dirty && leadingWhitespace) {
      body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);
    }

    /* Work on whole document or just its body */
    if (NAMESPACE === HTML_NAMESPACE) {
      return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];
    }

    return WHOLE_DOCUMENT ? doc.documentElement : body;
  };

  /**
   * _createIterator
   *
   * @param  {Document} root document/fragment to create iterator for
   * @return {Iterator} iterator instance
   */
  var _createIterator = function _createIterator(root) {
    return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);
  };

  /**
   * _isClobbered
   *
   * @param  {Node} elm element to check for clobbering attacks
   * @return {Boolean} true if clobbered, false if safe
   */
  var _isClobbered = function _isClobbered(elm) {
    if (elm instanceof Text || elm instanceof Comment) {
      return false;
    }

    if (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string' || typeof elm.insertBefore !== 'function') {
      return true;
    }

    return false;
  };

  /**
   * _isNode
   *
   * @param  {Node} obj object to check whether it's a DOM node
   * @return {Boolean} true is object is a DOM node
   */
  var _isNode = function _isNode(object) {
    return (typeof Node === 'undefined' ? 'undefined' : _typeof(Node)) === 'object' ? object instanceof Node : object && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string';
  };

  /**
   * _executeHook
   * Execute user configurable hooks
   *
   * @param  {String} entryPoint  Name of the hook's entry point
   * @param  {Node} currentNode node to work on with the hook
   * @param  {Object} data additional hook parameters
   */
  var _executeHook = function _executeHook(entryPoint, currentNode, data) {
    if (!hooks[entryPoint]) {
      return;
    }

    arrayForEach(hooks[entryPoint], function (hook) {
      hook.call(DOMPurify, currentNode, data, CONFIG);
    });
  };

  /**
   * _sanitizeElements
   *
   * @protect nodeName
   * @protect textContent
   * @protect removeChild
   *
   * @param   {Node} currentNode to check for permission to exist
   * @return  {Boolean} true if node was killed, false if left alive
   */
  var _sanitizeElements = function _sanitizeElements(currentNode) {
    var content = void 0;

    /* Execute a hook if present */
    _executeHook('beforeSanitizeElements', currentNode, null);

    /* Check if element is clobbered or can clobber */
    if (_isClobbered(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }

    /* Check if tagname contains Unicode */
    if (stringMatch(currentNode.nodeName, /[\u0080-\uFFFF]/)) {
      _forceRemove(currentNode);
      return true;
    }

    /* Now let's check the element's type and name */
    var tagName = stringToLowerCase(currentNode.nodeName);

    /* Execute a hook if present */
    _executeHook('uponSanitizeElement', currentNode, {
      tagName: tagName,
      allowedTags: ALLOWED_TAGS
    });

    /* Detect mXSS attempts abusing namespace confusion */
    if (!_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
      _forceRemove(currentNode);
      return true;
    }

    /* Mitigate a problem with templates inside select */
    if (tagName === 'select' && regExpTest(/<template/i, currentNode.innerHTML)) {
      _forceRemove(currentNode);
      return true;
    }

    /* Remove element if anything forbids its presence */
    if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
      /* Keep content except for bad-listed elements */
      if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
        var parentNode = getParentNode(currentNode) || currentNode.parentNode;
        var childNodes = getChildNodes(currentNode) || currentNode.childNodes;

        if (childNodes && parentNode) {
          var childCount = childNodes.length;

          for (var i = childCount - 1; i >= 0; --i) {
            parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));
          }
        }
      }

      _forceRemove(currentNode);
      return true;
    }

    /* Check whether element has a valid namespace */
    if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }

    if ((tagName === 'noscript' || tagName === 'noembed') && regExpTest(/<\/no(script|embed)/i, currentNode.innerHTML)) {
      _forceRemove(currentNode);
      return true;
    }

    /* Sanitize element content to be template-safe */
    if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
      /* Get the element's text content */
      content = currentNode.textContent;
      content = stringReplace(content, MUSTACHE_EXPR$$1, ' ');
      content = stringReplace(content, ERB_EXPR$$1, ' ');
      if (currentNode.textContent !== content) {
        arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() });
        currentNode.textContent = content;
      }
    }

    /* Execute a hook if present */
    _executeHook('afterSanitizeElements', currentNode, null);

    return false;
  };

  /**
   * _isValidAttribute
   *
   * @param  {string} lcTag Lowercase tag name of containing element.
   * @param  {string} lcName Lowercase attribute name.
   * @param  {string} value Attribute value.
   * @return {Boolean} Returns true if `value` is valid, otherwise false.
   */
  // eslint-disable-next-line complexity
  var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {
    /* Make sure attribute cannot clobber */
    if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {
      return false;
    }

    /* Allow valid data-* attributes: At least one character after "-"
        (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)
        XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)
        We don't need to check the value; it's always URI safe. */
    if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$$1, lcName)) ; else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$$1, lcName)) ; else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
      return false;

      /* Check value is safe. First, is attr inert? If so, is safe */
    } else if (URI_SAFE_ATTRIBUTES[lcName]) ; else if (regExpTest(IS_ALLOWED_URI$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) ; else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ; else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) ; else if (!value) ; else {
      return false;
    }

    return true;
  };

  /**
   * _sanitizeAttributes
   *
   * @protect attributes
   * @protect nodeName
   * @protect removeAttribute
   * @protect setAttribute
   *
   * @param  {Node} currentNode to sanitize
   */
  var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {
    var attr = void 0;
    var value = void 0;
    var lcName = void 0;
    var l = void 0;
    /* Execute a hook if present */
    _executeHook('beforeSanitizeAttributes', currentNode, null);

    var attributes = currentNode.attributes;

    /* Check if we have attributes; if not we might have a text node */

    if (!attributes) {
      return;
    }

    var hookEvent = {
      attrName: '',
      attrValue: '',
      keepAttr: true,
      allowedAttributes: ALLOWED_ATTR
    };
    l = attributes.length;

    /* Go backwards over all attributes; safely remove bad ones */
    while (l--) {
      attr = attributes[l];
      var _attr = attr,
          name = _attr.name,
          namespaceURI = _attr.namespaceURI;

      value = stringTrim(attr.value);
      lcName = stringToLowerCase(name);

      /* Execute a hook if present */
      hookEvent.attrName = lcName;
      hookEvent.attrValue = value;
      hookEvent.keepAttr = true;
      hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set
      _executeHook('uponSanitizeAttribute', currentNode, hookEvent);
      value = hookEvent.attrValue;
      /* Did the hooks approve of the attribute? */
      if (hookEvent.forceKeepAttr) {
        continue;
      }

      /* Remove attribute */
      _removeAttribute(name, currentNode);

      /* Did the hooks approve of the attribute? */
      if (!hookEvent.keepAttr) {
        continue;
      }

      /* Work around a security issue in jQuery 3.0 */
      if (regExpTest(/\/>/i, value)) {
        _removeAttribute(name, currentNode);
        continue;
      }

      /* Sanitize attribute content to be template-safe */
      if (SAFE_FOR_TEMPLATES) {
        value = stringReplace(value, MUSTACHE_EXPR$$1, ' ');
        value = stringReplace(value, ERB_EXPR$$1, ' ');
      }

      /* Is `value` valid for this attribute? */
      var lcTag = currentNode.nodeName.toLowerCase();
      if (!_isValidAttribute(lcTag, lcName, value)) {
        continue;
      }

      /* Handle invalid data-* attribute set by try-catching it */
      try {
        if (namespaceURI) {
          currentNode.setAttributeNS(namespaceURI, name, value);
        } else {
          /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. "x-schema". */
          currentNode.setAttribute(name, value);
        }

        arrayPop(DOMPurify.removed);
      } catch (_) {}
    }

    /* Execute a hook if present */
    _executeHook('afterSanitizeAttributes', currentNode, null);
  };

  /**
   * _sanitizeShadowDOM
   *
   * @param  {DocumentFragment} fragment to iterate over recursively
   */
  var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {
    var shadowNode = void 0;
    var shadowIterator = _createIterator(fragment);

    /* Execute a hook if present */
    _executeHook('beforeSanitizeShadowDOM', fragment, null);

    while (shadowNode = shadowIterator.nextNode()) {
      /* Execute a hook if present */
      _executeHook('uponSanitizeShadowNode', shadowNode, null);

      /* Sanitize tags and elements */
      if (_sanitizeElements(shadowNode)) {
        continue;
      }

      /* Deep shadow DOM detected */
      if (shadowNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM(shadowNode.content);
      }

      /* Check attributes, sanitize if necessary */
      _sanitizeAttributes(shadowNode);
    }

    /* Execute a hook if present */
    _executeHook('afterSanitizeShadowDOM', fragment, null);
  };

  /**
   * Sanitize
   * Public method providing core sanitation functionality
   *
   * @param {String|Node} dirty string or DOM node
   * @param {Object} configuration object
   */
  // eslint-disable-next-line complexity
  DOMPurify.sanitize = function (dirty, cfg) {
    var body = void 0;
    var importedNode = void 0;
    var currentNode = void 0;
    var oldNode = void 0;
    var returnNode = void 0;
    /* Make sure we have a string to sanitize.
      DO NOT return early, as this will return the wrong type if
      the user has requested a DOM object rather than a string */
    IS_EMPTY_INPUT = !dirty;
    if (IS_EMPTY_INPUT) {
      dirty = '<!-->';
    }

    /* Stringify, in case dirty is an object */
    if (typeof dirty !== 'string' && !_isNode(dirty)) {
      // eslint-disable-next-line no-negated-condition
      if (typeof dirty.toString !== 'function') {
        throw typeErrorCreate('toString is not a function');
      } else {
        dirty = dirty.toString();
        if (typeof dirty !== 'string') {
          throw typeErrorCreate('dirty is not a string, aborting');
        }
      }
    }

    /* Check we can run. Otherwise fall back or ignore */
    if (!DOMPurify.isSupported) {
      if (_typeof(window.toStaticHTML) === 'object' || typeof window.toStaticHTML === 'function') {
        if (typeof dirty === 'string') {
          return window.toStaticHTML(dirty);
        }

        if (_isNode(dirty)) {
          return window.toStaticHTML(dirty.outerHTML);
        }
      }

      return dirty;
    }

    /* Assign config vars */
    if (!SET_CONFIG) {
      _parseConfig(cfg);
    }

    /* Clean up removed elements */
    DOMPurify.removed = [];

    /* Check if dirty is correctly typed for IN_PLACE */
    if (typeof dirty === 'string') {
      IN_PLACE = false;
    }

    if (IN_PLACE) ; else if (dirty instanceof Node) {
      /* If dirty is a DOM element, append to an empty document to avoid
         elements being stripped by the parser */
      body = _initDocument('<!---->');
      importedNode = body.ownerDocument.importNode(dirty, true);
      if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {
        /* Node is already a body, use as is */
        body = importedNode;
      } else if (importedNode.nodeName === 'HTML') {
        body = importedNode;
      } else {
        // eslint-disable-next-line unicorn/prefer-dom-node-append
        body.appendChild(importedNode);
      }
    } else {
      /* Exit directly if we have nothing to do */
      if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT &&
      // eslint-disable-next-line unicorn/prefer-includes
      dirty.indexOf('<') === -1) {
        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
      }

      /* Initialize the document to work on */
      body = _initDocument(dirty);

      /* Check we have a DOM node from the data */
      if (!body) {
        return RETURN_DOM ? null : emptyHTML;
      }
    }

    /* Remove first element node (ours) if FORCE_BODY is set */
    if (body && FORCE_BODY) {
      _forceRemove(body.firstChild);
    }

    /* Get node iterator */
    var nodeIterator = _createIterator(IN_PLACE ? dirty : body);

    /* Now start iterating over the created document */
    while (currentNode = nodeIterator.nextNode()) {
      /* Fix IE's strange behavior with manipulated textNodes #89 */
      if (currentNode.nodeType === 3 && currentNode === oldNode) {
        continue;
      }

      /* Sanitize tags and elements */
      if (_sanitizeElements(currentNode)) {
        continue;
      }

      /* Shadow DOM detected, sanitize it */
      if (currentNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM(currentNode.content);
      }

      /* Check attributes, sanitize if necessary */
      _sanitizeAttributes(currentNode);

      oldNode = currentNode;
    }

    oldNode = null;

    /* If we sanitized `dirty` in-place, return it. */
    if (IN_PLACE) {
      return dirty;
    }

    /* Return sanitized string or DOM */
    if (RETURN_DOM) {
      if (RETURN_DOM_FRAGMENT) {
        returnNode = createDocumentFragment.call(body.ownerDocument);

        while (body.firstChild) {
          // eslint-disable-next-line unicorn/prefer-dom-node-append
          returnNode.appendChild(body.firstChild);
        }
      } else {
        returnNode = body;
      }

      if (RETURN_DOM_IMPORT) {
        /*
          AdoptNode() is not used because internal state is not reset
          (e.g. the past names map of a HTMLFormElement), this is safe
          in theory but we would rather not risk another attack vector.
          The state that is cloned by importNode() is explicitly defined
          by the specs.
        */
        returnNode = importNode.call(originalDocument, returnNode, true);
      }

      return returnNode;
    }

    var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;

    /* Sanitize final string template-safe */
    if (SAFE_FOR_TEMPLATES) {
      serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$$1, ' ');
      serializedHTML = stringReplace(serializedHTML, ERB_EXPR$$1, ' ');
    }

    return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
  };

  /**
   * Public method to set the configuration once
   * setConfig
   *
   * @param {Object} cfg configuration object
   */
  DOMPurify.setConfig = function (cfg) {
    _parseConfig(cfg);
    SET_CONFIG = true;
  };

  /**
   * Public method to remove the configuration
   * clearConfig
   *
   */
  DOMPurify.clearConfig = function () {
    CONFIG = null;
    SET_CONFIG = false;
  };

  /**
   * Public method to check if an attribute value is valid.
   * Uses last set config, if any. Otherwise, uses config defaults.
   * isValidAttribute
   *
   * @param  {string} tag Tag name of containing element.
   * @param  {string} attr Attribute name.
   * @param  {string} value Attribute value.
   * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.
   */
  DOMPurify.isValidAttribute = function (tag, attr, value) {
    /* Initialize shared config vars if necessary. */
    if (!CONFIG) {
      _parseConfig({});
    }

    var lcTag = stringToLowerCase(tag);
    var lcName = stringToLowerCase(attr);
    return _isValidAttribute(lcTag, lcName, value);
  };

  /**
   * AddHook
   * Public method to add DOMPurify hooks
   *
   * @param {String} entryPoint entry point for the hook to add
   * @param {Function} hookFunction function to execute
   */
  DOMPurify.addHook = function (entryPoint, hookFunction) {
    if (typeof hookFunction !== 'function') {
      return;
    }

    hooks[entryPoint] = hooks[entryPoint] || [];
    arrayPush(hooks[entryPoint], hookFunction);
  };

  /**
   * RemoveHook
   * Public method to remove a DOMPurify hook at a given entryPoint
   * (pops it from the stack of hooks if more are present)
   *
   * @param {String} entryPoint entry point for the hook to remove
   */
  DOMPurify.removeHook = function (entryPoint) {
    if (hooks[entryPoint]) {
      arrayPop(hooks[entryPoint]);
    }
  };

  /**
   * RemoveHooks
   * Public method to remove all DOMPurify hooks at a given entryPoint
   *
   * @param  {String} entryPoint entry point for the hooks to remove
   */
  DOMPurify.removeHooks = function (entryPoint) {
    if (hooks[entryPoint]) {
      hooks[entryPoint] = [];
    }
  };

  /**
   * RemoveAllHooks
   * Public method to remove all DOMPurify hooks
   *
   */
  DOMPurify.removeAllHooks = function () {
    hooks = {};
  };

  return DOMPurify;
}

var purify = createDOMPurify();

// ESM-comment-begin
!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () { return purify; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
// ESM-comment-end

// ESM-uncomment-begin
// export default purify;
// export const version = purify.version;
// export const isSupported = purify.isSupported;
// export const sanitize = purify.sanitize;
// export const setConfig = purify.setConfig;
// export const clearConfig = purify.clearConfig;
// export const isValidAttribute = purify.isValidAttribute;
// export const addHook = purify.addHook;
// export const removeHook = purify.removeHook;
// export const removeHooks = purify.removeHooks;
// export const removeAllHooks = purify.removeAllHooks;
// ESM-uncomment-end


/***/ }),
/* 84 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Mimes": () => (/* binding */ Mimes),
/* harmony export */   "getMediaOrTextMime": () => (/* binding */ getMediaOrTextMime),
/* harmony export */   "getMediaMime": () => (/* binding */ getMediaMime),
/* harmony export */   "getExtensionForMimeType": () => (/* binding */ getExtensionForMimeType),
/* harmony export */   "normalizeMimeType": () => (/* binding */ normalizeMimeType)
/* harmony export */ });
/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(73);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

const Mimes = Object.freeze({
  text: 'text/plain',
  binary: 'application/octet-stream',
  unknown: 'application/unknown',
  markdown: 'text/markdown',
  latex: 'text/latex',
  uriList: 'text/uri-list'
});
const mapExtToTextMimes = {
  '.css': 'text/css',
  '.csv': 'text/csv',
  '.htm': 'text/html',
  '.html': 'text/html',
  '.ics': 'text/calendar',
  '.js': 'text/javascript',
  '.mjs': 'text/javascript',
  '.txt': 'text/plain',
  '.xml': 'text/xml'
}; // Known media mimes that we can handle

const mapExtToMediaMimes = {
  '.aac': 'audio/x-aac',
  '.avi': 'video/x-msvideo',
  '.bmp': 'image/bmp',
  '.flv': 'video/x-flv',
  '.gif': 'image/gif',
  '.ico': 'image/x-icon',
  '.jpe': 'image/jpg',
  '.jpeg': 'image/jpg',
  '.jpg': 'image/jpg',
  '.m1v': 'video/mpeg',
  '.m2a': 'audio/mpeg',
  '.m2v': 'video/mpeg',
  '.m3a': 'audio/mpeg',
  '.mid': 'audio/midi',
  '.midi': 'audio/midi',
  '.mk3d': 'video/x-matroska',
  '.mks': 'video/x-matroska',
  '.mkv': 'video/x-matroska',
  '.mov': 'video/quicktime',
  '.movie': 'video/x-sgi-movie',
  '.mp2': 'audio/mpeg',
  '.mp2a': 'audio/mpeg',
  '.mp3': 'audio/mpeg',
  '.mp4': 'video/mp4',
  '.mp4a': 'audio/mp4',
  '.mp4v': 'video/mp4',
  '.mpe': 'video/mpeg',
  '.mpeg': 'video/mpeg',
  '.mpg': 'video/mpeg',
  '.mpg4': 'video/mp4',
  '.mpga': 'audio/mpeg',
  '.oga': 'audio/ogg',
  '.ogg': 'audio/ogg',
  '.opus': 'audio/opus',
  '.ogv': 'video/ogg',
  '.png': 'image/png',
  '.psd': 'image/vnd.adobe.photoshop',
  '.qt': 'video/quicktime',
  '.spx': 'audio/ogg',
  '.svg': 'image/svg+xml',
  '.tga': 'image/x-tga',
  '.tif': 'image/tiff',
  '.tiff': 'image/tiff',
  '.wav': 'audio/x-wav',
  '.webm': 'video/webm',
  '.webp': 'image/webp',
  '.wma': 'audio/x-ms-wma',
  '.wmv': 'video/x-ms-wmv',
  '.woff': 'application/font-woff'
};
function getMediaOrTextMime(path) {
  const ext = (0,_path__WEBPACK_IMPORTED_MODULE_0__.extname)(path);
  const textMime = mapExtToTextMimes[ext.toLowerCase()];

  if (textMime !== undefined) {
    return textMime;
  } else {
    return getMediaMime(path);
  }
}
function getMediaMime(path) {
  const ext = (0,_path__WEBPACK_IMPORTED_MODULE_0__.extname)(path);
  return mapExtToMediaMimes[ext.toLowerCase()];
}
function getExtensionForMimeType(mimeType) {
  for (const extension in mapExtToMediaMimes) {
    if (mapExtToMediaMimes[extension] === mimeType) {
      return extension;
    }
  }

  return undefined;
}
const _simplePattern = /^(.+)\/(.+?)(;.+)?$/;
function normalizeMimeType(mimeType, strict) {
  const match = _simplePattern.exec(mimeType);

  if (!match) {
    return strict ? undefined : mimeType;
  } // https://datatracker.ietf.org/doc/html/rfc2045#section-5.1
  // media and subtype must ALWAYS be lowercase, parameter not


  return `${match[1].toLowerCase()}/${match[2].toLowerCase()}${match[3] ?? ''}`;
}

/***/ }),
/* 85 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DomEmitter": () => (/* binding */ DomEmitter)
/* harmony export */ });
/* harmony import */ var _common_event__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(51);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

class DomEmitter {
  get event() {
    return this.emitter.event;
  }

  constructor(element, type, useCapture) {
    const fn = e => this.emitter.fire(e);

    this.emitter = new _common_event__WEBPACK_IMPORTED_MODULE_0__.Emitter({
      onFirstListenerAdd: () => element.addEventListener(type, fn, useCapture),
      onLastListenerRemove: () => element.removeEventListener(type, fn, useCapture)
    });
  }

  dispose() {
    this.emitter.dispose();
  }

}

/***/ }),
/* 86 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EventType": () => (/* binding */ EventType),
/* harmony export */   "Gesture": () => (/* binding */ Gesture)
/* harmony export */ });
/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(61);
/* harmony import */ var _common_arrays__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(87);
/* harmony import */ var _common_decorators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(88);
/* harmony import */ var _common_lifecycle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(54);
var _class;

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/




let EventType;

(function (_EventType) {
  const Tap = _EventType.Tap = '-monaco-gesturetap';
  const Change = _EventType.Change = '-monaco-gesturechange';
  const Start = _EventType.Start = '-monaco-gesturestart';
  const End = _EventType.End = '-monaco-gesturesend';
  const Contextmenu = _EventType.Contextmenu = '-monaco-gesturecontextmenu';
})(EventType || (EventType = {}));

let Gesture = (_class = class Gesture extends _common_lifecycle__WEBPACK_IMPORTED_MODULE_3__.Disposable {
  static SCROLL_FRICTION = -0.005;
  static HOLD_DELAY = 700;
  dispatched = false;
  static CLEAR_TAP_COUNT_TIME = 400; // ms

  constructor() {
    super();
    this.activeTouches = {};
    this.handle = null;
    this.targets = [];
    this.ignoreTargets = [];
    this._lastSetTapCountTime = 0;

    this._register(_dom__WEBPACK_IMPORTED_MODULE_0__.addDisposableListener(document, 'touchstart', e => this.onTouchStart(e), {
      passive: false
    }));

    this._register(_dom__WEBPACK_IMPORTED_MODULE_0__.addDisposableListener(document, 'touchend', e => this.onTouchEnd(e)));

    this._register(_dom__WEBPACK_IMPORTED_MODULE_0__.addDisposableListener(document, 'touchmove', e => this.onTouchMove(e), {
      passive: false
    }));
  }

  static addTarget(element) {
    if (!Gesture.isTouchDevice()) {
      return _common_lifecycle__WEBPACK_IMPORTED_MODULE_3__.Disposable.None;
    }

    if (!Gesture.INSTANCE) {
      Gesture.INSTANCE = new Gesture();
    }

    Gesture.INSTANCE.targets.push(element);
    return {
      dispose: () => {
        Gesture.INSTANCE.targets = Gesture.INSTANCE.targets.filter(t => t !== element);
      }
    };
  }

  static ignoreTarget(element) {
    if (!Gesture.isTouchDevice()) {
      return _common_lifecycle__WEBPACK_IMPORTED_MODULE_3__.Disposable.None;
    }

    if (!Gesture.INSTANCE) {
      Gesture.INSTANCE = new Gesture();
    }

    Gesture.INSTANCE.ignoreTargets.push(element);
    return {
      dispose: () => {
        Gesture.INSTANCE.ignoreTargets = Gesture.INSTANCE.ignoreTargets.filter(t => t !== element);
      }
    };
  }

  static isTouchDevice() {
    // `'ontouchstart' in window` always evaluates to true with typescript's modern typings. This causes `window` to be
    // `never` later in `window.navigator`. That's why we need the explicit `window as Window` cast
    return 'ontouchstart' in window || navigator.maxTouchPoints > 0;
  }

  dispose() {
    if (this.handle) {
      this.handle.dispose();
      this.handle = null;
    }

    super.dispose();
  }

  onTouchStart(e) {
    const timestamp = Date.now(); // use Date.now() because on FF e.timeStamp is not epoch based.

    if (this.handle) {
      this.handle.dispose();
      this.handle = null;
    }

    for (let i = 0, len = e.targetTouches.length; i < len; i++) {
      const touch = e.targetTouches.item(i);
      this.activeTouches[touch.identifier] = {
        id: touch.identifier,
        initialTarget: touch.target,
        initialTimeStamp: timestamp,
        initialPageX: touch.pageX,
        initialPageY: touch.pageY,
        rollingTimestamps: [timestamp],
        rollingPageX: [touch.pageX],
        rollingPageY: [touch.pageY]
      };
      const evt = this.newGestureEvent(EventType.Start, touch.target);
      evt.pageX = touch.pageX;
      evt.pageY = touch.pageY;
      this.dispatchEvent(evt);
    }

    if (this.dispatched) {
      e.preventDefault();
      e.stopPropagation();
      this.dispatched = false;
    }
  }

  onTouchEnd(e) {
    const timestamp = Date.now(); // use Date.now() because on FF e.timeStamp is not epoch based.

    const activeTouchCount = Object.keys(this.activeTouches).length;

    for (let i = 0, len = e.changedTouches.length; i < len; i++) {
      const touch = e.changedTouches.item(i);

      if (!this.activeTouches.hasOwnProperty(String(touch.identifier))) {
        console.warn('move of an UNKNOWN touch', touch);
        continue;
      }

      const data = this.activeTouches[touch.identifier],
            holdTime = Date.now() - data.initialTimeStamp;

      if (holdTime < Gesture.HOLD_DELAY && Math.abs(data.initialPageX - _common_arrays__WEBPACK_IMPORTED_MODULE_1__.tail(data.rollingPageX)) < 30 && Math.abs(data.initialPageY - _common_arrays__WEBPACK_IMPORTED_MODULE_1__.tail(data.rollingPageY)) < 30) {
        const evt = this.newGestureEvent(EventType.Tap, data.initialTarget);
        evt.pageX = _common_arrays__WEBPACK_IMPORTED_MODULE_1__.tail(data.rollingPageX);
        evt.pageY = _common_arrays__WEBPACK_IMPORTED_MODULE_1__.tail(data.rollingPageY);
        this.dispatchEvent(evt);
      } else if (holdTime >= Gesture.HOLD_DELAY && Math.abs(data.initialPageX - _common_arrays__WEBPACK_IMPORTED_MODULE_1__.tail(data.rollingPageX)) < 30 && Math.abs(data.initialPageY - _common_arrays__WEBPACK_IMPORTED_MODULE_1__.tail(data.rollingPageY)) < 30) {
        const evt = this.newGestureEvent(EventType.Contextmenu, data.initialTarget);
        evt.pageX = _common_arrays__WEBPACK_IMPORTED_MODULE_1__.tail(data.rollingPageX);
        evt.pageY = _common_arrays__WEBPACK_IMPORTED_MODULE_1__.tail(data.rollingPageY);
        this.dispatchEvent(evt);
      } else if (activeTouchCount === 1) {
        const finalX = _common_arrays__WEBPACK_IMPORTED_MODULE_1__.tail(data.rollingPageX);
        const finalY = _common_arrays__WEBPACK_IMPORTED_MODULE_1__.tail(data.rollingPageY);
        const deltaT = _common_arrays__WEBPACK_IMPORTED_MODULE_1__.tail(data.rollingTimestamps) - data.rollingTimestamps[0];
        const deltaX = finalX - data.rollingPageX[0];
        const deltaY = finalY - data.rollingPageY[0]; // We need to get all the dispatch targets on the start of the inertia event

        const dispatchTo = this.targets.filter(t => data.initialTarget instanceof Node && t.contains(data.initialTarget));
        this.inertia(dispatchTo, timestamp, // time now
        Math.abs(deltaX) / deltaT, // speed
        deltaX > 0 ? 1 : -1, // x direction
        finalX, // x now
        Math.abs(deltaY) / deltaT, // y speed
        deltaY > 0 ? 1 : -1, // y direction
        finalY // y now
        );
      }

      this.dispatchEvent(this.newGestureEvent(EventType.End, data.initialTarget)); // forget about this touch

      delete this.activeTouches[touch.identifier];
    }

    if (this.dispatched) {
      e.preventDefault();
      e.stopPropagation();
      this.dispatched = false;
    }
  }

  newGestureEvent(type, initialTarget) {
    const event = document.createEvent('CustomEvent');
    event.initEvent(type, false, true);
    event.initialTarget = initialTarget;
    event.tapCount = 0;
    return event;
  }

  dispatchEvent(event) {
    if (event.type === EventType.Tap) {
      const currentTime = new Date().getTime();
      let setTapCount = 0;

      if (currentTime - this._lastSetTapCountTime > Gesture.CLEAR_TAP_COUNT_TIME) {
        setTapCount = 1;
      } else {
        setTapCount = 2;
      }

      this._lastSetTapCountTime = currentTime;
      event.tapCount = setTapCount;
    } else if (event.type === EventType.Change || event.type === EventType.Contextmenu) {
      // tap is canceled by scrolling or context menu
      this._lastSetTapCountTime = 0;
    }

    for (let i = 0; i < this.ignoreTargets.length; i++) {
      if (event.initialTarget instanceof Node && this.ignoreTargets[i].contains(event.initialTarget)) {
        return;
      }
    }

    this.targets.forEach(target => {
      if (event.initialTarget instanceof Node && target.contains(event.initialTarget)) {
        target.dispatchEvent(event);
        this.dispatched = true;
      }
    });
  }

  inertia(dispatchTo, t1, vX, dirX, x, vY, dirY, y) {
    this.handle = _dom__WEBPACK_IMPORTED_MODULE_0__.scheduleAtNextAnimationFrame(() => {
      const now = Date.now(); // velocity: old speed + accel_over_time

      const deltaT = now - t1;
      let delta_pos_x = 0,
          delta_pos_y = 0;
      let stopped = true;
      vX += Gesture.SCROLL_FRICTION * deltaT;
      vY += Gesture.SCROLL_FRICTION * deltaT;

      if (vX > 0) {
        stopped = false;
        delta_pos_x = dirX * vX * deltaT;
      }

      if (vY > 0) {
        stopped = false;
        delta_pos_y = dirY * vY * deltaT;
      } // dispatch translation event


      const evt = this.newGestureEvent(EventType.Change);
      evt.translationX = delta_pos_x;
      evt.translationY = delta_pos_y;
      dispatchTo.forEach(d => d.dispatchEvent(evt));

      if (!stopped) {
        this.inertia(dispatchTo, now, vX, dirX, x + delta_pos_x, vY, dirY, y + delta_pos_y);
      }
    });
  }

  onTouchMove(e) {
    const timestamp = Date.now(); // use Date.now() because on FF e.timeStamp is not epoch based.

    for (let i = 0, len = e.changedTouches.length; i < len; i++) {
      const touch = e.changedTouches.item(i);

      if (!this.activeTouches.hasOwnProperty(String(touch.identifier))) {
        console.warn('end of an UNKNOWN touch', touch);
        continue;
      }

      const data = this.activeTouches[touch.identifier];
      const evt = this.newGestureEvent(EventType.Change, data.initialTarget);
      evt.translationX = touch.pageX - _common_arrays__WEBPACK_IMPORTED_MODULE_1__.tail(data.rollingPageX);
      evt.translationY = touch.pageY - _common_arrays__WEBPACK_IMPORTED_MODULE_1__.tail(data.rollingPageY);
      evt.pageX = touch.pageX;
      evt.pageY = touch.pageY;
      this.dispatchEvent(evt); // only keep a few data points, to average the final speed

      if (data.rollingPageX.length > 3) {
        data.rollingPageX.shift();
        data.rollingPageY.shift();
        data.rollingTimestamps.shift();
      }

      data.rollingPageX.push(touch.pageX);
      data.rollingPageY.push(touch.pageY);
      data.rollingTimestamps.push(timestamp);
    }

    if (this.dispatched) {
      e.preventDefault();
      e.stopPropagation();
      this.dispatched = false;
    }
  }

}, (_applyDecoratedDescriptor(_class, "isTouchDevice", [_common_decorators__WEBPACK_IMPORTED_MODULE_2__.memoize], Object.getOwnPropertyDescriptor(_class, "isTouchDevice"), _class)), _class);

/***/ }),
/* 87 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "tail": () => (/* binding */ tail),
/* harmony export */   "tail2": () => (/* binding */ tail2),
/* harmony export */   "equals": () => (/* binding */ equals),
/* harmony export */   "removeFastWithoutKeepingOrder": () => (/* binding */ removeFastWithoutKeepingOrder),
/* harmony export */   "binarySearch": () => (/* binding */ binarySearch),
/* harmony export */   "binarySearch2": () => (/* binding */ binarySearch2),
/* harmony export */   "findFirstInSorted": () => (/* binding */ findFirstInSorted),
/* harmony export */   "quickSelect": () => (/* binding */ quickSelect),
/* harmony export */   "groupBy": () => (/* binding */ groupBy),
/* harmony export */   "sortedDiff": () => (/* binding */ sortedDiff),
/* harmony export */   "delta": () => (/* binding */ delta),
/* harmony export */   "top": () => (/* binding */ top),
/* harmony export */   "topAsync": () => (/* binding */ topAsync),
/* harmony export */   "coalesce": () => (/* binding */ coalesce),
/* harmony export */   "coalesceInPlace": () => (/* binding */ coalesceInPlace),
/* harmony export */   "move": () => (/* binding */ move),
/* harmony export */   "isFalsyOrEmpty": () => (/* binding */ isFalsyOrEmpty),
/* harmony export */   "isNonEmptyArray": () => (/* binding */ isNonEmptyArray),
/* harmony export */   "distinct": () => (/* binding */ distinct),
/* harmony export */   "uniqueFilter": () => (/* binding */ uniqueFilter),
/* harmony export */   "findLast": () => (/* binding */ findLast),
/* harmony export */   "lastIndex": () => (/* binding */ lastIndex),
/* harmony export */   "firstOrDefault": () => (/* binding */ firstOrDefault),
/* harmony export */   "lastOrDefault": () => (/* binding */ lastOrDefault),
/* harmony export */   "commonPrefixLength": () => (/* binding */ commonPrefixLength),
/* harmony export */   "flatten": () => (/* binding */ flatten),
/* harmony export */   "range": () => (/* binding */ range),
/* harmony export */   "index": () => (/* binding */ index),
/* harmony export */   "insert": () => (/* binding */ insert),
/* harmony export */   "remove": () => (/* binding */ remove),
/* harmony export */   "arrayInsert": () => (/* binding */ arrayInsert),
/* harmony export */   "shuffle": () => (/* binding */ shuffle),
/* harmony export */   "pushToStart": () => (/* binding */ pushToStart),
/* harmony export */   "pushToEnd": () => (/* binding */ pushToEnd),
/* harmony export */   "pushMany": () => (/* binding */ pushMany),
/* harmony export */   "mapArrayOrNot": () => (/* binding */ mapArrayOrNot),
/* harmony export */   "asArray": () => (/* binding */ asArray),
/* harmony export */   "getRandomElement": () => (/* binding */ getRandomElement),
/* harmony export */   "mapFind": () => (/* binding */ mapFind),
/* harmony export */   "insertInto": () => (/* binding */ insertInto),
/* harmony export */   "splice": () => (/* binding */ splice),
/* harmony export */   "CompareResult": () => (/* binding */ CompareResult),
/* harmony export */   "compareBy": () => (/* binding */ compareBy),
/* harmony export */   "tieBreakComparators": () => (/* binding */ tieBreakComparators),
/* harmony export */   "numberComparator": () => (/* binding */ numberComparator),
/* harmony export */   "findMaxBy": () => (/* binding */ findMaxBy),
/* harmony export */   "findLastMaxBy": () => (/* binding */ findLastMaxBy),
/* harmony export */   "findMinBy": () => (/* binding */ findMinBy),
/* harmony export */   "ArrayQueue": () => (/* binding */ ArrayQueue),
/* harmony export */   "CallbackIterable": () => (/* binding */ CallbackIterable)
/* harmony export */ });
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


/**
 * Returns the last element of an array.
 * @param array The array.
 * @param n Which element from the end (default is zero).
 */
function tail(array, n = 0) {
  return array[array.length - (1 + n)];
}
function tail2(arr) {
  if (arr.length === 0) {
    throw new Error('Invalid tail call');
  }

  return [arr.slice(0, arr.length - 1), arr[arr.length - 1]];
}
function equals(one, other, itemEquals = (a, b) => a === b) {
  if (one === other) {
    return true;
  }

  if (!one || !other) {
    return false;
  }

  if (one.length !== other.length) {
    return false;
  }

  for (let i = 0, len = one.length; i < len; i++) {
    if (!itemEquals(one[i], other[i])) {
      return false;
    }
  }

  return true;
}
/**
 * Remove the element at `index` by replacing it with the last element. This is faster than `splice`
 * but changes the order of the array
 */

function removeFastWithoutKeepingOrder(array, index) {
  const last = array.length - 1;

  if (index < last) {
    array[index] = array[last];
  }

  array.pop();
}
/**
 * Performs a binary search algorithm over a sorted array.
 *
 * @param array The array being searched.
 * @param key The value we search for.
 * @param comparator A function that takes two array elements and returns zero
 *   if they are equal, a negative number if the first element precedes the
 *   second one in the sorting order, or a positive number if the second element
 *   precedes the first one.
 * @return See {@link binarySearch2}
 */

function binarySearch(array, key, comparator) {
  return binarySearch2(array.length, i => comparator(array[i], key));
}
/**
 * Performs a binary search algorithm over a sorted collection. Useful for cases
 * when we need to perform a binary search over something that isn't actually an
 * array, and converting data to an array would defeat the use of binary search
 * in the first place.
 *
 * @param length The collection length.
 * @param compareToKey A function that takes an index of an element in the
 *   collection and returns zero if the value at this index is equal to the
 *   search key, a negative number if the value precedes the search key in the
 *   sorting order, or a positive number if the search key precedes the value.
 * @return A non-negative index of an element, if found. If not found, the
 *   result is -(n+1) (or ~n, using bitwise notation), where n is the index
 *   where the key should be inserted to maintain the sorting order.
 */

function binarySearch2(length, compareToKey) {
  let low = 0,
      high = length - 1;

  while (low <= high) {
    const mid = (low + high) / 2 | 0;
    const comp = compareToKey(mid);

    if (comp < 0) {
      low = mid + 1;
    } else if (comp > 0) {
      high = mid - 1;
    } else {
      return mid;
    }
  }

  return -(low + 1);
}
/**
 * Takes a sorted array and a function p. The array is sorted in such a way that all elements where p(x) is false
 * are located before all elements where p(x) is true.
 * @returns the least x for which p(x) is true or array.length if no element fullfills the given function.
 */

function findFirstInSorted(array, p) {
  let low = 0,
      high = array.length;

  if (high === 0) {
    return 0; // no children
  }

  while (low < high) {
    const mid = Math.floor((low + high) / 2);

    if (p(array[mid])) {
      high = mid;
    } else {
      low = mid + 1;
    }
  }

  return low;
}
function quickSelect(nth, data, compare) {
  nth = nth | 0;

  if (nth >= data.length) {
    throw new TypeError('invalid index');
  }

  const pivotValue = data[Math.floor(data.length * Math.random())];
  const lower = [];
  const higher = [];
  const pivots = [];

  for (const value of data) {
    const val = compare(value, pivotValue);

    if (val < 0) {
      lower.push(value);
    } else if (val > 0) {
      higher.push(value);
    } else {
      pivots.push(value);
    }
  }

  if (nth < lower.length) {
    return quickSelect(nth, lower, compare);
  } else if (nth < lower.length + pivots.length) {
    return pivots[0];
  } else {
    return quickSelect(nth - (lower.length + pivots.length), higher, compare);
  }
}
function groupBy(data, compare) {
  const result = [];
  let currentGroup = undefined;

  for (const element of data.slice(0).sort(compare)) {
    if (!currentGroup || compare(currentGroup[0], element) !== 0) {
      currentGroup = [element];
      result.push(currentGroup);
    } else {
      currentGroup.push(element);
    }
  }

  return result;
}

/**
 * Diffs two *sorted* arrays and computes the splices which apply the diff.
 */
function sortedDiff(before, after, compare) {
  const result = [];

  function pushSplice(start, deleteCount, toInsert) {
    if (deleteCount === 0 && toInsert.length === 0) {
      return;
    }

    const latest = result[result.length - 1];

    if (latest && latest.start + latest.deleteCount === start) {
      latest.deleteCount += deleteCount;
      latest.toInsert.push(...toInsert);
    } else {
      result.push({
        start,
        deleteCount,
        toInsert
      });
    }
  }

  let beforeIdx = 0;
  let afterIdx = 0;

  while (true) {
    if (beforeIdx === before.length) {
      pushSplice(beforeIdx, 0, after.slice(afterIdx));
      break;
    }

    if (afterIdx === after.length) {
      pushSplice(beforeIdx, before.length - beforeIdx, []);
      break;
    }

    const beforeElement = before[beforeIdx];
    const afterElement = after[afterIdx];
    const n = compare(beforeElement, afterElement);

    if (n === 0) {
      // equal
      beforeIdx += 1;
      afterIdx += 1;
    } else if (n < 0) {
      // beforeElement is smaller -> before element removed
      pushSplice(beforeIdx, 1, []);
      beforeIdx += 1;
    } else if (n > 0) {
      // beforeElement is greater -> after element added
      pushSplice(beforeIdx, 0, [afterElement]);
      afterIdx += 1;
    }
  }

  return result;
}
/**
 * Takes two *sorted* arrays and computes their delta (removed, added elements).
 * Finishes in `Math.min(before.length, after.length)` steps.
 */

function delta(before, after, compare) {
  const splices = sortedDiff(before, after, compare);
  const removed = [];
  const added = [];

  for (const splice of splices) {
    removed.push(...before.slice(splice.start, splice.start + splice.deleteCount));
    added.push(...splice.toInsert);
  }

  return {
    removed,
    added
  };
}
/**
 * Returns the top N elements from the array.
 *
 * Faster than sorting the entire array when the array is a lot larger than N.
 *
 * @param array The unsorted array.
 * @param compare A sort function for the elements.
 * @param n The number of elements to return.
 * @return The first n elements from array when sorted with compare.
 */

function top(array, compare, n) {
  if (n === 0) {
    return [];
  }

  const result = array.slice(0, n).sort(compare);
  topStep(array, compare, result, n, array.length);
  return result;
}
/**
 * Asynchronous variant of `top()` allowing for splitting up work in batches between which the event loop can run.
 *
 * Returns the top N elements from the array.
 *
 * Faster than sorting the entire array when the array is a lot larger than N.
 *
 * @param array The unsorted array.
 * @param compare A sort function for the elements.
 * @param n The number of elements to return.
 * @param batch The number of elements to examine before yielding to the event loop.
 * @return The first n elements from array when sorted with compare.
 */

function topAsync(array, compare, n, batch, token) {
  if (n === 0) {
    return Promise.resolve([]);
  }

  return new Promise((resolve, reject) => {
    (async () => {
      const o = array.length;
      const result = array.slice(0, n).sort(compare);

      for (let i = n, m = Math.min(n + batch, o); i < o; i = m, m = Math.min(m + batch, o)) {
        if (i > n) {
          await new Promise(resolve => setTimeout(resolve)); // any other delay function would starve I/O
        }

        if (token && token.isCancellationRequested) {
          throw new _errors__WEBPACK_IMPORTED_MODULE_0__.CancellationError();
        }

        topStep(array, compare, result, i, m);
      }

      return result;
    })().then(resolve, reject);
  });
}

function topStep(array, compare, result, i, m) {
  for (const n = result.length; i < m; i++) {
    const element = array[i];

    if (compare(element, result[n - 1]) < 0) {
      result.pop();
      const j = findFirstInSorted(result, e => compare(element, e) < 0);
      result.splice(j, 0, element);
    }
  }
}
/**
 * @returns New array with all falsy values removed. The original array IS NOT modified.
 */


function coalesce(array) {
  return array.filter(e => !!e);
}
/**
 * Remove all falsy values from `array`. The original array IS modified.
 */

function coalesceInPlace(array) {
  let to = 0;

  for (let i = 0; i < array.length; i++) {
    if (!!array[i]) {
      array[to] = array[i];
      to += 1;
    }
  }

  array.length = to;
}
/**
 * @deprecated Use `Array.copyWithin` instead
 */

function move(array, from, to) {
  array.splice(to, 0, array.splice(from, 1)[0]);
}
/**
 * @returns false if the provided object is an array and not empty.
 */

function isFalsyOrEmpty(obj) {
  return !Array.isArray(obj) || obj.length === 0;
}
/**
 * @returns True if the provided object is an array and has at least one element.
 */

function isNonEmptyArray(obj) {
  return Array.isArray(obj) && obj.length > 0;
}
/**
 * Removes duplicates from the given array. The optional keyFn allows to specify
 * how elements are checked for equality by returning an alternate value for each.
 */

function distinct(array, keyFn = value => value) {
  const seen = new Set();
  return array.filter(element => {
    const key = keyFn(element);

    if (seen.has(key)) {
      return false;
    }

    seen.add(key);
    return true;
  });
}
function uniqueFilter(keyFn) {
  const seen = new Set();
  return element => {
    const key = keyFn(element);

    if (seen.has(key)) {
      return false;
    }

    seen.add(key);
    return true;
  };
}
function findLast(arr, predicate) {
  const idx = lastIndex(arr, predicate);

  if (idx === -1) {
    return undefined;
  }

  return arr[idx];
}
function lastIndex(array, fn) {
  for (let i = array.length - 1; i >= 0; i--) {
    const element = array[i];

    if (fn(element)) {
      return i;
    }
  }

  return -1;
}
function firstOrDefault(array, notFoundValue) {
  return array.length > 0 ? array[0] : notFoundValue;
}
function lastOrDefault(array, notFoundValue) {
  return array.length > 0 ? array[array.length - 1] : notFoundValue;
}
function commonPrefixLength(one, other, equals = (a, b) => a === b) {
  let result = 0;

  for (let i = 0, len = Math.min(one.length, other.length); i < len && equals(one[i], other[i]); i++) {
    result++;
  }

  return result;
}
/**
 * @deprecated Use `[].flat()`
 */

function flatten(arr) {
  return [].concat(...arr);
}
function range(arg, to) {
  let from = typeof to === 'number' ? arg : 0;

  if (typeof to === 'number') {
    from = arg;
  } else {
    from = 0;
    to = arg;
  }

  const result = [];

  if (from <= to) {
    for (let i = from; i < to; i++) {
      result.push(i);
    }
  } else {
    for (let i = from; i > to; i--) {
      result.push(i);
    }
  }

  return result;
}
function index(array, indexer, mapper) {
  return array.reduce((r, t) => {
    r[indexer(t)] = mapper ? mapper(t) : t;
    return r;
  }, Object.create(null));
}
/**
 * Inserts an element into an array. Returns a function which, when
 * called, will remove that element from the array.
 *
 * @deprecated In almost all cases, use a `Set<T>` instead.
 */

function insert(array, element) {
  array.push(element);
  return () => remove(array, element);
}
/**
 * Removes an element from an array if it can be found.
 *
 * @deprecated In almost all cases, use a `Set<T>` instead.
 */

function remove(array, element) {
  const index = array.indexOf(element);

  if (index > -1) {
    array.splice(index, 1);
    return element;
  }

  return undefined;
}
/**
 * Insert `insertArr` inside `target` at `insertIndex`.
 * Please don't touch unless you understand https://jsperf.com/inserting-an-array-within-an-array
 */

function arrayInsert(target, insertIndex, insertArr) {
  const before = target.slice(0, insertIndex);
  const after = target.slice(insertIndex);
  return before.concat(insertArr, after);
}
/**
 * Uses Fisher-Yates shuffle to shuffle the given array
 */

function shuffle(array, _seed) {
  let rand;

  if (typeof _seed === 'number') {
    let seed = _seed; // Seeded random number generator in JS. Modified from:
    // https://stackoverflow.com/questions/521295/seeding-the-random-number-generator-in-javascript

    rand = () => {
      const x = Math.sin(seed++) * 179426549; // throw away most significant digits and reduce any potential bias

      return x - Math.floor(x);
    };
  } else {
    rand = Math.random;
  }

  for (let i = array.length - 1; i > 0; i -= 1) {
    const j = Math.floor(rand() * (i + 1));
    const temp = array[i];
    array[i] = array[j];
    array[j] = temp;
  }
}
/**
 * Pushes an element to the start of the array, if found.
 */

function pushToStart(arr, value) {
  const index = arr.indexOf(value);

  if (index > -1) {
    arr.splice(index, 1);
    arr.unshift(value);
  }
}
/**
 * Pushes an element to the end of the array, if found.
 */

function pushToEnd(arr, value) {
  const index = arr.indexOf(value);

  if (index > -1) {
    arr.splice(index, 1);
    arr.push(value);
  }
}
function pushMany(arr, items) {
  for (const item of items) {
    arr.push(item);
  }
}
function mapArrayOrNot(items, fn) {
  return Array.isArray(items) ? items.map(fn) : fn(items);
}
function asArray(x) {
  return Array.isArray(x) ? x : [x];
}
function getRandomElement(arr) {
  return arr[Math.floor(Math.random() * arr.length)];
}
/**
 * Returns the first mapped value of the array which is not undefined.
 */

function mapFind(array, mapFn) {
  for (const value of array) {
    const mapped = mapFn(value);

    if (mapped !== undefined) {
      return mapped;
    }
  }

  return undefined;
}
/**
 * Insert the new items in the array.
 * @param array The original array.
 * @param start The zero-based location in the array from which to start inserting elements.
 * @param newItems The items to be inserted
 */

function insertInto(array, start, newItems) {
  const startIdx = getActualStartIndex(array, start);
  const originalLength = array.length;
  const newItemsLength = newItems.length;
  array.length = originalLength + newItemsLength; // Move the items after the start index, start from the end so that we don't overwrite any value.

  for (let i = originalLength - 1; i >= startIdx; i--) {
    array[i + newItemsLength] = array[i];
  }

  for (let i = 0; i < newItemsLength; i++) {
    array[i + startIdx] = newItems[i];
  }
}
/**
 * Removes elements from an array and inserts new elements in their place, returning the deleted elements. Alternative to the native Array.splice method, it
 * can only support limited number of items due to the maximum call stack size limit.
 * @param array The original array.
 * @param start The zero-based location in the array from which to start removing elements.
 * @param deleteCount The number of elements to remove.
 * @returns An array containing the elements that were deleted.
 */

function splice(array, start, deleteCount, newItems) {
  const index = getActualStartIndex(array, start);
  const result = array.splice(index, deleteCount);
  insertInto(array, index, newItems);
  return result;
}
/**
 * Determine the actual start index (same logic as the native splice() or slice())
 * If greater than the length of the array, start will be set to the length of the array. In this case, no element will be deleted but the method will behave as an adding function, adding as many element as item[n*] provided.
 * If negative, it will begin that many elements from the end of the array. (In this case, the origin -1, meaning -n is the index of the nth last element, and is therefore equivalent to the index of array.length - n.) If array.length + start is less than 0, it will begin from index 0.
 * @param array The target array.
 * @param start The operation index.
 */

function getActualStartIndex(array, start) {
  return start < 0 ? Math.max(start + array.length, 0) : Math.min(start, array.length);
}
/**
 * When comparing two values,
 * a negative number indicates that the first value is less than the second,
 * a positive number indicates that the first value is greater than the second,
 * and zero indicates that neither is the case.
*/


let CompareResult;
/**
 * A comparator `c` defines a total order `<=` on `T` as following:
 * `c(a, b) <= 0` iff `a` <= `b`.
 * We also have `c(a, b) == 0` iff `c(b, a) == 0`.
*/

(function (_CompareResult) {
  function isLessThan(result) {
    return result < 0;
  }

  _CompareResult.isLessThan = isLessThan;

  function isGreaterThan(result) {
    return result > 0;
  }

  _CompareResult.isGreaterThan = isGreaterThan;

  function isNeitherLessOrGreaterThan(result) {
    return result === 0;
  }

  _CompareResult.isNeitherLessOrGreaterThan = isNeitherLessOrGreaterThan;
  const greaterThan = _CompareResult.greaterThan = 1;
  const lessThan = _CompareResult.lessThan = -1;
  const neitherLessOrGreaterThan = _CompareResult.neitherLessOrGreaterThan = 0;
})(CompareResult || (CompareResult = {}));

function compareBy(selector, comparator) {
  return (a, b) => comparator(selector(a), selector(b));
}
function tieBreakComparators(...comparators) {
  return (item1, item2) => {
    for (const comparator of comparators) {
      const result = comparator(item1, item2);

      if (!CompareResult.isNeitherLessOrGreaterThan(result)) {
        return result;
      }
    }

    return CompareResult.neitherLessOrGreaterThan;
  };
}
/**
 * The natural order on numbers.
*/

const numberComparator = (a, b) => a - b;
/**
 * Returns the first item that is equal to or greater than every other item.
*/

function findMaxBy(items, comparator) {
  if (items.length === 0) {
    return undefined;
  }

  let max = items[0];

  for (let i = 1; i < items.length; i++) {
    const item = items[i];

    if (comparator(item, max) > 0) {
      max = item;
    }
  }

  return max;
}
/**
 * Returns the last item that is equal to or greater than every other item.
*/

function findLastMaxBy(items, comparator) {
  if (items.length === 0) {
    return undefined;
  }

  let max = items[0];

  for (let i = 1; i < items.length; i++) {
    const item = items[i];

    if (comparator(item, max) >= 0) {
      max = item;
    }
  }

  return max;
}
/**
 * Returns the first item that is equal to or less than every other item.
*/

function findMinBy(items, comparator) {
  return findMaxBy(items, (a, b) => -comparator(a, b));
}
class ArrayQueue {
  firstIdx = 0;
  lastIdx = this.items.length - 1;
  /**
   * Constructs a queue that is backed by the given array. Runtime is O(1).
  */

  constructor(items) {
    this.items = items;
  }

  get length() {
    return this.lastIdx - this.firstIdx + 1;
  }
  /**
   * Consumes elements from the beginning of the queue as long as the predicate returns true.
   * If no elements were consumed, `null` is returned. Has a runtime of O(result.length).
  */


  takeWhile(predicate) {
    // P(k) := k <= this.lastIdx && predicate(this.items[k])
    // Find s := min { k | k >= this.firstIdx && !P(k) } and return this.data[this.firstIdx...s)
    let startIdx = this.firstIdx;

    while (startIdx < this.items.length && predicate(this.items[startIdx])) {
      startIdx++;
    }

    const result = startIdx === this.firstIdx ? null : this.items.slice(this.firstIdx, startIdx);
    this.firstIdx = startIdx;
    return result;
  }
  /**
   * Consumes elements from the end of the queue as long as the predicate returns true.
   * If no elements were consumed, `null` is returned.
   * The result has the same order as the underlying array!
  */


  takeFromEndWhile(predicate) {
    // P(k) := this.firstIdx >= k && predicate(this.items[k])
    // Find s := max { k | k <= this.lastIdx && !P(k) } and return this.data(s...this.lastIdx]
    let endIdx = this.lastIdx;

    while (endIdx >= 0 && predicate(this.items[endIdx])) {
      endIdx--;
    }

    const result = endIdx === this.lastIdx ? null : this.items.slice(endIdx + 1, this.lastIdx + 1);
    this.lastIdx = endIdx;
    return result;
  }

  peek() {
    if (this.length === 0) {
      return undefined;
    }

    return this.items[this.firstIdx];
  }

  peekLast() {
    if (this.length === 0) {
      return undefined;
    }

    return this.items[this.lastIdx];
  }

  dequeue() {
    const result = this.items[this.firstIdx];
    this.firstIdx++;
    return result;
  }

  removeLast() {
    const result = this.items[this.lastIdx];
    this.lastIdx--;
    return result;
  }

  takeCount(count) {
    const result = this.items.slice(this.firstIdx, this.firstIdx + count);
    this.firstIdx += count;
    return result;
  }

}
/**
 * This class is faster than an iterator and array for lazy computed data.
*/

class CallbackIterable {
  static empty = new CallbackIterable(_callback => {});

  constructor(
  /**
   * Calls the callback for every item.
   * Stops when the callback returns false.
  */
  iterate) {
    this.iterate = iterate;
  }

  forEach(handler) {
    this.iterate(item => {
      handler(item);
      return true;
    });
  }

  toArray() {
    const result = [];
    this.iterate(item => {
      result.push(item);
      return true;
    });
    return result;
  }

  filter(predicate) {
    return new CallbackIterable(cb => this.iterate(item => predicate(item) ? cb(item) : true));
  }

  map(mapFn) {
    return new CallbackIterable(cb => this.iterate(item => cb(mapFn(item))));
  }

  some(predicate) {
    let result = false;
    this.iterate(item => {
      result = predicate(item);
      return !result;
    });
    return result;
  }

  findFirst(predicate) {
    let result;
    this.iterate(item => {
      if (predicate(item)) {
        result = item;
        return false;
      }

      return true;
    });
    return result;
  }

  findLast(predicate) {
    let result;
    this.iterate(item => {
      if (predicate(item)) {
        result = item;
      }

      return true;
    });
    return result;
  }

  findLastMaxBy(comparator) {
    let result;
    let first = true;
    this.iterate(item => {
      if (first || CompareResult.isGreaterThan(comparator(item, result))) {
        first = false;
        result = item;
      }

      return true;
    });
    return result;
  }

}

/***/ }),
/* 88 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createDecorator": () => (/* binding */ createDecorator),
/* harmony export */   "memoize": () => (/* binding */ memoize),
/* harmony export */   "debounce": () => (/* binding */ debounce),
/* harmony export */   "throttle": () => (/* binding */ throttle)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
function createDecorator(mapFn) {
  return (target, key, descriptor) => {
    let fnKey = null;
    let fn = null;

    if (typeof descriptor.value === 'function') {
      fnKey = 'value';
      fn = descriptor.value;
    } else if (typeof descriptor.get === 'function') {
      fnKey = 'get';
      fn = descriptor.get;
    }

    if (!fn) {
      throw new Error('not supported');
    }

    descriptor[fnKey] = mapFn(fn, key);
  };
}
function memoize(_target, key, descriptor) {
  let fnKey = null;
  let fn = null;

  if (typeof descriptor.value === 'function') {
    fnKey = 'value';
    fn = descriptor.value;

    if (fn.length !== 0) {
      console.warn('Memoize should only be used in functions with zero parameters');
    }
  } else if (typeof descriptor.get === 'function') {
    fnKey = 'get';
    fn = descriptor.get;
  }

  if (!fn) {
    throw new Error('not supported');
  }

  const memoizeKey = `$memoize$${key}`;

  descriptor[fnKey] = function (...args) {
    if (!this.hasOwnProperty(memoizeKey)) {
      Object.defineProperty(this, memoizeKey, {
        configurable: false,
        enumerable: false,
        writable: false,
        value: fn.apply(this, args)
      });
    }

    return this[memoizeKey];
  };
}
function debounce(delay, reducer, initialValueProvider) {
  return createDecorator((fn, key) => {
    const timerKey = `$debounce$${key}`;
    const resultKey = `$debounce$result$${key}`;
    return function (...args) {
      if (!this[resultKey]) {
        this[resultKey] = initialValueProvider ? initialValueProvider() : undefined;
      }

      clearTimeout(this[timerKey]);

      if (reducer) {
        this[resultKey] = reducer(this[resultKey], ...args);
        args = [this[resultKey]];
      }

      this[timerKey] = setTimeout(() => {
        fn.apply(this, args);
        this[resultKey] = initialValueProvider ? initialValueProvider() : undefined;
      }, delay);
    };
  });
}
function throttle(delay, reducer, initialValueProvider) {
  return createDecorator((fn, key) => {
    const timerKey = `$throttle$timer$${key}`;
    const resultKey = `$throttle$result$${key}`;
    const lastRunKey = `$throttle$lastRun$${key}`;
    const pendingKey = `$throttle$pending$${key}`;
    return function (...args) {
      if (!this[resultKey]) {
        this[resultKey] = initialValueProvider ? initialValueProvider() : undefined;
      }

      if (this[lastRunKey] === null || this[lastRunKey] === undefined) {
        this[lastRunKey] = -Number.MAX_VALUE;
      }

      if (reducer) {
        this[resultKey] = reducer(this[resultKey], ...args);
      }

      if (this[pendingKey]) {
        return;
      }

      const nextTime = this[lastRunKey] + delay;

      if (nextTime <= Date.now()) {
        this[lastRunKey] = Date.now();
        fn.apply(this, [this[resultKey]]);
        this[resultKey] = initialValueProvider ? initialValueProvider() : undefined;
      } else {
        this[pendingKey] = true;
        this[timerKey] = setTimeout(() => {
          this[pendingKey] = false;
          this[lastRunKey] = Date.now();
          fn.apply(this, [this[resultKey]]);
          this[resultKey] = initialValueProvider ? initialValueProvider() : undefined;
        }, nextTime - Date.now());
      }
    };
  });
}

/***/ }),
/* 89 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OrthogonalEdge": () => (/* binding */ OrthogonalEdge),
/* harmony export */   "Orientation": () => (/* binding */ Orientation),
/* harmony export */   "SashState": () => (/* binding */ SashState),
/* harmony export */   "setGlobalSashSize": () => (/* binding */ setGlobalSashSize),
/* harmony export */   "setGlobalHoverDelay": () => (/* binding */ setGlobalHoverDelay),
/* harmony export */   "Sash": () => (/* binding */ Sash)
/* harmony export */ });
/* harmony import */ var _browser_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(61);
/* harmony import */ var _browser_event__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(85);
/* harmony import */ var _browser_touch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(86);
/* harmony import */ var _common_async__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(68);
/* harmony import */ var _common_decorators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(88);
/* harmony import */ var _common_event__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(51);
/* harmony import */ var _common_lifecycle__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(54);
/* harmony import */ var _common_platform__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(58);
/* harmony import */ var _sash_css__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(90);
var _class, _class2, _class3;

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









/**
 * Allow the sashes to be visible at runtime.
 * @remark Use for development purposes only.
 */

const DEBUG = false; // DEBUG = Boolean("true"); // done "weirdly" so that a lint warning prevents you from pushing this

/**
 * A vertical sash layout provider provides position and height for a sash.
 */

let OrthogonalEdge;

(function (OrthogonalEdge) {
  OrthogonalEdge["North"] = "north";
  OrthogonalEdge["South"] = "south";
  OrthogonalEdge["East"] = "east";
  OrthogonalEdge["West"] = "west";
})(OrthogonalEdge || (OrthogonalEdge = {}));

let Orientation;

(function (Orientation) {
  Orientation[Orientation["VERTICAL"] = 0] = "VERTICAL";
  Orientation[Orientation["HORIZONTAL"] = 1] = "HORIZONTAL";
})(Orientation || (Orientation = {}));

let SashState;

(function (SashState) {
  SashState[SashState["Disabled"] = 0] = "Disabled";
  SashState[SashState["AtMinimum"] = 1] = "AtMinimum";
  SashState[SashState["AtMaximum"] = 2] = "AtMaximum";
  SashState[SashState["Enabled"] = 3] = "Enabled";
})(SashState || (SashState = {}));

let globalSize = 4;
const onDidChangeGlobalSize = new _common_event__WEBPACK_IMPORTED_MODULE_5__.Emitter();
function setGlobalSashSize(size) {
  globalSize = size;
  onDidChangeGlobalSize.fire(size);
}
let globalHoverDelay = 300;
const onDidChangeHoverDelay = new _common_event__WEBPACK_IMPORTED_MODULE_5__.Emitter();
function setGlobalHoverDelay(size) {
  globalHoverDelay = size;
  onDidChangeHoverDelay.fire(size);
}
let MouseEventFactory = (_class = class MouseEventFactory {
  disposables = new _common_lifecycle__WEBPACK_IMPORTED_MODULE_6__.DisposableStore();

  get onPointerMove() {
    return this.disposables.add(new _browser_event__WEBPACK_IMPORTED_MODULE_1__.DomEmitter(window, 'mousemove')).event;
  }

  get onPointerUp() {
    return this.disposables.add(new _browser_event__WEBPACK_IMPORTED_MODULE_1__.DomEmitter(window, 'mouseup')).event;
  }

  dispose() {
    this.disposables.dispose();
  }

}, (_applyDecoratedDescriptor(_class.prototype, "onPointerMove", [_common_decorators__WEBPACK_IMPORTED_MODULE_4__.memoize], Object.getOwnPropertyDescriptor(_class.prototype, "onPointerMove"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "onPointerUp", [_common_decorators__WEBPACK_IMPORTED_MODULE_4__.memoize], Object.getOwnPropertyDescriptor(_class.prototype, "onPointerUp"), _class.prototype)), _class);
let GestureEventFactory = (_class2 = class GestureEventFactory {
  disposables = new _common_lifecycle__WEBPACK_IMPORTED_MODULE_6__.DisposableStore();

  get onPointerMove() {
    return this.disposables.add(new _browser_event__WEBPACK_IMPORTED_MODULE_1__.DomEmitter(this.el, _browser_touch__WEBPACK_IMPORTED_MODULE_2__.EventType.Change)).event;
  }

  get onPointerUp() {
    return this.disposables.add(new _browser_event__WEBPACK_IMPORTED_MODULE_1__.DomEmitter(this.el, _browser_touch__WEBPACK_IMPORTED_MODULE_2__.EventType.End)).event;
  }

  constructor(el) {
    this.el = el;
  }

  dispose() {
    this.disposables.dispose();
  }

}, (_applyDecoratedDescriptor(_class2.prototype, "onPointerMove", [_common_decorators__WEBPACK_IMPORTED_MODULE_4__.memoize], Object.getOwnPropertyDescriptor(_class2.prototype, "onPointerMove"), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, "onPointerUp", [_common_decorators__WEBPACK_IMPORTED_MODULE_4__.memoize], Object.getOwnPropertyDescriptor(_class2.prototype, "onPointerUp"), _class2.prototype)), _class2);
let OrthogonalPointerEventFactory = (_class3 = class OrthogonalPointerEventFactory {
  get onPointerMove() {
    return this.factory.onPointerMove;
  }

  get onPointerUp() {
    return this.factory.onPointerUp;
  }

  constructor(factory) {
    this.factory = factory;
  }

  dispose() {// noop
  }

}, (_applyDecoratedDescriptor(_class3.prototype, "onPointerMove", [_common_decorators__WEBPACK_IMPORTED_MODULE_4__.memoize], Object.getOwnPropertyDescriptor(_class3.prototype, "onPointerMove"), _class3.prototype), _applyDecoratedDescriptor(_class3.prototype, "onPointerUp", [_common_decorators__WEBPACK_IMPORTED_MODULE_4__.memoize], Object.getOwnPropertyDescriptor(_class3.prototype, "onPointerUp"), _class3.prototype)), _class3);
const PointerEventsDisabledCssClass = 'pointer-events-disabled';
/**
 * The {@link Sash} is the UI component which allows the user to resize other
 * components. It's usually an invisible horizontal or vertical line which, when
 * hovered, becomes highlighted and can be dragged along the perpendicular dimension
 * to its direction.
 *
 * Features:
 * - Touch event handling
 * - Corner sash support
 * - Hover with different mouse cursor support
 * - Configurable hover size
 * - Linked sash support, for 2x2 corner sashes
 */

class Sash extends _common_lifecycle__WEBPACK_IMPORTED_MODULE_6__.Disposable {
  hoverDelay = globalHoverDelay;
  hoverDelayer = this._register(new _common_async__WEBPACK_IMPORTED_MODULE_3__.Delayer(this.hoverDelay));
  _state = SashState.Enabled;
  onDidEnablementChange = this._register(new _common_event__WEBPACK_IMPORTED_MODULE_5__.Emitter());
  _onDidStart = this._register(new _common_event__WEBPACK_IMPORTED_MODULE_5__.Emitter());
  _onDidChange = this._register(new _common_event__WEBPACK_IMPORTED_MODULE_5__.Emitter());
  _onDidReset = this._register(new _common_event__WEBPACK_IMPORTED_MODULE_5__.Emitter());
  _onDidEnd = this._register(new _common_event__WEBPACK_IMPORTED_MODULE_5__.Emitter());
  orthogonalStartSashDisposables = this._register(new _common_lifecycle__WEBPACK_IMPORTED_MODULE_6__.DisposableStore());
  orthogonalStartDragHandleDisposables = this._register(new _common_lifecycle__WEBPACK_IMPORTED_MODULE_6__.DisposableStore());
  orthogonalEndSashDisposables = this._register(new _common_lifecycle__WEBPACK_IMPORTED_MODULE_6__.DisposableStore());
  orthogonalEndDragHandleDisposables = this._register(new _common_lifecycle__WEBPACK_IMPORTED_MODULE_6__.DisposableStore());

  get state() {
    return this._state;
  }

  get orthogonalStartSash() {
    return this._orthogonalStartSash;
  }

  get orthogonalEndSash() {
    return this._orthogonalEndSash;
  }
  /**
   * The state of a sash defines whether it can be interacted with by the user
   * as well as what mouse cursor to use, when hovered.
   */


  set state(state) {
    if (this._state === state) {
      return;
    }

    this.el.classList.toggle('disabled', state === SashState.Disabled);
    this.el.classList.toggle('minimum', state === SashState.AtMinimum);
    this.el.classList.toggle('maximum', state === SashState.AtMaximum);
    this._state = state;
    this.onDidEnablementChange.fire(state);
  }
  /**
   * An event which fires whenever the user starts dragging this sash.
   */


  onDidStart = this._onDidStart.event;
  /**
   * An event which fires whenever the user moves the mouse while
   * dragging this sash.
   */

  onDidChange = this._onDidChange.event;
  /**
   * An event which fires whenever the user double clicks this sash.
   */

  onDidReset = this._onDidReset.event;
  /**
   * An event which fires whenever the user stops dragging this sash.
   */

  onDidEnd = this._onDidEnd.event;
  /**
   * A linked sash will be forwarded the same user interactions and events
   * so it moves exactly the same way as this sash.
   *
   * Useful in 2x2 grids. Not meant for widespread usage.
   */

  linkedSash = undefined;
  /**
   * A reference to another sash, perpendicular to this one, which
   * aligns at the start of this one. A corner sash will be created
   * automatically at that location.
   *
   * The start of a horizontal sash is its left-most position.
   * The start of a vertical sash is its top-most position.
   */

  set orthogonalStartSash(sash) {
    this.orthogonalStartDragHandleDisposables.clear();
    this.orthogonalStartSashDisposables.clear();

    if (sash) {
      const onChange = state => {
        this.orthogonalStartDragHandleDisposables.clear();

        if (state !== SashState.Disabled) {
          this._orthogonalStartDragHandle = (0,_browser_dom__WEBPACK_IMPORTED_MODULE_0__.append)(this.el, (0,_browser_dom__WEBPACK_IMPORTED_MODULE_0__.$)('.orthogonal-drag-handle.start'));
          this.orthogonalStartDragHandleDisposables.add((0,_common_lifecycle__WEBPACK_IMPORTED_MODULE_6__.toDisposable)(() => this._orthogonalStartDragHandle.remove()));
          this.orthogonalStartDragHandleDisposables.add(new _browser_event__WEBPACK_IMPORTED_MODULE_1__.DomEmitter(this._orthogonalStartDragHandle, 'mouseenter')).event(() => Sash.onMouseEnter(sash), undefined, this.orthogonalStartDragHandleDisposables);
          this.orthogonalStartDragHandleDisposables.add(new _browser_event__WEBPACK_IMPORTED_MODULE_1__.DomEmitter(this._orthogonalStartDragHandle, 'mouseleave')).event(() => Sash.onMouseLeave(sash), undefined, this.orthogonalStartDragHandleDisposables);
        }
      };

      this.orthogonalStartSashDisposables.add(sash.onDidEnablementChange.event(onChange, this));
      onChange(sash.state);
    }

    this._orthogonalStartSash = sash;
  }
  /**
   * A reference to another sash, perpendicular to this one, which
   * aligns at the end of this one. A corner sash will be created
   * automatically at that location.
   *
   * The end of a horizontal sash is its right-most position.
   * The end of a vertical sash is its bottom-most position.
   */


  set orthogonalEndSash(sash) {
    this.orthogonalEndDragHandleDisposables.clear();
    this.orthogonalEndSashDisposables.clear();

    if (sash) {
      const onChange = state => {
        this.orthogonalEndDragHandleDisposables.clear();

        if (state !== SashState.Disabled) {
          this._orthogonalEndDragHandle = (0,_browser_dom__WEBPACK_IMPORTED_MODULE_0__.append)(this.el, (0,_browser_dom__WEBPACK_IMPORTED_MODULE_0__.$)('.orthogonal-drag-handle.end'));
          this.orthogonalEndDragHandleDisposables.add((0,_common_lifecycle__WEBPACK_IMPORTED_MODULE_6__.toDisposable)(() => this._orthogonalEndDragHandle.remove()));
          this.orthogonalEndDragHandleDisposables.add(new _browser_event__WEBPACK_IMPORTED_MODULE_1__.DomEmitter(this._orthogonalEndDragHandle, 'mouseenter')).event(() => Sash.onMouseEnter(sash), undefined, this.orthogonalEndDragHandleDisposables);
          this.orthogonalEndDragHandleDisposables.add(new _browser_event__WEBPACK_IMPORTED_MODULE_1__.DomEmitter(this._orthogonalEndDragHandle, 'mouseleave')).event(() => Sash.onMouseLeave(sash), undefined, this.orthogonalEndDragHandleDisposables);
        }
      };

      this.orthogonalEndSashDisposables.add(sash.onDidEnablementChange.event(onChange, this));
      onChange(sash.state);
    }

    this._orthogonalEndSash = sash;
  }
  /**
   * Create a new vertical sash.
   *
   * @param container A DOM node to append the sash to.
   * @param verticalLayoutProvider A vertical layout provider.
   * @param options The options.
   */


  constructor(container, layoutProvider, options) {
    super();
    this.el = (0,_browser_dom__WEBPACK_IMPORTED_MODULE_0__.append)(container, (0,_browser_dom__WEBPACK_IMPORTED_MODULE_0__.$)('.monaco-sash'));

    if (options.orthogonalEdge) {
      this.el.classList.add(`orthogonal-edge-${options.orthogonalEdge}`);
    }

    if (_common_platform__WEBPACK_IMPORTED_MODULE_7__.isMacintosh) {
      this.el.classList.add('mac');
    }

    const onMouseDown = this._register(new _browser_event__WEBPACK_IMPORTED_MODULE_1__.DomEmitter(this.el, 'mousedown')).event;

    this._register(onMouseDown(e => this.onPointerStart(e, new MouseEventFactory()), this));

    const onMouseDoubleClick = this._register(new _browser_event__WEBPACK_IMPORTED_MODULE_1__.DomEmitter(this.el, 'dblclick')).event;

    this._register(onMouseDoubleClick(this.onPointerDoublePress, this));

    const onMouseEnter = this._register(new _browser_event__WEBPACK_IMPORTED_MODULE_1__.DomEmitter(this.el, 'mouseenter')).event;

    this._register(onMouseEnter(() => Sash.onMouseEnter(this)));

    const onMouseLeave = this._register(new _browser_event__WEBPACK_IMPORTED_MODULE_1__.DomEmitter(this.el, 'mouseleave')).event;

    this._register(onMouseLeave(() => Sash.onMouseLeave(this)));

    this._register(_browser_touch__WEBPACK_IMPORTED_MODULE_2__.Gesture.addTarget(this.el));

    const onTouchStart = _common_event__WEBPACK_IMPORTED_MODULE_5__.Event.map(this._register(new _browser_event__WEBPACK_IMPORTED_MODULE_1__.DomEmitter(this.el, _browser_touch__WEBPACK_IMPORTED_MODULE_2__.EventType.Start)).event, e => ({ ...e,
      target: e.initialTarget ?? null
    }));

    this._register(onTouchStart(e => this.onPointerStart(e, new GestureEventFactory(this.el)), this));

    const onTap = this._register(new _browser_event__WEBPACK_IMPORTED_MODULE_1__.DomEmitter(this.el, _browser_touch__WEBPACK_IMPORTED_MODULE_2__.EventType.Tap)).event;

    const onDoubleTap = _common_event__WEBPACK_IMPORTED_MODULE_5__.Event.map(_common_event__WEBPACK_IMPORTED_MODULE_5__.Event.filter(_common_event__WEBPACK_IMPORTED_MODULE_5__.Event.debounce(onTap, (res, event) => ({
      event,
      count: (res?.count ?? 0) + 1
    }), 250), ({
      count
    }) => count === 2), ({
      event
    }) => ({ ...event,
      target: event.initialTarget ?? null
    }));

    this._register(onDoubleTap(this.onPointerDoublePress, this));

    if (typeof options.size === 'number') {
      this.size = options.size;

      if (options.orientation === Orientation.VERTICAL) {
        this.el.style.width = `${this.size}px`;
      } else {
        this.el.style.height = `${this.size}px`;
      }
    } else {
      this.size = globalSize;

      this._register(onDidChangeGlobalSize.event(size => {
        this.size = size;
        this.layout();
      }));
    }

    this._register(onDidChangeHoverDelay.event(delay => this.hoverDelay = delay));

    this.layoutProvider = layoutProvider;
    this.orthogonalStartSash = options.orthogonalStartSash;
    this.orthogonalEndSash = options.orthogonalEndSash;
    this.orientation = options.orientation || Orientation.VERTICAL;

    if (this.orientation === Orientation.HORIZONTAL) {
      this.el.classList.add('horizontal');
      this.el.classList.remove('vertical');
    } else {
      this.el.classList.remove('horizontal');
      this.el.classList.add('vertical');
    }

    this.el.classList.toggle('debug', DEBUG);
    this.layout();
  }

  onPointerStart(event, pointerEventFactory) {
    _browser_dom__WEBPACK_IMPORTED_MODULE_0__.EventHelper.stop(event);
    let isMultisashResize = false;

    if (!event.__orthogonalSashEvent) {
      const orthogonalSash = this.getOrthogonalSash(event);

      if (orthogonalSash) {
        isMultisashResize = true;
        event.__orthogonalSashEvent = true;
        orthogonalSash.onPointerStart(event, new OrthogonalPointerEventFactory(pointerEventFactory));
      }
    }

    if (this.linkedSash && !event.__linkedSashEvent) {
      event.__linkedSashEvent = true;
      this.linkedSash.onPointerStart(event, new OrthogonalPointerEventFactory(pointerEventFactory));
    }

    if (!this.state) {
      return;
    }

    const iframes = document.getElementsByTagName('iframe');

    for (const iframe of iframes) {
      iframe.classList.add(PointerEventsDisabledCssClass); // disable mouse events on iframes as long as we drag the sash
    }

    const startX = event.pageX;
    const startY = event.pageY;
    const altKey = event.altKey;
    const startEvent = {
      startX,
      currentX: startX,
      startY,
      currentY: startY,
      altKey
    };
    this.el.classList.add('active');

    this._onDidStart.fire(startEvent); // fix https://github.com/microsoft/vscode/issues/21675


    const style = (0,_browser_dom__WEBPACK_IMPORTED_MODULE_0__.createStyleSheet)(this.el);

    const updateStyle = () => {
      let cursor = '';

      if (isMultisashResize) {
        cursor = 'all-scroll';
      } else if (this.orientation === Orientation.HORIZONTAL) {
        if (this.state === SashState.AtMinimum) {
          cursor = 's-resize';
        } else if (this.state === SashState.AtMaximum) {
          cursor = 'n-resize';
        } else {
          cursor = _common_platform__WEBPACK_IMPORTED_MODULE_7__.isMacintosh ? 'row-resize' : 'ns-resize';
        }
      } else {
        if (this.state === SashState.AtMinimum) {
          cursor = 'e-resize';
        } else if (this.state === SashState.AtMaximum) {
          cursor = 'w-resize';
        } else {
          cursor = _common_platform__WEBPACK_IMPORTED_MODULE_7__.isMacintosh ? 'col-resize' : 'ew-resize';
        }
      }

      style.textContent = `* { cursor: ${cursor} !important; }`;
    };

    const disposables = new _common_lifecycle__WEBPACK_IMPORTED_MODULE_6__.DisposableStore();
    updateStyle();

    if (!isMultisashResize) {
      this.onDidEnablementChange.event(updateStyle, null, disposables);
    }

    const onPointerMove = e => {
      _browser_dom__WEBPACK_IMPORTED_MODULE_0__.EventHelper.stop(e, false);
      const event = {
        startX,
        currentX: e.pageX,
        startY,
        currentY: e.pageY,
        altKey
      };

      this._onDidChange.fire(event);
    };

    const onPointerUp = e => {
      _browser_dom__WEBPACK_IMPORTED_MODULE_0__.EventHelper.stop(e, false);
      this.el.removeChild(style);
      this.el.classList.remove('active');

      this._onDidEnd.fire();

      disposables.dispose();

      for (const iframe of iframes) {
        iframe.classList.remove(PointerEventsDisabledCssClass);
      }
    };

    pointerEventFactory.onPointerMove(onPointerMove, null, disposables);
    pointerEventFactory.onPointerUp(onPointerUp, null, disposables);
    disposables.add(pointerEventFactory);
  }

  onPointerDoublePress(e) {
    const orthogonalSash = this.getOrthogonalSash(e);

    if (orthogonalSash) {
      orthogonalSash._onDidReset.fire();
    }

    if (this.linkedSash) {
      this.linkedSash._onDidReset.fire();
    }

    this._onDidReset.fire();
  }

  static onMouseEnter(sash, fromLinkedSash = false) {
    if (sash.el.classList.contains('active')) {
      sash.hoverDelayer.cancel();
      sash.el.classList.add('hover');
    } else {
      sash.hoverDelayer.trigger(() => sash.el.classList.add('hover'), sash.hoverDelay).then(undefined, () => {});
    }

    if (!fromLinkedSash && sash.linkedSash) {
      Sash.onMouseEnter(sash.linkedSash, true);
    }
  }

  static onMouseLeave(sash, fromLinkedSash = false) {
    sash.hoverDelayer.cancel();
    sash.el.classList.remove('hover');

    if (!fromLinkedSash && sash.linkedSash) {
      Sash.onMouseLeave(sash.linkedSash, true);
    }
  }
  /**
   * Forcefully stop any user interactions with this sash.
   * Useful when hiding a parent component, while the user is still
   * interacting with the sash.
   */


  clearSashHoverState() {
    Sash.onMouseLeave(this);
  }
  /**
   * Layout the sash. The sash will size and position itself
   * based on its provided {@link ISashLayoutProvider layout provider}.
   */


  layout() {
    if (this.orientation === Orientation.VERTICAL) {
      const verticalProvider = this.layoutProvider;
      this.el.style.left = verticalProvider.getVerticalSashLeft(this) - this.size / 2 + 'px';

      if (verticalProvider.getVerticalSashTop) {
        this.el.style.top = verticalProvider.getVerticalSashTop(this) + 'px';
      }

      if (verticalProvider.getVerticalSashHeight) {
        this.el.style.height = verticalProvider.getVerticalSashHeight(this) + 'px';
      }
    } else {
      const horizontalProvider = this.layoutProvider;
      this.el.style.top = horizontalProvider.getHorizontalSashTop(this) - this.size / 2 + 'px';

      if (horizontalProvider.getHorizontalSashLeft) {
        this.el.style.left = horizontalProvider.getHorizontalSashLeft(this) + 'px';
      }

      if (horizontalProvider.getHorizontalSashWidth) {
        this.el.style.width = horizontalProvider.getHorizontalSashWidth(this) + 'px';
      }
    }
  }

  getOrthogonalSash(e) {
    if (!e.target || !(e.target instanceof HTMLElement)) {
      return undefined;
    }

    if (e.target.classList.contains('orthogonal-drag-handle')) {
      return e.target.classList.contains('start') ? this.orthogonalStartSash : this.orthogonalEndSash;
    }

    return undefined;
  }

  dispose() {
    super.dispose();
    this.el.remove();
  }

}

/***/ }),
/* 90 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),
/* 91 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RGBA": () => (/* binding */ RGBA),
/* harmony export */   "HSLA": () => (/* binding */ HSLA),
/* harmony export */   "HSVA": () => (/* binding */ HSVA),
/* harmony export */   "Color": () => (/* binding */ Color)
/* harmony export */ });
/* harmony import */ var _charCode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(71);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


function roundFloat(number, decimalPoints) {
  const decimal = Math.pow(10, decimalPoints);
  return Math.round(number * decimal) / decimal;
}

class RGBA {
  _rgbaBrand = undefined;
  /**
   * Red: integer in [0-255]
   */

  constructor(r, g, b, a = 1) {
    this.r = Math.min(255, Math.max(0, r)) | 0;
    this.g = Math.min(255, Math.max(0, g)) | 0;
    this.b = Math.min(255, Math.max(0, b)) | 0;
    this.a = roundFloat(Math.max(Math.min(1, a), 0), 3);
  }

  static equals(a, b) {
    return a.r === b.r && a.g === b.g && a.b === b.b && a.a === b.a;
  }

}
class HSLA {
  _hslaBrand = undefined;
  /**
   * Hue: integer in [0, 360]
   */

  constructor(h, s, l, a) {
    this.h = Math.max(Math.min(360, h), 0) | 0;
    this.s = roundFloat(Math.max(Math.min(1, s), 0), 3);
    this.l = roundFloat(Math.max(Math.min(1, l), 0), 3);
    this.a = roundFloat(Math.max(Math.min(1, a), 0), 3);
  }

  static equals(a, b) {
    return a.h === b.h && a.s === b.s && a.l === b.l && a.a === b.a;
  }
  /**
   * Converts an RGB color value to HSL. Conversion formula
   * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
   * Assumes r, g, and b are contained in the set [0, 255] and
   * returns h in the set [0, 360], s, and l in the set [0, 1].
   */


  static fromRGBA(rgba) {
    const r = rgba.r / 255;
    const g = rgba.g / 255;
    const b = rgba.b / 255;
    const a = rgba.a;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let h = 0;
    let s = 0;
    const l = (min + max) / 2;
    const chroma = max - min;

    if (chroma > 0) {
      s = Math.min(l <= 0.5 ? chroma / (2 * l) : chroma / (2 - 2 * l), 1);

      switch (max) {
        case r:
          h = (g - b) / chroma + (g < b ? 6 : 0);
          break;

        case g:
          h = (b - r) / chroma + 2;
          break;

        case b:
          h = (r - g) / chroma + 4;
          break;
      }

      h *= 60;
      h = Math.round(h);
    }

    return new HSLA(h, s, l, a);
  }

  static _hue2rgb(p, q, t) {
    if (t < 0) {
      t += 1;
    }

    if (t > 1) {
      t -= 1;
    }

    if (t < 1 / 6) {
      return p + (q - p) * 6 * t;
    }

    if (t < 1 / 2) {
      return q;
    }

    if (t < 2 / 3) {
      return p + (q - p) * (2 / 3 - t) * 6;
    }

    return p;
  }
  /**
   * Converts an HSL color value to RGB. Conversion formula
   * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
   * Assumes h in the set [0, 360] s, and l are contained in the set [0, 1] and
   * returns r, g, and b in the set [0, 255].
   */


  static toRGBA(hsla) {
    const h = hsla.h / 360;
    const {
      s,
      l,
      a
    } = hsla;
    let r, g, b;

    if (s === 0) {
      r = g = b = l; // achromatic
    } else {
      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      const p = 2 * l - q;
      r = HSLA._hue2rgb(p, q, h + 1 / 3);
      g = HSLA._hue2rgb(p, q, h);
      b = HSLA._hue2rgb(p, q, h - 1 / 3);
    }

    return new RGBA(Math.round(r * 255), Math.round(g * 255), Math.round(b * 255), a);
  }

}
class HSVA {
  _hsvaBrand = undefined;
  /**
   * Hue: integer in [0, 360]
   */

  constructor(h, s, v, a) {
    this.h = Math.max(Math.min(360, h), 0) | 0;
    this.s = roundFloat(Math.max(Math.min(1, s), 0), 3);
    this.v = roundFloat(Math.max(Math.min(1, v), 0), 3);
    this.a = roundFloat(Math.max(Math.min(1, a), 0), 3);
  }

  static equals(a, b) {
    return a.h === b.h && a.s === b.s && a.v === b.v && a.a === b.a;
  } // from http://www.rapidtables.com/convert/color/rgb-to-hsv.htm


  static fromRGBA(rgba) {
    const r = rgba.r / 255;
    const g = rgba.g / 255;
    const b = rgba.b / 255;
    const cmax = Math.max(r, g, b);
    const cmin = Math.min(r, g, b);
    const delta = cmax - cmin;
    const s = cmax === 0 ? 0 : delta / cmax;
    let m;

    if (delta === 0) {
      m = 0;
    } else if (cmax === r) {
      m = ((g - b) / delta % 6 + 6) % 6;
    } else if (cmax === g) {
      m = (b - r) / delta + 2;
    } else {
      m = (r - g) / delta + 4;
    }

    return new HSVA(Math.round(m * 60), s, cmax, rgba.a);
  } // from http://www.rapidtables.com/convert/color/hsv-to-rgb.htm


  static toRGBA(hsva) {
    const {
      h,
      s,
      v,
      a
    } = hsva;
    const c = v * s;
    const x = c * (1 - Math.abs(h / 60 % 2 - 1));
    const m = v - c;
    let [r, g, b] = [0, 0, 0];

    if (h < 60) {
      r = c;
      g = x;
    } else if (h < 120) {
      r = x;
      g = c;
    } else if (h < 180) {
      g = c;
      b = x;
    } else if (h < 240) {
      g = x;
      b = c;
    } else if (h < 300) {
      r = x;
      b = c;
    } else if (h <= 360) {
      r = c;
      b = x;
    }

    r = Math.round((r + m) * 255);
    g = Math.round((g + m) * 255);
    b = Math.round((b + m) * 255);
    return new RGBA(r, g, b, a);
  }

}
class Color {
  static fromHex(hex) {
    return Color.Format.CSS.parseHex(hex) || Color.red;
  }

  get hsla() {
    if (this._hsla) {
      return this._hsla;
    } else {
      return HSLA.fromRGBA(this.rgba);
    }
  }

  get hsva() {
    if (this._hsva) {
      return this._hsva;
    }

    return HSVA.fromRGBA(this.rgba);
  }

  constructor(arg) {
    if (!arg) {
      throw new Error('Color needs a value');
    } else if (arg instanceof RGBA) {
      this.rgba = arg;
    } else if (arg instanceof HSLA) {
      this._hsla = arg;
      this.rgba = HSLA.toRGBA(arg);
    } else if (arg instanceof HSVA) {
      this._hsva = arg;
      this.rgba = HSVA.toRGBA(arg);
    } else {
      throw new Error('Invalid color ctor argument');
    }
  }

  equals(other) {
    return !!other && RGBA.equals(this.rgba, other.rgba) && HSLA.equals(this.hsla, other.hsla) && HSVA.equals(this.hsva, other.hsva);
  }
  /**
   * http://www.w3.org/TR/WCAG20/#relativeluminancedef
   * Returns the number in the set [0, 1]. O => Darkest Black. 1 => Lightest white.
   */


  getRelativeLuminance() {
    const R = Color._relativeLuminanceForComponent(this.rgba.r);

    const G = Color._relativeLuminanceForComponent(this.rgba.g);

    const B = Color._relativeLuminanceForComponent(this.rgba.b);

    const luminance = 0.2126 * R + 0.7152 * G + 0.0722 * B;
    return roundFloat(luminance, 4);
  }

  static _relativeLuminanceForComponent(color) {
    const c = color / 255;
    return c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
  }
  /**
   * http://www.w3.org/TR/WCAG20/#contrast-ratiodef
   * Returns the contrast ration number in the set [1, 21].
   */


  getContrastRatio(another) {
    const lum1 = this.getRelativeLuminance();
    const lum2 = another.getRelativeLuminance();
    return lum1 > lum2 ? (lum1 + 0.05) / (lum2 + 0.05) : (lum2 + 0.05) / (lum1 + 0.05);
  }
  /**
   *	http://24ways.org/2010/calculating-color-contrast
   *  Return 'true' if darker color otherwise 'false'
   */


  isDarker() {
    const yiq = (this.rgba.r * 299 + this.rgba.g * 587 + this.rgba.b * 114) / 1000;
    return yiq < 128;
  }
  /**
   *	http://24ways.org/2010/calculating-color-contrast
   *  Return 'true' if lighter color otherwise 'false'
   */


  isLighter() {
    const yiq = (this.rgba.r * 299 + this.rgba.g * 587 + this.rgba.b * 114) / 1000;
    return yiq >= 128;
  }

  isLighterThan(another) {
    const lum1 = this.getRelativeLuminance();
    const lum2 = another.getRelativeLuminance();
    return lum1 > lum2;
  }

  isDarkerThan(another) {
    const lum1 = this.getRelativeLuminance();
    const lum2 = another.getRelativeLuminance();
    return lum1 < lum2;
  }

  lighten(factor) {
    return new Color(new HSLA(this.hsla.h, this.hsla.s, this.hsla.l + this.hsla.l * factor, this.hsla.a));
  }

  darken(factor) {
    return new Color(new HSLA(this.hsla.h, this.hsla.s, this.hsla.l - this.hsla.l * factor, this.hsla.a));
  }

  transparent(factor) {
    const {
      r,
      g,
      b,
      a
    } = this.rgba;
    return new Color(new RGBA(r, g, b, a * factor));
  }

  isTransparent() {
    return this.rgba.a === 0;
  }

  isOpaque() {
    return this.rgba.a === 1;
  }

  opposite() {
    return new Color(new RGBA(255 - this.rgba.r, 255 - this.rgba.g, 255 - this.rgba.b, this.rgba.a));
  }

  blend(c) {
    const rgba = c.rgba; // Convert to 0..1 opacity

    const thisA = this.rgba.a;
    const colorA = rgba.a;
    const a = thisA + colorA * (1 - thisA);

    if (a < 1e-6) {
      return Color.transparent;
    }

    const r = this.rgba.r * thisA / a + rgba.r * colorA * (1 - thisA) / a;
    const g = this.rgba.g * thisA / a + rgba.g * colorA * (1 - thisA) / a;
    const b = this.rgba.b * thisA / a + rgba.b * colorA * (1 - thisA) / a;
    return new Color(new RGBA(r, g, b, a));
  }

  makeOpaque(opaqueBackground) {
    if (this.isOpaque() || opaqueBackground.rgba.a !== 1) {
      // only allow to blend onto a non-opaque color onto a opaque color
      return this;
    }

    const {
      r,
      g,
      b,
      a
    } = this.rgba; // https://stackoverflow.com/questions/12228548/finding-equivalent-color-with-opacity

    return new Color(new RGBA(opaqueBackground.rgba.r - a * (opaqueBackground.rgba.r - r), opaqueBackground.rgba.g - a * (opaqueBackground.rgba.g - g), opaqueBackground.rgba.b - a * (opaqueBackground.rgba.b - b), 1));
  }

  flatten(...backgrounds) {
    const background = backgrounds.reduceRight((accumulator, color) => {
      return Color._flatten(color, accumulator);
    });
    return Color._flatten(this, background);
  }

  static _flatten(foreground, background) {
    const backgroundAlpha = 1 - foreground.rgba.a;
    return new Color(new RGBA(backgroundAlpha * background.rgba.r + foreground.rgba.a * foreground.rgba.r, backgroundAlpha * background.rgba.g + foreground.rgba.a * foreground.rgba.g, backgroundAlpha * background.rgba.b + foreground.rgba.a * foreground.rgba.b));
  }

  toString() {
    if (!this._toString) {
      this._toString = Color.Format.CSS.format(this);
    }

    return this._toString;
  }

  static getLighterColor(of, relative, factor) {
    if (of.isLighterThan(relative)) {
      return of;
    }

    factor = factor ? factor : 0.5;
    const lum1 = of.getRelativeLuminance();
    const lum2 = relative.getRelativeLuminance();
    factor = factor * (lum2 - lum1) / lum2;
    return of.lighten(factor);
  }

  static getDarkerColor(of, relative, factor) {
    if (of.isDarkerThan(relative)) {
      return of;
    }

    factor = factor ? factor : 0.5;
    const lum1 = of.getRelativeLuminance();
    const lum2 = relative.getRelativeLuminance();
    factor = factor * (lum1 - lum2) / lum1;
    return of.darken(factor);
  }

  static white = new Color(new RGBA(255, 255, 255, 1));
  static black = new Color(new RGBA(0, 0, 0, 1));
  static red = new Color(new RGBA(255, 0, 0, 1));
  static blue = new Color(new RGBA(0, 0, 255, 1));
  static green = new Color(new RGBA(0, 255, 0, 1));
  static cyan = new Color(new RGBA(0, 255, 255, 1));
  static lightgrey = new Color(new RGBA(211, 211, 211, 1));
  static transparent = new Color(new RGBA(0, 0, 0, 0));
}

(function (_Color) {
  let Format;

  (function (_Format) {
    let CSS;

    (function (_CSS) {
      function formatRGB(color) {
        if (color.rgba.a === 1) {
          return `rgb(${color.rgba.r}, ${color.rgba.g}, ${color.rgba.b})`;
        }

        return Color.Format.CSS.formatRGBA(color);
      }

      _CSS.formatRGB = formatRGB;

      function formatRGBA(color) {
        return `rgba(${color.rgba.r}, ${color.rgba.g}, ${color.rgba.b}, ${+color.rgba.a.toFixed(2)})`;
      }

      _CSS.formatRGBA = formatRGBA;

      function formatHSL(color) {
        if (color.hsla.a === 1) {
          return `hsl(${color.hsla.h}, ${(color.hsla.s * 100).toFixed(2)}%, ${(color.hsla.l * 100).toFixed(2)}%)`;
        }

        return Color.Format.CSS.formatHSLA(color);
      }

      _CSS.formatHSL = formatHSL;

      function formatHSLA(color) {
        return `hsla(${color.hsla.h}, ${(color.hsla.s * 100).toFixed(2)}%, ${(color.hsla.l * 100).toFixed(2)}%, ${color.hsla.a.toFixed(2)})`;
      }

      _CSS.formatHSLA = formatHSLA;

      function _toTwoDigitHex(n) {
        const r = n.toString(16);
        return r.length !== 2 ? '0' + r : r;
      }
      /**
       * Formats the color as #RRGGBB
       */


      function formatHex(color) {
        return `#${_toTwoDigitHex(color.rgba.r)}${_toTwoDigitHex(color.rgba.g)}${_toTwoDigitHex(color.rgba.b)}`;
      }

      _CSS.formatHex = formatHex;

      function formatHexA(color, compact = false) {
        if (compact && color.rgba.a === 1) {
          return Color.Format.CSS.formatHex(color);
        }

        return `#${_toTwoDigitHex(color.rgba.r)}${_toTwoDigitHex(color.rgba.g)}${_toTwoDigitHex(color.rgba.b)}${_toTwoDigitHex(Math.round(color.rgba.a * 255))}`;
      }

      _CSS.formatHexA = formatHexA;

      function format(color) {
        if (color.isOpaque()) {
          return Color.Format.CSS.formatHex(color);
        }

        return Color.Format.CSS.formatRGBA(color);
      }

      _CSS.format = format;

      function parseHex(hex) {
        const length = hex.length;

        if (length === 0) {
          // Invalid color
          return null;
        }

        if (hex.charCodeAt(0) !== _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Hash) {
          // Does not begin with a #
          return null;
        }

        if (length === 7) {
          // #RRGGBB format
          const r = 16 * _parseHexDigit(hex.charCodeAt(1)) + _parseHexDigit(hex.charCodeAt(2));

          const g = 16 * _parseHexDigit(hex.charCodeAt(3)) + _parseHexDigit(hex.charCodeAt(4));

          const b = 16 * _parseHexDigit(hex.charCodeAt(5)) + _parseHexDigit(hex.charCodeAt(6));

          return new Color(new RGBA(r, g, b, 1));
        }

        if (length === 9) {
          // #RRGGBBAA format
          const r = 16 * _parseHexDigit(hex.charCodeAt(1)) + _parseHexDigit(hex.charCodeAt(2));

          const g = 16 * _parseHexDigit(hex.charCodeAt(3)) + _parseHexDigit(hex.charCodeAt(4));

          const b = 16 * _parseHexDigit(hex.charCodeAt(5)) + _parseHexDigit(hex.charCodeAt(6));

          const a = 16 * _parseHexDigit(hex.charCodeAt(7)) + _parseHexDigit(hex.charCodeAt(8));

          return new Color(new RGBA(r, g, b, a / 255));
        }

        if (length === 4) {
          // #RGB format
          const r = _parseHexDigit(hex.charCodeAt(1));

          const g = _parseHexDigit(hex.charCodeAt(2));

          const b = _parseHexDigit(hex.charCodeAt(3));

          return new Color(new RGBA(16 * r + r, 16 * g + g, 16 * b + b));
        }

        if (length === 5) {
          // #RGBA format
          const r = _parseHexDigit(hex.charCodeAt(1));

          const g = _parseHexDigit(hex.charCodeAt(2));

          const b = _parseHexDigit(hex.charCodeAt(3));

          const a = _parseHexDigit(hex.charCodeAt(4));

          return new Color(new RGBA(16 * r + r, 16 * g + g, 16 * b + b, (16 * a + a) / 255));
        } // Invalid color


        return null;
      }

      _CSS.parseHex = parseHex;

      function _parseHexDigit(charCode) {
        switch (charCode) {
          case _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Digit0:
            return 0;

          case _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Digit1:
            return 1;

          case _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Digit2:
            return 2;

          case _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Digit3:
            return 3;

          case _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Digit4:
            return 4;

          case _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Digit5:
            return 5;

          case _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Digit6:
            return 6;

          case _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Digit7:
            return 7;

          case _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Digit8:
            return 8;

          case _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Digit9:
            return 9;

          case _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.a:
            return 10;

          case _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.A:
            return 10;

          case _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.b:
            return 11;

          case _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.B:
            return 11;

          case _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.c:
            return 12;

          case _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.C:
            return 12;

          case _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.d:
            return 13;

          case _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.D:
            return 13;

          case _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.e:
            return 14;

          case _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.E:
            return 14;

          case _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.f:
            return 15;

          case _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.F:
            return 15;
        }

        return 0;
      }
    })(CSS || (CSS = _Format.CSS || (_Format.CSS = {})));
  })(Format || (Format = _Color.Format || (_Color.Format = {})));
})(Color || (Color = {}));

/***/ }),
/* 92 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),
/* 93 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Orientation": () => (/* reexport safe */ _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_1__.Orientation),
/* harmony export */   "LayoutPriority": () => (/* binding */ LayoutPriority),
/* harmony export */   "Sizing": () => (/* binding */ Sizing),
/* harmony export */   "SplitView": () => (/* binding */ SplitView)
/* harmony export */ });
/* harmony import */ var _browser_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(61);
/* harmony import */ var _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(89);
/* harmony import */ var _browser_ui_scrollbar_scrollableElement__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(94);
/* harmony import */ var _common_arrays__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(87);
/* harmony import */ var _common_color__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(91);
/* harmony import */ var _common_event__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(51);
/* harmony import */ var _common_lifecycle__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(54);
/* harmony import */ var _common_numbers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(107);
/* harmony import */ var _common_scrollable__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(102);
/* harmony import */ var _common_types__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(79);
/* harmony import */ var _splitview_css__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(108);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/












const defaultStyles = {
  separatorBorder: _common_color__WEBPACK_IMPORTED_MODULE_4__.Color.transparent
};
let LayoutPriority;
/**
 * The interface to implement for views within a {@link SplitView}.
 *
 * An optional {@link TLayoutContext layout context type} may be used in order to
 * pass along layout contextual data from the {@link SplitView.layout} method down
 * to each view's {@link IView.layout} calls.
 */

(function (LayoutPriority) {
  LayoutPriority[LayoutPriority["Normal"] = 0] = "Normal";
  LayoutPriority[LayoutPriority["Low"] = 1] = "Low";
  LayoutPriority[LayoutPriority["High"] = 2] = "High";
})(LayoutPriority || (LayoutPriority = {}));

class ViewItem {
  set size(size) {
    this._size = size;
  }

  get size() {
    return this._size;
  }

  _cachedVisibleSize = undefined;

  get cachedVisibleSize() {
    return this._cachedVisibleSize;
  }

  get visible() {
    return typeof this._cachedVisibleSize === 'undefined';
  }

  setVisible(visible, size) {
    if (visible === this.visible) {
      return;
    }

    if (visible) {
      this.size = (0,_common_numbers__WEBPACK_IMPORTED_MODULE_7__.clamp)(this._cachedVisibleSize, this.viewMinimumSize, this.viewMaximumSize);
      this._cachedVisibleSize = undefined;
    } else {
      this._cachedVisibleSize = typeof size === 'number' ? size : this.size;
      this.size = 0;
    }

    this.container.classList.toggle('visible', visible);
    this.view.setVisible?.(visible);
  }

  get minimumSize() {
    return this.visible ? this.view.minimumSize : 0;
  }

  get viewMinimumSize() {
    return this.view.minimumSize;
  }

  get maximumSize() {
    return this.visible ? this.view.maximumSize : 0;
  }

  get viewMaximumSize() {
    return this.view.maximumSize;
  }

  get priority() {
    return this.view.priority;
  }

  get snap() {
    return !!this.view.snap;
  }

  set enabled(enabled) {
    this.container.style.pointerEvents = enabled ? '' : 'none';
  }

  constructor(container, view, size, disposable) {
    this.container = container;
    this.view = view;
    this.disposable = disposable;

    if (typeof size === 'number') {
      this._size = size;
      this._cachedVisibleSize = undefined;
      container.classList.add('visible');
    } else {
      this._size = 0;
      this._cachedVisibleSize = size.cachedVisibleSize;
    }
  }

  layout(offset, layoutContext) {
    this.layoutContainer(offset);
    this.view.layout(this.size, offset, layoutContext);
  }

  dispose() {
    this.disposable.dispose();
    return this.view;
  }

}

class VerticalViewItem extends ViewItem {
  layoutContainer(offset) {
    this.container.style.top = `${offset}px`;
    this.container.style.height = `${this.size}px`;
  }

}

class HorizontalViewItem extends ViewItem {
  layoutContainer(offset) {
    this.container.style.left = `${offset}px`;
    this.container.style.width = `${this.size}px`;
  }

}

var State;
/**
 * When adding or removing views, uniformly distribute the entire split view space among
 * all views.
 */

(function (State) {
  State[State["Idle"] = 0] = "Idle";
  State[State["Busy"] = 1] = "Busy";
})(State || (State = {}));

let Sizing;
/**
 * The {@link SplitView} is the UI component which implements a one dimensional
 * flex-like layout algorithm for a collection of {@link IView} instances, which
 * are essentially HTMLElement instances with the following size constraints:
 *
 * - {@link IView.minimumSize}
 * - {@link IView.maximumSize}
 * - {@link IView.priority}
 * - {@link IView.snap}
 *
 * In case the SplitView doesn't have enough size to fit all views, it will overflow
 * its content with a scrollbar.
 *
 * In between each pair of views there will be a {@link Sash} allowing the user
 * to resize the views, making sure the constraints are respected.
 *
 * An optional {@link TLayoutContext layout context type} may be used in order to
 * pass along layout contextual data from the {@link SplitView.layout} method down
 * to each view's {@link IView.layout} calls.
 *
 * Features:
 * - Flex-like layout algorithm
 * - Snap support
 * - Orthogonal sash support, for corner sashes
 * - View hide/show support
 * - View swap/move support
 * - Alt key modifier behavior, macOS style
 */

(function (_Sizing) {
  const Distribute = _Sizing.Distribute = {
    type: 'distribute'
  };

  function Split(index) {
    return {
      type: 'split',
      index
    };
  }

  _Sizing.Split = Split;

  function Invisible(cachedVisibleSize) {
    return {
      type: 'invisible',
      cachedVisibleSize
    };
  }

  _Sizing.Invisible = Invisible;
})(Sizing || (Sizing = {}));

class SplitView extends _common_lifecycle__WEBPACK_IMPORTED_MODULE_6__.Disposable {
  /**
   * This {@link SplitView}'s orientation.
   */

  /**
   * The DOM element representing this {@link SplitView}.
   */
  size = 0;
  contentSize = 0;
  proportions = undefined;
  viewItems = [];
  sashItems = [];
  state = State.Idle;
  _onDidSashChange = this._register(new _common_event__WEBPACK_IMPORTED_MODULE_5__.Emitter());
  _onDidSashReset = this._register(new _common_event__WEBPACK_IMPORTED_MODULE_5__.Emitter());
  _startSnappingEnabled = true;
  _endSnappingEnabled = true;
  /**
   * Fires whenever the user resizes a {@link Sash sash}.
   */

  onDidSashChange = this._onDidSashChange.event;
  /**
   * Fires whenever the user double clicks a {@link Sash sash}.
   */

  onDidSashReset = this._onDidSashReset.event;
  /**
   * Fires whenever the split view is scrolled.
   */

  /**
   * The amount of views in this {@link SplitView}.
   */
  get length() {
    return this.viewItems.length;
  }
  /**
   * The minimum size of this {@link SplitView}.
   */


  get minimumSize() {
    return this.viewItems.reduce((r, item) => r + item.minimumSize, 0);
  }
  /**
   * The maximum size of this {@link SplitView}.
   */


  get maximumSize() {
    return this.length === 0 ? Number.POSITIVE_INFINITY : this.viewItems.reduce((r, item) => r + item.maximumSize, 0);
  }

  get orthogonalStartSash() {
    return this._orthogonalStartSash;
  }

  get orthogonalEndSash() {
    return this._orthogonalEndSash;
  }

  get startSnappingEnabled() {
    return this._startSnappingEnabled;
  }

  get endSnappingEnabled() {
    return this._endSnappingEnabled;
  }
  /**
   * A reference to a sash, perpendicular to all sashes in this {@link SplitView},
   * located at the left- or top-most side of the SplitView.
   * Corner sashes will be created automatically at the intersections.
   */


  set orthogonalStartSash(sash) {
    for (const sashItem of this.sashItems) {
      sashItem.sash.orthogonalStartSash = sash;
    }

    this._orthogonalStartSash = sash;
  }
  /**
   * A reference to a sash, perpendicular to all sashes in this {@link SplitView},
   * located at the right- or bottom-most side of the SplitView.
   * Corner sashes will be created automatically at the intersections.
   */


  set orthogonalEndSash(sash) {
    for (const sashItem of this.sashItems) {
      sashItem.sash.orthogonalEndSash = sash;
    }

    this._orthogonalEndSash = sash;
  }
  /**
   * The internal sashes within this {@link SplitView}.
   */


  get sashes() {
    return this.sashItems.map(s => s.sash);
  }
  /**
   * Enable/disable snapping at the beginning of this {@link SplitView}.
   */


  set startSnappingEnabled(startSnappingEnabled) {
    if (this._startSnappingEnabled === startSnappingEnabled) {
      return;
    }

    this._startSnappingEnabled = startSnappingEnabled;
    this.updateSashEnablement();
  }
  /**
   * Enable/disable snapping at the end of this {@link SplitView}.
   */


  set endSnappingEnabled(endSnappingEnabled) {
    if (this._endSnappingEnabled === endSnappingEnabled) {
      return;
    }

    this._endSnappingEnabled = endSnappingEnabled;
    this.updateSashEnablement();
  }
  /**
   * Create a new {@link SplitView} instance.
   */


  constructor(container, options = {}) {
    super();
    this.orientation = options.orientation ?? _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_1__.Orientation.VERTICAL;
    this.inverseAltBehavior = options.inverseAltBehavior ?? false;
    this.proportionalLayout = options.proportionalLayout ?? true;
    this.getSashOrthogonalSize = options.getSashOrthogonalSize;
    this.el = document.createElement('div');
    this.el.classList.add('monaco-split-view2');
    this.el.classList.add(this.orientation === _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_1__.Orientation.VERTICAL ? 'vertical' : 'horizontal');
    container.appendChild(this.el);
    this.sashContainer = (0,_browser_dom__WEBPACK_IMPORTED_MODULE_0__.append)(this.el, (0,_browser_dom__WEBPACK_IMPORTED_MODULE_0__.$)('.sash-container'));
    this.viewContainer = (0,_browser_dom__WEBPACK_IMPORTED_MODULE_0__.$)('.split-view-container');
    this.scrollable = new _common_scrollable__WEBPACK_IMPORTED_MODULE_8__.Scrollable({
      forceIntegerValues: true,
      smoothScrollDuration: 125,
      scheduleAtNextAnimationFrame: _browser_dom__WEBPACK_IMPORTED_MODULE_0__.scheduleAtNextAnimationFrame
    });
    this.scrollableElement = this._register(new _browser_ui_scrollbar_scrollableElement__WEBPACK_IMPORTED_MODULE_2__.SmoothScrollableElement(this.viewContainer, {
      vertical: this.orientation === _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_1__.Orientation.VERTICAL ? options.scrollbarVisibility ?? _common_scrollable__WEBPACK_IMPORTED_MODULE_8__.ScrollbarVisibility.Auto : _common_scrollable__WEBPACK_IMPORTED_MODULE_8__.ScrollbarVisibility.Hidden,
      horizontal: this.orientation === _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_1__.Orientation.HORIZONTAL ? options.scrollbarVisibility ?? _common_scrollable__WEBPACK_IMPORTED_MODULE_8__.ScrollbarVisibility.Auto : _common_scrollable__WEBPACK_IMPORTED_MODULE_8__.ScrollbarVisibility.Hidden
    }, this.scrollable));
    this.onDidScroll = this.scrollableElement.onScroll;

    this._register(this.onDidScroll(e => {
      this.viewContainer.scrollTop = e.scrollTop;
      this.viewContainer.scrollLeft = e.scrollLeft;
    }));

    (0,_browser_dom__WEBPACK_IMPORTED_MODULE_0__.append)(this.el, this.scrollableElement.getDomNode());
    this.style(options.styles || defaultStyles); // We have an existing set of view, add them now

    if (options.descriptor) {
      this.size = options.descriptor.size;
      options.descriptor.views.forEach((viewDescriptor, index) => {
        const sizing = _common_types__WEBPACK_IMPORTED_MODULE_9__.isUndefined(viewDescriptor.visible) || viewDescriptor.visible ? viewDescriptor.size : {
          type: 'invisible',
          cachedVisibleSize: viewDescriptor.size
        };
        const view = viewDescriptor.view;
        this.doAddView(view, sizing, index, true);
      }); // Initialize content size and proportions for first layout

      this.contentSize = this.viewItems.reduce((r, i) => r + i.size, 0);
      this.saveProportions();
    }
  }

  style(styles) {
    if (styles.separatorBorder.isTransparent()) {
      this.el.classList.remove('separator-border');
      this.el.style.removeProperty('--separator-border');
    } else {
      this.el.classList.add('separator-border');
      this.el.style.setProperty('--separator-border', styles.separatorBorder.toString());
    }
  }
  /**
   * Add a {@link IView view} to this {@link SplitView}.
   *
   * @param view The view to add.
   * @param size Either a fixed size, or a dynamic {@link Sizing} strategy.
   * @param index The index to insert the view on.
   * @param skipLayout Whether layout should be skipped.
   */


  addView(view, size, index = this.viewItems.length, skipLayout) {
    this.doAddView(view, size, index, skipLayout);
  }
  /**
   * Remove a {@link IView view} from this {@link SplitView}.
   *
   * @param index The index where the {@link IView view} is located.
   * @param sizing Whether to distribute other {@link IView view}'s sizes.
   */


  removeView(index, sizing) {
    if (this.state !== State.Idle) {
      throw new Error('Cant modify splitview');
    }

    this.state = State.Busy;

    if (index < 0 || index >= this.viewItems.length) {
      throw new Error('Index out of bounds');
    } // Remove view


    const viewItem = this.viewItems.splice(index, 1)[0];
    const view = viewItem.dispose(); // Remove sash

    if (this.viewItems.length >= 1) {
      const sashIndex = Math.max(index - 1, 0);
      const sashItem = this.sashItems.splice(sashIndex, 1)[0];
      sashItem.disposable.dispose();
    }

    this.relayout();
    this.state = State.Idle;

    if (sizing?.type === 'distribute') {
      this.distributeViewSizes();
    }

    return view;
  }
  /**
   * Move a {@link IView view} to a different index.
   *
   * @param from The source index.
   * @param to The target index.
   */


  moveView(from, to) {
    if (this.state !== State.Idle) {
      throw new Error('Cant modify splitview');
    }

    const cachedVisibleSize = this.getViewCachedVisibleSize(from);
    const sizing = typeof cachedVisibleSize === 'undefined' ? this.getViewSize(from) : Sizing.Invisible(cachedVisibleSize);
    const view = this.removeView(from);
    this.addView(view, sizing, to);
  }
  /**
   * Swap two {@link IView views}.
   *
   * @param from The source index.
   * @param to The target index.
   */


  swapViews(from, to) {
    if (this.state !== State.Idle) {
      throw new Error('Cant modify splitview');
    }

    if (from > to) {
      return this.swapViews(to, from);
    }

    const fromSize = this.getViewSize(from);
    const toSize = this.getViewSize(to);
    const toView = this.removeView(to);
    const fromView = this.removeView(from);
    this.addView(toView, fromSize, from);
    this.addView(fromView, toSize, to);
  }
  /**
   * Returns whether the {@link IView view} is visible.
   *
   * @param index The {@link IView view} index.
   */


  isViewVisible(index) {
    if (index < 0 || index >= this.viewItems.length) {
      throw new Error('Index out of bounds');
    }

    const viewItem = this.viewItems[index];
    return viewItem.visible;
  }
  /**
   * Set a {@link IView view}'s visibility.
   *
   * @param index The {@link IView view} index.
   * @param visible Whether the {@link IView view} should be visible.
   */


  setViewVisible(index, visible) {
    if (index < 0 || index >= this.viewItems.length) {
      throw new Error('Index out of bounds');
    }

    const viewItem = this.viewItems[index];
    viewItem.setVisible(visible);
    this.distributeEmptySpace(index);
    this.layoutViews();
    this.saveProportions();
  }
  /**
   * Returns the {@link IView view}'s size previously to being hidden.
   *
   * @param index The {@link IView view} index.
   */


  getViewCachedVisibleSize(index) {
    if (index < 0 || index >= this.viewItems.length) {
      throw new Error('Index out of bounds');
    }

    const viewItem = this.viewItems[index];
    return viewItem.cachedVisibleSize;
  }
  /**
   * Layout the {@link SplitView}.
   *
   * @param size The entire size of the {@link SplitView}.
   * @param layoutContext An optional layout context to pass along to {@link IView views}.
   */


  layout(size, layoutContext) {
    console.info('split', size);
    const previousSize = Math.max(this.size, this.contentSize);
    this.size = size;
    this.layoutContext = layoutContext;

    if (!this.proportions) {
      const indexes = (0,_common_arrays__WEBPACK_IMPORTED_MODULE_3__.range)(this.viewItems.length);
      const lowPriorityIndexes = indexes.filter(i => this.viewItems[i].priority === LayoutPriority.Low);
      const highPriorityIndexes = indexes.filter(i => this.viewItems[i].priority === LayoutPriority.High);
      this.resize(this.viewItems.length - 1, size - previousSize, undefined, lowPriorityIndexes, highPriorityIndexes);
    } else {
      for (let i = 0; i < this.viewItems.length; i++) {
        const item = this.viewItems[i];
        item.size = (0,_common_numbers__WEBPACK_IMPORTED_MODULE_7__.clamp)(Math.round(this.proportions[i] * size), item.minimumSize, item.maximumSize);
      }
    }

    this.distributeEmptySpace();
    this.layoutViews();
  }

  saveProportions() {
    if (this.proportionalLayout && this.contentSize > 0) {
      this.proportions = this.viewItems.map(i => i.size / this.contentSize);
    }
  }

  onSashStart({
    sash,
    start,
    alt
  }) {
    for (const item of this.viewItems) {
      item.enabled = false;
    }

    const index = this.sashItems.findIndex(item => item.sash === sash); // This way, we can press Alt while we resize a sash, macOS style!

    const disposable = (0,_common_lifecycle__WEBPACK_IMPORTED_MODULE_6__.combinedDisposable)((0,_browser_dom__WEBPACK_IMPORTED_MODULE_0__.addDisposableListener)(document.body, 'keydown', e => resetSashDragState(this.sashDragState.current, e.altKey)), (0,_browser_dom__WEBPACK_IMPORTED_MODULE_0__.addDisposableListener)(document.body, 'keyup', () => resetSashDragState(this.sashDragState.current, false)));

    const resetSashDragState = (start, alt) => {
      const sizes = this.viewItems.map(i => i.size);
      let minDelta = Number.NEGATIVE_INFINITY;
      let maxDelta = Number.POSITIVE_INFINITY;

      if (this.inverseAltBehavior) {
        alt = !alt;
      }

      if (alt) {
        // When we're using the last sash with Alt, we're resizing
        // the view to the left/up, instead of right/down as usual
        // Thus, we must do the inverse of the usual
        const isLastSash = index === this.sashItems.length - 1;

        if (isLastSash) {
          const viewItem = this.viewItems[index];
          minDelta = (viewItem.minimumSize - viewItem.size) / 2;
          maxDelta = (viewItem.maximumSize - viewItem.size) / 2;
        } else {
          const viewItem = this.viewItems[index + 1];
          minDelta = (viewItem.size - viewItem.maximumSize) / 2;
          maxDelta = (viewItem.size - viewItem.minimumSize) / 2;
        }
      }

      let snapBefore;
      let snapAfter;

      if (!alt) {
        const upIndexes = (0,_common_arrays__WEBPACK_IMPORTED_MODULE_3__.range)(index, -1);
        const downIndexes = (0,_common_arrays__WEBPACK_IMPORTED_MODULE_3__.range)(index + 1, this.viewItems.length);
        const minDeltaUp = upIndexes.reduce((r, i) => r + (this.viewItems[i].minimumSize - sizes[i]), 0);
        const maxDeltaUp = upIndexes.reduce((r, i) => r + (this.viewItems[i].viewMaximumSize - sizes[i]), 0);
        const maxDeltaDown = downIndexes.length === 0 ? Number.POSITIVE_INFINITY : downIndexes.reduce((r, i) => r + (sizes[i] - this.viewItems[i].minimumSize), 0);
        const minDeltaDown = downIndexes.length === 0 ? Number.NEGATIVE_INFINITY : downIndexes.reduce((r, i) => r + (sizes[i] - this.viewItems[i].viewMaximumSize), 0);
        const minDelta = Math.max(minDeltaUp, minDeltaDown);
        const maxDelta = Math.min(maxDeltaDown, maxDeltaUp);
        const snapBeforeIndex = this.findFirstSnapIndex(upIndexes);
        const snapAfterIndex = this.findFirstSnapIndex(downIndexes);

        if (typeof snapBeforeIndex === 'number') {
          const viewItem = this.viewItems[snapBeforeIndex];
          const halfSize = Math.floor(viewItem.viewMinimumSize / 2);
          snapBefore = {
            index: snapBeforeIndex,
            limitDelta: viewItem.visible ? minDelta - halfSize : minDelta + halfSize,
            size: viewItem.size
          };
        }

        if (typeof snapAfterIndex === 'number') {
          const viewItem = this.viewItems[snapAfterIndex];
          const halfSize = Math.floor(viewItem.viewMinimumSize / 2);
          snapAfter = {
            index: snapAfterIndex,
            limitDelta: viewItem.visible ? maxDelta + halfSize : maxDelta - halfSize,
            size: viewItem.size
          };
        }
      }

      this.sashDragState = {
        start,
        current: start,
        index,
        sizes,
        minDelta,
        maxDelta,
        alt,
        snapBefore,
        snapAfter,
        disposable
      };
    };

    resetSashDragState(start, alt);
  }

  onSashChange({
    current
  }) {
    const {
      index,
      start,
      sizes,
      alt,
      minDelta,
      maxDelta,
      snapBefore,
      snapAfter
    } = this.sashDragState;
    this.sashDragState.current = current;
    const delta = current - start;
    const newDelta = this.resize(index, delta, sizes, undefined, undefined, minDelta, maxDelta, snapBefore, snapAfter);

    if (alt) {
      const isLastSash = index === this.sashItems.length - 1;
      const newSizes = this.viewItems.map(i => i.size);
      const viewItemIndex = isLastSash ? index : index + 1;
      const viewItem = this.viewItems[viewItemIndex];
      const newMinDelta = viewItem.size - viewItem.maximumSize;
      const newMaxDelta = viewItem.size - viewItem.minimumSize;
      const resizeIndex = isLastSash ? index - 1 : index + 1;
      this.resize(resizeIndex, -newDelta, newSizes, undefined, undefined, newMinDelta, newMaxDelta);
    }

    this.distributeEmptySpace();
    this.layoutViews();
  }

  onSashEnd(index) {
    this._onDidSashChange.fire(index);

    this.sashDragState.disposable.dispose();
    this.saveProportions();

    for (const item of this.viewItems) {
      item.enabled = true;
    }
  }

  onViewChange(item, size) {
    const index = this.viewItems.indexOf(item);

    if (index < 0 || index >= this.viewItems.length) {
      return;
    }

    size = typeof size === 'number' ? size : item.size;
    size = (0,_common_numbers__WEBPACK_IMPORTED_MODULE_7__.clamp)(size, item.minimumSize, item.maximumSize);

    if (this.inverseAltBehavior && index > 0) {
      // In this case, we want the view to grow or shrink both sides equally
      // so we just resize the "left" side by half and let `resize` do the clamping magic
      this.resize(index - 1, Math.floor((item.size - size) / 2));
      this.distributeEmptySpace();
      this.layoutViews();
    } else {
      item.size = size;
      this.relayout([index], undefined);
    }
  }
  /**
   * Resize a {@link IView view} within the {@link SplitView}.
   *
   * @param index The {@link IView view} index.
   * @param size The {@link IView view} size.
   */


  resizeView(index, size) {
    if (this.state !== State.Idle) {
      throw new Error('Cant modify splitview');
    }

    this.state = State.Busy;

    if (index < 0 || index >= this.viewItems.length) {
      return;
    }

    const indexes = (0,_common_arrays__WEBPACK_IMPORTED_MODULE_3__.range)(this.viewItems.length).filter(i => i !== index);
    const lowPriorityIndexes = [...indexes.filter(i => this.viewItems[i].priority === LayoutPriority.Low), index];
    const highPriorityIndexes = indexes.filter(i => this.viewItems[i].priority === LayoutPriority.High);
    const item = this.viewItems[index];
    size = Math.round(size);
    size = (0,_common_numbers__WEBPACK_IMPORTED_MODULE_7__.clamp)(size, item.minimumSize, Math.min(item.maximumSize, this.size));
    item.size = size;
    this.relayout(lowPriorityIndexes, highPriorityIndexes);
    this.state = State.Idle;
  }
  /**
   * Returns whether all other {@link IView views} are at their minimum size.
   */


  isViewSizeMaximized(index) {
    if (index < 0 || index >= this.viewItems.length) {
      return false;
    }

    for (const item of this.viewItems) {
      if (item !== this.viewItems[index] && item.size > item.minimumSize) {
        return false;
      }
    }

    return true;
  }
  /**
   * Distribute the entire {@link SplitView} size among all {@link IView views}.
   */


  distributeViewSizes() {
    const flexibleViewItems = [];
    let flexibleSize = 0;

    for (const item of this.viewItems) {
      if (item.maximumSize - item.minimumSize > 0) {
        flexibleViewItems.push(item);
        flexibleSize += item.size;
      }
    }

    const size = Math.floor(flexibleSize / flexibleViewItems.length);

    for (const item of flexibleViewItems) {
      item.size = (0,_common_numbers__WEBPACK_IMPORTED_MODULE_7__.clamp)(size, item.minimumSize, item.maximumSize);
    }

    const indexes = (0,_common_arrays__WEBPACK_IMPORTED_MODULE_3__.range)(this.viewItems.length);
    const lowPriorityIndexes = indexes.filter(i => this.viewItems[i].priority === LayoutPriority.Low);
    const highPriorityIndexes = indexes.filter(i => this.viewItems[i].priority === LayoutPriority.High);
    this.relayout(lowPriorityIndexes, highPriorityIndexes);
  }
  /**
   * Returns the size of a {@link IView view}.
   */


  getViewSize(index) {
    if (index < 0 || index >= this.viewItems.length) {
      return -1;
    }

    return this.viewItems[index].size;
  }

  doAddView(view, size, index = this.viewItems.length, skipLayout) {
    if (this.state !== State.Idle) {
      throw new Error('Cant modify splitview');
    }

    this.state = State.Busy; // Add view

    const container = (0,_browser_dom__WEBPACK_IMPORTED_MODULE_0__.$)('.split-view-view');

    if (index === this.viewItems.length) {
      this.viewContainer.appendChild(container);
    } else {
      this.viewContainer.insertBefore(container, this.viewContainer.children.item(index));
    }

    const onChangeDisposable = view.onDidChange(size => this.onViewChange(item, size));
    const containerDisposable = (0,_common_lifecycle__WEBPACK_IMPORTED_MODULE_6__.toDisposable)(() => this.viewContainer.removeChild(container));
    const disposable = (0,_common_lifecycle__WEBPACK_IMPORTED_MODULE_6__.combinedDisposable)(onChangeDisposable, containerDisposable);
    let viewSize;

    if (typeof size === 'number') {
      viewSize = size;
    } else if (size.type === 'split') {
      viewSize = this.getViewSize(size.index) / 2;
    } else if (size.type === 'invisible') {
      viewSize = {
        cachedVisibleSize: size.cachedVisibleSize
      };
    } else {
      viewSize = view.minimumSize;
    }

    const item = this.orientation === _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_1__.Orientation.VERTICAL ? new VerticalViewItem(container, view, viewSize, disposable) : new HorizontalViewItem(container, view, viewSize, disposable);
    this.viewItems.splice(index, 0, item); // Add sash

    if (this.viewItems.length > 1) {
      const opts = {
        orthogonalStartSash: this.orthogonalStartSash,
        orthogonalEndSash: this.orthogonalEndSash
      };
      const sash = this.orientation === _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_1__.Orientation.VERTICAL ? new _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_1__.Sash(this.sashContainer, {
        getHorizontalSashTop: s => this.getSashPosition(s),
        getHorizontalSashWidth: this.getSashOrthogonalSize
      }, { ...opts,
        orientation: _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_1__.Orientation.HORIZONTAL
      }) : new _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_1__.Sash(this.sashContainer, {
        getVerticalSashLeft: s => this.getSashPosition(s),
        getVerticalSashHeight: this.getSashOrthogonalSize
      }, { ...opts,
        orientation: _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_1__.Orientation.VERTICAL
      });
      const sashEventMapper = this.orientation === _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_1__.Orientation.VERTICAL ? e => ({
        sash,
        start: e.startY,
        current: e.currentY,
        alt: e.altKey
      }) : e => ({
        sash,
        start: e.startX,
        current: e.currentX,
        alt: e.altKey
      });
      const onStart = _common_event__WEBPACK_IMPORTED_MODULE_5__.Event.map(sash.onDidStart, sashEventMapper);
      const onStartDisposable = onStart(this.onSashStart, this);
      const onChange = _common_event__WEBPACK_IMPORTED_MODULE_5__.Event.map(sash.onDidChange, sashEventMapper);
      const onChangeDisposable = onChange(this.onSashChange, this);
      const onEnd = _common_event__WEBPACK_IMPORTED_MODULE_5__.Event.map(sash.onDidEnd, () => this.sashItems.findIndex(item => item.sash === sash));
      const onEndDisposable = onEnd(this.onSashEnd, this);
      const onDidResetDisposable = sash.onDidReset(() => {
        const index = this.sashItems.findIndex(item => item.sash === sash);
        const upIndexes = (0,_common_arrays__WEBPACK_IMPORTED_MODULE_3__.range)(index, -1);
        const downIndexes = (0,_common_arrays__WEBPACK_IMPORTED_MODULE_3__.range)(index + 1, this.viewItems.length);
        const snapBeforeIndex = this.findFirstSnapIndex(upIndexes);
        const snapAfterIndex = this.findFirstSnapIndex(downIndexes);

        if (typeof snapBeforeIndex === 'number' && !this.viewItems[snapBeforeIndex].visible) {
          return;
        }

        if (typeof snapAfterIndex === 'number' && !this.viewItems[snapAfterIndex].visible) {
          return;
        }

        this._onDidSashReset.fire(index);
      });
      const disposable = (0,_common_lifecycle__WEBPACK_IMPORTED_MODULE_6__.combinedDisposable)(onStartDisposable, onChangeDisposable, onEndDisposable, onDidResetDisposable, sash);
      const sashItem = {
        sash,
        disposable
      };
      this.sashItems.splice(index - 1, 0, sashItem);
    }

    container.appendChild(view.element);
    let highPriorityIndexes;

    if (typeof size !== 'number' && size.type === 'split') {
      highPriorityIndexes = [size.index];
    }

    if (!skipLayout) {
      this.relayout([index], highPriorityIndexes);
    }

    this.state = State.Idle;

    if (!skipLayout && typeof size !== 'number' && size.type === 'distribute') {
      this.distributeViewSizes();
    }
  }

  relayout(lowPriorityIndexes, highPriorityIndexes) {
    const contentSize = this.viewItems.reduce((r, i) => r + i.size, 0);
    this.resize(this.viewItems.length - 1, this.size - contentSize, undefined, lowPriorityIndexes, highPriorityIndexes);
    this.distributeEmptySpace();
    this.layoutViews();
    this.saveProportions();
  }

  resize(index, delta, sizes = this.viewItems.map(i => i.size), lowPriorityIndexes, highPriorityIndexes, overloadMinDelta = Number.NEGATIVE_INFINITY, overloadMaxDelta = Number.POSITIVE_INFINITY, snapBefore, snapAfter) {
    if (index < 0 || index >= this.viewItems.length) {
      return 0;
    }

    const upIndexes = (0,_common_arrays__WEBPACK_IMPORTED_MODULE_3__.range)(index, -1);
    const downIndexes = (0,_common_arrays__WEBPACK_IMPORTED_MODULE_3__.range)(index + 1, this.viewItems.length);

    if (highPriorityIndexes) {
      for (const index of highPriorityIndexes) {
        (0,_common_arrays__WEBPACK_IMPORTED_MODULE_3__.pushToStart)(upIndexes, index);
        (0,_common_arrays__WEBPACK_IMPORTED_MODULE_3__.pushToStart)(downIndexes, index);
      }
    }

    if (lowPriorityIndexes) {
      for (const index of lowPriorityIndexes) {
        (0,_common_arrays__WEBPACK_IMPORTED_MODULE_3__.pushToEnd)(upIndexes, index);
        (0,_common_arrays__WEBPACK_IMPORTED_MODULE_3__.pushToEnd)(downIndexes, index);
      }
    }

    const upItems = upIndexes.map(i => this.viewItems[i]);
    const upSizes = upIndexes.map(i => sizes[i]);
    const downItems = downIndexes.map(i => this.viewItems[i]);
    const downSizes = downIndexes.map(i => sizes[i]);
    const minDeltaUp = upIndexes.reduce((r, i) => r + (this.viewItems[i].minimumSize - sizes[i]), 0);
    const maxDeltaUp = upIndexes.reduce((r, i) => r + (this.viewItems[i].maximumSize - sizes[i]), 0);
    const maxDeltaDown = downIndexes.length === 0 ? Number.POSITIVE_INFINITY : downIndexes.reduce((r, i) => r + (sizes[i] - this.viewItems[i].minimumSize), 0);
    const minDeltaDown = downIndexes.length === 0 ? Number.NEGATIVE_INFINITY : downIndexes.reduce((r, i) => r + (sizes[i] - this.viewItems[i].maximumSize), 0);
    const minDelta = Math.max(minDeltaUp, minDeltaDown, overloadMinDelta);
    const maxDelta = Math.min(maxDeltaDown, maxDeltaUp, overloadMaxDelta);
    let snapped = false;

    if (snapBefore) {
      const snapView = this.viewItems[snapBefore.index];
      const visible = delta >= snapBefore.limitDelta;
      snapped = visible !== snapView.visible;
      snapView.setVisible(visible, snapBefore.size);
    }

    if (!snapped && snapAfter) {
      const snapView = this.viewItems[snapAfter.index];
      const visible = delta < snapAfter.limitDelta;
      snapped = visible !== snapView.visible;
      snapView.setVisible(visible, snapAfter.size);
    }

    if (snapped) {
      return this.resize(index, delta, sizes, lowPriorityIndexes, highPriorityIndexes, overloadMinDelta, overloadMaxDelta);
    }

    delta = (0,_common_numbers__WEBPACK_IMPORTED_MODULE_7__.clamp)(delta, minDelta, maxDelta);

    for (let i = 0, deltaUp = delta; i < upItems.length; i++) {
      const item = upItems[i];
      const size = (0,_common_numbers__WEBPACK_IMPORTED_MODULE_7__.clamp)(upSizes[i] + deltaUp, item.minimumSize, item.maximumSize);
      const viewDelta = size - upSizes[i];
      deltaUp -= viewDelta;
      item.size = size;
    }

    for (let i = 0, deltaDown = delta; i < downItems.length; i++) {
      const item = downItems[i];
      const size = (0,_common_numbers__WEBPACK_IMPORTED_MODULE_7__.clamp)(downSizes[i] - deltaDown, item.minimumSize, item.maximumSize);
      const viewDelta = size - downSizes[i];
      deltaDown += viewDelta;
      item.size = size;
    }

    return delta;
  }

  distributeEmptySpace(lowPriorityIndex) {
    const contentSize = this.viewItems.reduce((r, i) => r + i.size, 0);
    let emptyDelta = this.size - contentSize;
    const indexes = (0,_common_arrays__WEBPACK_IMPORTED_MODULE_3__.range)(this.viewItems.length - 1, -1);
    const lowPriorityIndexes = indexes.filter(i => this.viewItems[i].priority === LayoutPriority.Low);
    const highPriorityIndexes = indexes.filter(i => this.viewItems[i].priority === LayoutPriority.High);

    for (const index of highPriorityIndexes) {
      (0,_common_arrays__WEBPACK_IMPORTED_MODULE_3__.pushToStart)(indexes, index);
    }

    for (const index of lowPriorityIndexes) {
      (0,_common_arrays__WEBPACK_IMPORTED_MODULE_3__.pushToEnd)(indexes, index);
    }

    if (typeof lowPriorityIndex === 'number') {
      (0,_common_arrays__WEBPACK_IMPORTED_MODULE_3__.pushToEnd)(indexes, lowPriorityIndex);
    }

    for (let i = 0; emptyDelta !== 0 && i < indexes.length; i++) {
      const item = this.viewItems[indexes[i]];
      const size = (0,_common_numbers__WEBPACK_IMPORTED_MODULE_7__.clamp)(item.size + emptyDelta, item.minimumSize, item.maximumSize);
      const viewDelta = size - item.size;
      emptyDelta -= viewDelta;
      item.size = size;
    }
  }

  layoutViews() {
    // Save new content size
    this.contentSize = this.viewItems.reduce((r, i) => r + i.size, 0); // Layout views

    let offset = 0;

    for (const viewItem of this.viewItems) {
      viewItem.layout(offset, this.layoutContext);
      offset += viewItem.size;
    } // Layout sashes


    this.sashItems.forEach(item => item.sash.layout());
    this.updateSashEnablement();
    this.updateScrollableElement();
  }

  updateScrollableElement() {
    if (this.orientation === _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_1__.Orientation.VERTICAL) {
      this.scrollableElement.setScrollDimensions({
        height: this.size,
        scrollHeight: this.contentSize
      });
    } else {
      this.scrollableElement.setScrollDimensions({
        width: this.size,
        scrollWidth: this.contentSize
      });
    }
  }

  updateSashEnablement() {
    let previous = false;
    const collapsesDown = this.viewItems.map(i => previous = i.size - i.minimumSize > 0 || previous);
    previous = false;
    const expandsDown = this.viewItems.map(i => previous = i.maximumSize - i.size > 0 || previous);
    const reverseViews = [...this.viewItems].reverse();
    previous = false;
    const collapsesUp = reverseViews.map(i => previous = i.size - i.minimumSize > 0 || previous).reverse();
    previous = false;
    const expandsUp = reverseViews.map(i => previous = i.maximumSize - i.size > 0 || previous).reverse();
    let position = 0;

    for (let index = 0; index < this.sashItems.length; index++) {
      const {
        sash
      } = this.sashItems[index];
      const viewItem = this.viewItems[index];
      position += viewItem.size;
      const min = !(collapsesDown[index] && expandsUp[index + 1]);
      const max = !(expandsDown[index] && collapsesUp[index + 1]);

      if (min && max) {
        const upIndexes = (0,_common_arrays__WEBPACK_IMPORTED_MODULE_3__.range)(index, -1);
        const downIndexes = (0,_common_arrays__WEBPACK_IMPORTED_MODULE_3__.range)(index + 1, this.viewItems.length);
        const snapBeforeIndex = this.findFirstSnapIndex(upIndexes);
        const snapAfterIndex = this.findFirstSnapIndex(downIndexes);
        const snappedBefore = typeof snapBeforeIndex === 'number' && !this.viewItems[snapBeforeIndex].visible;
        const snappedAfter = typeof snapAfterIndex === 'number' && !this.viewItems[snapAfterIndex].visible;

        if (snappedBefore && collapsesUp[index] && (position > 0 || this.startSnappingEnabled)) {
          sash.state = _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_1__.SashState.AtMinimum;
        } else if (snappedAfter && collapsesDown[index] && (position < this.contentSize || this.endSnappingEnabled)) {
          sash.state = _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_1__.SashState.AtMaximum;
        } else {
          sash.state = _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_1__.SashState.Disabled;
        }
      } else if (min && !max) {
        sash.state = _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_1__.SashState.AtMinimum;
      } else if (!min && max) {
        sash.state = _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_1__.SashState.AtMaximum;
      } else {
        sash.state = _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_1__.SashState.Enabled;
      }
    }
  }

  getSashPosition(sash) {
    let position = 0;

    for (let i = 0; i < this.sashItems.length; i++) {
      position += this.viewItems[i].size;

      if (this.sashItems[i].sash === sash) {
        return position;
      }
    }

    return 0;
  }

  findFirstSnapIndex(indexes) {
    // visible views first
    for (const index of indexes) {
      const viewItem = this.viewItems[index];

      if (!viewItem.visible) {
        continue;
      }

      if (viewItem.snap) {
        return index;
      }
    } // then, hidden views


    for (const index of indexes) {
      const viewItem = this.viewItems[index];

      if (viewItem.visible && viewItem.maximumSize - viewItem.minimumSize > 0) {
        return undefined;
      }

      if (!viewItem.visible && viewItem.snap) {
        return index;
      }
    }

    return undefined;
  }

  dispose() {
    super.dispose();
    (0,_common_lifecycle__WEBPACK_IMPORTED_MODULE_6__.dispose)(this.viewItems);
    this.viewItems = [];
    this.sashItems.forEach(i => i.disposable.dispose());
    this.sashItems = [];
  }

}

/***/ }),
/* 94 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MouseWheelClassifier": () => (/* binding */ MouseWheelClassifier),
/* harmony export */   "AbstractScrollableElement": () => (/* binding */ AbstractScrollableElement),
/* harmony export */   "ScrollableElement": () => (/* binding */ ScrollableElement),
/* harmony export */   "SmoothScrollableElement": () => (/* binding */ SmoothScrollableElement),
/* harmony export */   "DomScrollableElement": () => (/* binding */ DomScrollableElement)
/* harmony export */ });
/* harmony import */ var _browser_browser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(50);
/* harmony import */ var _browser_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(61);
/* harmony import */ var _browser_fastDomNode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(95);
/* harmony import */ var _browser_mouseEvent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(66);
/* harmony import */ var _browser_ui_scrollbar_horizontalScrollbar__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(96);
/* harmony import */ var _browser_ui_scrollbar_verticalScrollbar__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(105);
/* harmony import */ var _browser_ui_widget__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(100);
/* harmony import */ var _common_async__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(68);
/* harmony import */ var _common_event__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(51);
/* harmony import */ var _common_lifecycle__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(54);
/* harmony import */ var _common_platform__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(58);
/* harmony import */ var _common_scrollable__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(102);
/* harmony import */ var _media_scrollbars_css__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(106);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













const HIDE_TIMEOUT = 500;
const SCROLL_WHEEL_SENSITIVITY = 50;
const SCROLL_WHEEL_SMOOTH_SCROLL_ENABLED = true;

class MouseWheelClassifierItem {
  constructor(timestamp, deltaX, deltaY) {
    this.timestamp = timestamp;
    this.deltaX = deltaX;
    this.deltaY = deltaY;
    this.score = 0;
  }

}

class MouseWheelClassifier {
  static INSTANCE = new MouseWheelClassifier();

  constructor() {
    this._capacity = 5;
    this._memory = [];
    this._front = -1;
    this._rear = -1;
  }

  isPhysicalMouseWheel() {
    if (this._front === -1 && this._rear === -1) {
      // no elements
      return false;
    } // 0.5 * last + 0.25 * 2nd last + 0.125 * 3rd last + ...


    let remainingInfluence = 1;
    let score = 0;
    let iteration = 1;
    let index = this._rear;

    do {
      const influence = index === this._front ? remainingInfluence : Math.pow(2, -iteration);
      remainingInfluence -= influence;
      score += this._memory[index].score * influence;

      if (index === this._front) {
        break;
      }

      index = (this._capacity + index - 1) % this._capacity;
      iteration++;
    } while (true);

    return score <= 0.5;
  }

  accept(timestamp, deltaX, deltaY) {
    const item = new MouseWheelClassifierItem(timestamp, deltaX, deltaY);
    item.score = this._computeScore(item);

    if (this._front === -1 && this._rear === -1) {
      this._memory[0] = item;
      this._front = 0;
      this._rear = 0;
    } else {
      this._rear = (this._rear + 1) % this._capacity;

      if (this._rear === this._front) {
        // Drop oldest
        this._front = (this._front + 1) % this._capacity;
      }

      this._memory[this._rear] = item;
    }
  }
  /**
   * A score between 0 and 1 for `item`.
   *  - a score towards 0 indicates that the source appears to be a physical mouse wheel
   *  - a score towards 1 indicates that the source appears to be a touchpad or magic mouse, etc.
   */


  _computeScore(item) {
    if (Math.abs(item.deltaX) > 0 && Math.abs(item.deltaY) > 0) {
      // both axes exercised => definitely not a physical mouse wheel
      return 1;
    }

    let score = 0.5;
    const prev = this._front === -1 && this._rear === -1 ? null : this._memory[this._rear];

    if (prev) {// const deltaT = item.timestamp - prev.timestamp;
      // if (deltaT < 1000 / 30) {
      // 	// sooner than X times per second => indicator that this is not a physical mouse wheel
      // 	score += 0.25;
      // }
      // if (item.deltaX === prev.deltaX && item.deltaY === prev.deltaY) {
      // 	// equal amplitude => indicator that this is a physical mouse wheel
      // 	score -= 0.25;
      // }
    }

    if (!this._isAlmostInt(item.deltaX) || !this._isAlmostInt(item.deltaY)) {
      // non-integer deltas => indicator that this is not a physical mouse wheel
      score += 0.25;
    }

    return Math.min(Math.max(score, 0), 1);
  }

  _isAlmostInt(value) {
    const delta = Math.abs(Math.round(value) - value);
    return delta < 0.01;
  }

}
class AbstractScrollableElement extends _browser_ui_widget__WEBPACK_IMPORTED_MODULE_6__.Widget {
  _onScroll = this._register(new _common_event__WEBPACK_IMPORTED_MODULE_8__.Emitter());
  onScroll = this._onScroll.event;
  _onWillScroll = this._register(new _common_event__WEBPACK_IMPORTED_MODULE_8__.Emitter());
  onWillScroll = this._onWillScroll.event;

  get options() {
    return this._options;
  }

  constructor(element, options, scrollable) {
    super();
    element.style.overflow = 'hidden';
    this._options = resolveOptions(options);
    this._scrollable = scrollable;

    this._register(this._scrollable.onScroll(e => {
      this._onWillScroll.fire(e);

      this._onDidScroll(e);

      this._onScroll.fire(e);
    }));

    const scrollbarHost = {
      onMouseWheel: mouseWheelEvent => this._onMouseWheel(mouseWheelEvent),
      onDragStart: () => this._onDragStart(),
      onDragEnd: () => this._onDragEnd()
    };
    this._verticalScrollbar = this._register(new _browser_ui_scrollbar_verticalScrollbar__WEBPACK_IMPORTED_MODULE_5__.VerticalScrollbar(this._scrollable, this._options, scrollbarHost));
    this._horizontalScrollbar = this._register(new _browser_ui_scrollbar_horizontalScrollbar__WEBPACK_IMPORTED_MODULE_4__.HorizontalScrollbar(this._scrollable, this._options, scrollbarHost));
    this._domNode = document.createElement('div');
    this._domNode.className = 'monaco-scrollable-element ' + this._options.className;

    this._domNode.setAttribute('role', 'presentation');

    this._domNode.style.position = 'relative';
    this._domNode.style.overflow = 'hidden';

    this._domNode.appendChild(element);

    this._domNode.appendChild(this._horizontalScrollbar.domNode.domNode);

    this._domNode.appendChild(this._verticalScrollbar.domNode.domNode);

    if (this._options.useShadows) {
      this._leftShadowDomNode = (0,_browser_fastDomNode__WEBPACK_IMPORTED_MODULE_2__.createFastDomNode)(document.createElement('div'));

      this._leftShadowDomNode.setClassName('shadow');

      this._domNode.appendChild(this._leftShadowDomNode.domNode);

      this._topShadowDomNode = (0,_browser_fastDomNode__WEBPACK_IMPORTED_MODULE_2__.createFastDomNode)(document.createElement('div'));

      this._topShadowDomNode.setClassName('shadow');

      this._domNode.appendChild(this._topShadowDomNode.domNode);

      this._topLeftShadowDomNode = (0,_browser_fastDomNode__WEBPACK_IMPORTED_MODULE_2__.createFastDomNode)(document.createElement('div'));

      this._topLeftShadowDomNode.setClassName('shadow');

      this._domNode.appendChild(this._topLeftShadowDomNode.domNode);
    } else {
      this._leftShadowDomNode = null;
      this._topShadowDomNode = null;
      this._topLeftShadowDomNode = null;
    }

    this._listenOnDomNode = this._options.listenOnDomNode || this._domNode;
    this._mouseWheelToDispose = [];

    this._setListeningToMouseWheel(this._options.handleMouseWheel);

    this.onmouseover(this._listenOnDomNode, e => this._onMouseOver(e));
    this.onmouseleave(this._listenOnDomNode, e => this._onMouseLeave(e));
    this._hideTimeout = this._register(new _common_async__WEBPACK_IMPORTED_MODULE_7__.TimeoutTimer());
    this._isDragging = false;
    this._mouseIsOver = false;
    this._shouldRender = true;
    this._revealOnScroll = true;
  }

  dispose() {
    this._mouseWheelToDispose = (0,_common_lifecycle__WEBPACK_IMPORTED_MODULE_9__.dispose)(this._mouseWheelToDispose);
    super.dispose();
  }
  /**
   * Get the generated 'scrollable' dom node
   */


  getDomNode() {
    return this._domNode;
  }

  getOverviewRulerLayoutInfo() {
    return {
      parent: this._domNode,
      insertBefore: this._verticalScrollbar.domNode.domNode
    };
  }
  /**
   * Delegate a pointer down event to the vertical scrollbar.
   * This is to help with clicking somewhere else and having the scrollbar react.
   */


  delegateVerticalScrollbarPointerDown(browserEvent) {
    this._verticalScrollbar.delegatePointerDown(browserEvent);
  }

  getScrollDimensions() {
    return this._scrollable.getScrollDimensions();
  }

  setScrollDimensions(dimensions) {
    this._scrollable.setScrollDimensions(dimensions, false);
  }
  /**
   * Update the class name of the scrollable element.
   */


  updateClassName(newClassName) {
    this._options.className = newClassName; // Defaults are different on Macs

    if (_common_platform__WEBPACK_IMPORTED_MODULE_10__.isMacintosh) {
      this._options.className += ' mac';
    }

    this._domNode.className = 'monaco-scrollable-element ' + this._options.className;
  }
  /**
   * Update configuration options for the scrollbar.
   */


  updateOptions(newOptions) {
    if (typeof newOptions.handleMouseWheel !== 'undefined') {
      this._options.handleMouseWheel = newOptions.handleMouseWheel;

      this._setListeningToMouseWheel(this._options.handleMouseWheel);
    }

    if (typeof newOptions.mouseWheelScrollSensitivity !== 'undefined') {
      this._options.mouseWheelScrollSensitivity = newOptions.mouseWheelScrollSensitivity;
    }

    if (typeof newOptions.fastScrollSensitivity !== 'undefined') {
      this._options.fastScrollSensitivity = newOptions.fastScrollSensitivity;
    }

    if (typeof newOptions.scrollPredominantAxis !== 'undefined') {
      this._options.scrollPredominantAxis = newOptions.scrollPredominantAxis;
    }

    if (typeof newOptions.horizontal !== 'undefined') {
      this._options.horizontal = newOptions.horizontal;
    }

    if (typeof newOptions.vertical !== 'undefined') {
      this._options.vertical = newOptions.vertical;
    }

    if (typeof newOptions.horizontalScrollbarSize !== 'undefined') {
      this._options.horizontalScrollbarSize = newOptions.horizontalScrollbarSize;
    }

    if (typeof newOptions.verticalScrollbarSize !== 'undefined') {
      this._options.verticalScrollbarSize = newOptions.verticalScrollbarSize;
    }

    if (typeof newOptions.scrollByPage !== 'undefined') {
      this._options.scrollByPage = newOptions.scrollByPage;
    }

    this._horizontalScrollbar.updateOptions(this._options);

    this._verticalScrollbar.updateOptions(this._options);

    if (!this._options.lazyRender) {
      this._render();
    }
  }

  setRevealOnScroll(value) {
    this._revealOnScroll = value;
  }

  triggerScrollFromMouseWheelEvent(browserEvent) {
    this._onMouseWheel(new _browser_mouseEvent__WEBPACK_IMPORTED_MODULE_3__.StandardWheelEvent(browserEvent));
  } // -------------------- mouse wheel scrolling --------------------


  _setListeningToMouseWheel(shouldListen) {
    const isListening = this._mouseWheelToDispose.length > 0;

    if (isListening === shouldListen) {
      // No change
      return;
    } // Stop listening (if necessary)


    this._mouseWheelToDispose = (0,_common_lifecycle__WEBPACK_IMPORTED_MODULE_9__.dispose)(this._mouseWheelToDispose); // Start listening (if necessary)

    if (shouldListen) {
      const onMouseWheel = browserEvent => {
        this._onMouseWheel(new _browser_mouseEvent__WEBPACK_IMPORTED_MODULE_3__.StandardWheelEvent(browserEvent));
      };

      this._mouseWheelToDispose.push(_browser_dom__WEBPACK_IMPORTED_MODULE_1__.addDisposableListener(this._listenOnDomNode, _browser_dom__WEBPACK_IMPORTED_MODULE_1__.EventType.MOUSE_WHEEL, onMouseWheel, {
        passive: false
      }));
    }
  }

  _onMouseWheel(e) {
    const classifier = MouseWheelClassifier.INSTANCE;

    if (SCROLL_WHEEL_SMOOTH_SCROLL_ENABLED) {
      const osZoomFactor = window.devicePixelRatio / (0,_browser_browser__WEBPACK_IMPORTED_MODULE_0__.getZoomFactor)();

      if (_common_platform__WEBPACK_IMPORTED_MODULE_10__.isWindows || _common_platform__WEBPACK_IMPORTED_MODULE_10__.isLinux) {
        // On Windows and Linux, the incoming delta events are multiplied with the OS zoom factor.
        // The OS zoom factor can be reverse engineered by using the device pixel ratio and the configured zoom factor into account.
        classifier.accept(Date.now(), e.deltaX / osZoomFactor, e.deltaY / osZoomFactor);
      } else {
        classifier.accept(Date.now(), e.deltaX, e.deltaY);
      }
    } // console.log(`${Date.now()}, ${e.deltaY}, ${e.deltaX}`);


    let didScroll = false;

    if (e.deltaY || e.deltaX) {
      let deltaY = e.deltaY * this._options.mouseWheelScrollSensitivity;
      let deltaX = e.deltaX * this._options.mouseWheelScrollSensitivity;

      if (this._options.scrollPredominantAxis) {
        if (Math.abs(deltaY) >= Math.abs(deltaX)) {
          deltaX = 0;
        } else {
          deltaY = 0;
        }
      }

      if (this._options.flipAxes) {
        [deltaY, deltaX] = [deltaX, deltaY];
      } // Convert vertical scrolling to horizontal if shift is held, this
      // is handled at a higher level on Mac


      const shiftConvert = !_common_platform__WEBPACK_IMPORTED_MODULE_10__.isMacintosh && e.browserEvent && e.browserEvent.shiftKey;

      if ((this._options.scrollYToX || shiftConvert) && !deltaX) {
        deltaX = deltaY;
        deltaY = 0;
      }

      if (e.browserEvent && e.browserEvent.altKey) {
        // fastScrolling
        deltaX = deltaX * this._options.fastScrollSensitivity;
        deltaY = deltaY * this._options.fastScrollSensitivity;
      }

      const futureScrollPosition = this._scrollable.getFutureScrollPosition();

      let desiredScrollPosition = {};

      if (deltaY) {
        const deltaScrollTop = SCROLL_WHEEL_SENSITIVITY * deltaY; // Here we convert values such as -0.3 to -1 or 0.3 to 1, otherwise low speed scrolling will never scroll

        const desiredScrollTop = futureScrollPosition.scrollTop - (deltaScrollTop < 0 ? Math.floor(deltaScrollTop) : Math.ceil(deltaScrollTop));

        this._verticalScrollbar.writeScrollPosition(desiredScrollPosition, desiredScrollTop);
      }

      if (deltaX) {
        const deltaScrollLeft = SCROLL_WHEEL_SENSITIVITY * deltaX; // Here we convert values such as -0.3 to -1 or 0.3 to 1, otherwise low speed scrolling will never scroll

        const desiredScrollLeft = futureScrollPosition.scrollLeft - (deltaScrollLeft < 0 ? Math.floor(deltaScrollLeft) : Math.ceil(deltaScrollLeft));

        this._horizontalScrollbar.writeScrollPosition(desiredScrollPosition, desiredScrollLeft);
      } // Check that we are scrolling towards a location which is valid


      desiredScrollPosition = this._scrollable.validateScrollPosition(desiredScrollPosition);

      if (futureScrollPosition.scrollLeft !== desiredScrollPosition.scrollLeft || futureScrollPosition.scrollTop !== desiredScrollPosition.scrollTop) {
        const canPerformSmoothScroll = SCROLL_WHEEL_SMOOTH_SCROLL_ENABLED && this._options.mouseWheelSmoothScroll && classifier.isPhysicalMouseWheel();

        if (canPerformSmoothScroll) {
          this._scrollable.setScrollPositionSmooth(desiredScrollPosition);
        } else {
          this._scrollable.setScrollPositionNow(desiredScrollPosition);
        }

        didScroll = true;
      }
    }

    let consumeMouseWheel = didScroll;

    if (!consumeMouseWheel && this._options.alwaysConsumeMouseWheel) {
      consumeMouseWheel = true;
    }

    if (!consumeMouseWheel && this._options.consumeMouseWheelIfScrollbarIsNeeded && (this._verticalScrollbar.isNeeded() || this._horizontalScrollbar.isNeeded())) {
      consumeMouseWheel = true;
    }

    if (consumeMouseWheel) {
      e.preventDefault();
      e.stopPropagation();
    }
  }

  _onDidScroll(e) {
    this._shouldRender = this._horizontalScrollbar.onDidScroll(e) || this._shouldRender;
    this._shouldRender = this._verticalScrollbar.onDidScroll(e) || this._shouldRender;

    if (this._options.useShadows) {
      this._shouldRender = true;
    }

    if (this._revealOnScroll) {
      this._reveal();
    }

    if (!this._options.lazyRender) {
      this._render();
    }
  }
  /**
   * Render / mutate the DOM now.
   * Should be used together with the ctor option `lazyRender`.
   */


  renderNow() {
    if (!this._options.lazyRender) {
      throw new Error('Please use `lazyRender` together with `renderNow`!');
    }

    this._render();
  }

  _render() {
    if (!this._shouldRender) {
      return;
    }

    this._shouldRender = false;

    this._horizontalScrollbar.render();

    this._verticalScrollbar.render();

    if (this._options.useShadows) {
      const scrollState = this._scrollable.getCurrentScrollPosition();

      const enableTop = scrollState.scrollTop > 0;
      const enableLeft = scrollState.scrollLeft > 0;
      const leftClassName = enableLeft ? ' left' : '';
      const topClassName = enableTop ? ' top' : '';
      const topLeftClassName = enableLeft || enableTop ? ' top-left-corner' : '';

      this._leftShadowDomNode.setClassName(`shadow${leftClassName}`);

      this._topShadowDomNode.setClassName(`shadow${topClassName}`);

      this._topLeftShadowDomNode.setClassName(`shadow${topLeftClassName}${topClassName}${leftClassName}`);
    }
  } // -------------------- fade in / fade out --------------------


  _onDragStart() {
    this._isDragging = true;

    this._reveal();
  }

  _onDragEnd() {
    this._isDragging = false;

    this._hide();
  }

  _onMouseLeave(e) {
    this._mouseIsOver = false;

    this._hide();
  }

  _onMouseOver(e) {
    this._mouseIsOver = true;

    this._reveal();
  }

  _reveal() {
    this._verticalScrollbar.beginReveal();

    this._horizontalScrollbar.beginReveal();

    this._scheduleHide();
  }

  _hide() {
    if (!this._mouseIsOver && !this._isDragging) {
      this._verticalScrollbar.beginHide();

      this._horizontalScrollbar.beginHide();
    }
  }

  _scheduleHide() {
    if (!this._mouseIsOver && !this._isDragging) {
      this._hideTimeout.cancelAndSet(() => this._hide(), HIDE_TIMEOUT);
    }
  }

}
class ScrollableElement extends AbstractScrollableElement {
  constructor(element, options) {
    options = options || {};
    options.mouseWheelSmoothScroll = false;
    const scrollable = new _common_scrollable__WEBPACK_IMPORTED_MODULE_11__.Scrollable({
      forceIntegerValues: true,
      smoothScrollDuration: 0,
      scheduleAtNextAnimationFrame: callback => _browser_dom__WEBPACK_IMPORTED_MODULE_1__.scheduleAtNextAnimationFrame(callback)
    });
    super(element, options, scrollable);

    this._register(scrollable);
  }

  setScrollPosition(update) {
    this._scrollable.setScrollPositionNow(update);
  }

  getScrollPosition() {
    return this._scrollable.getCurrentScrollPosition();
  }

}
class SmoothScrollableElement extends AbstractScrollableElement {
  constructor(element, options, scrollable) {
    super(element, options, scrollable);
  }

  setScrollPosition(update) {
    if (update.reuseAnimation) {
      this._scrollable.setScrollPositionSmooth(update, update.reuseAnimation);
    } else {
      this._scrollable.setScrollPositionNow(update);
    }
  }

  getScrollPosition() {
    return this._scrollable.getCurrentScrollPosition();
  }

}
class DomScrollableElement extends AbstractScrollableElement {
  constructor(element, options) {
    options = options || {};
    options.mouseWheelSmoothScroll = false;
    const scrollable = new _common_scrollable__WEBPACK_IMPORTED_MODULE_11__.Scrollable({
      forceIntegerValues: false,
      // See https://github.com/microsoft/vscode/issues/139877
      smoothScrollDuration: 0,
      scheduleAtNextAnimationFrame: callback => _browser_dom__WEBPACK_IMPORTED_MODULE_1__.scheduleAtNextAnimationFrame(callback)
    });
    super(element, options, scrollable);

    this._register(scrollable);

    this._element = element;
    this.onScroll(e => {
      if (e.scrollTopChanged) {
        this._element.scrollTop = e.scrollTop;
      }

      if (e.scrollLeftChanged) {
        this._element.scrollLeft = e.scrollLeft;
      }
    });
    this.scanDomNode();
  }

  setScrollPosition(update) {
    this._scrollable.setScrollPositionNow(update);
  }

  getScrollPosition() {
    return this._scrollable.getCurrentScrollPosition();
  }

  scanDomNode() {
    // width, scrollLeft, scrollWidth, height, scrollTop, scrollHeight
    this.setScrollDimensions({
      width: this._element.clientWidth,
      scrollWidth: this._element.scrollWidth,
      height: this._element.clientHeight,
      scrollHeight: this._element.scrollHeight
    });
    this.setScrollPosition({
      scrollLeft: this._element.scrollLeft,
      scrollTop: this._element.scrollTop
    });
  }

}

function resolveOptions(opts) {
  const result = {
    lazyRender: typeof opts.lazyRender !== 'undefined' ? opts.lazyRender : false,
    className: typeof opts.className !== 'undefined' ? opts.className : '',
    useShadows: typeof opts.useShadows !== 'undefined' ? opts.useShadows : true,
    handleMouseWheel: typeof opts.handleMouseWheel !== 'undefined' ? opts.handleMouseWheel : true,
    flipAxes: typeof opts.flipAxes !== 'undefined' ? opts.flipAxes : false,
    consumeMouseWheelIfScrollbarIsNeeded: typeof opts.consumeMouseWheelIfScrollbarIsNeeded !== 'undefined' ? opts.consumeMouseWheelIfScrollbarIsNeeded : false,
    alwaysConsumeMouseWheel: typeof opts.alwaysConsumeMouseWheel !== 'undefined' ? opts.alwaysConsumeMouseWheel : false,
    scrollYToX: typeof opts.scrollYToX !== 'undefined' ? opts.scrollYToX : false,
    mouseWheelScrollSensitivity: typeof opts.mouseWheelScrollSensitivity !== 'undefined' ? opts.mouseWheelScrollSensitivity : 1,
    fastScrollSensitivity: typeof opts.fastScrollSensitivity !== 'undefined' ? opts.fastScrollSensitivity : 5,
    scrollPredominantAxis: typeof opts.scrollPredominantAxis !== 'undefined' ? opts.scrollPredominantAxis : true,
    mouseWheelSmoothScroll: typeof opts.mouseWheelSmoothScroll !== 'undefined' ? opts.mouseWheelSmoothScroll : true,
    arrowSize: typeof opts.arrowSize !== 'undefined' ? opts.arrowSize : 11,
    listenOnDomNode: typeof opts.listenOnDomNode !== 'undefined' ? opts.listenOnDomNode : null,
    horizontal: typeof opts.horizontal !== 'undefined' ? opts.horizontal : _common_scrollable__WEBPACK_IMPORTED_MODULE_11__.ScrollbarVisibility.Auto,
    horizontalScrollbarSize: typeof opts.horizontalScrollbarSize !== 'undefined' ? opts.horizontalScrollbarSize : 10,
    horizontalSliderSize: typeof opts.horizontalSliderSize !== 'undefined' ? opts.horizontalSliderSize : 0,
    horizontalHasArrows: typeof opts.horizontalHasArrows !== 'undefined' ? opts.horizontalHasArrows : false,
    vertical: typeof opts.vertical !== 'undefined' ? opts.vertical : _common_scrollable__WEBPACK_IMPORTED_MODULE_11__.ScrollbarVisibility.Auto,
    verticalScrollbarSize: typeof opts.verticalScrollbarSize !== 'undefined' ? opts.verticalScrollbarSize : 10,
    verticalHasArrows: typeof opts.verticalHasArrows !== 'undefined' ? opts.verticalHasArrows : false,
    verticalSliderSize: typeof opts.verticalSliderSize !== 'undefined' ? opts.verticalSliderSize : 0,
    scrollByPage: typeof opts.scrollByPage !== 'undefined' ? opts.scrollByPage : false
  };
  result.horizontalSliderSize = typeof opts.horizontalSliderSize !== 'undefined' ? opts.horizontalSliderSize : result.horizontalScrollbarSize;
  result.verticalSliderSize = typeof opts.verticalSliderSize !== 'undefined' ? opts.verticalSliderSize : result.verticalScrollbarSize; // Defaults are different on Macs

  if (_common_platform__WEBPACK_IMPORTED_MODULE_10__.isMacintosh) {
    result.className += ' mac';
  }

  return result;
}

/***/ }),
/* 95 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FastDomNode": () => (/* binding */ FastDomNode),
/* harmony export */   "createFastDomNode": () => (/* binding */ createFastDomNode)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
class FastDomNode {
  _maxWidth = '';
  _width = '';
  _height = '';
  _top = '';
  _left = '';
  _bottom = '';
  _right = '';
  _fontFamily = '';
  _fontWeight = '';
  _fontSize = '';
  _fontStyle = '';
  _fontFeatureSettings = '';
  _textDecoration = '';
  _lineHeight = '';
  _letterSpacing = '';
  _className = '';
  _display = '';
  _position = '';
  _visibility = '';
  _color = '';
  _backgroundColor = '';
  _layerHint = false;
  _contain = 'none';
  _boxShadow = '';

  constructor(domNode) {
    this.domNode = domNode;
  }

  setMaxWidth(_maxWidth) {
    const maxWidth = numberAsPixels(_maxWidth);

    if (this._maxWidth === maxWidth) {
      return;
    }

    this._maxWidth = maxWidth;
    this.domNode.style.maxWidth = this._maxWidth;
  }

  setWidth(_width) {
    const width = numberAsPixels(_width);

    if (this._width === width) {
      return;
    }

    this._width = width;
    this.domNode.style.width = this._width;
  }

  setHeight(_height) {
    const height = numberAsPixels(_height);

    if (this._height === height) {
      return;
    }

    this._height = height;
    this.domNode.style.height = this._height;
  }

  setTop(_top) {
    const top = numberAsPixels(_top);

    if (this._top === top) {
      return;
    }

    this._top = top;
    this.domNode.style.top = this._top;
  }

  setLeft(_left) {
    const left = numberAsPixels(_left);

    if (this._left === left) {
      return;
    }

    this._left = left;
    this.domNode.style.left = this._left;
  }

  setBottom(_bottom) {
    const bottom = numberAsPixels(_bottom);

    if (this._bottom === bottom) {
      return;
    }

    this._bottom = bottom;
    this.domNode.style.bottom = this._bottom;
  }

  setRight(_right) {
    const right = numberAsPixels(_right);

    if (this._right === right) {
      return;
    }

    this._right = right;
    this.domNode.style.right = this._right;
  }

  setFontFamily(fontFamily) {
    if (this._fontFamily === fontFamily) {
      return;
    }

    this._fontFamily = fontFamily;
    this.domNode.style.fontFamily = this._fontFamily;
  }

  setFontWeight(fontWeight) {
    if (this._fontWeight === fontWeight) {
      return;
    }

    this._fontWeight = fontWeight;
    this.domNode.style.fontWeight = this._fontWeight;
  }

  setFontSize(_fontSize) {
    const fontSize = numberAsPixels(_fontSize);

    if (this._fontSize === fontSize) {
      return;
    }

    this._fontSize = fontSize;
    this.domNode.style.fontSize = this._fontSize;
  }

  setFontStyle(fontStyle) {
    if (this._fontStyle === fontStyle) {
      return;
    }

    this._fontStyle = fontStyle;
    this.domNode.style.fontStyle = this._fontStyle;
  }

  setFontFeatureSettings(fontFeatureSettings) {
    if (this._fontFeatureSettings === fontFeatureSettings) {
      return;
    }

    this._fontFeatureSettings = fontFeatureSettings;
    this.domNode.style.fontFeatureSettings = this._fontFeatureSettings;
  }

  setTextDecoration(textDecoration) {
    if (this._textDecoration === textDecoration) {
      return;
    }

    this._textDecoration = textDecoration;
    this.domNode.style.textDecoration = this._textDecoration;
  }

  setLineHeight(_lineHeight) {
    const lineHeight = numberAsPixels(_lineHeight);

    if (this._lineHeight === lineHeight) {
      return;
    }

    this._lineHeight = lineHeight;
    this.domNode.style.lineHeight = this._lineHeight;
  }

  setLetterSpacing(_letterSpacing) {
    const letterSpacing = numberAsPixels(_letterSpacing);

    if (this._letterSpacing === letterSpacing) {
      return;
    }

    this._letterSpacing = letterSpacing;
    this.domNode.style.letterSpacing = this._letterSpacing;
  }

  setClassName(className) {
    if (this._className === className) {
      return;
    }

    this._className = className;
    this.domNode.className = this._className;
  }

  toggleClassName(className, shouldHaveIt) {
    this.domNode.classList.toggle(className, shouldHaveIt);
    this._className = this.domNode.className;
  }

  setDisplay(display) {
    if (this._display === display) {
      return;
    }

    this._display = display;
    this.domNode.style.display = this._display;
  }

  setPosition(position) {
    if (this._position === position) {
      return;
    }

    this._position = position;
    this.domNode.style.position = this._position;
  }

  setVisibility(visibility) {
    if (this._visibility === visibility) {
      return;
    }

    this._visibility = visibility;
    this.domNode.style.visibility = this._visibility;
  }

  setColor(color) {
    if (this._color === color) {
      return;
    }

    this._color = color;
    this.domNode.style.color = this._color;
  }

  setBackgroundColor(backgroundColor) {
    if (this._backgroundColor === backgroundColor) {
      return;
    }

    this._backgroundColor = backgroundColor;
    this.domNode.style.backgroundColor = this._backgroundColor;
  }

  setLayerHinting(layerHint) {
    if (this._layerHint === layerHint) {
      return;
    }

    this._layerHint = layerHint;
    this.domNode.style.transform = this._layerHint ? 'translate3d(0px, 0px, 0px)' : '';
  }

  setBoxShadow(boxShadow) {
    if (this._boxShadow === boxShadow) {
      return;
    }

    this._boxShadow = boxShadow;
    this.domNode.style.boxShadow = boxShadow;
  }

  setContain(contain) {
    if (this._contain === contain) {
      return;
    }

    this._contain = contain;
    this.domNode.style.contain = this._contain;
  }

  setAttribute(name, value) {
    this.domNode.setAttribute(name, value);
  }

  removeAttribute(name) {
    this.domNode.removeAttribute(name);
  }

  appendChild(child) {
    this.domNode.appendChild(child.domNode);
  }

  removeChild(child) {
    this.domNode.removeChild(child.domNode);
  }

}

function numberAsPixels(value) {
  return typeof value === 'number' ? `${value}px` : value;
}

function createFastDomNode(domNode) {
  return new FastDomNode(domNode);
}

/***/ }),
/* 96 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HorizontalScrollbar": () => (/* binding */ HorizontalScrollbar)
/* harmony export */ });
/* harmony import */ var _browser_mouseEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(66);
/* harmony import */ var _browser_ui_scrollbar_abstractScrollbar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(97);
/* harmony import */ var _browser_ui_scrollbar_scrollbarArrow__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(99);
/* harmony import */ var _browser_ui_scrollbar_scrollbarState__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(103);
/* harmony import */ var _common_codicons__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(104);
/* harmony import */ var _common_scrollable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(102);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






class HorizontalScrollbar extends _browser_ui_scrollbar_abstractScrollbar__WEBPACK_IMPORTED_MODULE_1__.AbstractScrollbar {
  constructor(scrollable, options, host) {
    const scrollDimensions = scrollable.getScrollDimensions();
    const scrollPosition = scrollable.getCurrentScrollPosition();
    super({
      lazyRender: options.lazyRender,
      host: host,
      scrollbarState: new _browser_ui_scrollbar_scrollbarState__WEBPACK_IMPORTED_MODULE_3__.ScrollbarState(options.horizontalHasArrows ? options.arrowSize : 0, options.horizontal === _common_scrollable__WEBPACK_IMPORTED_MODULE_5__.ScrollbarVisibility.Hidden ? 0 : options.horizontalScrollbarSize, options.vertical === _common_scrollable__WEBPACK_IMPORTED_MODULE_5__.ScrollbarVisibility.Hidden ? 0 : options.verticalScrollbarSize, scrollDimensions.width, scrollDimensions.scrollWidth, scrollPosition.scrollLeft),
      visibility: options.horizontal,
      extraScrollbarClassName: 'horizontal',
      scrollable: scrollable,
      scrollByPage: options.scrollByPage
    });

    if (options.horizontalHasArrows) {
      const arrowDelta = (options.arrowSize - _browser_ui_scrollbar_scrollbarArrow__WEBPACK_IMPORTED_MODULE_2__.ARROW_IMG_SIZE) / 2;
      const scrollbarDelta = (options.horizontalScrollbarSize - _browser_ui_scrollbar_scrollbarArrow__WEBPACK_IMPORTED_MODULE_2__.ARROW_IMG_SIZE) / 2;

      this._createArrow({
        className: 'scra',
        icon: _common_codicons__WEBPACK_IMPORTED_MODULE_4__.Codicon.scrollbarButtonLeft,
        top: scrollbarDelta,
        left: arrowDelta,
        bottom: undefined,
        right: undefined,
        bgWidth: options.arrowSize,
        bgHeight: options.horizontalScrollbarSize,
        onActivate: () => this._host.onMouseWheel(new _browser_mouseEvent__WEBPACK_IMPORTED_MODULE_0__.StandardWheelEvent(null, 1, 0))
      });

      this._createArrow({
        className: 'scra',
        icon: _common_codicons__WEBPACK_IMPORTED_MODULE_4__.Codicon.scrollbarButtonRight,
        top: scrollbarDelta,
        left: undefined,
        bottom: undefined,
        right: arrowDelta,
        bgWidth: options.arrowSize,
        bgHeight: options.horizontalScrollbarSize,
        onActivate: () => this._host.onMouseWheel(new _browser_mouseEvent__WEBPACK_IMPORTED_MODULE_0__.StandardWheelEvent(null, -1, 0))
      });
    }

    this._createSlider(Math.floor((options.horizontalScrollbarSize - options.horizontalSliderSize) / 2), 0, undefined, options.horizontalSliderSize);
  }

  _updateSlider(sliderSize, sliderPosition) {
    this.slider.setWidth(sliderSize);
    this.slider.setLeft(sliderPosition);
  }

  _renderDomNode(largeSize, smallSize) {
    this.domNode.setWidth(largeSize);
    this.domNode.setHeight(smallSize);
    this.domNode.setLeft(0);
    this.domNode.setBottom(0);
  }

  onDidScroll(e) {
    this._shouldRender = this._onElementScrollSize(e.scrollWidth) || this._shouldRender;
    this._shouldRender = this._onElementScrollPosition(e.scrollLeft) || this._shouldRender;
    this._shouldRender = this._onElementSize(e.width) || this._shouldRender;
    return this._shouldRender;
  }

  _pointerDownRelativePosition(offsetX, offsetY) {
    return offsetX;
  }

  _sliderPointerPosition(e) {
    return e.pageX;
  }

  _sliderOrthogonalPointerPosition(e) {
    return e.pageY;
  }

  _updateScrollbarSize(size) {
    this.slider.setHeight(size);
  }

  writeScrollPosition(target, scrollPosition) {
    target.scrollLeft = scrollPosition;
  }

  updateOptions(options) {
    this.updateScrollbarSize(options.horizontal === _common_scrollable__WEBPACK_IMPORTED_MODULE_5__.ScrollbarVisibility.Hidden ? 0 : options.horizontalScrollbarSize);

    this._scrollbarState.setOppositeScrollbarSize(options.vertical === _common_scrollable__WEBPACK_IMPORTED_MODULE_5__.ScrollbarVisibility.Hidden ? 0 : options.verticalScrollbarSize);

    this._visibilityController.setVisibility(options.horizontal);

    this._scrollByPage = options.scrollByPage;
  }

}

/***/ }),
/* 97 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AbstractScrollbar": () => (/* binding */ AbstractScrollbar)
/* harmony export */ });
/* harmony import */ var _browser_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(61);
/* harmony import */ var _browser_fastDomNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(95);
/* harmony import */ var _browser_globalPointerMoveMonitor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(98);
/* harmony import */ var _browser_ui_scrollbar_scrollbarArrow__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(99);
/* harmony import */ var _browser_ui_scrollbar_scrollbarVisibilityController__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(101);
/* harmony import */ var _browser_ui_widget__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(100);
/* harmony import */ var _common_platform__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(58);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/








/**
 * The orthogonal distance to the slider at which dragging "resets". This implements "snapping"
 */
const POINTER_DRAG_RESET_DISTANCE = 140;
class AbstractScrollbar extends _browser_ui_widget__WEBPACK_IMPORTED_MODULE_5__.Widget {
  constructor(opts) {
    super();
    this._lazyRender = opts.lazyRender;
    this._host = opts.host;
    this._scrollable = opts.scrollable;
    this._scrollByPage = opts.scrollByPage;
    this._scrollbarState = opts.scrollbarState;
    this._visibilityController = this._register(new _browser_ui_scrollbar_scrollbarVisibilityController__WEBPACK_IMPORTED_MODULE_4__.ScrollbarVisibilityController(opts.visibility, 'visible scrollbar ' + opts.extraScrollbarClassName, 'invisible scrollbar ' + opts.extraScrollbarClassName));

    this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded());

    this._pointerMoveMonitor = this._register(new _browser_globalPointerMoveMonitor__WEBPACK_IMPORTED_MODULE_2__.GlobalPointerMoveMonitor());
    this._shouldRender = true;
    this.domNode = (0,_browser_fastDomNode__WEBPACK_IMPORTED_MODULE_1__.createFastDomNode)(document.createElement('div'));
    this.domNode.setAttribute('role', 'presentation');
    this.domNode.setAttribute('aria-hidden', 'true');

    this._visibilityController.setDomNode(this.domNode);

    this.domNode.setPosition('absolute');

    this._register(_browser_dom__WEBPACK_IMPORTED_MODULE_0__.addDisposableListener(this.domNode.domNode, _browser_dom__WEBPACK_IMPORTED_MODULE_0__.EventType.POINTER_DOWN, e => this._domNodePointerDown(e)));
  } // ----------------- creation

  /**
   * Creates the dom node for an arrow & adds it to the container
   */


  _createArrow(opts) {
    const arrow = this._register(new _browser_ui_scrollbar_scrollbarArrow__WEBPACK_IMPORTED_MODULE_3__.ScrollbarArrow(opts));

    this.domNode.domNode.appendChild(arrow.bgDomNode);
    this.domNode.domNode.appendChild(arrow.domNode);
  }
  /**
   * Creates the slider dom node, adds it to the container & hooks up the events
   */


  _createSlider(top, left, width, height) {
    this.slider = (0,_browser_fastDomNode__WEBPACK_IMPORTED_MODULE_1__.createFastDomNode)(document.createElement('div'));
    this.slider.setClassName('slider');
    this.slider.setPosition('absolute');
    this.slider.setTop(top);
    this.slider.setLeft(left);

    if (typeof width === 'number') {
      this.slider.setWidth(width);
    }

    if (typeof height === 'number') {
      this.slider.setHeight(height);
    }

    this.slider.setLayerHinting(true);
    this.slider.setContain('strict');
    this.domNode.domNode.appendChild(this.slider.domNode);

    this._register(_browser_dom__WEBPACK_IMPORTED_MODULE_0__.addDisposableListener(this.slider.domNode, _browser_dom__WEBPACK_IMPORTED_MODULE_0__.EventType.POINTER_DOWN, e => {
      if (e.button === 0) {
        e.preventDefault();

        this._sliderPointerDown(e);
      }
    }));

    this.onclick(this.slider.domNode, e => {
      if (e.leftButton) {
        e.stopPropagation();
      }
    });
  } // ----------------- Update state


  _onElementSize(visibleSize) {
    if (this._scrollbarState.setVisibleSize(visibleSize)) {
      this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded());

      this._shouldRender = true;

      if (!this._lazyRender) {
        this.render();
      }
    }

    return this._shouldRender;
  }

  _onElementScrollSize(elementScrollSize) {
    if (this._scrollbarState.setScrollSize(elementScrollSize)) {
      this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded());

      this._shouldRender = true;

      if (!this._lazyRender) {
        this.render();
      }
    }

    return this._shouldRender;
  }

  _onElementScrollPosition(elementScrollPosition) {
    if (this._scrollbarState.setScrollPosition(elementScrollPosition)) {
      this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded());

      this._shouldRender = true;

      if (!this._lazyRender) {
        this.render();
      }
    }

    return this._shouldRender;
  } // ----------------- rendering


  beginReveal() {
    this._visibilityController.setShouldBeVisible(true);
  }

  beginHide() {
    this._visibilityController.setShouldBeVisible(false);
  }

  render() {
    if (!this._shouldRender) {
      return;
    }

    this._shouldRender = false;

    this._renderDomNode(this._scrollbarState.getRectangleLargeSize(), this._scrollbarState.getRectangleSmallSize());

    this._updateSlider(this._scrollbarState.getSliderSize(), this._scrollbarState.getArrowSize() + this._scrollbarState.getSliderPosition());
  } // ----------------- DOM events


  _domNodePointerDown(e) {
    if (e.target !== this.domNode.domNode) {
      return;
    }

    this._onPointerDown(e);
  }

  delegatePointerDown(e) {
    const domTop = this.domNode.domNode.getClientRects()[0].top;

    const sliderStart = domTop + this._scrollbarState.getSliderPosition();

    const sliderStop = domTop + this._scrollbarState.getSliderPosition() + this._scrollbarState.getSliderSize();

    const pointerPos = this._sliderPointerPosition(e);

    if (sliderStart <= pointerPos && pointerPos <= sliderStop) {
      // Act as if it was a pointer down on the slider
      if (e.button === 0) {
        e.preventDefault();

        this._sliderPointerDown(e);
      }
    } else {
      // Act as if it was a pointer down on the scrollbar
      this._onPointerDown(e);
    }
  }

  _onPointerDown(e) {
    let offsetX;
    let offsetY;

    if (e.target === this.domNode.domNode && typeof e.offsetX === 'number' && typeof e.offsetY === 'number') {
      offsetX = e.offsetX;
      offsetY = e.offsetY;
    } else {
      const domNodePosition = _browser_dom__WEBPACK_IMPORTED_MODULE_0__.getDomNodePagePosition(this.domNode.domNode);
      offsetX = e.pageX - domNodePosition.left;
      offsetY = e.pageY - domNodePosition.top;
    }

    const offset = this._pointerDownRelativePosition(offsetX, offsetY);

    this._setDesiredScrollPositionNow(this._scrollByPage ? this._scrollbarState.getDesiredScrollPositionFromOffsetPaged(offset) : this._scrollbarState.getDesiredScrollPositionFromOffset(offset));

    if (e.button === 0) {
      // left button
      e.preventDefault();

      this._sliderPointerDown(e);
    }
  }

  _sliderPointerDown(e) {
    if (!e.target || !(e.target instanceof Element)) {
      return;
    }

    const initialPointerPosition = this._sliderPointerPosition(e);

    const initialPointerOrthogonalPosition = this._sliderOrthogonalPointerPosition(e);

    const initialScrollbarState = this._scrollbarState.clone();

    this.slider.toggleClassName('active', true);

    this._pointerMoveMonitor.startMonitoring(e.target, e.pointerId, e.buttons, pointerMoveData => {
      const pointerOrthogonalPosition = this._sliderOrthogonalPointerPosition(pointerMoveData);

      const pointerOrthogonalDelta = Math.abs(pointerOrthogonalPosition - initialPointerOrthogonalPosition);

      if (_common_platform__WEBPACK_IMPORTED_MODULE_6__.isWindows && pointerOrthogonalDelta > POINTER_DRAG_RESET_DISTANCE) {
        // The pointer has wondered away from the scrollbar => reset dragging
        this._setDesiredScrollPositionNow(initialScrollbarState.getScrollPosition());

        return;
      }

      const pointerPosition = this._sliderPointerPosition(pointerMoveData);

      const pointerDelta = pointerPosition - initialPointerPosition;

      this._setDesiredScrollPositionNow(initialScrollbarState.getDesiredScrollPositionFromDelta(pointerDelta));
    }, () => {
      this.slider.toggleClassName('active', false);

      this._host.onDragEnd();
    });

    this._host.onDragStart();
  }

  _setDesiredScrollPositionNow(_desiredScrollPosition) {
    const desiredScrollPosition = {};
    this.writeScrollPosition(desiredScrollPosition, _desiredScrollPosition);

    this._scrollable.setScrollPositionNow(desiredScrollPosition);
  }

  updateScrollbarSize(scrollbarSize) {
    this._updateScrollbarSize(scrollbarSize);

    this._scrollbarState.setScrollbarSize(scrollbarSize);

    this._shouldRender = true;

    if (!this._lazyRender) {
      this.render();
    }
  }

  isNeeded() {
    return this._scrollbarState.isNeeded();
  } // ----------------- Overwrite these


}

/***/ }),
/* 98 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GlobalPointerMoveMonitor": () => (/* binding */ GlobalPointerMoveMonitor)
/* harmony export */ });
/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(61);
/* harmony import */ var _common_lifecycle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(54);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


class GlobalPointerMoveMonitor {
  _hooks = new _common_lifecycle__WEBPACK_IMPORTED_MODULE_1__.DisposableStore();
  _pointerMoveCallback = null;
  _onStopCallback = null;

  dispose() {
    this.stopMonitoring(false);

    this._hooks.dispose();
  }

  stopMonitoring(invokeStopCallback, browserEvent) {
    if (!this.isMonitoring()) {
      // Not monitoring
      return;
    } // Unhook


    this._hooks.clear();

    this._pointerMoveCallback = null;
    const onStopCallback = this._onStopCallback;
    this._onStopCallback = null;

    if (invokeStopCallback && onStopCallback) {
      onStopCallback(browserEvent);
    }
  }

  isMonitoring() {
    return !!this._pointerMoveCallback;
  }

  startMonitoring(initialElement, pointerId, initialButtons, pointerMoveCallback, onStopCallback) {
    if (this.isMonitoring()) {
      this.stopMonitoring(false);
    }

    this._pointerMoveCallback = pointerMoveCallback;
    this._onStopCallback = onStopCallback;
    let eventSource = initialElement;

    try {
      initialElement.setPointerCapture(pointerId);

      this._hooks.add((0,_common_lifecycle__WEBPACK_IMPORTED_MODULE_1__.toDisposable)(() => {
        initialElement.releasePointerCapture(pointerId);
      }));
    } catch (err) {
      // See https://github.com/microsoft/vscode/issues/144584
      // See https://github.com/microsoft/vscode/issues/146947
      // `setPointerCapture` sometimes fails when being invoked
      // from a `mousedown` listener on macOS and Windows
      // and it always fails on Linux with the exception:
      //     DOMException: Failed to execute 'setPointerCapture' on 'Element':
      //     No active pointer with the given id is found.
      // In case of failure, we bind the listeners on the window
      eventSource = window;
    }

    this._hooks.add(_dom__WEBPACK_IMPORTED_MODULE_0__.addDisposableListener(eventSource, _dom__WEBPACK_IMPORTED_MODULE_0__.EventType.POINTER_MOVE, e => {
      if (e.buttons !== initialButtons) {
        // Buttons state has changed in the meantime
        this.stopMonitoring(true);
        return;
      }

      e.preventDefault();

      this._pointerMoveCallback(e);
    }));

    this._hooks.add(_dom__WEBPACK_IMPORTED_MODULE_0__.addDisposableListener(eventSource, _dom__WEBPACK_IMPORTED_MODULE_0__.EventType.POINTER_UP, e => this.stopMonitoring(true)));
  }

}

/***/ }),
/* 99 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ARROW_IMG_SIZE": () => (/* binding */ ARROW_IMG_SIZE),
/* harmony export */   "ScrollbarArrow": () => (/* binding */ ScrollbarArrow)
/* harmony export */ });
/* harmony import */ var _browser_globalPointerMoveMonitor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98);
/* harmony import */ var _browser_ui_widget__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(100);
/* harmony import */ var _common_async__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(68);
/* harmony import */ var _browser_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(61);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/




/**
 * The arrow image size.
 */

const ARROW_IMG_SIZE = 11;
class ScrollbarArrow extends _browser_ui_widget__WEBPACK_IMPORTED_MODULE_1__.Widget {
  constructor(opts) {
    super();
    this._onActivate = opts.onActivate;
    this.bgDomNode = document.createElement('div');
    this.bgDomNode.className = 'arrow-background';
    this.bgDomNode.style.position = 'absolute';
    this.bgDomNode.style.width = opts.bgWidth + 'px';
    this.bgDomNode.style.height = opts.bgHeight + 'px';

    if (typeof opts.top !== 'undefined') {
      this.bgDomNode.style.top = '0px';
    }

    if (typeof opts.left !== 'undefined') {
      this.bgDomNode.style.left = '0px';
    }

    if (typeof opts.bottom !== 'undefined') {
      this.bgDomNode.style.bottom = '0px';
    }

    if (typeof opts.right !== 'undefined') {
      this.bgDomNode.style.right = '0px';
    }

    this.domNode = document.createElement('div');
    this.domNode.className = opts.className;
    this.domNode.classList.add(...opts.icon.classNamesArray);
    this.domNode.style.position = 'absolute';
    this.domNode.style.width = ARROW_IMG_SIZE + 'px';
    this.domNode.style.height = ARROW_IMG_SIZE + 'px';

    if (typeof opts.top !== 'undefined') {
      this.domNode.style.top = opts.top + 'px';
    }

    if (typeof opts.left !== 'undefined') {
      this.domNode.style.left = opts.left + 'px';
    }

    if (typeof opts.bottom !== 'undefined') {
      this.domNode.style.bottom = opts.bottom + 'px';
    }

    if (typeof opts.right !== 'undefined') {
      this.domNode.style.right = opts.right + 'px';
    }

    this._pointerMoveMonitor = this._register(new _browser_globalPointerMoveMonitor__WEBPACK_IMPORTED_MODULE_0__.GlobalPointerMoveMonitor());

    this._register(_browser_dom__WEBPACK_IMPORTED_MODULE_3__.addStandardDisposableListener(this.bgDomNode, _browser_dom__WEBPACK_IMPORTED_MODULE_3__.EventType.POINTER_DOWN, e => this._arrowPointerDown(e)));

    this._register(_browser_dom__WEBPACK_IMPORTED_MODULE_3__.addStandardDisposableListener(this.domNode, _browser_dom__WEBPACK_IMPORTED_MODULE_3__.EventType.POINTER_DOWN, e => this._arrowPointerDown(e)));

    this._pointerdownRepeatTimer = this._register(new _common_async__WEBPACK_IMPORTED_MODULE_2__.IntervalTimer());
    this._pointerdownScheduleRepeatTimer = this._register(new _common_async__WEBPACK_IMPORTED_MODULE_2__.TimeoutTimer());
  }

  _arrowPointerDown(e) {
    if (!e.target || !(e.target instanceof Element)) {
      return;
    }

    const scheduleRepeater = () => {
      this._pointerdownRepeatTimer.cancelAndSet(() => this._onActivate(), 1000 / 24);
    };

    this._onActivate();

    this._pointerdownRepeatTimer.cancel();

    this._pointerdownScheduleRepeatTimer.cancelAndSet(scheduleRepeater, 200);

    this._pointerMoveMonitor.startMonitoring(e.target, e.pointerId, e.buttons, pointerMoveData => {
      /* Intentional empty */
    }, () => {
      this._pointerdownRepeatTimer.cancel();

      this._pointerdownScheduleRepeatTimer.cancel();
    });

    e.preventDefault();
  }

}

/***/ }),
/* 100 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Widget": () => (/* binding */ Widget)
/* harmony export */ });
/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(61);
/* harmony import */ var _keyboardEvent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(63);
/* harmony import */ var _mouseEvent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(66);
/* harmony import */ var _touch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(86);
/* harmony import */ var _common_lifecycle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(54);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





class Widget extends _common_lifecycle__WEBPACK_IMPORTED_MODULE_4__.Disposable {
  onclick(domNode, listener) {
    this._register(_dom__WEBPACK_IMPORTED_MODULE_0__.addDisposableListener(domNode, _dom__WEBPACK_IMPORTED_MODULE_0__.EventType.CLICK, e => listener(new _mouseEvent__WEBPACK_IMPORTED_MODULE_2__.StandardMouseEvent(e))));
  }

  onmousedown(domNode, listener) {
    this._register(_dom__WEBPACK_IMPORTED_MODULE_0__.addDisposableListener(domNode, _dom__WEBPACK_IMPORTED_MODULE_0__.EventType.MOUSE_DOWN, e => listener(new _mouseEvent__WEBPACK_IMPORTED_MODULE_2__.StandardMouseEvent(e))));
  }

  onmouseover(domNode, listener) {
    this._register(_dom__WEBPACK_IMPORTED_MODULE_0__.addDisposableListener(domNode, _dom__WEBPACK_IMPORTED_MODULE_0__.EventType.MOUSE_OVER, e => listener(new _mouseEvent__WEBPACK_IMPORTED_MODULE_2__.StandardMouseEvent(e))));
  }

  onmouseleave(domNode, listener) {
    this._register(_dom__WEBPACK_IMPORTED_MODULE_0__.addDisposableListener(domNode, _dom__WEBPACK_IMPORTED_MODULE_0__.EventType.MOUSE_LEAVE, e => listener(new _mouseEvent__WEBPACK_IMPORTED_MODULE_2__.StandardMouseEvent(e))));
  }

  onkeydown(domNode, listener) {
    this._register(_dom__WEBPACK_IMPORTED_MODULE_0__.addDisposableListener(domNode, _dom__WEBPACK_IMPORTED_MODULE_0__.EventType.KEY_DOWN, e => listener(new _keyboardEvent__WEBPACK_IMPORTED_MODULE_1__.StandardKeyboardEvent(e))));
  }

  onkeyup(domNode, listener) {
    this._register(_dom__WEBPACK_IMPORTED_MODULE_0__.addDisposableListener(domNode, _dom__WEBPACK_IMPORTED_MODULE_0__.EventType.KEY_UP, e => listener(new _keyboardEvent__WEBPACK_IMPORTED_MODULE_1__.StandardKeyboardEvent(e))));
  }

  oninput(domNode, listener) {
    this._register(_dom__WEBPACK_IMPORTED_MODULE_0__.addDisposableListener(domNode, _dom__WEBPACK_IMPORTED_MODULE_0__.EventType.INPUT, listener));
  }

  onblur(domNode, listener) {
    this._register(_dom__WEBPACK_IMPORTED_MODULE_0__.addDisposableListener(domNode, _dom__WEBPACK_IMPORTED_MODULE_0__.EventType.BLUR, listener));
  }

  onfocus(domNode, listener) {
    this._register(_dom__WEBPACK_IMPORTED_MODULE_0__.addDisposableListener(domNode, _dom__WEBPACK_IMPORTED_MODULE_0__.EventType.FOCUS, listener));
  }

  onchange(domNode, listener) {
    this._register(_dom__WEBPACK_IMPORTED_MODULE_0__.addDisposableListener(domNode, _dom__WEBPACK_IMPORTED_MODULE_0__.EventType.CHANGE, listener));
  }

  ignoreGesture(domNode) {
    _touch__WEBPACK_IMPORTED_MODULE_3__.Gesture.ignoreTarget(domNode);
  }

}

/***/ }),
/* 101 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ScrollbarVisibilityController": () => (/* binding */ ScrollbarVisibilityController)
/* harmony export */ });
/* harmony import */ var _common_async__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(68);
/* harmony import */ var _common_lifecycle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(54);
/* harmony import */ var _common_scrollable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(102);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/



class ScrollbarVisibilityController extends _common_lifecycle__WEBPACK_IMPORTED_MODULE_1__.Disposable {
  constructor(visibility, visibleClassName, invisibleClassName) {
    super();
    this._visibility = visibility;
    this._visibleClassName = visibleClassName;
    this._invisibleClassName = invisibleClassName;
    this._domNode = null;
    this._isVisible = false;
    this._isNeeded = false;
    this._rawShouldBeVisible = false;
    this._shouldBeVisible = false;
    this._revealTimer = this._register(new _common_async__WEBPACK_IMPORTED_MODULE_0__.TimeoutTimer());
  }

  setVisibility(visibility) {
    if (this._visibility !== visibility) {
      this._visibility = visibility;

      this._updateShouldBeVisible();
    }
  } // ----------------- Hide / Reveal


  setShouldBeVisible(rawShouldBeVisible) {
    this._rawShouldBeVisible = rawShouldBeVisible;

    this._updateShouldBeVisible();
  }

  _applyVisibilitySetting() {
    if (this._visibility === _common_scrollable__WEBPACK_IMPORTED_MODULE_2__.ScrollbarVisibility.Hidden) {
      return false;
    }

    if (this._visibility === _common_scrollable__WEBPACK_IMPORTED_MODULE_2__.ScrollbarVisibility.Visible) {
      return true;
    }

    return this._rawShouldBeVisible;
  }

  _updateShouldBeVisible() {
    const shouldBeVisible = this._applyVisibilitySetting();

    if (this._shouldBeVisible !== shouldBeVisible) {
      this._shouldBeVisible = shouldBeVisible;
      this.ensureVisibility();
    }
  }

  setIsNeeded(isNeeded) {
    if (this._isNeeded !== isNeeded) {
      this._isNeeded = isNeeded;
      this.ensureVisibility();
    }
  }

  setDomNode(domNode) {
    this._domNode = domNode;

    this._domNode.setClassName(this._invisibleClassName); // Now that the flags & the dom node are in a consistent state, ensure the Hidden/Visible configuration


    this.setShouldBeVisible(false);
  }

  ensureVisibility() {
    if (!this._isNeeded) {
      // Nothing to be rendered
      this._hide(false);

      return;
    }

    if (this._shouldBeVisible) {
      this._reveal();
    } else {
      this._hide(true);
    }
  }

  _reveal() {
    if (this._isVisible) {
      return;
    }

    this._isVisible = true; // The CSS animation doesn't play otherwise

    this._revealTimer.setIfNotSet(() => {
      this._domNode?.setClassName(this._visibleClassName);
    }, 0);
  }

  _hide(withFadeAway) {
    this._revealTimer.cancel();

    if (!this._isVisible) {
      return;
    }

    this._isVisible = false;
    this._domNode?.setClassName(this._invisibleClassName + (withFadeAway ? ' fade' : ''));
  }

}

/***/ }),
/* 102 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ScrollbarVisibility": () => (/* binding */ ScrollbarVisibility),
/* harmony export */   "ScrollState": () => (/* binding */ ScrollState),
/* harmony export */   "Scrollable": () => (/* binding */ Scrollable),
/* harmony export */   "SmoothScrollingUpdate": () => (/* binding */ SmoothScrollingUpdate),
/* harmony export */   "SmoothScrollingOperation": () => (/* binding */ SmoothScrollingOperation)
/* harmony export */ });
/* harmony import */ var _event__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(51);
/* harmony import */ var _lifecycle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(54);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


let ScrollbarVisibility;

(function (ScrollbarVisibility) {
  ScrollbarVisibility[ScrollbarVisibility["Auto"] = 1] = "Auto";
  ScrollbarVisibility[ScrollbarVisibility["Hidden"] = 2] = "Hidden";
  ScrollbarVisibility[ScrollbarVisibility["Visible"] = 3] = "Visible";
})(ScrollbarVisibility || (ScrollbarVisibility = {}));

class ScrollState {
  _scrollStateBrand = undefined;

  constructor(_forceIntegerValues, width, scrollWidth, scrollLeft, height, scrollHeight, scrollTop) {
    this._forceIntegerValues = _forceIntegerValues;

    if (this._forceIntegerValues) {
      width = width | 0;
      scrollWidth = scrollWidth | 0;
      scrollLeft = scrollLeft | 0;
      height = height | 0;
      scrollHeight = scrollHeight | 0;
      scrollTop = scrollTop | 0;
    }

    this.rawScrollLeft = scrollLeft; // before validation

    this.rawScrollTop = scrollTop; // before validation

    if (width < 0) {
      width = 0;
    }

    if (scrollLeft + width > scrollWidth) {
      scrollLeft = scrollWidth - width;
    }

    if (scrollLeft < 0) {
      scrollLeft = 0;
    }

    if (height < 0) {
      height = 0;
    }

    if (scrollTop + height > scrollHeight) {
      scrollTop = scrollHeight - height;
    }

    if (scrollTop < 0) {
      scrollTop = 0;
    }

    this.width = width;
    this.scrollWidth = scrollWidth;
    this.scrollLeft = scrollLeft;
    this.height = height;
    this.scrollHeight = scrollHeight;
    this.scrollTop = scrollTop;
  }

  equals(other) {
    return this.rawScrollLeft === other.rawScrollLeft && this.rawScrollTop === other.rawScrollTop && this.width === other.width && this.scrollWidth === other.scrollWidth && this.scrollLeft === other.scrollLeft && this.height === other.height && this.scrollHeight === other.scrollHeight && this.scrollTop === other.scrollTop;
  }

  withScrollDimensions(update, useRawScrollPositions) {
    return new ScrollState(this._forceIntegerValues, typeof update.width !== 'undefined' ? update.width : this.width, typeof update.scrollWidth !== 'undefined' ? update.scrollWidth : this.scrollWidth, useRawScrollPositions ? this.rawScrollLeft : this.scrollLeft, typeof update.height !== 'undefined' ? update.height : this.height, typeof update.scrollHeight !== 'undefined' ? update.scrollHeight : this.scrollHeight, useRawScrollPositions ? this.rawScrollTop : this.scrollTop);
  }

  withScrollPosition(update) {
    return new ScrollState(this._forceIntegerValues, this.width, this.scrollWidth, typeof update.scrollLeft !== 'undefined' ? update.scrollLeft : this.rawScrollLeft, this.height, this.scrollHeight, typeof update.scrollTop !== 'undefined' ? update.scrollTop : this.rawScrollTop);
  }

  createScrollEvent(previous, inSmoothScrolling) {
    const widthChanged = this.width !== previous.width;
    const scrollWidthChanged = this.scrollWidth !== previous.scrollWidth;
    const scrollLeftChanged = this.scrollLeft !== previous.scrollLeft;
    const heightChanged = this.height !== previous.height;
    const scrollHeightChanged = this.scrollHeight !== previous.scrollHeight;
    const scrollTopChanged = this.scrollTop !== previous.scrollTop;
    return {
      inSmoothScrolling: inSmoothScrolling,
      oldWidth: previous.width,
      oldScrollWidth: previous.scrollWidth,
      oldScrollLeft: previous.scrollLeft,
      width: this.width,
      scrollWidth: this.scrollWidth,
      scrollLeft: this.scrollLeft,
      oldHeight: previous.height,
      oldScrollHeight: previous.scrollHeight,
      oldScrollTop: previous.scrollTop,
      height: this.height,
      scrollHeight: this.scrollHeight,
      scrollTop: this.scrollTop,
      widthChanged: widthChanged,
      scrollWidthChanged: scrollWidthChanged,
      scrollLeftChanged: scrollLeftChanged,
      heightChanged: heightChanged,
      scrollHeightChanged: scrollHeightChanged,
      scrollTopChanged: scrollTopChanged
    };
  }

}
class Scrollable extends _lifecycle__WEBPACK_IMPORTED_MODULE_1__.Disposable {
  _scrollableBrand = undefined;
  _onScroll = this._register(new _event__WEBPACK_IMPORTED_MODULE_0__.Emitter());
  onScroll = this._onScroll.event;

  constructor(options) {
    super();
    this._smoothScrollDuration = options.smoothScrollDuration;
    this._scheduleAtNextAnimationFrame = options.scheduleAtNextAnimationFrame;
    this._state = new ScrollState(options.forceIntegerValues, 0, 0, 0, 0, 0, 0);
    this._smoothScrolling = null;
  }

  dispose() {
    if (this._smoothScrolling) {
      this._smoothScrolling.dispose();

      this._smoothScrolling = null;
    }

    super.dispose();
  }

  setSmoothScrollDuration(smoothScrollDuration) {
    this._smoothScrollDuration = smoothScrollDuration;
  }

  validateScrollPosition(scrollPosition) {
    return this._state.withScrollPosition(scrollPosition);
  }

  getScrollDimensions() {
    return this._state;
  }

  setScrollDimensions(dimensions, useRawScrollPositions) {
    const newState = this._state.withScrollDimensions(dimensions, useRawScrollPositions);

    this._setState(newState, Boolean(this._smoothScrolling)); // Validate outstanding animated scroll position target


    this._smoothScrolling?.acceptScrollDimensions(this._state);
  }
  /**
   * Returns the final scroll position that the instance will have once the smooth scroll animation concludes.
   * If no scroll animation is occurring, it will return the current scroll position instead.
   */


  getFutureScrollPosition() {
    if (this._smoothScrolling) {
      return this._smoothScrolling.to;
    }

    return this._state;
  }
  /**
   * Returns the current scroll position.
   * Note: This result might be an intermediate scroll position, as there might be an ongoing smooth scroll animation.
   */


  getCurrentScrollPosition() {
    return this._state;
  }

  setScrollPositionNow(update) {
    // no smooth scrolling requested
    const newState = this._state.withScrollPosition(update); // Terminate any outstanding smooth scrolling


    if (this._smoothScrolling) {
      this._smoothScrolling.dispose();

      this._smoothScrolling = null;
    }

    this._setState(newState, false);
  }

  setScrollPositionSmooth(update, reuseAnimation) {
    if (this._smoothScrollDuration === 0) {
      // Smooth scrolling not supported.
      return this.setScrollPositionNow(update);
    }

    if (this._smoothScrolling) {
      // Combine our pending scrollLeft/scrollTop with incoming scrollLeft/scrollTop
      update = {
        scrollLeft: typeof update.scrollLeft === 'undefined' ? this._smoothScrolling.to.scrollLeft : update.scrollLeft,
        scrollTop: typeof update.scrollTop === 'undefined' ? this._smoothScrolling.to.scrollTop : update.scrollTop
      }; // Validate `update`

      const validTarget = this._state.withScrollPosition(update);

      if (this._smoothScrolling.to.scrollLeft === validTarget.scrollLeft && this._smoothScrolling.to.scrollTop === validTarget.scrollTop) {
        // No need to interrupt or extend the current animation since we're going to the same place
        return;
      }

      let newSmoothScrolling;

      if (reuseAnimation) {
        newSmoothScrolling = new SmoothScrollingOperation(this._smoothScrolling.from, validTarget, this._smoothScrolling.startTime, this._smoothScrolling.duration);
      } else {
        newSmoothScrolling = this._smoothScrolling.combine(this._state, validTarget, this._smoothScrollDuration);
      }

      this._smoothScrolling.dispose();

      this._smoothScrolling = newSmoothScrolling;
    } else {
      // Validate `update`
      const validTarget = this._state.withScrollPosition(update);

      this._smoothScrolling = SmoothScrollingOperation.start(this._state, validTarget, this._smoothScrollDuration);
    } // Begin smooth scrolling animation


    this._smoothScrolling.animationFrameDisposable = this._scheduleAtNextAnimationFrame(() => {
      if (!this._smoothScrolling) {
        return;
      }

      this._smoothScrolling.animationFrameDisposable = null;

      this._performSmoothScrolling();
    });
  }

  _performSmoothScrolling() {
    if (!this._smoothScrolling) {
      return;
    }

    const update = this._smoothScrolling.tick();

    const newState = this._state.withScrollPosition(update);

    this._setState(newState, true);

    if (!this._smoothScrolling) {
      // Looks like someone canceled the smooth scrolling
      // from the scroll event handler
      return;
    }

    if (update.isDone) {
      this._smoothScrolling.dispose();

      this._smoothScrolling = null;
      return;
    } // Continue smooth scrolling animation


    this._smoothScrolling.animationFrameDisposable = this._scheduleAtNextAnimationFrame(() => {
      if (!this._smoothScrolling) {
        return;
      }

      this._smoothScrolling.animationFrameDisposable = null;

      this._performSmoothScrolling();
    });
  }

  _setState(newState, inSmoothScrolling) {
    const oldState = this._state;

    if (oldState.equals(newState)) {
      // no change
      return;
    }

    this._state = newState;

    this._onScroll.fire(this._state.createScrollEvent(oldState, inSmoothScrolling));
  }

}
class SmoothScrollingUpdate {
  constructor(scrollLeft, scrollTop, isDone) {
    this.scrollLeft = scrollLeft;
    this.scrollTop = scrollTop;
    this.isDone = isDone;
  }

}

function createEaseOutCubic(from, to) {
  const delta = to - from;
  return function (completion) {
    return from + delta * easeOutCubic(completion);
  };
}

function createComposed(a, b, cut) {
  return function (completion) {
    if (completion < cut) {
      return a(completion / cut);
    }

    return b((completion - cut) / (1 - cut));
  };
}

class SmoothScrollingOperation {
  constructor(from, to, startTime, duration) {
    this.from = from;
    this.to = to;
    this.duration = duration;
    this.startTime = startTime;
    this.animationFrameDisposable = null;

    this._initAnimations();
  }

  _initAnimations() {
    this.scrollLeft = this._initAnimation(this.from.scrollLeft, this.to.scrollLeft, this.to.width);
    this.scrollTop = this._initAnimation(this.from.scrollTop, this.to.scrollTop, this.to.height);
  }

  _initAnimation(from, to, viewportSize) {
    const delta = Math.abs(from - to);

    if (delta > 2.5 * viewportSize) {
      let stop1, stop2;

      if (from < to) {
        // scroll to 75% of the viewportSize
        stop1 = from + 0.75 * viewportSize;
        stop2 = to - 0.75 * viewportSize;
      } else {
        stop1 = from - 0.75 * viewportSize;
        stop2 = to + 0.75 * viewportSize;
      }

      return createComposed(createEaseOutCubic(from, stop1), createEaseOutCubic(stop2, to), 0.33);
    }

    return createEaseOutCubic(from, to);
  }

  dispose() {
    if (this.animationFrameDisposable !== null) {
      this.animationFrameDisposable.dispose();
      this.animationFrameDisposable = null;
    }
  }

  acceptScrollDimensions(state) {
    this.to = state.withScrollPosition(this.to);

    this._initAnimations();
  }

  tick() {
    return this._tick(Date.now());
  }

  _tick(now) {
    const completion = (now - this.startTime) / this.duration;

    if (completion < 1) {
      const newScrollLeft = this.scrollLeft(completion);
      const newScrollTop = this.scrollTop(completion);
      return new SmoothScrollingUpdate(newScrollLeft, newScrollTop, false);
    }

    return new SmoothScrollingUpdate(this.to.scrollLeft, this.to.scrollTop, true);
  }

  combine(from, to, duration) {
    return SmoothScrollingOperation.start(from, to, duration);
  }

  static start(from, to, duration) {
    // +10 / -10 : pretend the animation already started for a quicker response to a scroll request
    duration = duration + 10;
    const startTime = Date.now() - 10;
    return new SmoothScrollingOperation(from, to, startTime, duration);
  }

}

function easeInCubic(t) {
  return Math.pow(t, 3);
}

function easeOutCubic(t) {
  return 1 - easeInCubic(1 - t);
}

/***/ }),
/* 103 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ScrollbarState": () => (/* binding */ ScrollbarState)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

/**
 * The minimal size of the slider (such that it can still be clickable) -- it is artificially enlarged.
 */
const MINIMUM_SLIDER_SIZE = 20;
class ScrollbarState {
  /**
   * For the vertical scrollbar: the width.
   * For the horizontal scrollbar: the height.
   */

  /**
   * For the vertical scrollbar: the height of the pair horizontal scrollbar.
   * For the horizontal scrollbar: the width of the pair vertical scrollbar.
   */

  /**
   * For the vertical scrollbar: the height of the scrollbar's arrows.
   * For the horizontal scrollbar: the width of the scrollbar's arrows.
   */
  // --- variables

  /**
   * For the vertical scrollbar: the viewport height.
   * For the horizontal scrollbar: the viewport width.
   */

  /**
   * For the vertical scrollbar: the scroll height.
   * For the horizontal scrollbar: the scroll width.
   */

  /**
   * For the vertical scrollbar: the scroll top.
   * For the horizontal scrollbar: the scroll left.
   */
  // --- computed variables

  /**
   * `visibleSize` - `oppositeScrollbarSize`
   */

  /**
   * (`scrollSize` > 0 && `scrollSize` > `visibleSize`)
   */
  constructor(arrowSize, scrollbarSize, oppositeScrollbarSize, visibleSize, scrollSize, scrollPosition) {
    this._scrollbarSize = Math.round(scrollbarSize);
    this._oppositeScrollbarSize = Math.round(oppositeScrollbarSize);
    this._arrowSize = Math.round(arrowSize);
    this._visibleSize = visibleSize;
    this._scrollSize = scrollSize;
    this._scrollPosition = scrollPosition;
    this._computedAvailableSize = 0;
    this._computedIsNeeded = false;
    this._computedSliderSize = 0;
    this._computedSliderRatio = 0;
    this._computedSliderPosition = 0;

    this._refreshComputedValues();
  }

  clone() {
    return new ScrollbarState(this._arrowSize, this._scrollbarSize, this._oppositeScrollbarSize, this._visibleSize, this._scrollSize, this._scrollPosition);
  }

  setVisibleSize(visibleSize) {
    const iVisibleSize = Math.round(visibleSize);

    if (this._visibleSize !== iVisibleSize) {
      this._visibleSize = iVisibleSize;

      this._refreshComputedValues();

      return true;
    }

    return false;
  }

  setScrollSize(scrollSize) {
    const iScrollSize = Math.round(scrollSize);

    if (this._scrollSize !== iScrollSize) {
      this._scrollSize = iScrollSize;

      this._refreshComputedValues();

      return true;
    }

    return false;
  }

  setScrollPosition(scrollPosition) {
    const iScrollPosition = Math.round(scrollPosition);

    if (this._scrollPosition !== iScrollPosition) {
      this._scrollPosition = iScrollPosition;

      this._refreshComputedValues();

      return true;
    }

    return false;
  }

  setScrollbarSize(scrollbarSize) {
    this._scrollbarSize = Math.round(scrollbarSize);
  }

  setOppositeScrollbarSize(oppositeScrollbarSize) {
    this._oppositeScrollbarSize = Math.round(oppositeScrollbarSize);
  }

  static _computeValues(oppositeScrollbarSize, arrowSize, visibleSize, scrollSize, scrollPosition) {
    const computedAvailableSize = Math.max(0, visibleSize - oppositeScrollbarSize);
    const computedRepresentableSize = Math.max(0, computedAvailableSize - 2 * arrowSize);
    const computedIsNeeded = scrollSize > 0 && scrollSize > visibleSize;

    if (!computedIsNeeded) {
      // There is no need for a slider
      return {
        computedAvailableSize: Math.round(computedAvailableSize),
        computedIsNeeded: computedIsNeeded,
        computedSliderSize: Math.round(computedRepresentableSize),
        computedSliderRatio: 0,
        computedSliderPosition: 0
      };
    } // We must artificially increase the size of the slider if needed, since the slider would be too small to grab with the mouse otherwise


    const computedSliderSize = Math.round(Math.max(MINIMUM_SLIDER_SIZE, Math.floor(visibleSize * computedRepresentableSize / scrollSize))); // The slider can move from 0 to `computedRepresentableSize` - `computedSliderSize`
    // in the same way `scrollPosition` can move from 0 to `scrollSize` - `visibleSize`.

    const computedSliderRatio = (computedRepresentableSize - computedSliderSize) / (scrollSize - visibleSize);
    const computedSliderPosition = scrollPosition * computedSliderRatio;
    return {
      computedAvailableSize: Math.round(computedAvailableSize),
      computedIsNeeded: computedIsNeeded,
      computedSliderSize: Math.round(computedSliderSize),
      computedSliderRatio: computedSliderRatio,
      computedSliderPosition: Math.round(computedSliderPosition)
    };
  }

  _refreshComputedValues() {
    const r = ScrollbarState._computeValues(this._oppositeScrollbarSize, this._arrowSize, this._visibleSize, this._scrollSize, this._scrollPosition);

    this._computedAvailableSize = r.computedAvailableSize;
    this._computedIsNeeded = r.computedIsNeeded;
    this._computedSliderSize = r.computedSliderSize;
    this._computedSliderRatio = r.computedSliderRatio;
    this._computedSliderPosition = r.computedSliderPosition;
  }

  getArrowSize() {
    return this._arrowSize;
  }

  getScrollPosition() {
    return this._scrollPosition;
  }

  getRectangleLargeSize() {
    return this._computedAvailableSize;
  }

  getRectangleSmallSize() {
    return this._scrollbarSize;
  }

  isNeeded() {
    return this._computedIsNeeded;
  }

  getSliderSize() {
    return this._computedSliderSize;
  }

  getSliderPosition() {
    return this._computedSliderPosition;
  }
  /**
   * Compute a desired `scrollPosition` such that `offset` ends up in the center of the slider.
   * `offset` is based on the same coordinate system as the `sliderPosition`.
   */


  getDesiredScrollPositionFromOffset(offset) {
    if (!this._computedIsNeeded) {
      // no need for a slider
      return 0;
    }

    const desiredSliderPosition = offset - this._arrowSize - this._computedSliderSize / 2;
    return Math.round(desiredSliderPosition / this._computedSliderRatio);
  }
  /**
   * Compute a desired `scrollPosition` from if offset is before or after the slider position.
   * If offset is before slider, treat as a page up (or left).  If after, page down (or right).
   * `offset` and `_computedSliderPosition` are based on the same coordinate system.
   * `_visibleSize` corresponds to a "page" of lines in the returned coordinate system.
   */


  getDesiredScrollPositionFromOffsetPaged(offset) {
    if (!this._computedIsNeeded) {
      // no need for a slider
      return 0;
    }

    const correctedOffset = offset - this._arrowSize; // compensate if has arrows

    let desiredScrollPosition = this._scrollPosition;

    if (correctedOffset < this._computedSliderPosition) {
      desiredScrollPosition -= this._visibleSize; // page up/left
    } else {
      desiredScrollPosition += this._visibleSize; // page down/right
    }

    return desiredScrollPosition;
  }
  /**
   * Compute a desired `scrollPosition` such that the slider moves by `delta`.
   */


  getDesiredScrollPositionFromDelta(delta) {
    if (!this._computedIsNeeded) {
      // no need for a slider
      return 0;
    }

    const desiredSliderPosition = this._computedSliderPosition + delta;
    return Math.round(desiredSliderPosition / this._computedSliderRatio);
  }

}

/***/ }),
/* 104 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getCodiconAriaLabel": () => (/* binding */ getCodiconAriaLabel),
/* harmony export */   "Codicon": () => (/* binding */ Codicon),
/* harmony export */   "getClassNamesArray": () => (/* binding */ getClassNamesArray),
/* harmony export */   "CSSIcon": () => (/* binding */ CSSIcon)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// Selects all codicon names encapsulated in the `$()` syntax and wraps the
// results with spaces so that screen readers can read the text better.
function getCodiconAriaLabel(text) {
  if (!text) {
    return '';
  }

  return text.replace(/\$\((.*?)\)/g, (_match, codiconName) => ` ${codiconName} `).trim();
}
/**
 * The Codicon library is a set of default icons that are built-in in VS Code.
 *
 * In the product (outside of base) Codicons should only be used as defaults. In order to have all icons in VS Code
 * themeable, component should define new, UI component specific icons using `iconRegistry.registerIcon`.
 * In that call a Codicon can be named as default.
 */

class Codicon {
  constructor(id, definition, description) {
    this.id = id;
    this.definition = definition;
    this.description = description;

    Codicon._allCodicons.push(this);
  }

  get classNames() {
    return 'codicon codicon-' + this.id;
  } // classNamesArray is useful for migrating to ES6 classlist


  get classNamesArray() {
    return ['codicon', 'codicon-' + this.id];
  }

  get cssSelector() {
    return '.codicon.codicon-' + this.id;
  } // registry


  static _allCodicons = [];
  /**
   * @returns Returns all default icons covered by the codicon font. Only to be used by the icon registry in platform.
   */

  static getAll() {
    return Codicon._allCodicons;
  } // built-in icons, with image name


  static add = new Codicon('add', {
    fontCharacter: '\\ea60'
  });
  static plus = new Codicon('plus', Codicon.add.definition);
  static gistNew = new Codicon('gist-new', Codicon.add.definition);
  static repoCreate = new Codicon('repo-create', Codicon.add.definition);
  static lightbulb = new Codicon('lightbulb', {
    fontCharacter: '\\ea61'
  });
  static lightBulb = new Codicon('light-bulb', {
    fontCharacter: '\\ea61'
  });
  static repo = new Codicon('repo', {
    fontCharacter: '\\ea62'
  });
  static repoDelete = new Codicon('repo-delete', {
    fontCharacter: '\\ea62'
  });
  static gistFork = new Codicon('gist-fork', {
    fontCharacter: '\\ea63'
  });
  static repoForked = new Codicon('repo-forked', {
    fontCharacter: '\\ea63'
  });
  static gitPullRequest = new Codicon('git-pull-request', {
    fontCharacter: '\\ea64'
  });
  static gitPullRequestAbandoned = new Codicon('git-pull-request-abandoned', {
    fontCharacter: '\\ea64'
  });
  static recordKeys = new Codicon('record-keys', {
    fontCharacter: '\\ea65'
  });
  static keyboard = new Codicon('keyboard', {
    fontCharacter: '\\ea65'
  });
  static tag = new Codicon('tag', {
    fontCharacter: '\\ea66'
  });
  static tagAdd = new Codicon('tag-add', {
    fontCharacter: '\\ea66'
  });
  static tagRemove = new Codicon('tag-remove', {
    fontCharacter: '\\ea66'
  });
  static person = new Codicon('person', {
    fontCharacter: '\\ea67'
  });
  static personFollow = new Codicon('person-follow', {
    fontCharacter: '\\ea67'
  });
  static personOutline = new Codicon('person-outline', {
    fontCharacter: '\\ea67'
  });
  static personFilled = new Codicon('person-filled', {
    fontCharacter: '\\ea67'
  });
  static gitBranch = new Codicon('git-branch', {
    fontCharacter: '\\ea68'
  });
  static gitBranchCreate = new Codicon('git-branch-create', {
    fontCharacter: '\\ea68'
  });
  static gitBranchDelete = new Codicon('git-branch-delete', {
    fontCharacter: '\\ea68'
  });
  static sourceControl = new Codicon('source-control', {
    fontCharacter: '\\ea68'
  });
  static mirror = new Codicon('mirror', {
    fontCharacter: '\\ea69'
  });
  static mirrorPublic = new Codicon('mirror-public', {
    fontCharacter: '\\ea69'
  });
  static star = new Codicon('star', {
    fontCharacter: '\\ea6a'
  });
  static starAdd = new Codicon('star-add', {
    fontCharacter: '\\ea6a'
  });
  static starDelete = new Codicon('star-delete', {
    fontCharacter: '\\ea6a'
  });
  static starEmpty = new Codicon('star-empty', {
    fontCharacter: '\\ea6a'
  });
  static comment = new Codicon('comment', {
    fontCharacter: '\\ea6b'
  });
  static commentAdd = new Codicon('comment-add', {
    fontCharacter: '\\ea6b'
  });
  static alert = new Codicon('alert', {
    fontCharacter: '\\ea6c'
  });
  static warning = new Codicon('warning', {
    fontCharacter: '\\ea6c'
  });
  static search = new Codicon('search', {
    fontCharacter: '\\ea6d'
  });
  static searchSave = new Codicon('search-save', {
    fontCharacter: '\\ea6d'
  });
  static logOut = new Codicon('log-out', {
    fontCharacter: '\\ea6e'
  });
  static signOut = new Codicon('sign-out', {
    fontCharacter: '\\ea6e'
  });
  static logIn = new Codicon('log-in', {
    fontCharacter: '\\ea6f'
  });
  static signIn = new Codicon('sign-in', {
    fontCharacter: '\\ea6f'
  });
  static eye = new Codicon('eye', {
    fontCharacter: '\\ea70'
  });
  static eyeUnwatch = new Codicon('eye-unwatch', {
    fontCharacter: '\\ea70'
  });
  static eyeWatch = new Codicon('eye-watch', {
    fontCharacter: '\\ea70'
  });
  static circleFilled = new Codicon('circle-filled', {
    fontCharacter: '\\ea71'
  });
  static primitiveDot = new Codicon('primitive-dot', Codicon.circleFilled.definition);
  static closeDirty = new Codicon('close-dirty', Codicon.circleFilled.definition);
  static debugBreakpoint = new Codicon('debug-breakpoint', Codicon.circleFilled.definition);
  static debugBreakpointDisabled = new Codicon('debug-breakpoint-disabled', Codicon.circleFilled.definition);
  static debugHint = new Codicon('debug-hint', Codicon.circleFilled.definition);
  static primitiveSquare = new Codicon('primitive-square', {
    fontCharacter: '\\ea72'
  });
  static edit = new Codicon('edit', {
    fontCharacter: '\\ea73'
  });
  static pencil = new Codicon('pencil', {
    fontCharacter: '\\ea73'
  });
  static info = new Codicon('info', {
    fontCharacter: '\\ea74'
  });
  static issueOpened = new Codicon('issue-opened', {
    fontCharacter: '\\ea74'
  });
  static gistPrivate = new Codicon('gist-private', {
    fontCharacter: '\\ea75'
  });
  static gitForkPrivate = new Codicon('git-fork-private', {
    fontCharacter: '\\ea75'
  });
  static lock = new Codicon('lock', {
    fontCharacter: '\\ea75'
  });
  static mirrorPrivate = new Codicon('mirror-private', {
    fontCharacter: '\\ea75'
  });
  static close = new Codicon('close', {
    fontCharacter: '\\ea76'
  });
  static removeClose = new Codicon('remove-close', {
    fontCharacter: '\\ea76'
  });
  static x = new Codicon('x', {
    fontCharacter: '\\ea76'
  });
  static repoSync = new Codicon('repo-sync', {
    fontCharacter: '\\ea77'
  });
  static sync = new Codicon('sync', {
    fontCharacter: '\\ea77'
  });
  static clone = new Codicon('clone', {
    fontCharacter: '\\ea78'
  });
  static desktopDownload = new Codicon('desktop-download', {
    fontCharacter: '\\ea78'
  });
  static beaker = new Codicon('beaker', {
    fontCharacter: '\\ea79'
  });
  static microscope = new Codicon('microscope', {
    fontCharacter: '\\ea79'
  });
  static vm = new Codicon('vm', {
    fontCharacter: '\\ea7a'
  });
  static deviceDesktop = new Codicon('device-desktop', {
    fontCharacter: '\\ea7a'
  });
  static file = new Codicon('file', {
    fontCharacter: '\\ea7b'
  });
  static fileText = new Codicon('file-text', {
    fontCharacter: '\\ea7b'
  });
  static more = new Codicon('more', {
    fontCharacter: '\\ea7c'
  });
  static ellipsis = new Codicon('ellipsis', {
    fontCharacter: '\\ea7c'
  });
  static kebabHorizontal = new Codicon('kebab-horizontal', {
    fontCharacter: '\\ea7c'
  });
  static mailReply = new Codicon('mail-reply', {
    fontCharacter: '\\ea7d'
  });
  static reply = new Codicon('reply', {
    fontCharacter: '\\ea7d'
  });
  static organization = new Codicon('organization', {
    fontCharacter: '\\ea7e'
  });
  static organizationFilled = new Codicon('organization-filled', {
    fontCharacter: '\\ea7e'
  });
  static organizationOutline = new Codicon('organization-outline', {
    fontCharacter: '\\ea7e'
  });
  static newFile = new Codicon('new-file', {
    fontCharacter: '\\ea7f'
  });
  static fileAdd = new Codicon('file-add', {
    fontCharacter: '\\ea7f'
  });
  static newFolder = new Codicon('new-folder', {
    fontCharacter: '\\ea80'
  });
  static fileDirectoryCreate = new Codicon('file-directory-create', {
    fontCharacter: '\\ea80'
  });
  static trash = new Codicon('trash', {
    fontCharacter: '\\ea81'
  });
  static trashcan = new Codicon('trashcan', {
    fontCharacter: '\\ea81'
  });
  static history = new Codicon('history', {
    fontCharacter: '\\ea82'
  });
  static clock = new Codicon('clock', {
    fontCharacter: '\\ea82'
  });
  static folder = new Codicon('folder', {
    fontCharacter: '\\ea83'
  });
  static fileDirectory = new Codicon('file-directory', {
    fontCharacter: '\\ea83'
  });
  static symbolFolder = new Codicon('symbol-folder', {
    fontCharacter: '\\ea83'
  });
  static logoGithub = new Codicon('logo-github', {
    fontCharacter: '\\ea84'
  });
  static markGithub = new Codicon('mark-github', {
    fontCharacter: '\\ea84'
  });
  static github = new Codicon('github', {
    fontCharacter: '\\ea84'
  });
  static terminal = new Codicon('terminal', {
    fontCharacter: '\\ea85'
  });
  static console = new Codicon('console', {
    fontCharacter: '\\ea85'
  });
  static repl = new Codicon('repl', {
    fontCharacter: '\\ea85'
  });
  static zap = new Codicon('zap', {
    fontCharacter: '\\ea86'
  });
  static symbolEvent = new Codicon('symbol-event', {
    fontCharacter: '\\ea86'
  });
  static error = new Codicon('error', {
    fontCharacter: '\\ea87'
  });
  static stop = new Codicon('stop', {
    fontCharacter: '\\ea87'
  });
  static variable = new Codicon('variable', {
    fontCharacter: '\\ea88'
  });
  static symbolVariable = new Codicon('symbol-variable', {
    fontCharacter: '\\ea88'
  });
  static array = new Codicon('array', {
    fontCharacter: '\\ea8a'
  });
  static symbolArray = new Codicon('symbol-array', {
    fontCharacter: '\\ea8a'
  });
  static symbolModule = new Codicon('symbol-module', {
    fontCharacter: '\\ea8b'
  });
  static symbolPackage = new Codicon('symbol-package', {
    fontCharacter: '\\ea8b'
  });
  static symbolNamespace = new Codicon('symbol-namespace', {
    fontCharacter: '\\ea8b'
  });
  static symbolObject = new Codicon('symbol-object', {
    fontCharacter: '\\ea8b'
  });
  static symbolMethod = new Codicon('symbol-method', {
    fontCharacter: '\\ea8c'
  });
  static symbolFunction = new Codicon('symbol-function', {
    fontCharacter: '\\ea8c'
  });
  static symbolConstructor = new Codicon('symbol-constructor', {
    fontCharacter: '\\ea8c'
  });
  static symbolBoolean = new Codicon('symbol-boolean', {
    fontCharacter: '\\ea8f'
  });
  static symbolNull = new Codicon('symbol-null', {
    fontCharacter: '\\ea8f'
  });
  static symbolNumeric = new Codicon('symbol-numeric', {
    fontCharacter: '\\ea90'
  });
  static symbolNumber = new Codicon('symbol-number', {
    fontCharacter: '\\ea90'
  });
  static symbolStructure = new Codicon('symbol-structure', {
    fontCharacter: '\\ea91'
  });
  static symbolStruct = new Codicon('symbol-struct', {
    fontCharacter: '\\ea91'
  });
  static symbolParameter = new Codicon('symbol-parameter', {
    fontCharacter: '\\ea92'
  });
  static symbolTypeParameter = new Codicon('symbol-type-parameter', {
    fontCharacter: '\\ea92'
  });
  static symbolKey = new Codicon('symbol-key', {
    fontCharacter: '\\ea93'
  });
  static symbolText = new Codicon('symbol-text', {
    fontCharacter: '\\ea93'
  });
  static symbolReference = new Codicon('symbol-reference', {
    fontCharacter: '\\ea94'
  });
  static goToFile = new Codicon('go-to-file', {
    fontCharacter: '\\ea94'
  });
  static symbolEnum = new Codicon('symbol-enum', {
    fontCharacter: '\\ea95'
  });
  static symbolValue = new Codicon('symbol-value', {
    fontCharacter: '\\ea95'
  });
  static symbolRuler = new Codicon('symbol-ruler', {
    fontCharacter: '\\ea96'
  });
  static symbolUnit = new Codicon('symbol-unit', {
    fontCharacter: '\\ea96'
  });
  static activateBreakpoints = new Codicon('activate-breakpoints', {
    fontCharacter: '\\ea97'
  });
  static archive = new Codicon('archive', {
    fontCharacter: '\\ea98'
  });
  static arrowBoth = new Codicon('arrow-both', {
    fontCharacter: '\\ea99'
  });
  static arrowDown = new Codicon('arrow-down', {
    fontCharacter: '\\ea9a'
  });
  static arrowLeft = new Codicon('arrow-left', {
    fontCharacter: '\\ea9b'
  });
  static arrowRight = new Codicon('arrow-right', {
    fontCharacter: '\\ea9c'
  });
  static arrowSmallDown = new Codicon('arrow-small-down', {
    fontCharacter: '\\ea9d'
  });
  static arrowSmallLeft = new Codicon('arrow-small-left', {
    fontCharacter: '\\ea9e'
  });
  static arrowSmallRight = new Codicon('arrow-small-right', {
    fontCharacter: '\\ea9f'
  });
  static arrowSmallUp = new Codicon('arrow-small-up', {
    fontCharacter: '\\eaa0'
  });
  static arrowUp = new Codicon('arrow-up', {
    fontCharacter: '\\eaa1'
  });
  static bell = new Codicon('bell', {
    fontCharacter: '\\eaa2'
  });
  static bold = new Codicon('bold', {
    fontCharacter: '\\eaa3'
  });
  static book = new Codicon('book', {
    fontCharacter: '\\eaa4'
  });
  static bookmark = new Codicon('bookmark', {
    fontCharacter: '\\eaa5'
  });
  static debugBreakpointConditionalUnverified = new Codicon('debug-breakpoint-conditional-unverified', {
    fontCharacter: '\\eaa6'
  });
  static debugBreakpointConditional = new Codicon('debug-breakpoint-conditional', {
    fontCharacter: '\\eaa7'
  });
  static debugBreakpointConditionalDisabled = new Codicon('debug-breakpoint-conditional-disabled', {
    fontCharacter: '\\eaa7'
  });
  static debugBreakpointDataUnverified = new Codicon('debug-breakpoint-data-unverified', {
    fontCharacter: '\\eaa8'
  });
  static debugBreakpointData = new Codicon('debug-breakpoint-data', {
    fontCharacter: '\\eaa9'
  });
  static debugBreakpointDataDisabled = new Codicon('debug-breakpoint-data-disabled', {
    fontCharacter: '\\eaa9'
  });
  static debugBreakpointLogUnverified = new Codicon('debug-breakpoint-log-unverified', {
    fontCharacter: '\\eaaa'
  });
  static debugBreakpointLog = new Codicon('debug-breakpoint-log', {
    fontCharacter: '\\eaab'
  });
  static debugBreakpointLogDisabled = new Codicon('debug-breakpoint-log-disabled', {
    fontCharacter: '\\eaab'
  });
  static briefcase = new Codicon('briefcase', {
    fontCharacter: '\\eaac'
  });
  static broadcast = new Codicon('broadcast', {
    fontCharacter: '\\eaad'
  });
  static browser = new Codicon('browser', {
    fontCharacter: '\\eaae'
  });
  static bug = new Codicon('bug', {
    fontCharacter: '\\eaaf'
  });
  static calendar = new Codicon('calendar', {
    fontCharacter: '\\eab0'
  });
  static caseSensitive = new Codicon('case-sensitive', {
    fontCharacter: '\\eab1'
  });
  static check = new Codicon('check', {
    fontCharacter: '\\eab2'
  });
  static checklist = new Codicon('checklist', {
    fontCharacter: '\\eab3'
  });
  static chevronDown = new Codicon('chevron-down', {
    fontCharacter: '\\eab4'
  });
  static dropDownButton = new Codicon('drop-down-button', Codicon.chevronDown.definition);
  static chevronLeft = new Codicon('chevron-left', {
    fontCharacter: '\\eab5'
  });
  static chevronRight = new Codicon('chevron-right', {
    fontCharacter: '\\eab6'
  });
  static chevronUp = new Codicon('chevron-up', {
    fontCharacter: '\\eab7'
  });
  static chromeClose = new Codicon('chrome-close', {
    fontCharacter: '\\eab8'
  });
  static chromeMaximize = new Codicon('chrome-maximize', {
    fontCharacter: '\\eab9'
  });
  static chromeMinimize = new Codicon('chrome-minimize', {
    fontCharacter: '\\eaba'
  });
  static chromeRestore = new Codicon('chrome-restore', {
    fontCharacter: '\\eabb'
  });
  static circle = new Codicon('circle', {
    fontCharacter: '\\eabc'
  });
  static circleOutline = new Codicon('circle-outline', Codicon.circle.definition);
  static debugBreakpointUnverified = new Codicon('debug-breakpoint-unverified', Codicon.circle.definition);
  static circleSlash = new Codicon('circle-slash', {
    fontCharacter: '\\eabd'
  });
  static circuitBoard = new Codicon('circuit-board', {
    fontCharacter: '\\eabe'
  });
  static clearAll = new Codicon('clear-all', {
    fontCharacter: '\\eabf'
  });
  static clippy = new Codicon('clippy', {
    fontCharacter: '\\eac0'
  });
  static closeAll = new Codicon('close-all', {
    fontCharacter: '\\eac1'
  });
  static cloudDownload = new Codicon('cloud-download', {
    fontCharacter: '\\eac2'
  });
  static cloudUpload = new Codicon('cloud-upload', {
    fontCharacter: '\\eac3'
  });
  static code = new Codicon('code', {
    fontCharacter: '\\eac4'
  });
  static collapseAll = new Codicon('collapse-all', {
    fontCharacter: '\\eac5'
  });
  static colorMode = new Codicon('color-mode', {
    fontCharacter: '\\eac6'
  });
  static commentDiscussion = new Codicon('comment-discussion', {
    fontCharacter: '\\eac7'
  });
  static compareChanges = new Codicon('compare-changes', {
    fontCharacter: '\\eafd'
  });
  static creditCard = new Codicon('credit-card', {
    fontCharacter: '\\eac9'
  });
  static dash = new Codicon('dash', {
    fontCharacter: '\\eacc'
  });
  static dashboard = new Codicon('dashboard', {
    fontCharacter: '\\eacd'
  });
  static database = new Codicon('database', {
    fontCharacter: '\\eace'
  });
  static debugContinue = new Codicon('debug-continue', {
    fontCharacter: '\\eacf'
  });
  static debugDisconnect = new Codicon('debug-disconnect', {
    fontCharacter: '\\ead0'
  });
  static debugPause = new Codicon('debug-pause', {
    fontCharacter: '\\ead1'
  });
  static debugRestart = new Codicon('debug-restart', {
    fontCharacter: '\\ead2'
  });
  static debugStart = new Codicon('debug-start', {
    fontCharacter: '\\ead3'
  });
  static debugStepInto = new Codicon('debug-step-into', {
    fontCharacter: '\\ead4'
  });
  static debugStepOut = new Codicon('debug-step-out', {
    fontCharacter: '\\ead5'
  });
  static debugStepOver = new Codicon('debug-step-over', {
    fontCharacter: '\\ead6'
  });
  static debugStop = new Codicon('debug-stop', {
    fontCharacter: '\\ead7'
  });
  static debug = new Codicon('debug', {
    fontCharacter: '\\ead8'
  });
  static deviceCameraVideo = new Codicon('device-camera-video', {
    fontCharacter: '\\ead9'
  });
  static deviceCamera = new Codicon('device-camera', {
    fontCharacter: '\\eada'
  });
  static deviceMobile = new Codicon('device-mobile', {
    fontCharacter: '\\eadb'
  });
  static diffAdded = new Codicon('diff-added', {
    fontCharacter: '\\eadc'
  });
  static diffIgnored = new Codicon('diff-ignored', {
    fontCharacter: '\\eadd'
  });
  static diffModified = new Codicon('diff-modified', {
    fontCharacter: '\\eade'
  });
  static diffRemoved = new Codicon('diff-removed', {
    fontCharacter: '\\eadf'
  });
  static diffRenamed = new Codicon('diff-renamed', {
    fontCharacter: '\\eae0'
  });
  static diff = new Codicon('diff', {
    fontCharacter: '\\eae1'
  });
  static discard = new Codicon('discard', {
    fontCharacter: '\\eae2'
  });
  static editorLayout = new Codicon('editor-layout', {
    fontCharacter: '\\eae3'
  });
  static emptyWindow = new Codicon('empty-window', {
    fontCharacter: '\\eae4'
  });
  static exclude = new Codicon('exclude', {
    fontCharacter: '\\eae5'
  });
  static extensions = new Codicon('extensions', {
    fontCharacter: '\\eae6'
  });
  static eyeClosed = new Codicon('eye-closed', {
    fontCharacter: '\\eae7'
  });
  static fileBinary = new Codicon('file-binary', {
    fontCharacter: '\\eae8'
  });
  static fileCode = new Codicon('file-code', {
    fontCharacter: '\\eae9'
  });
  static fileMedia = new Codicon('file-media', {
    fontCharacter: '\\eaea'
  });
  static filePdf = new Codicon('file-pdf', {
    fontCharacter: '\\eaeb'
  });
  static fileSubmodule = new Codicon('file-submodule', {
    fontCharacter: '\\eaec'
  });
  static fileSymlinkDirectory = new Codicon('file-symlink-directory', {
    fontCharacter: '\\eaed'
  });
  static fileSymlinkFile = new Codicon('file-symlink-file', {
    fontCharacter: '\\eaee'
  });
  static fileZip = new Codicon('file-zip', {
    fontCharacter: '\\eaef'
  });
  static files = new Codicon('files', {
    fontCharacter: '\\eaf0'
  });
  static filter = new Codicon('filter', {
    fontCharacter: '\\eaf1'
  });
  static flame = new Codicon('flame', {
    fontCharacter: '\\eaf2'
  });
  static foldDown = new Codicon('fold-down', {
    fontCharacter: '\\eaf3'
  });
  static foldUp = new Codicon('fold-up', {
    fontCharacter: '\\eaf4'
  });
  static fold = new Codicon('fold', {
    fontCharacter: '\\eaf5'
  });
  static folderActive = new Codicon('folder-active', {
    fontCharacter: '\\eaf6'
  });
  static folderOpened = new Codicon('folder-opened', {
    fontCharacter: '\\eaf7'
  });
  static gear = new Codicon('gear', {
    fontCharacter: '\\eaf8'
  });
  static gift = new Codicon('gift', {
    fontCharacter: '\\eaf9'
  });
  static gistSecret = new Codicon('gist-secret', {
    fontCharacter: '\\eafa'
  });
  static gist = new Codicon('gist', {
    fontCharacter: '\\eafb'
  });
  static gitCommit = new Codicon('git-commit', {
    fontCharacter: '\\eafc'
  });
  static gitCompare = new Codicon('git-compare', {
    fontCharacter: '\\eafd'
  });
  static gitMerge = new Codicon('git-merge', {
    fontCharacter: '\\eafe'
  });
  static githubAction = new Codicon('github-action', {
    fontCharacter: '\\eaff'
  });
  static githubAlt = new Codicon('github-alt', {
    fontCharacter: '\\eb00'
  });
  static globe = new Codicon('globe', {
    fontCharacter: '\\eb01'
  });
  static grabber = new Codicon('grabber', {
    fontCharacter: '\\eb02'
  });
  static graph = new Codicon('graph', {
    fontCharacter: '\\eb03'
  });
  static gripper = new Codicon('gripper', {
    fontCharacter: '\\eb04'
  });
  static heart = new Codicon('heart', {
    fontCharacter: '\\eb05'
  });
  static home = new Codicon('home', {
    fontCharacter: '\\eb06'
  });
  static horizontalRule = new Codicon('horizontal-rule', {
    fontCharacter: '\\eb07'
  });
  static hubot = new Codicon('hubot', {
    fontCharacter: '\\eb08'
  });
  static inbox = new Codicon('inbox', {
    fontCharacter: '\\eb09'
  });
  static issueClosed = new Codicon('issue-closed', {
    fontCharacter: '\\eba4'
  });
  static issueReopened = new Codicon('issue-reopened', {
    fontCharacter: '\\eb0b'
  });
  static issues = new Codicon('issues', {
    fontCharacter: '\\eb0c'
  });
  static italic = new Codicon('italic', {
    fontCharacter: '\\eb0d'
  });
  static jersey = new Codicon('jersey', {
    fontCharacter: '\\eb0e'
  });
  static json = new Codicon('json', {
    fontCharacter: '\\eb0f'
  });
  static kebabVertical = new Codicon('kebab-vertical', {
    fontCharacter: '\\eb10'
  });
  static key = new Codicon('key', {
    fontCharacter: '\\eb11'
  });
  static law = new Codicon('law', {
    fontCharacter: '\\eb12'
  });
  static lightbulbAutofix = new Codicon('lightbulb-autofix', {
    fontCharacter: '\\eb13'
  });
  static linkExternal = new Codicon('link-external', {
    fontCharacter: '\\eb14'
  });
  static link = new Codicon('link', {
    fontCharacter: '\\eb15'
  });
  static listOrdered = new Codicon('list-ordered', {
    fontCharacter: '\\eb16'
  });
  static listUnordered = new Codicon('list-unordered', {
    fontCharacter: '\\eb17'
  });
  static liveShare = new Codicon('live-share', {
    fontCharacter: '\\eb18'
  });
  static loading = new Codicon('loading', {
    fontCharacter: '\\eb19'
  });
  static location = new Codicon('location', {
    fontCharacter: '\\eb1a'
  });
  static mailRead = new Codicon('mail-read', {
    fontCharacter: '\\eb1b'
  });
  static mail = new Codicon('mail', {
    fontCharacter: '\\eb1c'
  });
  static markdown = new Codicon('markdown', {
    fontCharacter: '\\eb1d'
  });
  static megaphone = new Codicon('megaphone', {
    fontCharacter: '\\eb1e'
  });
  static mention = new Codicon('mention', {
    fontCharacter: '\\eb1f'
  });
  static milestone = new Codicon('milestone', {
    fontCharacter: '\\eb20'
  });
  static mortarBoard = new Codicon('mortar-board', {
    fontCharacter: '\\eb21'
  });
  static move = new Codicon('move', {
    fontCharacter: '\\eb22'
  });
  static multipleWindows = new Codicon('multiple-windows', {
    fontCharacter: '\\eb23'
  });
  static mute = new Codicon('mute', {
    fontCharacter: '\\eb24'
  });
  static noNewline = new Codicon('no-newline', {
    fontCharacter: '\\eb25'
  });
  static note = new Codicon('note', {
    fontCharacter: '\\eb26'
  });
  static octoface = new Codicon('octoface', {
    fontCharacter: '\\eb27'
  });
  static openPreview = new Codicon('open-preview', {
    fontCharacter: '\\eb28'
  });
  static package_ = new Codicon('package', {
    fontCharacter: '\\eb29'
  });
  static paintcan = new Codicon('paintcan', {
    fontCharacter: '\\eb2a'
  });
  static pin = new Codicon('pin', {
    fontCharacter: '\\eb2b'
  });
  static play = new Codicon('play', {
    fontCharacter: '\\eb2c'
  });
  static run = new Codicon('run', {
    fontCharacter: '\\eb2c'
  });
  static plug = new Codicon('plug', {
    fontCharacter: '\\eb2d'
  });
  static preserveCase = new Codicon('preserve-case', {
    fontCharacter: '\\eb2e'
  });
  static preview = new Codicon('preview', {
    fontCharacter: '\\eb2f'
  });
  static project = new Codicon('project', {
    fontCharacter: '\\eb30'
  });
  static pulse = new Codicon('pulse', {
    fontCharacter: '\\eb31'
  });
  static question = new Codicon('question', {
    fontCharacter: '\\eb32'
  });
  static quote = new Codicon('quote', {
    fontCharacter: '\\eb33'
  });
  static radioTower = new Codicon('radio-tower', {
    fontCharacter: '\\eb34'
  });
  static reactions = new Codicon('reactions', {
    fontCharacter: '\\eb35'
  });
  static references = new Codicon('references', {
    fontCharacter: '\\eb36'
  });
  static refresh = new Codicon('refresh', {
    fontCharacter: '\\eb37'
  });
  static regex = new Codicon('regex', {
    fontCharacter: '\\eb38'
  });
  static remoteExplorer = new Codicon('remote-explorer', {
    fontCharacter: '\\eb39'
  });
  static remote = new Codicon('remote', {
    fontCharacter: '\\eb3a'
  });
  static remove = new Codicon('remove', {
    fontCharacter: '\\eb3b'
  });
  static replaceAll = new Codicon('replace-all', {
    fontCharacter: '\\eb3c'
  });
  static replace = new Codicon('replace', {
    fontCharacter: '\\eb3d'
  });
  static repoClone = new Codicon('repo-clone', {
    fontCharacter: '\\eb3e'
  });
  static repoForcePush = new Codicon('repo-force-push', {
    fontCharacter: '\\eb3f'
  });
  static repoPull = new Codicon('repo-pull', {
    fontCharacter: '\\eb40'
  });
  static repoPush = new Codicon('repo-push', {
    fontCharacter: '\\eb41'
  });
  static report = new Codicon('report', {
    fontCharacter: '\\eb42'
  });
  static requestChanges = new Codicon('request-changes', {
    fontCharacter: '\\eb43'
  });
  static rocket = new Codicon('rocket', {
    fontCharacter: '\\eb44'
  });
  static rootFolderOpened = new Codicon('root-folder-opened', {
    fontCharacter: '\\eb45'
  });
  static rootFolder = new Codicon('root-folder', {
    fontCharacter: '\\eb46'
  });
  static rss = new Codicon('rss', {
    fontCharacter: '\\eb47'
  });
  static ruby = new Codicon('ruby', {
    fontCharacter: '\\eb48'
  });
  static saveAll = new Codicon('save-all', {
    fontCharacter: '\\eb49'
  });
  static saveAs = new Codicon('save-as', {
    fontCharacter: '\\eb4a'
  });
  static save = new Codicon('save', {
    fontCharacter: '\\eb4b'
  });
  static screenFull = new Codicon('screen-full', {
    fontCharacter: '\\eb4c'
  });
  static screenNormal = new Codicon('screen-normal', {
    fontCharacter: '\\eb4d'
  });
  static searchStop = new Codicon('search-stop', {
    fontCharacter: '\\eb4e'
  });
  static server = new Codicon('server', {
    fontCharacter: '\\eb50'
  });
  static settingsGear = new Codicon('settings-gear', {
    fontCharacter: '\\eb51'
  });
  static settings = new Codicon('settings', {
    fontCharacter: '\\eb52'
  });
  static shield = new Codicon('shield', {
    fontCharacter: '\\eb53'
  });
  static smiley = new Codicon('smiley', {
    fontCharacter: '\\eb54'
  });
  static sortPrecedence = new Codicon('sort-precedence', {
    fontCharacter: '\\eb55'
  });
  static splitHorizontal = new Codicon('split-horizontal', {
    fontCharacter: '\\eb56'
  });
  static splitVertical = new Codicon('split-vertical', {
    fontCharacter: '\\eb57'
  });
  static squirrel = new Codicon('squirrel', {
    fontCharacter: '\\eb58'
  });
  static starFull = new Codicon('star-full', {
    fontCharacter: '\\eb59'
  });
  static starHalf = new Codicon('star-half', {
    fontCharacter: '\\eb5a'
  });
  static symbolClass = new Codicon('symbol-class', {
    fontCharacter: '\\eb5b'
  });
  static symbolColor = new Codicon('symbol-color', {
    fontCharacter: '\\eb5c'
  });
  static symbolCustomColor = new Codicon('symbol-customcolor', {
    fontCharacter: '\\eb5c'
  });
  static symbolConstant = new Codicon('symbol-constant', {
    fontCharacter: '\\eb5d'
  });
  static symbolEnumMember = new Codicon('symbol-enum-member', {
    fontCharacter: '\\eb5e'
  });
  static symbolField = new Codicon('symbol-field', {
    fontCharacter: '\\eb5f'
  });
  static symbolFile = new Codicon('symbol-file', {
    fontCharacter: '\\eb60'
  });
  static symbolInterface = new Codicon('symbol-interface', {
    fontCharacter: '\\eb61'
  });
  static symbolKeyword = new Codicon('symbol-keyword', {
    fontCharacter: '\\eb62'
  });
  static symbolMisc = new Codicon('symbol-misc', {
    fontCharacter: '\\eb63'
  });
  static symbolOperator = new Codicon('symbol-operator', {
    fontCharacter: '\\eb64'
  });
  static symbolProperty = new Codicon('symbol-property', {
    fontCharacter: '\\eb65'
  });
  static wrench = new Codicon('wrench', {
    fontCharacter: '\\eb65'
  });
  static wrenchSubaction = new Codicon('wrench-subaction', {
    fontCharacter: '\\eb65'
  });
  static symbolSnippet = new Codicon('symbol-snippet', {
    fontCharacter: '\\eb66'
  });
  static tasklist = new Codicon('tasklist', {
    fontCharacter: '\\eb67'
  });
  static telescope = new Codicon('telescope', {
    fontCharacter: '\\eb68'
  });
  static textSize = new Codicon('text-size', {
    fontCharacter: '\\eb69'
  });
  static threeBars = new Codicon('three-bars', {
    fontCharacter: '\\eb6a'
  });
  static thumbsdown = new Codicon('thumbsdown', {
    fontCharacter: '\\eb6b'
  });
  static thumbsup = new Codicon('thumbsup', {
    fontCharacter: '\\eb6c'
  });
  static tools = new Codicon('tools', {
    fontCharacter: '\\eb6d'
  });
  static triangleDown = new Codicon('triangle-down', {
    fontCharacter: '\\eb6e'
  });
  static triangleLeft = new Codicon('triangle-left', {
    fontCharacter: '\\eb6f'
  });
  static triangleRight = new Codicon('triangle-right', {
    fontCharacter: '\\eb70'
  });
  static triangleUp = new Codicon('triangle-up', {
    fontCharacter: '\\eb71'
  });
  static twitter = new Codicon('twitter', {
    fontCharacter: '\\eb72'
  });
  static unfold = new Codicon('unfold', {
    fontCharacter: '\\eb73'
  });
  static unlock = new Codicon('unlock', {
    fontCharacter: '\\eb74'
  });
  static unmute = new Codicon('unmute', {
    fontCharacter: '\\eb75'
  });
  static unverified = new Codicon('unverified', {
    fontCharacter: '\\eb76'
  });
  static verified = new Codicon('verified', {
    fontCharacter: '\\eb77'
  });
  static versions = new Codicon('versions', {
    fontCharacter: '\\eb78'
  });
  static vmActive = new Codicon('vm-active', {
    fontCharacter: '\\eb79'
  });
  static vmOutline = new Codicon('vm-outline', {
    fontCharacter: '\\eb7a'
  });
  static vmRunning = new Codicon('vm-running', {
    fontCharacter: '\\eb7b'
  });
  static watch = new Codicon('watch', {
    fontCharacter: '\\eb7c'
  });
  static whitespace = new Codicon('whitespace', {
    fontCharacter: '\\eb7d'
  });
  static wholeWord = new Codicon('whole-word', {
    fontCharacter: '\\eb7e'
  });
  static window = new Codicon('window', {
    fontCharacter: '\\eb7f'
  });
  static wordWrap = new Codicon('word-wrap', {
    fontCharacter: '\\eb80'
  });
  static zoomIn = new Codicon('zoom-in', {
    fontCharacter: '\\eb81'
  });
  static zoomOut = new Codicon('zoom-out', {
    fontCharacter: '\\eb82'
  });
  static listFilter = new Codicon('list-filter', {
    fontCharacter: '\\eb83'
  });
  static listFlat = new Codicon('list-flat', {
    fontCharacter: '\\eb84'
  });
  static listSelection = new Codicon('list-selection', {
    fontCharacter: '\\eb85'
  });
  static selection = new Codicon('selection', {
    fontCharacter: '\\eb85'
  });
  static listTree = new Codicon('list-tree', {
    fontCharacter: '\\eb86'
  });
  static debugBreakpointFunctionUnverified = new Codicon('debug-breakpoint-function-unverified', {
    fontCharacter: '\\eb87'
  });
  static debugBreakpointFunction = new Codicon('debug-breakpoint-function', {
    fontCharacter: '\\eb88'
  });
  static debugBreakpointFunctionDisabled = new Codicon('debug-breakpoint-function-disabled', {
    fontCharacter: '\\eb88'
  });
  static debugStackframeActive = new Codicon('debug-stackframe-active', {
    fontCharacter: '\\eb89'
  });
  static circleSmallFilled = new Codicon('circle-small-filled', {
    fontCharacter: '\\eb8a'
  });
  static debugStackframeDot = new Codicon('debug-stackframe-dot', Codicon.circleSmallFilled.definition);
  static debugStackframe = new Codicon('debug-stackframe', {
    fontCharacter: '\\eb8b'
  });
  static debugStackframeFocused = new Codicon('debug-stackframe-focused', {
    fontCharacter: '\\eb8b'
  });
  static debugBreakpointUnsupported = new Codicon('debug-breakpoint-unsupported', {
    fontCharacter: '\\eb8c'
  });
  static symbolString = new Codicon('symbol-string', {
    fontCharacter: '\\eb8d'
  });
  static debugReverseContinue = new Codicon('debug-reverse-continue', {
    fontCharacter: '\\eb8e'
  });
  static debugStepBack = new Codicon('debug-step-back', {
    fontCharacter: '\\eb8f'
  });
  static debugRestartFrame = new Codicon('debug-restart-frame', {
    fontCharacter: '\\eb90'
  });
  static callIncoming = new Codicon('call-incoming', {
    fontCharacter: '\\eb92'
  });
  static callOutgoing = new Codicon('call-outgoing', {
    fontCharacter: '\\eb93'
  });
  static menu = new Codicon('menu', {
    fontCharacter: '\\eb94'
  });
  static expandAll = new Codicon('expand-all', {
    fontCharacter: '\\eb95'
  });
  static feedback = new Codicon('feedback', {
    fontCharacter: '\\eb96'
  });
  static groupByRefType = new Codicon('group-by-ref-type', {
    fontCharacter: '\\eb97'
  });
  static ungroupByRefType = new Codicon('ungroup-by-ref-type', {
    fontCharacter: '\\eb98'
  });
  static account = new Codicon('account', {
    fontCharacter: '\\eb99'
  });
  static bellDot = new Codicon('bell-dot', {
    fontCharacter: '\\eb9a'
  });
  static debugConsole = new Codicon('debug-console', {
    fontCharacter: '\\eb9b'
  });
  static library = new Codicon('library', {
    fontCharacter: '\\eb9c'
  });
  static output = new Codicon('output', {
    fontCharacter: '\\eb9d'
  });
  static runAll = new Codicon('run-all', {
    fontCharacter: '\\eb9e'
  });
  static syncIgnored = new Codicon('sync-ignored', {
    fontCharacter: '\\eb9f'
  });
  static pinned = new Codicon('pinned', {
    fontCharacter: '\\eba0'
  });
  static githubInverted = new Codicon('github-inverted', {
    fontCharacter: '\\eba1'
  });
  static debugAlt = new Codicon('debug-alt', {
    fontCharacter: '\\eb91'
  });
  static serverProcess = new Codicon('server-process', {
    fontCharacter: '\\eba2'
  });
  static serverEnvironment = new Codicon('server-environment', {
    fontCharacter: '\\eba3'
  });
  static pass = new Codicon('pass', {
    fontCharacter: '\\eba4'
  });
  static stopCircle = new Codicon('stop-circle', {
    fontCharacter: '\\eba5'
  });
  static playCircle = new Codicon('play-circle', {
    fontCharacter: '\\eba6'
  });
  static record = new Codicon('record', {
    fontCharacter: '\\eba7'
  });
  static debugAltSmall = new Codicon('debug-alt-small', {
    fontCharacter: '\\eba8'
  });
  static vmConnect = new Codicon('vm-connect', {
    fontCharacter: '\\eba9'
  });
  static cloud = new Codicon('cloud', {
    fontCharacter: '\\ebaa'
  });
  static merge = new Codicon('merge', {
    fontCharacter: '\\ebab'
  });
  static exportIcon = new Codicon('export', {
    fontCharacter: '\\ebac'
  });
  static graphLeft = new Codicon('graph-left', {
    fontCharacter: '\\ebad'
  });
  static magnet = new Codicon('magnet', {
    fontCharacter: '\\ebae'
  });
  static notebook = new Codicon('notebook', {
    fontCharacter: '\\ebaf'
  });
  static redo = new Codicon('redo', {
    fontCharacter: '\\ebb0'
  });
  static checkAll = new Codicon('check-all', {
    fontCharacter: '\\ebb1'
  });
  static pinnedDirty = new Codicon('pinned-dirty', {
    fontCharacter: '\\ebb2'
  });
  static passFilled = new Codicon('pass-filled', {
    fontCharacter: '\\ebb3'
  });
  static circleLargeFilled = new Codicon('circle-large-filled', {
    fontCharacter: '\\ebb4'
  });
  static circleLarge = new Codicon('circle-large', {
    fontCharacter: '\\ebb5'
  });
  static circleLargeOutline = new Codicon('circle-large-outline', Codicon.circleLarge.definition);
  static combine = new Codicon('combine', {
    fontCharacter: '\\ebb6'
  });
  static gather = new Codicon('gather', {
    fontCharacter: '\\ebb6'
  });
  static table = new Codicon('table', {
    fontCharacter: '\\ebb7'
  });
  static variableGroup = new Codicon('variable-group', {
    fontCharacter: '\\ebb8'
  });
  static typeHierarchy = new Codicon('type-hierarchy', {
    fontCharacter: '\\ebb9'
  });
  static typeHierarchySub = new Codicon('type-hierarchy-sub', {
    fontCharacter: '\\ebba'
  });
  static typeHierarchySuper = new Codicon('type-hierarchy-super', {
    fontCharacter: '\\ebbb'
  });
  static gitPullRequestCreate = new Codicon('git-pull-request-create', {
    fontCharacter: '\\ebbc'
  });
  static runAbove = new Codicon('run-above', {
    fontCharacter: '\\ebbd'
  });
  static runBelow = new Codicon('run-below', {
    fontCharacter: '\\ebbe'
  });
  static notebookTemplate = new Codicon('notebook-template', {
    fontCharacter: '\\ebbf'
  });
  static debugRerun = new Codicon('debug-rerun', {
    fontCharacter: '\\ebc0'
  });
  static workspaceTrusted = new Codicon('workspace-trusted', {
    fontCharacter: '\\ebc1'
  });
  static workspaceUntrusted = new Codicon('workspace-untrusted', {
    fontCharacter: '\\ebc2'
  });
  static workspaceUnspecified = new Codicon('workspace-unspecified', {
    fontCharacter: '\\ebc3'
  });
  static terminalCmd = new Codicon('terminal-cmd', {
    fontCharacter: '\\ebc4'
  });
  static terminalDebian = new Codicon('terminal-debian', {
    fontCharacter: '\\ebc5'
  });
  static terminalLinux = new Codicon('terminal-linux', {
    fontCharacter: '\\ebc6'
  });
  static terminalPowershell = new Codicon('terminal-powershell', {
    fontCharacter: '\\ebc7'
  });
  static terminalTmux = new Codicon('terminal-tmux', {
    fontCharacter: '\\ebc8'
  });
  static terminalUbuntu = new Codicon('terminal-ubuntu', {
    fontCharacter: '\\ebc9'
  });
  static terminalBash = new Codicon('terminal-bash', {
    fontCharacter: '\\ebca'
  });
  static arrowSwap = new Codicon('arrow-swap', {
    fontCharacter: '\\ebcb'
  });
  static copy = new Codicon('copy', {
    fontCharacter: '\\ebcc'
  });
  static personAdd = new Codicon('person-add', {
    fontCharacter: '\\ebcd'
  });
  static filterFilled = new Codicon('filter-filled', {
    fontCharacter: '\\ebce'
  });
  static wand = new Codicon('wand', {
    fontCharacter: '\\ebcf'
  });
  static debugLineByLine = new Codicon('debug-line-by-line', {
    fontCharacter: '\\ebd0'
  });
  static inspect = new Codicon('inspect', {
    fontCharacter: '\\ebd1'
  });
  static layers = new Codicon('layers', {
    fontCharacter: '\\ebd2'
  });
  static layersDot = new Codicon('layers-dot', {
    fontCharacter: '\\ebd3'
  });
  static layersActive = new Codicon('layers-active', {
    fontCharacter: '\\ebd4'
  });
  static compass = new Codicon('compass', {
    fontCharacter: '\\ebd5'
  });
  static compassDot = new Codicon('compass-dot', {
    fontCharacter: '\\ebd6'
  });
  static compassActive = new Codicon('compass-active', {
    fontCharacter: '\\ebd7'
  });
  static azure = new Codicon('azure', {
    fontCharacter: '\\ebd8'
  });
  static issueDraft = new Codicon('issue-draft', {
    fontCharacter: '\\ebd9'
  });
  static gitPullRequestClosed = new Codicon('git-pull-request-closed', {
    fontCharacter: '\\ebda'
  });
  static gitPullRequestDraft = new Codicon('git-pull-request-draft', {
    fontCharacter: '\\ebdb'
  });
  static debugAll = new Codicon('debug-all', {
    fontCharacter: '\\ebdc'
  });
  static debugCoverage = new Codicon('debug-coverage', {
    fontCharacter: '\\ebdd'
  });
  static runErrors = new Codicon('run-errors', {
    fontCharacter: '\\ebde'
  });
  static folderLibrary = new Codicon('folder-library', {
    fontCharacter: '\\ebdf'
  });
  static debugContinueSmall = new Codicon('debug-continue-small', {
    fontCharacter: '\\ebe0'
  });
  static beakerStop = new Codicon('beaker-stop', {
    fontCharacter: '\\ebe1'
  });
  static graphLine = new Codicon('graph-line', {
    fontCharacter: '\\ebe2'
  });
  static graphScatter = new Codicon('graph-scatter', {
    fontCharacter: '\\ebe3'
  });
  static pieChart = new Codicon('pie-chart', {
    fontCharacter: '\\ebe4'
  });
  static bracket = new Codicon('bracket', Codicon.json.definition);
  static bracketDot = new Codicon('bracket-dot', {
    fontCharacter: '\\ebe5'
  });
  static bracketError = new Codicon('bracket-error', {
    fontCharacter: '\\ebe6'
  });
  static lockSmall = new Codicon('lock-small', {
    fontCharacter: '\\ebe7'
  });
  static azureDevops = new Codicon('azure-devops', {
    fontCharacter: '\\ebe8'
  });
  static verifiedFilled = new Codicon('verified-filled', {
    fontCharacter: '\\ebe9'
  });
  static newLine = new Codicon('newline', {
    fontCharacter: '\\ebea'
  });
  static layout = new Codicon('layout', {
    fontCharacter: '\\ebeb'
  });
  static layoutActivitybarLeft = new Codicon('layout-activitybar-left', {
    fontCharacter: '\\ebec'
  });
  static layoutActivitybarRight = new Codicon('layout-activitybar-right', {
    fontCharacter: '\\ebed'
  });
  static layoutPanelLeft = new Codicon('layout-panel-left', {
    fontCharacter: '\\ebee'
  });
  static layoutPanelCenter = new Codicon('layout-panel-center', {
    fontCharacter: '\\ebef'
  });
  static layoutPanelJustify = new Codicon('layout-panel-justify', {
    fontCharacter: '\\ebf0'
  });
  static layoutPanelRight = new Codicon('layout-panel-right', {
    fontCharacter: '\\ebf1'
  });
  static layoutPanel = new Codicon('layout-panel', {
    fontCharacter: '\\ebf2'
  });
  static layoutSidebarLeft = new Codicon('layout-sidebar-left', {
    fontCharacter: '\\ebf3'
  });
  static layoutSidebarRight = new Codicon('layout-sidebar-right', {
    fontCharacter: '\\ebf4'
  });
  static layoutStatusbar = new Codicon('layout-statusbar', {
    fontCharacter: '\\ebf5'
  });
  static layoutMenubar = new Codicon('layout-menubar', {
    fontCharacter: '\\ebf6'
  });
  static layoutCentered = new Codicon('layout-centered', {
    fontCharacter: '\\ebf7'
  });
  static layoutSidebarRightOff = new Codicon('layout-sidebar-right-off', {
    fontCharacter: '\\ec00'
  });
  static layoutPanelOff = new Codicon('layout-panel-off', {
    fontCharacter: '\\ec01'
  });
  static layoutSidebarLeftOff = new Codicon('layout-sidebar-left-off', {
    fontCharacter: '\\ec02'
  });
  static target = new Codicon('target', {
    fontCharacter: '\\ebf8'
  });
  static indent = new Codicon('indent', {
    fontCharacter: '\\ebf9'
  });
  static recordSmall = new Codicon('record-small', {
    fontCharacter: '\\ebfa'
  });
  static errorSmall = new Codicon('error-small', {
    fontCharacter: '\\ebfb'
  });
  static arrowCircleDown = new Codicon('arrow-circle-down', {
    fontCharacter: '\\ebfc'
  });
  static arrowCircleLeft = new Codicon('arrow-circle-left', {
    fontCharacter: '\\ebfd'
  });
  static arrowCircleRight = new Codicon('arrow-circle-right', {
    fontCharacter: '\\ebfe'
  });
  static arrowCircleUp = new Codicon('arrow-circle-up', {
    fontCharacter: '\\ebff'
  });
  static heartFilled = new Codicon('heart-filled', {
    fontCharacter: '\\ec04'
  });
  static map = new Codicon('map', {
    fontCharacter: '\\ec05'
  });
  static mapFilled = new Codicon('map-filled', {
    fontCharacter: '\\ec06'
  });
  static circleSmall = new Codicon('circle-small', {
    fontCharacter: '\\ec07'
  });
  static bellSlash = new Codicon('bell-slash', {
    fontCharacter: '\\ec08'
  });
  static bellSlashDot = new Codicon('bell-slash-dot', {
    fontCharacter: '\\ec09'
  });
  static commentUnresolved = new Codicon('comment-unresolved', {
    fontCharacter: '\\ec0a'
  });
  static gitPullRequestGoToChanges = new Codicon('git-pull-request-go-to-changes', {
    fontCharacter: '\\ec0b'
  });
  static gitPullRequestNewChanges = new Codicon('git-pull-request-new-changes', {
    fontCharacter: '\\ec0c'
  });
  static searchFuzzy = new Codicon('search-fuzzy', {
    fontCharacter: '\\ec0d'
  }); // derived icons, that could become separate icons

  static dialogError = new Codicon('dialog-error', Codicon.error.definition);
  static dialogWarning = new Codicon('dialog-warning', Codicon.warning.definition);
  static dialogInfo = new Codicon('dialog-info', Codicon.info.definition);
  static dialogClose = new Codicon('dialog-close', Codicon.close.definition);
  static treeItemExpanded = new Codicon('tree-item-expanded', Codicon.chevronDown.definition); // collapsed is done with rotation

  static treeFilterOnTypeOn = new Codicon('tree-filter-on-type-on', Codicon.listFilter.definition);
  static treeFilterOnTypeOff = new Codicon('tree-filter-on-type-off', Codicon.listSelection.definition);
  static treeFilterClear = new Codicon('tree-filter-clear', Codicon.close.definition);
  static treeItemLoading = new Codicon('tree-item-loading', Codicon.loading.definition);
  static menuSelection = new Codicon('menu-selection', Codicon.check.definition);
  static menuSubmenu = new Codicon('menu-submenu', Codicon.chevronRight.definition);
  static menuBarMore = new Codicon('menubar-more', Codicon.more.definition);
  static scrollbarButtonLeft = new Codicon('scrollbar-button-left', Codicon.triangleLeft.definition);
  static scrollbarButtonRight = new Codicon('scrollbar-button-right', Codicon.triangleRight.definition);
  static scrollbarButtonUp = new Codicon('scrollbar-button-up', Codicon.triangleUp.definition);
  static scrollbarButtonDown = new Codicon('scrollbar-button-down', Codicon.triangleDown.definition);
  static toolBarMore = new Codicon('toolbar-more', Codicon.more.definition);
  static quickInputBack = new Codicon('quick-input-back', Codicon.arrowLeft.definition);
}
function getClassNamesArray(id, modifier) {
  const classNames = ['codicon', 'codicon-' + id];

  if (modifier) {
    classNames.push('codicon-modifier-' + modifier);
  }

  return classNames;
}
let CSSIcon;

(function (_CSSIcon) {
  const iconNameSegment = _CSSIcon.iconNameSegment = '[A-Za-z0-9]+';
  const iconNameExpression = _CSSIcon.iconNameExpression = '[A-Za-z0-9-]+';
  const iconModifierExpression = _CSSIcon.iconModifierExpression = '~[A-Za-z]+';
  const iconNameCharacter = _CSSIcon.iconNameCharacter = '[A-Za-z0-9~-]';
  const cssIconIdRegex = new RegExp(`^(${iconNameExpression})(${iconModifierExpression})?$`);

  function asClassNameArray(icon) {
    if (icon instanceof Codicon) {
      return ['codicon', 'codicon-' + icon.id];
    }

    const match = cssIconIdRegex.exec(icon.id);

    if (!match) {
      return asClassNameArray(Codicon.error);
    }

    const [, id, modifier] = match;
    const classNames = ['codicon', 'codicon-' + id];

    if (modifier) {
      classNames.push('codicon-modifier-' + modifier.substr(1));
    }

    return classNames;
  }

  _CSSIcon.asClassNameArray = asClassNameArray;

  function asClassName(icon) {
    return asClassNameArray(icon).join(' ');
  }

  _CSSIcon.asClassName = asClassName;

  function asCSSSelector(icon) {
    return '.' + asClassNameArray(icon).join('.');
  }

  _CSSIcon.asCSSSelector = asCSSSelector;
})(CSSIcon || (CSSIcon = {}));

/***/ }),
/* 105 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "VerticalScrollbar": () => (/* binding */ VerticalScrollbar)
/* harmony export */ });
/* harmony import */ var _browser_mouseEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(66);
/* harmony import */ var _browser_ui_scrollbar_abstractScrollbar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(97);
/* harmony import */ var _browser_ui_scrollbar_scrollbarArrow__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(99);
/* harmony import */ var _browser_ui_scrollbar_scrollbarState__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(103);
/* harmony import */ var _common_codicons__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(104);
/* harmony import */ var _common_scrollable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(102);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






class VerticalScrollbar extends _browser_ui_scrollbar_abstractScrollbar__WEBPACK_IMPORTED_MODULE_1__.AbstractScrollbar {
  constructor(scrollable, options, host) {
    const scrollDimensions = scrollable.getScrollDimensions();
    const scrollPosition = scrollable.getCurrentScrollPosition();
    super({
      lazyRender: options.lazyRender,
      host: host,
      scrollbarState: new _browser_ui_scrollbar_scrollbarState__WEBPACK_IMPORTED_MODULE_3__.ScrollbarState(options.verticalHasArrows ? options.arrowSize : 0, options.vertical === _common_scrollable__WEBPACK_IMPORTED_MODULE_5__.ScrollbarVisibility.Hidden ? 0 : options.verticalScrollbarSize, // give priority to vertical scroll bar over horizontal and let it scroll all the way to the bottom
      0, scrollDimensions.height, scrollDimensions.scrollHeight, scrollPosition.scrollTop),
      visibility: options.vertical,
      extraScrollbarClassName: 'vertical',
      scrollable: scrollable,
      scrollByPage: options.scrollByPage
    });

    if (options.verticalHasArrows) {
      const arrowDelta = (options.arrowSize - _browser_ui_scrollbar_scrollbarArrow__WEBPACK_IMPORTED_MODULE_2__.ARROW_IMG_SIZE) / 2;
      const scrollbarDelta = (options.verticalScrollbarSize - _browser_ui_scrollbar_scrollbarArrow__WEBPACK_IMPORTED_MODULE_2__.ARROW_IMG_SIZE) / 2;

      this._createArrow({
        className: 'scra',
        icon: _common_codicons__WEBPACK_IMPORTED_MODULE_4__.Codicon.scrollbarButtonUp,
        top: arrowDelta,
        left: scrollbarDelta,
        bottom: undefined,
        right: undefined,
        bgWidth: options.verticalScrollbarSize,
        bgHeight: options.arrowSize,
        onActivate: () => this._host.onMouseWheel(new _browser_mouseEvent__WEBPACK_IMPORTED_MODULE_0__.StandardWheelEvent(null, 0, 1))
      });

      this._createArrow({
        className: 'scra',
        icon: _common_codicons__WEBPACK_IMPORTED_MODULE_4__.Codicon.scrollbarButtonDown,
        top: undefined,
        left: scrollbarDelta,
        bottom: arrowDelta,
        right: undefined,
        bgWidth: options.verticalScrollbarSize,
        bgHeight: options.arrowSize,
        onActivate: () => this._host.onMouseWheel(new _browser_mouseEvent__WEBPACK_IMPORTED_MODULE_0__.StandardWheelEvent(null, 0, -1))
      });
    }

    this._createSlider(0, Math.floor((options.verticalScrollbarSize - options.verticalSliderSize) / 2), options.verticalSliderSize, undefined);
  }

  _updateSlider(sliderSize, sliderPosition) {
    this.slider.setHeight(sliderSize);
    this.slider.setTop(sliderPosition);
  }

  _renderDomNode(largeSize, smallSize) {
    this.domNode.setWidth(smallSize);
    this.domNode.setHeight(largeSize);
    this.domNode.setRight(0);
    this.domNode.setTop(0);
  }

  onDidScroll(e) {
    this._shouldRender = this._onElementScrollSize(e.scrollHeight) || this._shouldRender;
    this._shouldRender = this._onElementScrollPosition(e.scrollTop) || this._shouldRender;
    this._shouldRender = this._onElementSize(e.height) || this._shouldRender;
    return this._shouldRender;
  }

  _pointerDownRelativePosition(offsetX, offsetY) {
    return offsetY;
  }

  _sliderPointerPosition(e) {
    return e.pageY;
  }

  _sliderOrthogonalPointerPosition(e) {
    return e.pageX;
  }

  _updateScrollbarSize(size) {
    this.slider.setWidth(size);
  }

  writeScrollPosition(target, scrollPosition) {
    target.scrollTop = scrollPosition;
  }

  updateOptions(options) {
    this.updateScrollbarSize(options.vertical === _common_scrollable__WEBPACK_IMPORTED_MODULE_5__.ScrollbarVisibility.Hidden ? 0 : options.verticalScrollbarSize); // give priority to vertical scroll bar over horizontal and let it scroll all the way to the bottom

    this._scrollbarState.setOppositeScrollbarSize(0);

    this._visibilityController.setVisibility(options.vertical);

    this._scrollByPage = options.scrollByPage;
  }

}

/***/ }),
/* 106 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),
/* 107 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "clamp": () => (/* binding */ clamp),
/* harmony export */   "rot": () => (/* binding */ rot),
/* harmony export */   "Counter": () => (/* binding */ Counter),
/* harmony export */   "MovingAverage": () => (/* binding */ MovingAverage),
/* harmony export */   "SlidingWindowAverage": () => (/* binding */ SlidingWindowAverage)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
function clamp(value, min, max) {
  return Math.min(Math.max(value, min), max);
}
function rot(index, modulo) {
  return (modulo + index % modulo) % modulo;
}
class Counter {
  _next = 0;

  getNext() {
    return this._next++;
  }

}
class MovingAverage {
  _n = 1;
  _val = 0;

  update(value) {
    this._val = this._val + (value - this._val) / this._n;
    this._n += 1;
    return this._val;
  }

  get value() {
    return this._val;
  }

}
class SlidingWindowAverage {
  _n = 0;
  _val = 0;
  _values = [];
  _index = 0;
  _sum = 0;

  constructor(size) {
    this._values = new Array(size);

    this._values.fill(0, 0, size);
  }

  update(value) {
    const oldValue = this._values[this._index];
    this._values[this._index] = value;
    this._index = (this._index + 1) % this._values.length;
    this._sum -= oldValue;
    this._sum += value;

    if (this._n < this._values.length) {
      this._n += 1;
    }

    this._val = this._sum / this._n;
    return this._val;
  }

  get value() {
    return this._val;
  }

}

/***/ }),
/* 108 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),
/* 109 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ok": () => (/* binding */ ok),
/* harmony export */   "assertNever": () => (/* binding */ assertNever),
/* harmony export */   "assert": () => (/* binding */ assert),
/* harmony export */   "assertFn": () => (/* binding */ assertFn),
/* harmony export */   "checkAdjacentItems": () => (/* binding */ checkAdjacentItems)
/* harmony export */ });
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

/**
 * Throws an error with the provided message if the provided value does not evaluate to a true Javascript value.
 *
 * @deprecated Use `assert(...)` instead.
 * This method is usually used like this:
 * ```ts
 * import * as assert from './assert';
 * assert.ok(...);
 * ```
 *
 * However, `assert` in that example is a user chosen name.
 * There is no tooling for generating such an import statement.
 * Thus, the `assert(...)` function should be used instead.
 */

function ok(value, message) {
  if (!value) {
    throw new Error(message ? `Assertion failed (${message})` : 'Assertion Failed');
  }
}
function assertNever(value, message = 'Unreachable') {
  throw new Error(message);
}
function assert(condition) {
  if (!condition) {
    throw new _errors__WEBPACK_IMPORTED_MODULE_0__.BugIndicatingError('Assertion Failed');
  }
}
/**
 * condition must be side-effect free!
 */

function assertFn(condition) {
  if (!condition()) {
    // eslint-disable-next-line no-debugger
    debugger; // Reevaluate `condition` again to make debugging easier

    condition();
    (0,_errors__WEBPACK_IMPORTED_MODULE_0__.onUnexpectedError)(new _errors__WEBPACK_IMPORTED_MODULE_0__.BugIndicatingError('Assertion Failed'));
  }
}
function checkAdjacentItems(items, predicate) {
  let i = 0;

  while (i < items.length - 1) {
    const a = items[i];
    const b = items[i + 1];

    if (!predicate(a, b)) {
      return false;
    }

    i++;
  }

  return true;
}

/***/ }),
/* 110 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IViewSize": () => (/* reexport safe */ _gridview__WEBPACK_IMPORTED_MODULE_4__.IViewSize),
/* harmony export */   "LayoutPriority": () => (/* reexport safe */ _gridview__WEBPACK_IMPORTED_MODULE_4__.LayoutPriority),
/* harmony export */   "Orientation": () => (/* reexport safe */ _gridview__WEBPACK_IMPORTED_MODULE_4__.Orientation),
/* harmony export */   "orthogonal": () => (/* reexport safe */ _gridview__WEBPACK_IMPORTED_MODULE_4__.orthogonal),
/* harmony export */   "Direction": () => (/* binding */ Direction),
/* harmony export */   "isGridBranchNode": () => (/* binding */ isGridBranchNode),
/* harmony export */   "getRelativeLocation": () => (/* binding */ getRelativeLocation),
/* harmony export */   "Sizing": () => (/* binding */ Sizing),
/* harmony export */   "Grid": () => (/* binding */ Grid),
/* harmony export */   "SerializableGrid": () => (/* binding */ SerializableGrid),
/* harmony export */   "sanitizeGridNodeDescriptor": () => (/* binding */ sanitizeGridNodeDescriptor),
/* harmony export */   "createSerializedGrid": () => (/* binding */ createSerializedGrid)
/* harmony export */ });
/* harmony import */ var _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(89);
/* harmony import */ var _common_arrays__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(87);
/* harmony import */ var _common_lifecycle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(54);
/* harmony import */ var _gridview_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(111);
/* harmony import */ var _gridview__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(112);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






let Direction;

(function (Direction) {
  Direction[Direction["Up"] = 0] = "Up";
  Direction[Direction["Down"] = 1] = "Down";
  Direction[Direction["Left"] = 2] = "Left";
  Direction[Direction["Right"] = 3] = "Right";
})(Direction || (Direction = {}));

function oppositeDirection(direction) {
  switch (direction) {
    case Direction.Up:
      return Direction.Down;

    case Direction.Down:
      return Direction.Up;

    case Direction.Left:
      return Direction.Right;

    case Direction.Right:
      return Direction.Left;
  }
}
/**
 * The interface to implement for views within a {@link Grid}.
 */


function isGridBranchNode(node) {
  return !!node.children;
}

function getGridNode(node, location) {
  if (location.length === 0) {
    return node;
  }

  if (!isGridBranchNode(node)) {
    throw new Error('Invalid location');
  }

  const [index, ...rest] = location;
  return getGridNode(node.children[index], rest);
}

function intersects(one, other) {
  return !(one.start >= other.end || other.start >= one.end);
}

function getBoxBoundary(box, direction) {
  const orientation = getDirectionOrientation(direction);
  const offset = direction === Direction.Up ? box.top : direction === Direction.Right ? box.left + box.width : direction === Direction.Down ? box.top + box.height : box.left;
  const range = {
    start: orientation === _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_0__.Orientation.HORIZONTAL ? box.top : box.left,
    end: orientation === _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_0__.Orientation.HORIZONTAL ? box.top + box.height : box.left + box.width
  };
  return {
    offset,
    range
  };
}

function findAdjacentBoxLeafNodes(boxNode, direction, boundary) {
  const result = [];

  function _(boxNode, direction, boundary) {
    if (isGridBranchNode(boxNode)) {
      for (const child of boxNode.children) {
        _(child, direction, boundary);
      }
    } else {
      const {
        offset,
        range
      } = getBoxBoundary(boxNode.box, direction);

      if (offset === boundary.offset && intersects(range, boundary.range)) {
        result.push(boxNode);
      }
    }
  }

  _(boxNode, direction, boundary);

  return result;
}

function getLocationOrientation(rootOrientation, location) {
  return location.length % 2 === 0 ? (0,_gridview__WEBPACK_IMPORTED_MODULE_4__.orthogonal)(rootOrientation) : rootOrientation;
}

function getDirectionOrientation(direction) {
  return direction === Direction.Up || direction === Direction.Down ? _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_0__.Orientation.VERTICAL : _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_0__.Orientation.HORIZONTAL;
}

function getRelativeLocation(rootOrientation, location, direction) {
  const orientation = getLocationOrientation(rootOrientation, location);
  const directionOrientation = getDirectionOrientation(direction);

  if (orientation === directionOrientation) {
    let [rest, index] = (0,_common_arrays__WEBPACK_IMPORTED_MODULE_1__.tail2)(location);

    if (direction === Direction.Right || direction === Direction.Down) {
      index += 1;
    }

    return [...rest, index];
  } else {
    const index = direction === Direction.Right || direction === Direction.Down ? 1 : 0;
    return [...location, index];
  }
}

function indexInParent(element) {
  const parentElement = element.parentElement;

  if (!parentElement) {
    throw new Error('Invalid grid element');
  }

  let el = parentElement.firstElementChild;
  let index = 0;

  while (el !== element && el !== parentElement.lastElementChild && el) {
    el = el.nextElementSibling;
    index++;
  }

  return index;
}
/**
 * Find the grid location of a specific DOM element by traversing the parent
 * chain and finding each child index on the way.
 *
 * This will break as soon as DOM structures of the Splitview or Gridview change.
 */


function getGridLocation(element) {
  const parentElement = element.parentElement;

  if (!parentElement) {
    throw new Error('Invalid grid element');
  }

  if (/\bmonaco-grid-view\b/.test(parentElement.className)) {
    return [];
  }

  const index = indexInParent(parentElement);
  const ancestor = parentElement.parentElement.parentElement.parentElement.parentElement;
  return [...getGridLocation(ancestor), index];
}

let Sizing;

(function (_Sizing) {
  const Distribute = _Sizing.Distribute = {
    type: 'distribute'
  };
  const Split = _Sizing.Split = {
    type: 'split'
  };

  function Invisible(cachedVisibleSize) {
    return {
      type: 'invisible',
      cachedVisibleSize
    };
  }

  _Sizing.Invisible = Invisible;
})(Sizing || (Sizing = {}));

/**
 * The {@link Grid} exposes a Grid widget in a friendlier API than the underlying
 * {@link GridView} widget. Namely, all mutation operations are addressed by the
 * model elements, rather than indexes.
 *
 * It support the same features as the {@link GridView}.
 */
class Grid extends _common_lifecycle__WEBPACK_IMPORTED_MODULE_2__.Disposable {
  views = new Map();
  /**
   * The orientation of the grid. Matches the orientation of the root
   * {@link SplitView} in the grid's {@link GridLocation} model.
   */

  get orientation() {
    return this.gridview.orientation;
  }

  set orientation(orientation) {
    this.gridview.orientation = orientation;
  }
  /**
   * The width of the grid.
   */


  get width() {
    return this.gridview.width;
  }
  /**
   * The height of the grid.
   */


  get height() {
    return this.gridview.height;
  }
  /**
   * The minimum width of the grid.
   */


  get minimumWidth() {
    return this.gridview.minimumWidth;
  }
  /**
   * The minimum height of the grid.
   */


  get minimumHeight() {
    return this.gridview.minimumHeight;
  }
  /**
   * The maximum width of the grid.
   */


  get maximumWidth() {
    return this.gridview.maximumWidth;
  }
  /**
   * The maximum height of the grid.
   */


  get maximumHeight() {
    return this.gridview.maximumHeight;
  }
  /**
   * Fires whenever a view within the grid changes its size constraints.
   */


  /**
   * A collection of sashes perpendicular to each edge of the grid.
   * Corner sashes will be created for each intersection.
   */
  get boundarySashes() {
    return this.gridview.boundarySashes;
  }

  set boundarySashes(boundarySashes) {
    this.gridview.boundarySashes = boundarySashes;
  }
  /**
   * Enable/disable edge snapping across all grid views.
   */


  set edgeSnapping(edgeSnapping) {
    this.gridview.edgeSnapping = edgeSnapping;
  }
  /**
   * The DOM element for this view.
   */


  get element() {
    return this.gridview.element;
  }

  didLayout = false;
  /**
   * Create a new {@link Grid}. A grid must *always* have a view
   * inside.
   *
   * @param view An initial view for this Grid.
   */

  constructor(view, options = {}) {
    super();

    if (view instanceof _gridview__WEBPACK_IMPORTED_MODULE_4__.GridView) {
      this.gridview = view;
      this.gridview.getViewMap(this.views);
    } else {
      this.gridview = new _gridview__WEBPACK_IMPORTED_MODULE_4__.GridView(options);
    }

    this._register(this.gridview);

    this._register(this.gridview.onDidSashReset(this.onDidSashReset, this));

    if (!(view instanceof _gridview__WEBPACK_IMPORTED_MODULE_4__.GridView)) {
      this._addView(view, 0, [0]);
    }

    this.onDidChange = this.gridview.onDidChange;
    this.onDidScroll = this.gridview.onDidScroll;
  }

  style(styles) {
    this.gridview.style(styles);
  }
  /**
   * Layout the {@link Grid}.
   *
   * Optionally provide a `top` and `left` positions, those will propagate
   * as an origin for positions passed to {@link IView.layout}.
   *
   * @param width The width of the {@link Grid}.
   * @param height The height of the {@link Grid}.
   * @param top Optional, the top location of the {@link Grid}.
   * @param left Optional, the left location of the {@link Grid}.
   */


  layout(width, height, top = 0, left = 0) {
    this.gridview.layout(width, height, top, left);
    this.didLayout = true;
  }
  /**
   * Add a {@link IView view} to this {@link Grid}, based on another reference view.
   *
   * Take this grid as an example:
   *
   * ```
   *  +-----+---------------+
   *  |  A  |      B        |
   *  +-----+---------+-----+
   *  |        C      |     |
   *  +---------------+  D  |
   *  |        E      |     |
   *  +---------------+-----+
   * ```
   *
   * Calling `addView(X, Sizing.Distribute, C, Direction.Right)` will make the following
   * changes:
   *
   * ```
   *  +-----+---------------+
   *  |  A  |      B        |
   *  +-----+-+-------+-----+
   *  |   C   |   X   |     |
   *  +-------+-------+  D  |
   *  |        E      |     |
   *  +---------------+-----+
   * ```
   *
   * Or `addView(X, Sizing.Distribute, D, Direction.Down)`:
   *
   * ```
   *  +-----+---------------+
   *  |  A  |      B        |
   *  +-----+---------+-----+
   *  |        C      |  D  |
   *  +---------------+-----+
   *  |        E      |  X  |
   *  +---------------+-----+
   * ```
   *
   * @param newView The view to add.
   * @param size Either a fixed size, or a dynamic {@link Sizing} strategy.
   * @param referenceView Another view to place this new view next to.
   * @param direction The direction the new view should be placed next to the reference view.
   */


  addView(newView, size, referenceView, direction) {
    if (this.views.has(newView)) {
      throw new Error('Can\'t add same view twice');
    }

    const orientation = getDirectionOrientation(direction);

    if (this.views.size === 1 && this.orientation !== orientation) {
      this.orientation = orientation;
    }

    const referenceLocation = this.getViewLocation(referenceView);
    const location = getRelativeLocation(this.gridview.orientation, referenceLocation, direction);
    let viewSize;

    if (typeof size === 'number') {
      viewSize = size;
    } else if (size.type === 'split') {
      const [, index] = (0,_common_arrays__WEBPACK_IMPORTED_MODULE_1__.tail2)(referenceLocation);
      viewSize = _gridview__WEBPACK_IMPORTED_MODULE_4__.Sizing.Split(index);
    } else if (size.type === 'distribute') {
      viewSize = _gridview__WEBPACK_IMPORTED_MODULE_4__.Sizing.Distribute;
    } else {
      viewSize = size;
    }

    this._addView(newView, viewSize, location);
  }

  addViewAt(newView, size, location) {
    if (this.views.has(newView)) {
      throw new Error('Can\'t add same view twice');
    }

    let viewSize;

    if (typeof size === 'number') {
      viewSize = size;
    } else if (size.type === 'distribute') {
      viewSize = _gridview__WEBPACK_IMPORTED_MODULE_4__.Sizing.Distribute;
    } else {
      viewSize = size;
    }

    this._addView(newView, viewSize, location);
  }

  _addView(newView, size, location) {
    this.views.set(newView, newView.element);
    this.gridview.addView(newView, size, location);
  }
  /**
   * Remove a {@link IView view} from this {@link Grid}.
   *
   * @param view The {@link IView view} to remove.
   * @param sizing Whether to distribute other {@link IView view}'s sizes.
   */


  removeView(view, sizing) {
    if (this.views.size === 1) {
      throw new Error('Can\'t remove last view');
    }

    const location = this.getViewLocation(view);
    this.gridview.removeView(location, sizing && sizing.type === 'distribute' ? _gridview__WEBPACK_IMPORTED_MODULE_4__.Sizing.Distribute : undefined);
    this.views.delete(view);
  }
  /**
   * Move a {@link IView view} to another location in the grid.
   *
   * @remarks See {@link Grid.addView}.
   *
   * @param view The {@link IView view} to move.
   * @param sizing Either a fixed size, or a dynamic {@link Sizing} strategy.
   * @param referenceView Another view to place the view next to.
   * @param direction The direction the view should be placed next to the reference view.
   */


  moveView(view, sizing, referenceView, direction) {
    const sourceLocation = this.getViewLocation(view);
    const [sourceParentLocation, from] = (0,_common_arrays__WEBPACK_IMPORTED_MODULE_1__.tail2)(sourceLocation);
    const referenceLocation = this.getViewLocation(referenceView);
    const targetLocation = getRelativeLocation(this.gridview.orientation, referenceLocation, direction);
    const [targetParentLocation, to] = (0,_common_arrays__WEBPACK_IMPORTED_MODULE_1__.tail2)(targetLocation);

    if ((0,_common_arrays__WEBPACK_IMPORTED_MODULE_1__.equals)(sourceParentLocation, targetParentLocation)) {
      this.gridview.moveView(sourceParentLocation, from, to);
    } else {
      this.removeView(view, typeof sizing === 'number' ? undefined : sizing);
      this.addView(view, sizing, referenceView, direction);
    }
  }
  /**
   * Move a {@link IView view} to another location in the grid.
   *
   * @remarks Internal method, do not use without knowing what you're doing.
   * @remarks See {@link GridView.moveView}.
   *
   * @param view The {@link IView view} to move.
   * @param location The {@link GridLocation location} to insert the view on.
   */


  moveViewTo(view, location) {
    const sourceLocation = this.getViewLocation(view);
    const [sourceParentLocation, from] = (0,_common_arrays__WEBPACK_IMPORTED_MODULE_1__.tail2)(sourceLocation);
    const [targetParentLocation, to] = (0,_common_arrays__WEBPACK_IMPORTED_MODULE_1__.tail2)(location);

    if ((0,_common_arrays__WEBPACK_IMPORTED_MODULE_1__.equals)(sourceParentLocation, targetParentLocation)) {
      this.gridview.moveView(sourceParentLocation, from, to);
    } else {
      const size = this.getViewSize(view);
      const orientation = getLocationOrientation(this.gridview.orientation, sourceLocation);
      const cachedViewSize = this.getViewCachedVisibleSize(view);
      const sizing = typeof cachedViewSize === 'undefined' ? orientation === _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_0__.Orientation.HORIZONTAL ? size.width : size.height : Sizing.Invisible(cachedViewSize);
      this.removeView(view);
      this.addViewAt(view, sizing, location);
    }
  }
  /**
   * Swap two {@link IView views} within the {@link Grid}.
   *
   * @param from One {@link IView view}.
   * @param to Another {@link IView view}.
   */


  swapViews(from, to) {
    const fromLocation = this.getViewLocation(from);
    const toLocation = this.getViewLocation(to);
    return this.gridview.swapViews(fromLocation, toLocation);
  }
  /**
   * Resize a {@link IView view}.
   *
   * @param view The {@link IView view} to resize.
   * @param size The size the view should be.
   */


  resizeView(view, size) {
    const location = this.getViewLocation(view);
    return this.gridview.resizeView(location, size);
  }
  /**
   * Returns whether all other {@link IView views} are at their minimum size.
   *
   * @param view The reference {@link IView view}.
   */


  isViewSizeMaximized(view) {
    const location = this.getViewLocation(view);
    return this.gridview.isViewSizeMaximized(location);
  }
  /**
   * Get the size of a {@link IView view}.
   *
   * @param view The {@link IView view}. Provide `undefined` to get the size
   * of the grid itself.
   */


  getViewSize(view) {
    if (!view) {
      return this.gridview.getViewSize();
    }

    const location = this.getViewLocation(view);
    return this.gridview.getViewSize(location);
  }
  /**
   * Get the cached visible size of a {@link IView view}. This was the size
   * of the view at the moment it last became hidden.
   *
   * @param view The {@link IView view}.
   */


  getViewCachedVisibleSize(view) {
    const location = this.getViewLocation(view);
    return this.gridview.getViewCachedVisibleSize(location);
  }
  /**
   * Maximize the size of a {@link IView view} by collapsing all other views
   * to their minimum sizes.
   *
   * @param view The {@link IView view}.
   */


  maximizeViewSize(view) {
    const location = this.getViewLocation(view);
    this.gridview.maximizeViewSize(location);
  }
  /**
   * Distribute the size among all {@link IView views} within the entire
   * grid or within a single {@link SplitView}.
   */


  distributeViewSizes() {
    this.gridview.distributeViewSizes();
  }
  /**
   * Returns whether a {@link IView view} is visible.
   *
   * @param view The {@link IView view}.
   */


  isViewVisible(view) {
    const location = this.getViewLocation(view);
    return this.gridview.isViewVisible(location);
  }
  /**
   * Set the visibility state of a {@link IView view}.
   *
   * @param view The {@link IView view}.
   */


  setViewVisible(view, visible) {
    const location = this.getViewLocation(view);
    this.gridview.setViewVisible(location, visible);
  }
  /**
   * Returns a descriptor for the entire grid.
   */


  getViews() {
    return this.gridview.getView();
  }
  /**
   * Utility method to return the collection all views which intersect
   * a view's edge.
   *
   * @param view The {@link IView view}.
   * @param direction Which direction edge to be considered.
   * @param wrap Whether the grid wraps around (from right to left, from bottom to top).
   */


  getNeighborViews(view, direction, wrap = false) {
    if (!this.didLayout) {
      throw new Error('Can\'t call getNeighborViews before first layout');
    }

    const location = this.getViewLocation(view);
    const root = this.getViews();
    const node = getGridNode(root, location);
    let boundary = getBoxBoundary(node.box, direction);

    if (wrap) {
      if (direction === Direction.Up && node.box.top === 0) {
        boundary = {
          offset: root.box.top + root.box.height,
          range: boundary.range
        };
      } else if (direction === Direction.Right && node.box.left + node.box.width === root.box.width) {
        boundary = {
          offset: 0,
          range: boundary.range
        };
      } else if (direction === Direction.Down && node.box.top + node.box.height === root.box.height) {
        boundary = {
          offset: 0,
          range: boundary.range
        };
      } else if (direction === Direction.Left && node.box.left === 0) {
        boundary = {
          offset: root.box.left + root.box.width,
          range: boundary.range
        };
      }
    }

    return findAdjacentBoxLeafNodes(root, oppositeDirection(direction), boundary).map(node => node.view);
  }

  getViewLocation(view) {
    const element = this.views.get(view);

    if (!element) {
      throw new Error('View not found');
    }

    return getGridLocation(element);
  }

  onDidSashReset(location) {
    const resizeToPreferredSize = location => {
      const node = this.gridview.getView(location);

      if (isGridBranchNode(node)) {
        return false;
      }

      const direction = getLocationOrientation(this.orientation, location);
      const size = direction === _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_0__.Orientation.HORIZONTAL ? node.view.preferredWidth : node.view.preferredHeight;

      if (typeof size !== 'number') {
        return false;
      }

      const viewSize = direction === _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_0__.Orientation.HORIZONTAL ? {
        width: Math.round(size)
      } : {
        height: Math.round(size)
      };
      this.gridview.resizeView(location, viewSize);
      return true;
    };

    if (resizeToPreferredSize(location)) {
      return;
    }

    const [parentLocation, index] = (0,_common_arrays__WEBPACK_IMPORTED_MODULE_1__.tail2)(location);

    if (resizeToPreferredSize([...parentLocation, index + 1])) {
      return;
    }

    this.gridview.distributeViewSizes(parentLocation);
  }

}

/**
 * A {@link Grid} which can serialize itself.
 */
class SerializableGrid extends Grid {
  static serializeNode(node, orientation) {
    const size = orientation === _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_0__.Orientation.VERTICAL ? node.box.width : node.box.height;

    if (!isGridBranchNode(node)) {
      if (typeof node.cachedVisibleSize === 'number') {
        return {
          type: 'leaf',
          data: node.view.toJSON(),
          size: node.cachedVisibleSize,
          visible: false
        };
      }

      return {
        type: 'leaf',
        data: node.view.toJSON(),
        size
      };
    }

    return {
      type: 'branch',
      data: node.children.map(c => SerializableGrid.serializeNode(c, (0,_gridview__WEBPACK_IMPORTED_MODULE_4__.orthogonal)(orientation))),
      size
    };
  }
  /**
   * Construct a new {@link SerializableGrid} from a JSON object.
   *
   * @param json The JSON object.
   * @param deserializer A deserializer which can revive each view.
   * @returns A new {@link SerializableGrid} instance.
   */


  static deserialize(json, deserializer, options = {}) {
    if (typeof json.orientation !== 'number') {
      throw new Error('Invalid JSON: \'orientation\' property must be a number.');
    } else if (typeof json.width !== 'number') {
      throw new Error('Invalid JSON: \'width\' property must be a number.');
    } else if (typeof json.height !== 'number') {
      throw new Error('Invalid JSON: \'height\' property must be a number.');
    }

    const gridview = _gridview__WEBPACK_IMPORTED_MODULE_4__.GridView.deserialize(json, deserializer, options);
    const result = new SerializableGrid(gridview, options);
    return result;
  }
  /**
   * Construct a new {@link SerializableGrid} from a grid descriptor.
   *
   * @param gridDescriptor A grid descriptor in which leaf nodes point to actual views.
   * @returns A new {@link SerializableGrid} instance.
   */


  static from(gridDescriptor, options = {}) {
    return SerializableGrid.deserialize(createSerializedGrid(gridDescriptor), {
      fromJSON: view => view
    }, options);
  }
  /**
   * Useful information in order to proportionally restore view sizes
   * upon the very first layout call.
   */


  initialLayoutContext = true;
  /**
   * Serialize this grid into a JSON object.
   */

  serialize() {
    return {
      root: SerializableGrid.serializeNode(this.getViews(), this.orientation),
      orientation: this.orientation,
      width: this.width,
      height: this.height
    };
  }

  layout(width, height, top = 0, left = 0) {
    super.layout(width, height, top, left);

    if (this.initialLayoutContext) {
      this.initialLayoutContext = false;
      this.gridview.trySet2x2();
    }
  }

}

function isGridBranchNodeDescriptor(nodeDescriptor) {
  return !!nodeDescriptor.groups;
}

function sanitizeGridNodeDescriptor(nodeDescriptor, rootNode) {
  if (!rootNode && nodeDescriptor.groups && nodeDescriptor.groups.length <= 1) {
    nodeDescriptor.groups = undefined;
  }

  if (!isGridBranchNodeDescriptor(nodeDescriptor)) {
    return;
  }

  let totalDefinedSize = 0;
  let totalDefinedSizeCount = 0;

  for (const child of nodeDescriptor.groups) {
    sanitizeGridNodeDescriptor(child, false);

    if (child.size) {
      totalDefinedSize += child.size;
      totalDefinedSizeCount++;
    }
  }

  const totalUndefinedSize = totalDefinedSizeCount > 0 ? totalDefinedSize : 1;
  const totalUndefinedSizeCount = nodeDescriptor.groups.length - totalDefinedSizeCount;
  const eachUndefinedSize = totalUndefinedSize / totalUndefinedSizeCount;

  for (const child of nodeDescriptor.groups) {
    if (!child.size) {
      child.size = eachUndefinedSize;
    }
  }
}

function createSerializedNode(nodeDescriptor) {
  if (isGridBranchNodeDescriptor(nodeDescriptor)) {
    return {
      type: 'branch',
      data: nodeDescriptor.groups.map(c => createSerializedNode(c)),
      size: nodeDescriptor.size
    };
  } else {
    return {
      type: 'leaf',
      data: nodeDescriptor.data,
      size: nodeDescriptor.size
    };
  }
}

function getDimensions(node, orientation) {
  if (node.type === 'branch') {
    const childrenDimensions = node.data.map(c => getDimensions(c, (0,_gridview__WEBPACK_IMPORTED_MODULE_4__.orthogonal)(orientation)));

    if (orientation === _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_0__.Orientation.VERTICAL) {
      const width = node.size || (childrenDimensions.length === 0 ? undefined : Math.max(...childrenDimensions.map(d => d.width || 0)));
      const height = childrenDimensions.length === 0 ? undefined : childrenDimensions.reduce((r, d) => r + (d.height || 0), 0);
      return {
        width,
        height
      };
    } else {
      const width = childrenDimensions.length === 0 ? undefined : childrenDimensions.reduce((r, d) => r + (d.width || 0), 0);
      const height = node.size || (childrenDimensions.length === 0 ? undefined : Math.max(...childrenDimensions.map(d => d.height || 0)));
      return {
        width,
        height
      };
    }
  } else {
    const width = orientation === _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_0__.Orientation.VERTICAL ? node.size : undefined;
    const height = orientation === _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_0__.Orientation.VERTICAL ? undefined : node.size;
    return {
      width,
      height
    };
  }
}
/**
 * Creates a new JSON object from a {@link GridDescriptor}, which can
 * be deserialized by {@link SerializableGrid.deserialize}.
 */


function createSerializedGrid(gridDescriptor) {
  sanitizeGridNodeDescriptor(gridDescriptor, true);
  const root = createSerializedNode(gridDescriptor);
  const {
    width,
    height
  } = getDimensions(root, gridDescriptor.orientation);
  return {
    root,
    orientation: gridDescriptor.orientation,
    width: width || 1,
    height: height || 1
  };
}

/***/ }),
/* 111 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),
/* 112 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Orientation": () => (/* reexport safe */ _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_1__.Orientation),
/* harmony export */   "LayoutPriority": () => (/* reexport safe */ _browser_ui_splitview_splitview__WEBPACK_IMPORTED_MODULE_2__.LayoutPriority),
/* harmony export */   "Sizing": () => (/* reexport safe */ _browser_ui_splitview_splitview__WEBPACK_IMPORTED_MODULE_2__.Sizing),
/* harmony export */   "orthogonal": () => (/* binding */ orthogonal),
/* harmony export */   "isGridBranchNode": () => (/* binding */ isGridBranchNode),
/* harmony export */   "GridView": () => (/* binding */ GridView)
/* harmony export */ });
/* harmony import */ var _browser_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(61);
/* harmony import */ var _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(89);
/* harmony import */ var _browser_ui_splitview_splitview__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(93);
/* harmony import */ var _common_arrays__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(87);
/* harmony import */ var _common_color__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(91);
/* harmony import */ var _common_event__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(51);
/* harmony import */ var _common_lifecycle__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(54);
/* harmony import */ var _common_numbers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(107);
/* harmony import */ var _common_types__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(79);
/* harmony import */ var _gridview_css__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(111);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/












const defaultStyles = {
  separatorBorder: _common_color__WEBPACK_IMPORTED_MODULE_4__.Color.transparent
};
function orthogonal(orientation) {
  return orientation === _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_1__.Orientation.VERTICAL ? _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_1__.Orientation.HORIZONTAL : _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_1__.Orientation.VERTICAL;
}
function isGridBranchNode(node) {
  return !!node.children;
}

class LayoutController {
  constructor(isLayoutEnabled) {
    this.isLayoutEnabled = isLayoutEnabled;
  }

}

function toAbsoluteBoundarySashes(sashes, orientation) {
  if (orientation === _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_1__.Orientation.HORIZONTAL) {
    return {
      left: sashes.start,
      right: sashes.end,
      top: sashes.orthogonalStart,
      bottom: sashes.orthogonalEnd
    };
  } else {
    return {
      top: sashes.start,
      bottom: sashes.end,
      left: sashes.orthogonalStart,
      right: sashes.orthogonalEnd
    };
  }
}

function fromAbsoluteBoundarySashes(sashes, orientation) {
  if (orientation === _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_1__.Orientation.HORIZONTAL) {
    return {
      start: sashes.left,
      end: sashes.right,
      orthogonalStart: sashes.top,
      orthogonalEnd: sashes.bottom
    };
  } else {
    return {
      start: sashes.top,
      end: sashes.bottom,
      orthogonalStart: sashes.left,
      orthogonalEnd: sashes.right
    };
  }
}

function validateIndex(index, numChildren) {
  if (Math.abs(index) > numChildren) {
    throw new Error('Invalid index');
  }

  return (0,_common_numbers__WEBPACK_IMPORTED_MODULE_7__.rot)(index, numChildren + 1);
}

class BranchNode {
  children = [];

  get size() {
    return this._size;
  }

  get orthogonalSize() {
    return this._orthogonalSize;
  }

  absoluteOffset = 0;
  absoluteOrthogonalOffset = 0;
  absoluteOrthogonalSize = 0;

  get styles() {
    return this._styles;
  }

  get width() {
    return this.orientation === _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_1__.Orientation.HORIZONTAL ? this.size : this.orthogonalSize;
  }

  get height() {
    return this.orientation === _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_1__.Orientation.HORIZONTAL ? this.orthogonalSize : this.size;
  }

  get top() {
    return this.orientation === _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_1__.Orientation.HORIZONTAL ? this.absoluteOffset : this.absoluteOrthogonalOffset;
  }

  get left() {
    return this.orientation === _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_1__.Orientation.HORIZONTAL ? this.absoluteOrthogonalOffset : this.absoluteOffset;
  }

  get minimumSize() {
    return this.children.length === 0 ? 0 : Math.max(...this.children.map(c => c.minimumOrthogonalSize));
  }

  get maximumSize() {
    return Math.min(...this.children.map(c => c.maximumOrthogonalSize));
  }

  get priority() {
    if (this.children.length === 0) {
      return _browser_ui_splitview_splitview__WEBPACK_IMPORTED_MODULE_2__.LayoutPriority.Normal;
    }

    const priorities = this.children.map(c => typeof c.priority === 'undefined' ? _browser_ui_splitview_splitview__WEBPACK_IMPORTED_MODULE_2__.LayoutPriority.Normal : c.priority);

    if (priorities.some(p => p === _browser_ui_splitview_splitview__WEBPACK_IMPORTED_MODULE_2__.LayoutPriority.High)) {
      return _browser_ui_splitview_splitview__WEBPACK_IMPORTED_MODULE_2__.LayoutPriority.High;
    } else if (priorities.some(p => p === _browser_ui_splitview_splitview__WEBPACK_IMPORTED_MODULE_2__.LayoutPriority.Low)) {
      return _browser_ui_splitview_splitview__WEBPACK_IMPORTED_MODULE_2__.LayoutPriority.Low;
    }

    return _browser_ui_splitview_splitview__WEBPACK_IMPORTED_MODULE_2__.LayoutPriority.Normal;
  }

  get minimumOrthogonalSize() {
    return this.splitview.minimumSize;
  }

  get maximumOrthogonalSize() {
    return this.splitview.maximumSize;
  }

  get minimumWidth() {
    return this.orientation === _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_1__.Orientation.HORIZONTAL ? this.minimumOrthogonalSize : this.minimumSize;
  }

  get minimumHeight() {
    return this.orientation === _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_1__.Orientation.HORIZONTAL ? this.minimumSize : this.minimumOrthogonalSize;
  }

  get maximumWidth() {
    return this.orientation === _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_1__.Orientation.HORIZONTAL ? this.maximumOrthogonalSize : this.maximumSize;
  }

  get maximumHeight() {
    return this.orientation === _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_1__.Orientation.HORIZONTAL ? this.maximumSize : this.maximumOrthogonalSize;
  }

  _onDidChange = new _common_event__WEBPACK_IMPORTED_MODULE_5__.Emitter();
  onDidChange = this._onDidChange.event;
  _onDidScroll = new _common_event__WEBPACK_IMPORTED_MODULE_5__.Emitter();
  onDidScrollDisposable = _common_lifecycle__WEBPACK_IMPORTED_MODULE_6__.Disposable.None;
  onDidScroll = this._onDidScroll.event;
  childrenChangeDisposable = _common_lifecycle__WEBPACK_IMPORTED_MODULE_6__.Disposable.None;
  _onDidSashReset = new _common_event__WEBPACK_IMPORTED_MODULE_5__.Emitter();
  onDidSashReset = this._onDidSashReset.event;
  splitviewSashResetDisposable = _common_lifecycle__WEBPACK_IMPORTED_MODULE_6__.Disposable.None;
  childrenSashResetDisposable = _common_lifecycle__WEBPACK_IMPORTED_MODULE_6__.Disposable.None;
  _boundarySashes = {};

  get boundarySashes() {
    return this._boundarySashes;
  }

  set boundarySashes(boundarySashes) {
    this._boundarySashes = boundarySashes;
    this.splitview.orthogonalStartSash = boundarySashes.orthogonalStart;
    this.splitview.orthogonalEndSash = boundarySashes.orthogonalEnd;

    for (let index = 0; index < this.children.length; index++) {
      const child = this.children[index];
      const first = index === 0;
      const last = index === this.children.length - 1;
      child.boundarySashes = {
        start: boundarySashes.orthogonalStart,
        end: boundarySashes.orthogonalEnd,
        orthogonalStart: first ? boundarySashes.start : child.boundarySashes.orthogonalStart,
        orthogonalEnd: last ? boundarySashes.end : child.boundarySashes.orthogonalEnd
      };
    }
  }

  _edgeSnapping = false;

  get edgeSnapping() {
    return this._edgeSnapping;
  }

  set edgeSnapping(edgeSnapping) {
    if (this._edgeSnapping === edgeSnapping) {
      return;
    }

    this._edgeSnapping = edgeSnapping;

    for (const child of this.children) {
      if (child instanceof BranchNode) {
        child.edgeSnapping = edgeSnapping;
      }
    }

    this.updateSplitviewEdgeSnappingEnablement();
  }

  constructor(orientation, layoutController, styles, proportionalLayout, size = 0, orthogonalSize = 0, edgeSnapping = false, childDescriptors) {
    this.orientation = orientation;
    this.layoutController = layoutController;
    this.proportionalLayout = proportionalLayout;
    this._styles = styles;
    this._size = size;
    this._orthogonalSize = orthogonalSize;
    this.element = (0,_browser_dom__WEBPACK_IMPORTED_MODULE_0__.$)('.monaco-grid-branch-node');

    if (!childDescriptors) {
      // Normal behavior, we have no children yet, just set up the splitview
      this.splitview = new _browser_ui_splitview_splitview__WEBPACK_IMPORTED_MODULE_2__.SplitView(this.element, {
        orientation,
        styles,
        proportionalLayout
      });
      this.splitview.layout(size, {
        orthogonalSize,
        absoluteOffset: 0,
        absoluteOrthogonalOffset: 0,
        absoluteSize: size,
        absoluteOrthogonalSize: orthogonalSize
      });
    } else {
      // Reconstruction behavior, we want to reconstruct a splitview
      const descriptor = {
        views: childDescriptors.map(childDescriptor => {
          return {
            view: childDescriptor.node,
            size: childDescriptor.node.size,
            visible: childDescriptor.node instanceof LeafNode && childDescriptor.visible !== undefined ? childDescriptor.visible : true
          };
        }),
        size: this.orthogonalSize
      };
      const options = {
        proportionalLayout,
        orientation,
        styles
      };
      this.children = childDescriptors.map(c => c.node);
      this.splitview = new _browser_ui_splitview_splitview__WEBPACK_IMPORTED_MODULE_2__.SplitView(this.element, { ...options,
        descriptor
      });
      this.children.forEach((node, index) => {
        const first = index === 0;
        const last = index === this.children.length;
        node.boundarySashes = {
          start: this.boundarySashes.orthogonalStart,
          end: this.boundarySashes.orthogonalEnd,
          orthogonalStart: first ? this.boundarySashes.start : this.splitview.sashes[index - 1],
          orthogonalEnd: last ? this.boundarySashes.end : this.splitview.sashes[index]
        };
      });
    }

    const onDidSashReset = _common_event__WEBPACK_IMPORTED_MODULE_5__.Event.map(this.splitview.onDidSashReset, i => [i]);
    this.splitviewSashResetDisposable = onDidSashReset(this._onDidSashReset.fire, this._onDidSashReset);
    this.updateChildrenEvents();
  }

  style(styles) {
    this._styles = styles;
    this.splitview.style(styles);

    for (const child of this.children) {
      if (child instanceof BranchNode) {
        child.style(styles);
      }
    }
  }

  layout(size, offset, ctx) {
    if (!this.layoutController.isLayoutEnabled) {
      return;
    }

    if (typeof ctx === 'undefined') {
      throw new Error('Invalid state');
    } // branch nodes should flip the normal/orthogonal directions


    this._size = ctx.orthogonalSize;
    this._orthogonalSize = size;
    this.absoluteOffset = ctx.absoluteOffset + offset;
    this.absoluteOrthogonalOffset = ctx.absoluteOrthogonalOffset;
    this.absoluteOrthogonalSize = ctx.absoluteOrthogonalSize;
    this.splitview.layout(ctx.orthogonalSize, {
      orthogonalSize: size,
      absoluteOffset: this.absoluteOrthogonalOffset,
      absoluteOrthogonalOffset: this.absoluteOffset,
      absoluteSize: ctx.absoluteOrthogonalSize,
      absoluteOrthogonalSize: ctx.absoluteSize
    });
    this.updateSplitviewEdgeSnappingEnablement();
  }

  setVisible(visible) {
    for (const child of this.children) {
      child.setVisible(visible);
    }
  }

  addChild(node, size, index, skipLayout) {
    index = validateIndex(index, this.children.length);
    this.splitview.addView(node, size, index, skipLayout);

    this._addChild(node, index);

    this.onDidChildrenChange();
  }

  _addChild(node, index) {
    const first = index === 0;
    const last = index === this.children.length;
    this.children.splice(index, 0, node);
    node.boundarySashes = {
      start: this.boundarySashes.orthogonalStart,
      end: this.boundarySashes.orthogonalEnd,
      orthogonalStart: first ? this.boundarySashes.start : this.splitview.sashes[index - 1],
      orthogonalEnd: last ? this.boundarySashes.end : this.splitview.sashes[index]
    };

    if (!first) {
      this.children[index - 1].boundarySashes = { ...this.children[index - 1].boundarySashes,
        orthogonalEnd: this.splitview.sashes[index - 1]
      };
    }

    if (!last) {
      this.children[index + 1].boundarySashes = { ...this.children[index + 1].boundarySashes,
        orthogonalStart: this.splitview.sashes[index]
      };
    }
  }

  removeChild(index, sizing) {
    index = validateIndex(index, this.children.length);
    this.splitview.removeView(index, sizing);

    this._removeChild(index);

    this.onDidChildrenChange();
  }

  _removeChild(index) {
    const first = index === 0;
    const last = index === this.children.length - 1;
    const [child] = this.children.splice(index, 1);

    if (!first) {
      this.children[index - 1].boundarySashes = { ...this.children[index - 1].boundarySashes,
        orthogonalEnd: this.splitview.sashes[index - 1]
      };
    }

    if (!last) {
      // [0,1,2,3] (2) => [0,1,3]
      this.children[index].boundarySashes = { ...this.children[index].boundarySashes,
        orthogonalStart: this.splitview.sashes[Math.max(index - 1, 0)]
      };
    }

    return child;
  }

  moveChild(from, to) {
    from = validateIndex(from, this.children.length);
    to = validateIndex(to, this.children.length);

    if (from === to) {
      return;
    }

    if (from < to) {
      to--;
    }

    this.splitview.moveView(from, to);

    const child = this._removeChild(from);

    this._addChild(child, to);

    this.onDidChildrenChange();
  }

  swapChildren(from, to) {
    from = validateIndex(from, this.children.length);
    to = validateIndex(to, this.children.length);

    if (from === to) {
      return;
    }

    this.splitview.swapViews(from, to); // swap boundary sashes

    [this.children[from].boundarySashes, this.children[to].boundarySashes] = [this.children[from].boundarySashes, this.children[to].boundarySashes]; // swap children

    [this.children[from], this.children[to]] = [this.children[to], this.children[from]];
    this.onDidChildrenChange();
  }

  resizeChild(index, size) {
    index = validateIndex(index, this.children.length);
    this.splitview.resizeView(index, size);
  }

  isChildSizeMaximized(index) {
    return this.splitview.isViewSizeMaximized(index);
  }

  distributeViewSizes(recursive = false) {
    this.splitview.distributeViewSizes();

    if (recursive) {
      for (const child of this.children) {
        if (child instanceof BranchNode) {
          child.distributeViewSizes(true);
        }
      }
    }
  }

  getChildSize(index) {
    index = validateIndex(index, this.children.length);
    return this.splitview.getViewSize(index);
  }

  isChildVisible(index) {
    index = validateIndex(index, this.children.length);
    return this.splitview.isViewVisible(index);
  }

  setChildVisible(index, visible) {
    index = validateIndex(index, this.children.length);

    if (this.splitview.isViewVisible(index) === visible) {
      return;
    }

    this.splitview.setViewVisible(index, visible);
  }

  getChildCachedVisibleSize(index) {
    index = validateIndex(index, this.children.length);
    return this.splitview.getViewCachedVisibleSize(index);
  }

  onDidChildrenChange() {
    this.updateChildrenEvents();

    this._onDidChange.fire(undefined);
  }

  updateChildrenEvents() {
    const onDidChildrenChange = _common_event__WEBPACK_IMPORTED_MODULE_5__.Event.map(_common_event__WEBPACK_IMPORTED_MODULE_5__.Event.any(...this.children.map(c => c.onDidChange)), () => undefined);
    this.childrenChangeDisposable.dispose();
    this.childrenChangeDisposable = onDidChildrenChange(this._onDidChange.fire, this._onDidChange);
    const onDidChildrenSashReset = _common_event__WEBPACK_IMPORTED_MODULE_5__.Event.any(...this.children.map((c, i) => _common_event__WEBPACK_IMPORTED_MODULE_5__.Event.map(c.onDidSashReset, location => [i, ...location])));
    this.childrenSashResetDisposable.dispose();
    this.childrenSashResetDisposable = onDidChildrenSashReset(this._onDidSashReset.fire, this._onDidSashReset);
    const onDidScroll = _common_event__WEBPACK_IMPORTED_MODULE_5__.Event.any(_common_event__WEBPACK_IMPORTED_MODULE_5__.Event.signal(this.splitview.onDidScroll), ...this.children.map(c => c.onDidScroll));
    this.onDidScrollDisposable.dispose();
    this.onDidScrollDisposable = onDidScroll(this._onDidScroll.fire, this._onDidScroll);
  }

  trySet2x2(other) {
    if (this.children.length !== 2 || other.children.length !== 2) {
      return _common_lifecycle__WEBPACK_IMPORTED_MODULE_6__.Disposable.None;
    }

    if (this.getChildSize(0) !== other.getChildSize(0)) {
      return _common_lifecycle__WEBPACK_IMPORTED_MODULE_6__.Disposable.None;
    }

    const [firstChild, secondChild] = this.children;
    const [otherFirstChild, otherSecondChild] = other.children;

    if (!(firstChild instanceof LeafNode) || !(secondChild instanceof LeafNode)) {
      return _common_lifecycle__WEBPACK_IMPORTED_MODULE_6__.Disposable.None;
    }

    if (!(otherFirstChild instanceof LeafNode) || !(otherSecondChild instanceof LeafNode)) {
      return _common_lifecycle__WEBPACK_IMPORTED_MODULE_6__.Disposable.None;
    }

    if (this.orientation === _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_1__.Orientation.VERTICAL) {
      secondChild.linkedWidthNode = otherFirstChild.linkedHeightNode = firstChild;
      firstChild.linkedWidthNode = otherSecondChild.linkedHeightNode = secondChild;
      otherSecondChild.linkedWidthNode = firstChild.linkedHeightNode = otherFirstChild;
      otherFirstChild.linkedWidthNode = secondChild.linkedHeightNode = otherSecondChild;
    } else {
      otherFirstChild.linkedWidthNode = secondChild.linkedHeightNode = firstChild;
      otherSecondChild.linkedWidthNode = firstChild.linkedHeightNode = secondChild;
      firstChild.linkedWidthNode = otherSecondChild.linkedHeightNode = otherFirstChild;
      secondChild.linkedWidthNode = otherFirstChild.linkedHeightNode = otherSecondChild;
    }

    const mySash = this.splitview.sashes[0];
    const otherSash = other.splitview.sashes[0];
    mySash.linkedSash = otherSash;
    otherSash.linkedSash = mySash;

    this._onDidChange.fire(undefined);

    other._onDidChange.fire(undefined);

    return (0,_common_lifecycle__WEBPACK_IMPORTED_MODULE_6__.toDisposable)(() => {
      mySash.linkedSash = otherSash.linkedSash = undefined;
      firstChild.linkedHeightNode = firstChild.linkedWidthNode = undefined;
      secondChild.linkedHeightNode = secondChild.linkedWidthNode = undefined;
      otherFirstChild.linkedHeightNode = otherFirstChild.linkedWidthNode = undefined;
      otherSecondChild.linkedHeightNode = otherSecondChild.linkedWidthNode = undefined;
    });
  }

  updateSplitviewEdgeSnappingEnablement() {
    this.splitview.startSnappingEnabled = this._edgeSnapping || this.absoluteOrthogonalOffset > 0;
    this.splitview.endSnappingEnabled = this._edgeSnapping || this.absoluteOrthogonalOffset + this._size < this.absoluteOrthogonalSize;
  }

  dispose() {
    for (const child of this.children) {
      child.dispose();
    }

    this._onDidChange.dispose();

    this._onDidSashReset.dispose();

    this.splitviewSashResetDisposable.dispose();
    this.childrenSashResetDisposable.dispose();
    this.childrenChangeDisposable.dispose();
    this.splitview.dispose();
  }

}
/**
 * Creates a latched event that avoids being fired when the view
 * constraints do not change at all.
 */


function createLatchedOnDidChangeViewEvent(view) {
  const [onDidChangeViewConstraints, onDidSetViewSize] = _common_event__WEBPACK_IMPORTED_MODULE_5__.Event.split(view.onDidChange, _common_types__WEBPACK_IMPORTED_MODULE_8__.isUndefined);
  return _common_event__WEBPACK_IMPORTED_MODULE_5__.Event.any(onDidSetViewSize, _common_event__WEBPACK_IMPORTED_MODULE_5__.Event.map(_common_event__WEBPACK_IMPORTED_MODULE_5__.Event.latch(_common_event__WEBPACK_IMPORTED_MODULE_5__.Event.map(onDidChangeViewConstraints, _ => [view.minimumWidth, view.maximumWidth, view.minimumHeight, view.maximumHeight]), _common_arrays__WEBPACK_IMPORTED_MODULE_3__.equals), _ => undefined));
}

class LeafNode {
  _size = 0;

  get size() {
    return this._size;
  }

  get orthogonalSize() {
    return this._orthogonalSize;
  }

  absoluteOffset = 0;
  absoluteOrthogonalOffset = 0;
  onDidScroll = _common_event__WEBPACK_IMPORTED_MODULE_5__.Event.None;
  onDidSashReset = _common_event__WEBPACK_IMPORTED_MODULE_5__.Event.None;
  _onDidLinkedWidthNodeChange = new _common_event__WEBPACK_IMPORTED_MODULE_5__.Relay();
  _linkedWidthNode = undefined;

  get linkedWidthNode() {
    return this._linkedWidthNode;
  }

  set linkedWidthNode(node) {
    this._onDidLinkedWidthNodeChange.input = node ? node._onDidViewChange : _common_event__WEBPACK_IMPORTED_MODULE_5__.Event.None;
    this._linkedWidthNode = node;

    this._onDidSetLinkedNode.fire(undefined);
  }

  _onDidLinkedHeightNodeChange = new _common_event__WEBPACK_IMPORTED_MODULE_5__.Relay();
  _linkedHeightNode = undefined;

  get linkedHeightNode() {
    return this._linkedHeightNode;
  }

  set linkedHeightNode(node) {
    this._onDidLinkedHeightNodeChange.input = node ? node._onDidViewChange : _common_event__WEBPACK_IMPORTED_MODULE_5__.Event.None;
    this._linkedHeightNode = node;

    this._onDidSetLinkedNode.fire(undefined);
  }

  _onDidSetLinkedNode = new _common_event__WEBPACK_IMPORTED_MODULE_5__.Emitter();
  disposables = new _common_lifecycle__WEBPACK_IMPORTED_MODULE_6__.DisposableStore();

  constructor(view, orientation, layoutController, orthogonalSize, size = 0) {
    this.view = view;
    this.orientation = orientation;
    this.layoutController = layoutController;
    this._orthogonalSize = orthogonalSize;
    this._size = size;
    const onDidChange = createLatchedOnDidChangeViewEvent(view);
    this._onDidViewChange = _common_event__WEBPACK_IMPORTED_MODULE_5__.Event.map(onDidChange, e => e && (this.orientation === _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_1__.Orientation.VERTICAL ? e.width : e.height), this.disposables);
    this.onDidChange = _common_event__WEBPACK_IMPORTED_MODULE_5__.Event.any(this._onDidViewChange, this._onDidSetLinkedNode.event, this._onDidLinkedWidthNodeChange.event, this._onDidLinkedHeightNodeChange.event);
  }

  get width() {
    return this.orientation === _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_1__.Orientation.HORIZONTAL ? this.orthogonalSize : this.size;
  }

  get height() {
    return this.orientation === _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_1__.Orientation.HORIZONTAL ? this.size : this.orthogonalSize;
  }

  get top() {
    return this.orientation === _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_1__.Orientation.HORIZONTAL ? this.absoluteOffset : this.absoluteOrthogonalOffset;
  }

  get left() {
    return this.orientation === _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_1__.Orientation.HORIZONTAL ? this.absoluteOrthogonalOffset : this.absoluteOffset;
  }

  get element() {
    return this.view.element;
  }

  get minimumWidth() {
    return this.linkedWidthNode ? Math.max(this.linkedWidthNode.view.minimumWidth, this.view.minimumWidth) : this.view.minimumWidth;
  }

  get maximumWidth() {
    return this.linkedWidthNode ? Math.min(this.linkedWidthNode.view.maximumWidth, this.view.maximumWidth) : this.view.maximumWidth;
  }

  get minimumHeight() {
    return this.linkedHeightNode ? Math.max(this.linkedHeightNode.view.minimumHeight, this.view.minimumHeight) : this.view.minimumHeight;
  }

  get maximumHeight() {
    return this.linkedHeightNode ? Math.min(this.linkedHeightNode.view.maximumHeight, this.view.maximumHeight) : this.view.maximumHeight;
  }

  get minimumSize() {
    return this.orientation === _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_1__.Orientation.HORIZONTAL ? this.minimumHeight : this.minimumWidth;
  }

  get maximumSize() {
    return this.orientation === _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_1__.Orientation.HORIZONTAL ? this.maximumHeight : this.maximumWidth;
  }

  get priority() {
    return this.view.priority;
  }

  get snap() {
    return this.view.snap;
  }

  get minimumOrthogonalSize() {
    return this.orientation === _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_1__.Orientation.HORIZONTAL ? this.minimumWidth : this.minimumHeight;
  }

  get maximumOrthogonalSize() {
    return this.orientation === _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_1__.Orientation.HORIZONTAL ? this.maximumWidth : this.maximumHeight;
  }

  _boundarySashes = {};

  get boundarySashes() {
    return this._boundarySashes;
  }

  set boundarySashes(boundarySashes) {
    this._boundarySashes = boundarySashes;
    this.view.setBoundarySashes?.(toAbsoluteBoundarySashes(boundarySashes, this.orientation));
  }

  layout(size, offset, ctx) {
    if (!this.layoutController.isLayoutEnabled) {
      return;
    }

    if (typeof ctx === 'undefined') {
      throw new Error('Invalid state');
    }

    this._size = size;
    this._orthogonalSize = ctx.orthogonalSize;
    this.absoluteOffset = ctx.absoluteOffset + offset;
    this.absoluteOrthogonalOffset = ctx.absoluteOrthogonalOffset;

    this._layout(this.width, this.height, this.top, this.left);
  }

  cachedWidth = 0;
  cachedHeight = 0;
  cachedTop = 0;
  cachedLeft = 0;

  _layout(width, height, top, left) {
    if (this.cachedWidth === width && this.cachedHeight === height && this.cachedTop === top && this.cachedLeft === left) {
      return;
    }

    this.cachedWidth = width;
    this.cachedHeight = height;
    this.cachedTop = top;
    this.cachedLeft = left;
    this.view.layout(width, height, top, left);
  }

  setVisible(visible) {
    this.view.setVisible?.(visible);
  }

  dispose() {
    this.disposables.dispose();
  }

}

function flipNode(node, size, orthogonalSize) {
  if (node instanceof BranchNode) {
    const result = new BranchNode(orthogonal(node.orientation), node.layoutController, node.styles, node.proportionalLayout, size, orthogonalSize, node.edgeSnapping);
    let totalSize = 0;

    for (let i = node.children.length - 1; i >= 0; i--) {
      const child = node.children[i];
      const childSize = child instanceof BranchNode ? child.orthogonalSize : child.size;
      let newSize = node.size === 0 ? 0 : Math.round(size * childSize / node.size);
      totalSize += newSize; // The last view to add should adjust to rounding errors

      if (i === 0) {
        newSize += size - totalSize;
      }

      result.addChild(flipNode(child, orthogonalSize, newSize), newSize, 0, true);
    }

    return result;
  } else {
    return new LeafNode(node.view, orthogonal(node.orientation), node.layoutController, orthogonalSize);
  }
}
/**
 * The location of a {@link IView view} within a {@link GridView}.
 *
 * A GridView is a tree composition of multiple {@link SplitView} instances, orthogonal
 * between one another. Here's an example:
 *
 * ```
 *  +-----+---------------+
 *  |  A  |      B        |
 *  +-----+---------+-----+
 *  |        C      |     |
 *  +---------------+  D  |
 *  |        E      |     |
 *  +---------------+-----+
 * ```
 *
 * The above grid's tree structure is:
 *
 * ```
 *  Vertical SplitView
 *  +-Horizontal SplitView
 *  | +-A
 *  | +-B
 *  +- Horizontal SplitView
 *    +-Vertical SplitView
 *    | +-C
 *    | +-E
 *    +-D
 * ```
 *
 * So, {@link IView views} within a {@link GridView} can be referenced by
 * a sequence of indexes, each index referencing each SplitView. Here are
 * each view's locations, from the example above:
 *
 * - `A`: `[0,0]`
 * - `B`: `[0,1]`
 * - `C`: `[1,0,0]`
 * - `D`: `[1,1]`
 * - `E`: `[1,0,1]`
 */


/**
 * The {@link GridView} is the UI component which implements a two dimensional
 * flex-like layout algorithm for a collection of {@link IView} instances, which
 * are mostly HTMLElement instances with size constraints. A {@link GridView} is a
 * tree composition of multiple {@link SplitView} instances, orthogonal between
 * one another. It will respect view's size contraints, just like the SplitView.
 *
 * It has a low-level index based API, allowing for fine grain performant operations.
 * Look into the {@link Grid} widget for a higher-level API.
 *
 * Features:
 * - flex-like layout algorithm
 * - snap support
 * - corner sash support
 * - Alt key modifier behavior, macOS style
 * - layout (de)serialization
 */
class GridView {
  /**
   * The DOM element for this view.
   */
  onDidSashResetRelay = new _common_event__WEBPACK_IMPORTED_MODULE_5__.Relay();
  _onDidScroll = new _common_event__WEBPACK_IMPORTED_MODULE_5__.Relay();
  _onDidChange = new _common_event__WEBPACK_IMPORTED_MODULE_5__.Relay();
  _boundarySashes = {};
  /**
   * The layout controller makes sure layout only propagates
   * to the views after the very first call to {@link GridView.layout}.
   */

  disposable2x2 = _common_lifecycle__WEBPACK_IMPORTED_MODULE_6__.Disposable.None;

  get root() {
    return this._root;
  }

  set root(root) {
    const oldRoot = this._root;

    if (oldRoot) {
      this.element.removeChild(oldRoot.element);
      oldRoot.dispose();
    }

    this._root = root;
    this.element.appendChild(root.element);
    this.onDidSashResetRelay.input = root.onDidSashReset;
    this._onDidChange.input = _common_event__WEBPACK_IMPORTED_MODULE_5__.Event.map(root.onDidChange, () => undefined); // TODO

    this._onDidScroll.input = root.onDidScroll;
  }
  /**
   * Fires whenever the user double clicks a {@link Sash sash}.
   */


  onDidSashReset = this.onDidSashResetRelay.event;
  /**
   * Fires whenever the user scrolls a {@link SplitView} within
   * the grid.
   */

  onDidScroll = this._onDidScroll.event;
  /**
   * Fires whenever a view within the grid changes its size constraints.
   */

  onDidChange = this._onDidChange.event;
  /**
   * The width of the grid.
   */

  get width() {
    return this.root.width;
  }
  /**
   * The height of the grid.
   */


  get height() {
    return this.root.height;
  }
  /**
   * The minimum width of the grid.
   */


  get minimumWidth() {
    return this.root.minimumWidth;
  }
  /**
   * The minimum height of the grid.
   */


  get minimumHeight() {
    return this.root.minimumHeight;
  }
  /**
   * The maximum width of the grid.
   */


  get maximumWidth() {
    return this.root.maximumHeight;
  }
  /**
   * The maximum height of the grid.
   */


  get maximumHeight() {
    return this.root.maximumHeight;
  }

  get orientation() {
    return this._root.orientation;
  }

  get boundarySashes() {
    return this._boundarySashes;
  }
  /**
   * The orientation of the grid. Matches the orientation of the root
   * {@link SplitView} in the grid's tree model.
   */


  set orientation(orientation) {
    if (this._root.orientation === orientation) {
      return;
    }

    const {
      size,
      orthogonalSize
    } = this._root;
    this.root = flipNode(this._root, orthogonalSize, size);
    this.root.layout(size, 0, {
      orthogonalSize,
      absoluteOffset: 0,
      absoluteOrthogonalOffset: 0,
      absoluteSize: size,
      absoluteOrthogonalSize: orthogonalSize
    });
    this.boundarySashes = this.boundarySashes;
  }
  /**
   * A collection of sashes perpendicular to each edge of the grid.
   * Corner sashes will be created for each intersection.
   */


  set boundarySashes(boundarySashes) {
    this._boundarySashes = boundarySashes;
    this.root.boundarySashes = fromAbsoluteBoundarySashes(boundarySashes, this.orientation);
  }
  /**
   * Enable/disable edge snapping across all grid views.
   */


  set edgeSnapping(edgeSnapping) {
    this.root.edgeSnapping = edgeSnapping;
  }
  /**
   * Create a new {@link GridView} instance.
   *
   * @remarks It's the caller's responsibility to append the
   * {@link GridView.element} to the page's DOM.
   */


  constructor(options = {}) {
    this.element = (0,_browser_dom__WEBPACK_IMPORTED_MODULE_0__.$)('.monaco-grid-view');
    this.styles = options.styles || defaultStyles;
    this.proportionalLayout = typeof options.proportionalLayout !== 'undefined' ? !!options.proportionalLayout : true;
    this.layoutController = new LayoutController(false);
    this.root = new BranchNode(_browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_1__.Orientation.VERTICAL, this.layoutController, this.styles, this.proportionalLayout);
  }

  style(styles) {
    this.styles = styles;
    this.root.style(styles);
  }
  /**
   * Layout the {@link GridView}.
   *
   * Optionally provide a `top` and `left` positions, those will propagate
   * as an origin for positions passed to {@link IView.layout}.
   *
   * @param width The width of the {@link GridView}.
   * @param height The height of the {@link GridView}.
   * @param top Optional, the top location of the {@link GridView}.
   * @param left Optional, the left location of the {@link GridView}.
   */


  layout(width, height, top = 0, left = 0) {
    this.layoutController.isLayoutEnabled = true;
    const [size, orthogonalSize, offset, orthogonalOffset] = this.root.orientation === _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_1__.Orientation.HORIZONTAL ? [height, width, top, left] : [width, height, left, top];
    this.root.layout(size, offset, {
      orthogonalSize,
      absoluteOffset: offset,
      absoluteOrthogonalOffset: orthogonalOffset,
      absoluteSize: size,
      absoluteOrthogonalSize: orthogonalSize
    });
  }
  /**
   * Add a {@link IView view} to this {@link GridView}.
   *
   * @param view The view to add.
   * @param size Either a fixed size, or a dynamic {@link Sizing} strategy.
   * @param location The {@link GridLocation location} to insert the view on.
   */


  addView(view, size, location) {
    this.disposable2x2.dispose();
    this.disposable2x2 = _common_lifecycle__WEBPACK_IMPORTED_MODULE_6__.Disposable.None;
    const [rest, index] = (0,_common_arrays__WEBPACK_IMPORTED_MODULE_3__.tail2)(location);
    const [pathToParent, parent] = this.getNode(rest);

    if (parent instanceof BranchNode) {
      const node = new LeafNode(view, orthogonal(parent.orientation), this.layoutController, parent.orthogonalSize);
      parent.addChild(node, size, index);
    } else {
      const [, grandParent] = (0,_common_arrays__WEBPACK_IMPORTED_MODULE_3__.tail2)(pathToParent);
      const [, parentIndex] = (0,_common_arrays__WEBPACK_IMPORTED_MODULE_3__.tail2)(rest);
      let newSiblingSize = 0;
      const newSiblingCachedVisibleSize = grandParent.getChildCachedVisibleSize(parentIndex);

      if (typeof newSiblingCachedVisibleSize === 'number') {
        newSiblingSize = _browser_ui_splitview_splitview__WEBPACK_IMPORTED_MODULE_2__.Sizing.Invisible(newSiblingCachedVisibleSize);
      }

      grandParent.removeChild(parentIndex);
      const newParent = new BranchNode(parent.orientation, parent.layoutController, this.styles, this.proportionalLayout, parent.size, parent.orthogonalSize, grandParent.edgeSnapping);
      grandParent.addChild(newParent, parent.size, parentIndex);
      const newSibling = new LeafNode(parent.view, grandParent.orientation, this.layoutController, parent.size);
      newParent.addChild(newSibling, newSiblingSize, 0);

      if (typeof size !== 'number' && size.type === 'split') {
        size = _browser_ui_splitview_splitview__WEBPACK_IMPORTED_MODULE_2__.Sizing.Split(0);
      }

      const node = new LeafNode(view, grandParent.orientation, this.layoutController, parent.size);
      newParent.addChild(node, size, index);
    }

    this.trySet2x2();
  }
  /**
   * Remove a {@link IView view} from this {@link GridView}.
   *
   * @param location The {@link GridLocation location} of the {@link IView view}.
   * @param sizing Whether to distribute other {@link IView view}'s sizes.
   */


  removeView(location, sizing) {
    this.disposable2x2.dispose();
    this.disposable2x2 = _common_lifecycle__WEBPACK_IMPORTED_MODULE_6__.Disposable.None;
    const [rest, index] = (0,_common_arrays__WEBPACK_IMPORTED_MODULE_3__.tail2)(location);
    const [pathToParent, parent] = this.getNode(rest);

    if (!(parent instanceof BranchNode)) {
      throw new Error('Invalid location');
    }

    const node = parent.children[index];

    if (!(node instanceof LeafNode)) {
      throw new Error('Invalid location');
    }

    parent.removeChild(index, sizing);

    if (parent.children.length === 0) {
      throw new Error('Invalid grid state');
    }

    if (parent.children.length > 1) {
      this.trySet2x2();
      return node.view;
    }

    if (pathToParent.length === 0) {
      // parent is root
      const sibling = parent.children[0];

      if (sibling instanceof LeafNode) {
        return node.view;
      } // we must promote sibling to be the new root


      parent.removeChild(0);
      this.root = sibling;
      this.boundarySashes = this.boundarySashes;
      this.trySet2x2();
      return node.view;
    }

    const [, grandParent] = (0,_common_arrays__WEBPACK_IMPORTED_MODULE_3__.tail2)(pathToParent);
    const [, parentIndex] = (0,_common_arrays__WEBPACK_IMPORTED_MODULE_3__.tail2)(rest);
    const sibling = parent.children[0];
    const isSiblingVisible = parent.isChildVisible(0);
    parent.removeChild(0);
    const sizes = grandParent.children.map((_, i) => grandParent.getChildSize(i));
    grandParent.removeChild(parentIndex, sizing);

    if (sibling instanceof BranchNode) {
      sizes.splice(parentIndex, 1, ...sibling.children.map(c => c.size));

      for (let i = 0; i < sibling.children.length; i++) {
        const child = sibling.children[i];
        grandParent.addChild(child, child.size, parentIndex + i);
      }
    } else {
      const newSibling = new LeafNode(sibling.view, orthogonal(sibling.orientation), this.layoutController, sibling.size);
      const sizing = isSiblingVisible ? sibling.orthogonalSize : _browser_ui_splitview_splitview__WEBPACK_IMPORTED_MODULE_2__.Sizing.Invisible(sibling.orthogonalSize);
      grandParent.addChild(newSibling, sizing, parentIndex);
    }

    for (let i = 0; i < sizes.length; i++) {
      grandParent.resizeChild(i, sizes[i]);
    }

    this.trySet2x2();
    return node.view;
  }
  /**
   * Move a {@link IView view} within its parent.
   *
   * @param parentLocation The {@link GridLocation location} of the {@link IView view}'s parent.
   * @param from The index of the {@link IView view} to move.
   * @param to The index where the {@link IView view} should move to.
   */


  moveView(parentLocation, from, to) {
    const [, parent] = this.getNode(parentLocation);

    if (!(parent instanceof BranchNode)) {
      throw new Error('Invalid location');
    }

    parent.moveChild(from, to);
    this.trySet2x2();
  }
  /**
   * Swap two {@link IView views} within the {@link GridView}.
   *
   * @param from The {@link GridLocation location} of one view.
   * @param to The {@link GridLocation location} of another view.
   */


  swapViews(from, to) {
    const [fromRest, fromIndex] = (0,_common_arrays__WEBPACK_IMPORTED_MODULE_3__.tail2)(from);
    const [, fromParent] = this.getNode(fromRest);

    if (!(fromParent instanceof BranchNode)) {
      throw new Error('Invalid from location');
    }

    const fromSize = fromParent.getChildSize(fromIndex);
    const fromNode = fromParent.children[fromIndex];

    if (!(fromNode instanceof LeafNode)) {
      throw new Error('Invalid from location');
    }

    const [toRest, toIndex] = (0,_common_arrays__WEBPACK_IMPORTED_MODULE_3__.tail2)(to);
    const [, toParent] = this.getNode(toRest);

    if (!(toParent instanceof BranchNode)) {
      throw new Error('Invalid to location');
    }

    const toSize = toParent.getChildSize(toIndex);
    const toNode = toParent.children[toIndex];

    if (!(toNode instanceof LeafNode)) {
      throw new Error('Invalid to location');
    }

    if (fromParent === toParent) {
      fromParent.swapChildren(fromIndex, toIndex);
    } else {
      fromParent.removeChild(fromIndex);
      toParent.removeChild(toIndex);
      fromParent.addChild(toNode, fromSize, fromIndex);
      toParent.addChild(fromNode, toSize, toIndex);
    }

    this.trySet2x2();
  }
  /**
   * Resize a {@link IView view}.
   *
   * @param location The {@link GridLocation location} of the view.
   * @param size The size the view should be. Optionally provide a single dimension.
   */


  resizeView(location, size) {
    const [rest, index] = (0,_common_arrays__WEBPACK_IMPORTED_MODULE_3__.tail2)(location);
    const [pathToParent, parent] = this.getNode(rest);

    if (!(parent instanceof BranchNode)) {
      throw new Error('Invalid location');
    }

    if (!size.width && !size.height) {
      return;
    }

    const [parentSize, grandParentSize] = parent.orientation === _browser_ui_sash_sash__WEBPACK_IMPORTED_MODULE_1__.Orientation.HORIZONTAL ? [size.width, size.height] : [size.height, size.width];

    if (typeof grandParentSize === 'number' && pathToParent.length > 0) {
      const [, grandParent] = (0,_common_arrays__WEBPACK_IMPORTED_MODULE_3__.tail2)(pathToParent);
      const [, parentIndex] = (0,_common_arrays__WEBPACK_IMPORTED_MODULE_3__.tail2)(rest);
      grandParent.resizeChild(parentIndex, grandParentSize);
    }

    if (typeof parentSize === 'number') {
      parent.resizeChild(index, parentSize);
    }

    this.trySet2x2();
  }
  /**
   * Get the size of a {@link IView view}.
   *
   * @param location The {@link GridLocation location} of the view. Provide `undefined` to get
   * the size of the grid itself.
   */


  getViewSize(location) {
    if (!location) {
      return {
        width: this.root.width,
        height: this.root.height
      };
    }

    const [, node] = this.getNode(location);
    return {
      width: node.width,
      height: node.height
    };
  }
  /**
   * Get the cached visible size of a {@link IView view}. This was the size
   * of the view at the moment it last became hidden.
   *
   * @param location The {@link GridLocation location} of the view.
   */


  getViewCachedVisibleSize(location) {
    const [rest, index] = (0,_common_arrays__WEBPACK_IMPORTED_MODULE_3__.tail2)(location);
    const [, parent] = this.getNode(rest);

    if (!(parent instanceof BranchNode)) {
      throw new Error('Invalid location');
    }

    return parent.getChildCachedVisibleSize(index);
  }
  /**
   * Maximize the size of a {@link IView view} by collapsing all other views
   * to their minimum sizes.
   *
   * @param location The {@link GridLocation location} of the view.
   */


  maximizeViewSize(location) {
    const [ancestors, node] = this.getNode(location);

    if (!(node instanceof LeafNode)) {
      throw new Error('Invalid location');
    }

    for (let i = 0; i < ancestors.length; i++) {
      ancestors[i].resizeChild(location[i], Number.POSITIVE_INFINITY);
    }
  }
  /**
   * Returns whether all other {@link IView views} are at their minimum size.
   *
   * @param location The {@link GridLocation location} of the view.
   */


  isViewSizeMaximized(location) {
    const [ancestors, node] = this.getNode(location);

    if (!(node instanceof LeafNode)) {
      throw new Error('Invalid location');
    }

    for (let i = 0; i < ancestors.length; i++) {
      if (!ancestors[i].isChildSizeMaximized(location[i])) {
        return false;
      }
    }

    return true;
  }
  /**
   * Distribute the size among all {@link IView views} within the entire
   * grid or within a single {@link SplitView}.
   *
   * @param location The {@link GridLocation location} of a view containing
   * children views, which will have their sizes distributed within the parent
   * view's size. Provide `undefined` to recursively distribute all views' sizes
   * in the entire grid.
   */


  distributeViewSizes(location) {
    if (!location) {
      this.root.distributeViewSizes(true);
      return;
    }

    const [, node] = this.getNode(location);

    if (!(node instanceof BranchNode)) {
      throw new Error('Invalid location');
    }

    node.distributeViewSizes();
    this.trySet2x2();
  }
  /**
   * Returns whether a {@link IView view} is visible.
   *
   * @param location The {@link GridLocation location} of the view.
   */


  isViewVisible(location) {
    const [rest, index] = (0,_common_arrays__WEBPACK_IMPORTED_MODULE_3__.tail2)(location);
    const [, parent] = this.getNode(rest);

    if (!(parent instanceof BranchNode)) {
      throw new Error('Invalid from location');
    }

    return parent.isChildVisible(index);
  }
  /**
   * Set the visibility state of a {@link IView view}.
   *
   * @param location The {@link GridLocation location} of the view.
   */


  setViewVisible(location, visible) {
    const [rest, index] = (0,_common_arrays__WEBPACK_IMPORTED_MODULE_3__.tail2)(location);
    const [, parent] = this.getNode(rest);

    if (!(parent instanceof BranchNode)) {
      throw new Error('Invalid from location');
    }

    parent.setChildVisible(index, visible);
  }
  /**
   * Returns a descriptor for the entire grid.
   */


  getView(location) {
    const node = location ? this.getNode(location)[1] : this._root;
    return this._getViews(node, this.orientation);
  }
  /**
   * Construct a new {@link GridView} from a JSON object.
   *
   * @param json The JSON object.
   * @param deserializer A deserializer which can revive each view.
   * @returns A new {@link GridView} instance.
   */


  static deserialize(json, deserializer, options = {}) {
    if (typeof json.orientation !== 'number') {
      throw new Error('Invalid JSON: \'orientation\' property must be a number.');
    } else if (typeof json.width !== 'number') {
      throw new Error('Invalid JSON: \'width\' property must be a number.');
    } else if (typeof json.height !== 'number') {
      throw new Error('Invalid JSON: \'height\' property must be a number.');
    } else if (json.root?.type !== 'branch') {
      throw new Error('Invalid JSON: \'root\' property must have \'type\' value of branch.');
    }

    const orientation = json.orientation;
    const height = json.height;
    const result = new GridView(options);

    result._deserialize(json.root, orientation, deserializer, height);

    return result;
  }

  _deserialize(root, orientation, deserializer, orthogonalSize) {
    this.root = this._deserializeNode(root, orientation, deserializer, orthogonalSize);
  }

  _deserializeNode(node, orientation, deserializer, orthogonalSize) {
    let result;

    if (node.type === 'branch') {
      const serializedChildren = node.data;
      const children = serializedChildren.map(serializedChild => {
        return {
          node: this._deserializeNode(serializedChild, orthogonal(orientation), deserializer, node.size),
          visible: serializedChild.visible
        };
      });
      result = new BranchNode(orientation, this.layoutController, this.styles, this.proportionalLayout, node.size, orthogonalSize, undefined, children);
    } else {
      result = new LeafNode(deserializer.fromJSON(node.data), orientation, this.layoutController, orthogonalSize, node.size);
    }

    return result;
  }

  _getViews(node, orientation, cachedVisibleSize) {
    const box = {
      top: node.top,
      left: node.left,
      width: node.width,
      height: node.height
    };

    if (node instanceof LeafNode) {
      return {
        view: node.view,
        box,
        cachedVisibleSize
      };
    }

    const children = [];

    for (let i = 0; i < node.children.length; i++) {
      const child = node.children[i];
      const cachedVisibleSize = node.getChildCachedVisibleSize(i);
      children.push(this._getViews(child, orthogonal(orientation), cachedVisibleSize));
    }

    return {
      children,
      box
    };
  }

  getNode(location, node = this.root, path = []) {
    if (location.length === 0) {
      return [path, node];
    }

    if (!(node instanceof BranchNode)) {
      throw new Error('Invalid location');
    }

    const [index, ...rest] = location;

    if (index < 0 || index >= node.children.length) {
      throw new Error('Invalid location');
    }

    const child = node.children[index];
    path.push(node);
    return this.getNode(rest, child, path);
  }
  /**
   * Attempt to lock the {@link Sash sashes} in this {@link GridView} so
   * the grid behaves as a 2x2 matrix, with a corner sash in the middle.
   *
   * In case the grid isn't a 2x2 grid _and_ all sashes are not aligned,
   * this method is a no-op.
   */


  trySet2x2() {
    this.disposable2x2.dispose();
    this.disposable2x2 = _common_lifecycle__WEBPACK_IMPORTED_MODULE_6__.Disposable.None;

    if (this.root.children.length !== 2) {
      return;
    }

    const [first, second] = this.root.children;

    if (!(first instanceof BranchNode) || !(second instanceof BranchNode)) {
      return;
    }

    this.disposable2x2 = first.trySet2x2(second);
  }
  /**
   * Populate a map with views to DOM nodes.
   * @remarks To be used internally only.
   */


  getViewMap(map, node) {
    if (!node) {
      node = this.root;
    }

    if (node instanceof BranchNode) {
      node.children.forEach(child => this.getViewMap(map, child));
    } else {
      map.set(node.view, node.element);
    }
  }

  dispose() {
    this.onDidSashResetRelay.dispose();
    this.root.dispose();

    if (this.element && this.element.parentElement) {
      this.element.parentElement.removeChild(this.element);
    }
  }

}

/***/ }),
/* 113 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DataTree": () => (/* binding */ DataTree)
/* harmony export */ });
/* harmony import */ var _browser_ui_tree_abstractTree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(114);
/* harmony import */ var _browser_ui_tree_objectTreeModel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(168);
/* harmony import */ var _browser_ui_tree_tree__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(162);
/* harmony import */ var _common_iterator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(55);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/




class DataTree extends _browser_ui_tree_abstractTree__WEBPACK_IMPORTED_MODULE_0__.AbstractTree {
  nodesByIdentity = new Map();

  constructor(user, container, delegate, renderers, dataSource, options = {}) {
    super(user, container, delegate, renderers, options);
    this.user = user;
    this.dataSource = dataSource;
    this.identityProvider = options.identityProvider;
  } // Model


  getInput() {
    return this.input;
  }

  setInput(input, viewState) {
    if (viewState && !this.identityProvider) {
      throw new _browser_ui_tree_tree__WEBPACK_IMPORTED_MODULE_2__.TreeError(this.user, 'Can\'t restore tree view state without an identity provider');
    }

    this.input = input;

    if (!input) {
      this.nodesByIdentity.clear();
      this.model.setChildren(null, _common_iterator__WEBPACK_IMPORTED_MODULE_3__.Iterable.empty());
      return;
    }

    if (!viewState) {
      this._refresh(input);

      return;
    }

    const focus = [];
    const selection = [];

    const isCollapsed = element => {
      const id = this.identityProvider.getId(element).toString();
      return !viewState.expanded[id];
    };

    const onDidCreateNode = node => {
      const id = this.identityProvider.getId(node.element).toString();

      if (viewState.focus.has(id)) {
        focus.push(node.element);
      }

      if (viewState.selection.has(id)) {
        selection.push(node.element);
      }
    };

    this._refresh(input, isCollapsed, onDidCreateNode);

    this.setFocus(focus);
    this.setSelection(selection);

    if (viewState && typeof viewState.scrollTop === 'number') {
      this.scrollTop = viewState.scrollTop;
    }
  }

  updateChildren(element = this.input) {
    if (typeof this.input === 'undefined') {
      throw new _browser_ui_tree_tree__WEBPACK_IMPORTED_MODULE_2__.TreeError(this.user, 'Tree input not set');
    }

    let isCollapsed;

    if (this.identityProvider) {
      isCollapsed = element => {
        const id = this.identityProvider.getId(element).toString();
        const node = this.nodesByIdentity.get(id);

        if (!node) {
          return undefined;
        }

        return node.collapsed;
      };
    }

    this._refresh(element, isCollapsed);
  }

  resort(element = this.input, recursive = true) {
    this.model.resort(element === this.input ? null : element, recursive);
  } // View


  refresh(element) {
    if (element === undefined) {
      this.view.rerender();
      return;
    }

    this.model.rerender(element);
  } // Implementation


  _refresh(element, isCollapsed, onDidCreateNode) {
    let onDidDeleteNode;

    if (this.identityProvider) {
      const insertedElements = new Set();
      const outerOnDidCreateNode = onDidCreateNode;

      onDidCreateNode = node => {
        const id = this.identityProvider.getId(node.element).toString();
        insertedElements.add(id);
        this.nodesByIdentity.set(id, node);
        outerOnDidCreateNode?.(node);
      };

      onDidDeleteNode = node => {
        const id = this.identityProvider.getId(node.element).toString();

        if (!insertedElements.has(id)) {
          this.nodesByIdentity.delete(id);
        }
      };
    }

    this.model.setChildren(element === this.input ? null : element, this.iterate(element, isCollapsed).elements, {
      onDidCreateNode,
      onDidDeleteNode
    });
  }

  iterate(element, isCollapsed) {
    const children = [...this.dataSource.getChildren(element)];
    const elements = _common_iterator__WEBPACK_IMPORTED_MODULE_3__.Iterable.map(children, element => {
      const {
        elements: children,
        size
      } = this.iterate(element, isCollapsed);
      const collapsible = this.dataSource.hasChildren ? this.dataSource.hasChildren(element) : undefined;
      const collapsed = size === 0 ? undefined : isCollapsed && isCollapsed(element);
      return {
        element,
        children,
        collapsible,
        collapsed
      };
    });
    return {
      elements,
      size: children.length
    };
  }

  createModel(user, view, options) {
    return new _browser_ui_tree_objectTreeModel__WEBPACK_IMPORTED_MODULE_1__.ObjectTreeModel(user, view, options);
  }

}

/***/ }),
/* 114 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ComposedTreeDelegate": () => (/* binding */ ComposedTreeDelegate),
/* harmony export */   "AbstractTreeViewState": () => (/* binding */ AbstractTreeViewState),
/* harmony export */   "RenderIndentGuides": () => (/* binding */ RenderIndentGuides),
/* harmony export */   "ModeToggle": () => (/* binding */ ModeToggle),
/* harmony export */   "TreeFindMode": () => (/* binding */ TreeFindMode),
/* harmony export */   "AbstractTree": () => (/* binding */ AbstractTree)
/* harmony export */ });
/* harmony import */ var _browser_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(61);
/* harmony import */ var _browser_event__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(85);
/* harmony import */ var _browser_keyboardEvent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(63);
/* harmony import */ var _browser_ui_actionbar_actionbar__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(115);
/* harmony import */ var _browser_ui_findinput_findInput__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(152);
/* harmony import */ var _browser_ui_inputbox_inputBox__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(156);
/* harmony import */ var _browser_ui_list_listView__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(144);
/* harmony import */ var _browser_ui_list_listWidget__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(138);
/* harmony import */ var _browser_ui_toggle_toggle__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(154);
/* harmony import */ var _browser_ui_tree_indexTreeModel__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(161);
/* harmony import */ var _browser_ui_tree_tree__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(162);
/* harmony import */ var _common_actions__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(150);
/* harmony import */ var _common_arrays__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(87);
/* harmony import */ var _common_async__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(68);
/* harmony import */ var _common_codicons__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(104);
/* harmony import */ var _common_collections__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(166);
/* harmony import */ var _common_event__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(51);
/* harmony import */ var _common_filters__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(122);
/* harmony import */ var _common_keyCodes__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(64);
/* harmony import */ var _common_lifecycle__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(54);
/* harmony import */ var _common_numbers__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(107);
/* harmony import */ var _common_types__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(79);
/* harmony import */ var _media_tree_css__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(167);
/* harmony import */ var _common_nls__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(59);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

























class TreeElementsDragAndDropData extends _browser_ui_list_listView__WEBPACK_IMPORTED_MODULE_6__.ElementsDragAndDropData {
  set context(context) {
    this.data.context = context;
  }

  get context() {
    return this.data.context;
  }

  constructor(data) {
    super(data.elements.map(node => node.element));
    this.data = data;
  }

}

function asTreeDragAndDropData(data) {
  if (data instanceof _browser_ui_list_listView__WEBPACK_IMPORTED_MODULE_6__.ElementsDragAndDropData) {
    return new TreeElementsDragAndDropData(data);
  }

  return data;
}

class TreeNodeListDragAndDrop {
  autoExpandDisposable = _common_lifecycle__WEBPACK_IMPORTED_MODULE_19__.Disposable.None;

  constructor(modelProvider, dnd) {
    this.modelProvider = modelProvider;
    this.dnd = dnd;
  }

  getDragURI(node) {
    return this.dnd.getDragURI(node.element);
  }

  getDragLabel(nodes, originalEvent) {
    if (this.dnd.getDragLabel) {
      return this.dnd.getDragLabel(nodes.map(node => node.element), originalEvent);
    }

    return undefined;
  }

  onDragStart(data, originalEvent) {
    this.dnd.onDragStart?.(asTreeDragAndDropData(data), originalEvent);
  }

  onDragOver(data, targetNode, targetIndex, originalEvent, raw = true) {
    const result = this.dnd.onDragOver(asTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, originalEvent);
    const didChangeAutoExpandNode = this.autoExpandNode !== targetNode;

    if (didChangeAutoExpandNode) {
      this.autoExpandDisposable.dispose();
      this.autoExpandNode = targetNode;
    }

    if (typeof targetNode === 'undefined') {
      return result;
    }

    if (didChangeAutoExpandNode && typeof result !== 'boolean' && result.autoExpand) {
      this.autoExpandDisposable = (0,_common_async__WEBPACK_IMPORTED_MODULE_13__.disposableTimeout)(() => {
        const model = this.modelProvider();
        const ref = model.getNodeLocation(targetNode);

        if (model.isCollapsed(ref)) {
          model.setCollapsed(ref, false);
        }

        this.autoExpandNode = undefined;
      }, 500);
    }

    if (typeof result === 'boolean' || !result.accept || typeof result.bubble === 'undefined' || result.feedback) {
      if (!raw) {
        const accept = typeof result === 'boolean' ? result : result.accept;
        const effect = typeof result === 'boolean' ? undefined : result.effect;
        return {
          accept,
          effect,
          feedback: [targetIndex]
        };
      }

      return result;
    }

    if (result.bubble === _browser_ui_tree_tree__WEBPACK_IMPORTED_MODULE_10__.TreeDragOverBubble.Up) {
      const model = this.modelProvider();
      const ref = model.getNodeLocation(targetNode);
      const parentRef = model.getParentNodeLocation(ref);
      const parentNode = model.getNode(parentRef);
      const parentIndex = parentRef && model.getListIndex(parentRef);
      return this.onDragOver(data, parentNode, parentIndex, originalEvent, false);
    }

    const model = this.modelProvider();
    const ref = model.getNodeLocation(targetNode);
    const start = model.getListIndex(ref);
    const length = model.getListRenderCount(ref);
    return { ...result,
      feedback: (0,_common_arrays__WEBPACK_IMPORTED_MODULE_12__.range)(start, start + length)
    };
  }

  drop(data, targetNode, targetIndex, originalEvent) {
    this.autoExpandDisposable.dispose();
    this.autoExpandNode = undefined;
    this.dnd.drop(asTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, originalEvent);
  }

  onDragEnd(originalEvent) {
    this.dnd.onDragEnd?.(originalEvent);
  }

}

function asListOptions(modelProvider, options) {
  return options && { ...options,
    identityProvider: options.identityProvider && {
      getId(el) {
        return options.identityProvider.getId(el.element);
      }

    },
    dnd: options.dnd && new TreeNodeListDragAndDrop(modelProvider, options.dnd),
    multipleSelectionController: options.multipleSelectionController && {
      isSelectionSingleChangeEvent(e) {
        return options.multipleSelectionController.isSelectionSingleChangeEvent({ ...e,
          element: e.element
        });
      },

      isSelectionRangeChangeEvent(e) {
        return options.multipleSelectionController.isSelectionRangeChangeEvent({ ...e,
          element: e.element
        });
      }

    },
    accessibilityProvider: options.accessibilityProvider && { ...options.accessibilityProvider,

      getSetSize(node) {
        const model = modelProvider();
        const ref = model.getNodeLocation(node);
        const parentRef = model.getParentNodeLocation(ref);
        const parentNode = model.getNode(parentRef);
        return parentNode.visibleChildrenCount;
      },

      getPosInSet(node) {
        return node.visibleChildIndex + 1;
      },

      isChecked: options.accessibilityProvider && options.accessibilityProvider.isChecked ? node => {
        return options.accessibilityProvider.isChecked(node.element);
      } : undefined,
      getRole: options.accessibilityProvider && options.accessibilityProvider.getRole ? node => {
        return options.accessibilityProvider.getRole(node.element);
      } : () => 'treeitem',

      getAriaLabel(e) {
        return options.accessibilityProvider.getAriaLabel(e.element);
      },

      getWidgetAriaLabel() {
        return options.accessibilityProvider.getWidgetAriaLabel();
      },

      getWidgetRole: options.accessibilityProvider && options.accessibilityProvider.getWidgetRole ? () => options.accessibilityProvider.getWidgetRole() : () => 'tree',
      getAriaLevel: options.accessibilityProvider && options.accessibilityProvider.getAriaLevel ? node => options.accessibilityProvider.getAriaLevel(node.element) : node => {
        return node.depth;
      },
      getActiveDescendantId: options.accessibilityProvider.getActiveDescendantId && (node => {
        return options.accessibilityProvider.getActiveDescendantId(node.element);
      })
    },
    keyboardNavigationLabelProvider: options.keyboardNavigationLabelProvider && { ...options.keyboardNavigationLabelProvider,

      getKeyboardNavigationLabel(node) {
        return options.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(node.element);
      }

    }
  };
}

class ComposedTreeDelegate {
  constructor(delegate) {
    this.delegate = delegate;
  }

  getHeight(element) {
    return this.delegate.getHeight(element.element);
  }

  getTemplateId(element) {
    return this.delegate.getTemplateId(element.element);
  }

  hasDynamicHeight(element) {
    return !!this.delegate.hasDynamicHeight && this.delegate.hasDynamicHeight(element.element);
  }

  setDynamicHeight(element, height) {
    this.delegate.setDynamicHeight?.(element.element, height);
  }

}
class AbstractTreeViewState {
  static lift(state) {
    return state instanceof AbstractTreeViewState ? state : new AbstractTreeViewState(state);
  }

  static empty(scrollTop = 0) {
    return new AbstractTreeViewState({
      focus: [],
      selection: [],
      expanded: Object.create(null),
      scrollTop
    });
  }

  constructor(state) {
    this.focus = new Set(state.focus);
    this.selection = new Set(state.selection);

    if (state.expanded instanceof Array) {
      // old format
      this.expanded = Object.create(null);

      for (const id of state.expanded) {
        this.expanded[id] = 1;
      }
    } else {
      this.expanded = state.expanded;
    }

    this.expanded = state.expanded;
    this.scrollTop = state.scrollTop;
  }

  toJSON() {
    return {
      focus: Array.from(this.focus),
      selection: Array.from(this.selection),
      expanded: this.expanded,
      scrollTop: this.scrollTop
    };
  }

}
let RenderIndentGuides;

(function (RenderIndentGuides) {
  RenderIndentGuides["None"] = "none";
  RenderIndentGuides["OnHover"] = "onHover";
  RenderIndentGuides["Always"] = "always";
})(RenderIndentGuides || (RenderIndentGuides = {}));

class EventCollection {
  disposables = new _common_lifecycle__WEBPACK_IMPORTED_MODULE_19__.DisposableStore();

  get elements() {
    return this._elements;
  }

  constructor(onDidChange, _elements = []) {
    this._elements = _elements;
    this.onDidChange = _common_event__WEBPACK_IMPORTED_MODULE_16__.Event.forEach(onDidChange, elements => this._elements = elements, this.disposables);
  }

  dispose() {
    this.disposables.dispose();
  }

}

class TreeRenderer {
  static DefaultIndent = 8;
  renderedElements = new Map();
  renderedNodes = new Map();
  indent = TreeRenderer.DefaultIndent;
  hideTwistiesOfChildlessElements = false;
  shouldRenderIndentGuides = false;
  renderedIndentGuides = new _common_collections__WEBPACK_IMPORTED_MODULE_15__.SetMap();
  activeIndentNodes = new Set();
  indentGuidesDisposable = _common_lifecycle__WEBPACK_IMPORTED_MODULE_19__.Disposable.None;
  disposables = new _common_lifecycle__WEBPACK_IMPORTED_MODULE_19__.DisposableStore();

  constructor(renderer, modelProvider, onDidChangeCollapseState, activeNodes, options = {}) {
    this.renderer = renderer;
    this.modelProvider = modelProvider;
    this.activeNodes = activeNodes;
    this.templateId = renderer.templateId;
    this.updateOptions(options);
    _common_event__WEBPACK_IMPORTED_MODULE_16__.Event.map(onDidChangeCollapseState, e => e.node)(this.onDidChangeNodeTwistieState, this, this.disposables);
    renderer.onDidChangeTwistieState?.(this.onDidChangeTwistieState, this, this.disposables);
  }

  updateOptions(options = {}) {
    if (typeof options.indent !== 'undefined') {
      this.indent = (0,_common_numbers__WEBPACK_IMPORTED_MODULE_20__.clamp)(options.indent, 0, 40);
    }

    if (typeof options.renderIndentGuides !== 'undefined') {
      const shouldRenderIndentGuides = options.renderIndentGuides !== RenderIndentGuides.None;

      if (shouldRenderIndentGuides !== this.shouldRenderIndentGuides) {
        this.shouldRenderIndentGuides = shouldRenderIndentGuides;
        this.indentGuidesDisposable.dispose();

        if (shouldRenderIndentGuides) {
          const disposables = new _common_lifecycle__WEBPACK_IMPORTED_MODULE_19__.DisposableStore();
          this.activeNodes.onDidChange(this._onDidChangeActiveNodes, this, disposables);
          this.indentGuidesDisposable = disposables;

          this._onDidChangeActiveNodes(this.activeNodes.elements);
        }
      }
    }

    if (typeof options.hideTwistiesOfChildlessElements !== 'undefined') {
      this.hideTwistiesOfChildlessElements = options.hideTwistiesOfChildlessElements;
    }
  }

  renderTemplate(container) {
    const el = (0,_browser_dom__WEBPACK_IMPORTED_MODULE_0__.append)(container, (0,_browser_dom__WEBPACK_IMPORTED_MODULE_0__.$)('.monaco-tl-row'));
    const indent = (0,_browser_dom__WEBPACK_IMPORTED_MODULE_0__.append)(el, (0,_browser_dom__WEBPACK_IMPORTED_MODULE_0__.$)('.monaco-tl-indent'));
    const twistie = (0,_browser_dom__WEBPACK_IMPORTED_MODULE_0__.append)(el, (0,_browser_dom__WEBPACK_IMPORTED_MODULE_0__.$)('.monaco-tl-twistie'));
    const contents = (0,_browser_dom__WEBPACK_IMPORTED_MODULE_0__.append)(el, (0,_browser_dom__WEBPACK_IMPORTED_MODULE_0__.$)('.monaco-tl-contents'));
    const templateData = this.renderer.renderTemplate(contents);
    return {
      container,
      indent,
      twistie,
      indentGuidesDisposable: _common_lifecycle__WEBPACK_IMPORTED_MODULE_19__.Disposable.None,
      templateData
    };
  }

  renderElement(node, index, templateData, height) {
    if (typeof height === 'number') {
      this.renderedNodes.set(node, {
        templateData,
        height
      });
      this.renderedElements.set(node.element, node);
    }

    const indent = TreeRenderer.DefaultIndent + (node.depth - 1) * this.indent;
    templateData.twistie.style.paddingLeft = `${indent}px`;
    templateData.indent.style.width = `${indent + this.indent - 16}px`;
    this.renderTwistie(node, templateData);

    if (typeof height === 'number') {
      this.renderIndentGuides(node, templateData);
    }

    this.renderer.renderElement(node, index, templateData.templateData, height);
  }

  disposeElement(node, index, templateData, height) {
    templateData.indentGuidesDisposable.dispose();
    this.renderer.disposeElement?.(node, index, templateData.templateData, height);

    if (typeof height === 'number') {
      this.renderedNodes.delete(node);
      this.renderedElements.delete(node.element);
    }
  }

  disposeTemplate(templateData) {
    this.renderer.disposeTemplate(templateData.templateData);
  }

  onDidChangeTwistieState(element) {
    const node = this.renderedElements.get(element);

    if (!node) {
      return;
    }

    this.onDidChangeNodeTwistieState(node);
  }

  onDidChangeNodeTwistieState(node) {
    const data = this.renderedNodes.get(node);

    if (!data) {
      return;
    }

    this.renderTwistie(node, data.templateData);

    this._onDidChangeActiveNodes(this.activeNodes.elements);

    this.renderIndentGuides(node, data.templateData);
  }

  renderTwistie(node, templateData) {
    templateData.twistie.classList.remove(..._common_codicons__WEBPACK_IMPORTED_MODULE_14__.Codicon.treeItemExpanded.classNamesArray);
    let twistieRendered = false;

    if (this.renderer.renderTwistie) {
      twistieRendered = this.renderer.renderTwistie(node.element, templateData.twistie);
    }

    if (node.collapsible && (!this.hideTwistiesOfChildlessElements || node.visibleChildrenCount > 0)) {
      if (!twistieRendered) {
        templateData.twistie.classList.add(..._common_codicons__WEBPACK_IMPORTED_MODULE_14__.Codicon.treeItemExpanded.classNamesArray);
      }

      templateData.twistie.classList.add('collapsible');
      templateData.twistie.classList.toggle('collapsed', node.collapsed);
    } else {
      templateData.twistie.classList.remove('collapsible', 'collapsed');
    }

    if (node.collapsible) {
      templateData.container.setAttribute('aria-expanded', String(!node.collapsed));
    } else {
      templateData.container.removeAttribute('aria-expanded');
    }
  }

  renderIndentGuides(target, templateData) {
    (0,_browser_dom__WEBPACK_IMPORTED_MODULE_0__.clearNode)(templateData.indent);
    templateData.indentGuidesDisposable.dispose();

    if (!this.shouldRenderIndentGuides) {
      return;
    }

    const disposableStore = new _common_lifecycle__WEBPACK_IMPORTED_MODULE_19__.DisposableStore();
    const model = this.modelProvider();
    let node = target;

    while (true) {
      const ref = model.getNodeLocation(node);
      const parentRef = model.getParentNodeLocation(ref);

      if (!parentRef) {
        break;
      }

      const parent = model.getNode(parentRef);
      const guide = (0,_browser_dom__WEBPACK_IMPORTED_MODULE_0__.$)('.indent-guide', {
        style: `width: ${this.indent}px`
      });

      if (this.activeIndentNodes.has(parent)) {
        guide.classList.add('active');
      }

      if (templateData.indent.childElementCount === 0) {
        templateData.indent.appendChild(guide);
      } else {
        templateData.indent.insertBefore(guide, templateData.indent.firstElementChild);
      }

      this.renderedIndentGuides.add(parent, guide);
      disposableStore.add((0,_common_lifecycle__WEBPACK_IMPORTED_MODULE_19__.toDisposable)(() => this.renderedIndentGuides.delete(parent, guide)));
      node = parent;
    }

    templateData.indentGuidesDisposable = disposableStore;
  }

  _onDidChangeActiveNodes(nodes) {
    if (!this.shouldRenderIndentGuides) {
      return;
    }

    const set = new Set();
    const model = this.modelProvider();
    nodes.forEach(node => {
      const ref = model.getNodeLocation(node);

      try {
        const parentRef = model.getParentNodeLocation(ref);

        if (node.collapsible && node.children.length > 0 && !node.collapsed) {
          set.add(node);
        } else if (parentRef) {
          set.add(model.getNode(parentRef));
        }
      } catch {// noop
      }
    });
    this.activeIndentNodes.forEach(node => {
      if (!set.has(node)) {
        this.renderedIndentGuides.forEach(node, line => line.classList.remove('active'));
      }
    });
    set.forEach(node => {
      if (!this.activeIndentNodes.has(node)) {
        this.renderedIndentGuides.forEach(node, line => line.classList.add('active'));
      }
    });
    this.activeIndentNodes = set;
  }

  dispose() {
    this.renderedNodes.clear();
    this.renderedElements.clear();
    this.indentGuidesDisposable.dispose();
    (0,_common_lifecycle__WEBPACK_IMPORTED_MODULE_19__.dispose)(this.disposables);
  }

}

class FindFilter {
  _totalCount = 0;

  get totalCount() {
    return this._totalCount;
  }

  _matchCount = 0;

  get matchCount() {
    return this._matchCount;
  }

  _pattern = '';
  _lowercasePattern = '';
  disposables = new _common_lifecycle__WEBPACK_IMPORTED_MODULE_19__.DisposableStore();

  set pattern(pattern) {
    this._pattern = pattern;
    this._lowercasePattern = pattern.toLowerCase();
  }

  constructor(tree, keyboardNavigationLabelProvider, _filter) {
    this.tree = tree;
    this.keyboardNavigationLabelProvider = keyboardNavigationLabelProvider;
    this._filter = _filter;
    tree.onWillRefilter(this.reset, this, this.disposables);
  }

  filter(element, parentVisibility) {
    let visibility = _browser_ui_tree_tree__WEBPACK_IMPORTED_MODULE_10__.TreeVisibility.Visible;

    if (this._filter) {
      const result = this._filter.filter(element, parentVisibility);

      if (typeof result === 'boolean') {
        visibility = result ? _browser_ui_tree_tree__WEBPACK_IMPORTED_MODULE_10__.TreeVisibility.Visible : _browser_ui_tree_tree__WEBPACK_IMPORTED_MODULE_10__.TreeVisibility.Hidden;
      } else if ((0,_browser_ui_tree_indexTreeModel__WEBPACK_IMPORTED_MODULE_9__.isFilterResult)(result)) {
        visibility = (0,_browser_ui_tree_indexTreeModel__WEBPACK_IMPORTED_MODULE_9__.getVisibleState)(result.visibility);
      } else {
        visibility = result;
      }

      if (visibility === _browser_ui_tree_tree__WEBPACK_IMPORTED_MODULE_10__.TreeVisibility.Hidden) {
        return false;
      }
    }

    this._totalCount++;

    if (!this._pattern) {
      this._matchCount++;
      return {
        data: _common_filters__WEBPACK_IMPORTED_MODULE_17__.FuzzyScore.Default,
        visibility
      };
    }

    const label = this.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(element);
    const labels = Array.isArray(label) ? label : [label];

    for (const l of labels) {
      const labelStr = l && l.toString();

      if (typeof labelStr === 'undefined') {
        return {
          data: _common_filters__WEBPACK_IMPORTED_MODULE_17__.FuzzyScore.Default,
          visibility
        };
      }

      const score = (0,_common_filters__WEBPACK_IMPORTED_MODULE_17__.fuzzyScore)(this._pattern, this._lowercasePattern, 0, labelStr, labelStr.toLowerCase(), 0, {
        firstMatchCanBeWeak: true,
        boostFullMatch: true
      });

      if (score) {
        this._matchCount++;
        return labels.length === 1 ? {
          data: score,
          visibility
        } : {
          data: {
            label: labelStr,
            score: score
          },
          visibility
        };
      }
    }

    if (this.tree.findMode === TreeFindMode.Filter) {
      return _browser_ui_tree_tree__WEBPACK_IMPORTED_MODULE_10__.TreeVisibility.Recurse;
    } else {
      return {
        data: _common_filters__WEBPACK_IMPORTED_MODULE_17__.FuzzyScore.Default,
        visibility
      };
    }
  }

  reset() {
    this._totalCount = 0;
    this._matchCount = 0;
  }

  dispose() {
    (0,_common_lifecycle__WEBPACK_IMPORTED_MODULE_19__.dispose)(this.disposables);
  }

}

class ModeToggle extends _browser_ui_toggle_toggle__WEBPACK_IMPORTED_MODULE_8__.Toggle {
  constructor(opts) {
    super({
      icon: _common_codicons__WEBPACK_IMPORTED_MODULE_14__.Codicon.listFilter,
      title: (0,_common_nls__WEBPACK_IMPORTED_MODULE_23__.localize)('filter', "Filter"),
      isChecked: opts?.isChecked ?? false,
      inputActiveOptionBorder: opts?.inputActiveOptionBorder,
      inputActiveOptionForeground: opts?.inputActiveOptionForeground,
      inputActiveOptionBackground: opts?.inputActiveOptionBackground
    });
  }

}
let TreeFindMode;

(function (TreeFindMode) {
  TreeFindMode[TreeFindMode["Highlight"] = 0] = "Highlight";
  TreeFindMode[TreeFindMode["Filter"] = 1] = "Filter";
})(TreeFindMode || (TreeFindMode = {}));

class FindWidget extends _common_lifecycle__WEBPACK_IMPORTED_MODULE_19__.Disposable {
  elements = (0,_browser_dom__WEBPACK_IMPORTED_MODULE_0__.h)('.monaco-tree-type-filter', [(0,_browser_dom__WEBPACK_IMPORTED_MODULE_0__.h)('.monaco-tree-type-filter-grab.codicon.codicon-debug-gripper@grab', {
    tabIndex: 0
  }), (0,_browser_dom__WEBPACK_IMPORTED_MODULE_0__.h)('.monaco-tree-type-filter-input@findInput'), (0,_browser_dom__WEBPACK_IMPORTED_MODULE_0__.h)('.monaco-tree-type-filter-actionbar@actionbar')]);

  set mode(mode) {
    this.modeToggle.checked = mode === TreeFindMode.Filter;
    this.findInput.inputBox.setPlaceHolder(mode === TreeFindMode.Filter ? (0,_common_nls__WEBPACK_IMPORTED_MODULE_23__.localize)('type to filter', "Type to filter") : (0,_common_nls__WEBPACK_IMPORTED_MODULE_23__.localize)('type to search', "Type to search"));
  }

  width = 0;
  right = 0;
  _onDidDisable = new _common_event__WEBPACK_IMPORTED_MODULE_16__.Emitter();
  onDidDisable = this._onDidDisable.event;

  constructor(container, tree, contextViewProvider, mode, options) {
    super();
    this.tree = tree;
    container.appendChild(this.elements.root);

    this._register((0,_common_lifecycle__WEBPACK_IMPORTED_MODULE_19__.toDisposable)(() => container.removeChild(this.elements.root)));

    this.modeToggle = this._register(new ModeToggle({ ...options,
      isChecked: mode === TreeFindMode.Filter
    }));
    this.onDidChangeMode = _common_event__WEBPACK_IMPORTED_MODULE_16__.Event.map(this.modeToggle.onChange, () => this.modeToggle.checked ? TreeFindMode.Filter : TreeFindMode.Highlight, this._store);
    this.findInput = this._register(new _browser_ui_findinput_findInput__WEBPACK_IMPORTED_MODULE_4__.FindInput(this.elements.findInput, contextViewProvider, {
      label: (0,_common_nls__WEBPACK_IMPORTED_MODULE_23__.localize)('type to search', "Type to search"),
      additionalToggles: [this.modeToggle],
      showCommonFindToggles: false
    }));
    this.actionbar = this._register(new _browser_ui_actionbar_actionbar__WEBPACK_IMPORTED_MODULE_3__.ActionBar(this.elements.actionbar));
    this.mode = mode;

    const emitter = this._register(new _browser_event__WEBPACK_IMPORTED_MODULE_1__.DomEmitter(this.findInput.inputBox.inputElement, 'keydown'));

    const onKeyDown = this._register(_common_event__WEBPACK_IMPORTED_MODULE_16__.Event.chain(emitter.event)).map(e => new _browser_keyboardEvent__WEBPACK_IMPORTED_MODULE_2__.StandardKeyboardEvent(e)).event;

    this._register(onKeyDown(e => {
      switch (e.keyCode) {
        case _common_keyCodes__WEBPACK_IMPORTED_MODULE_18__.KeyCode.DownArrow:
          e.preventDefault();
          e.stopPropagation();
          this.tree.domFocus();
          return;
      }
    }));

    const closeAction = this._register(new _common_actions__WEBPACK_IMPORTED_MODULE_11__.Action('close', (0,_common_nls__WEBPACK_IMPORTED_MODULE_23__.localize)('close', "Close"), 'codicon codicon-close', true, () => this.dispose()));

    this.actionbar.push(closeAction, {
      icon: true,
      label: false
    });

    const onGrabMouseDown = this._register(new _browser_event__WEBPACK_IMPORTED_MODULE_1__.DomEmitter(this.elements.grab, 'mousedown'));

    this._register(onGrabMouseDown.event(e => {
      const disposables = new _common_lifecycle__WEBPACK_IMPORTED_MODULE_19__.DisposableStore();
      const onWindowMouseMove = disposables.add(new _browser_event__WEBPACK_IMPORTED_MODULE_1__.DomEmitter(window, 'mousemove'));
      const onWindowMouseUp = disposables.add(new _browser_event__WEBPACK_IMPORTED_MODULE_1__.DomEmitter(window, 'mouseup'));
      const startRight = this.right;
      const startX = e.pageX;
      this.elements.grab.classList.add('grabbing');

      const update = e => {
        const deltaX = e.pageX - startX;
        this.right = startRight - deltaX;
        this.layout();
      };

      disposables.add(onWindowMouseMove.event(update));
      disposables.add(onWindowMouseUp.event(e => {
        update(e);
        this.elements.grab.classList.remove('grabbing');
        disposables.dispose();
      }));
    }));

    const onGrabKeyDown = this._register(_common_event__WEBPACK_IMPORTED_MODULE_16__.Event.chain(this._register(new _browser_event__WEBPACK_IMPORTED_MODULE_1__.DomEmitter(this.elements.grab, 'keydown')).event)).map(e => new _browser_keyboardEvent__WEBPACK_IMPORTED_MODULE_2__.StandardKeyboardEvent(e)).event;

    this._register(onGrabKeyDown(e => {
      let right;

      if (e.keyCode === _common_keyCodes__WEBPACK_IMPORTED_MODULE_18__.KeyCode.LeftArrow) {
        right = Number.POSITIVE_INFINITY;
      } else if (e.keyCode === _common_keyCodes__WEBPACK_IMPORTED_MODULE_18__.KeyCode.RightArrow) {
        right = 0;
      } else if (e.keyCode === _common_keyCodes__WEBPACK_IMPORTED_MODULE_18__.KeyCode.Space) {
        right = this.right === 0 ? Number.POSITIVE_INFINITY : 0;
      }

      if (right !== undefined) {
        e.preventDefault();
        e.stopPropagation();
        this.right = right;
        this.layout();
      }
    }));

    this.onDidChangeValue = this.findInput.onDidChange;
    this.style(options ?? {});
  }

  style(styles) {
    this.findInput.style(styles);

    if (styles.listFilterWidgetBackground) {
      this.elements.root.style.backgroundColor = styles.listFilterWidgetBackground.toString();
    }

    if (styles.listFilterWidgetShadow) {
      this.elements.root.style.boxShadow = `0 0 8px 2px ${styles.listFilterWidgetShadow}`;
    }
  }

  focus() {
    this.findInput.focus();
  }

  select() {
    this.findInput.select();
  }

  layout(width = this.width) {
    this.width = width;
    this.right = (0,_common_numbers__WEBPACK_IMPORTED_MODULE_20__.clamp)(this.right, 0, Math.max(0, width - 212));
    this.elements.root.style.right = `${this.right}px`;
  }

  showMessage(message) {
    this.findInput.showMessage(message);
  }

  clearMessage() {
    this.findInput.clearMessage();
  }

  async dispose() {
    this._onDidDisable.fire();

    this.elements.root.classList.add('disabled');
    await (0,_common_async__WEBPACK_IMPORTED_MODULE_13__.timeout)(300);
    super.dispose();
  }

}

class FindController {
  _pattern = '';

  get pattern() {
    return this._pattern;
  }

  get mode() {
    return this._mode;
  }

  set mode(mode) {
    if (mode === this._mode) {
      return;
    }

    this._mode = mode;

    if (this.widget) {
      this.widget.mode = this._mode;
    }

    this.tree.refilter();
    this.render();

    this._onDidChangeMode.fire(mode);
  }

  width = 0;
  _onDidChangeMode = new _common_event__WEBPACK_IMPORTED_MODULE_16__.Emitter();
  onDidChangeMode = this._onDidChangeMode.event;
  _onDidChangePattern = new _common_event__WEBPACK_IMPORTED_MODULE_16__.Emitter();
  onDidChangePattern = this._onDidChangePattern.event;
  _onDidChangeOpenState = new _common_event__WEBPACK_IMPORTED_MODULE_16__.Emitter();
  onDidChangeOpenState = this._onDidChangeOpenState.event;
  enabledDisposables = new _common_lifecycle__WEBPACK_IMPORTED_MODULE_19__.DisposableStore();
  disposables = new _common_lifecycle__WEBPACK_IMPORTED_MODULE_19__.DisposableStore();

  constructor(tree, model, view, filter, contextViewProvider) {
    this.tree = tree;
    this.view = view;
    this.filter = filter;
    this.contextViewProvider = contextViewProvider;
    this._mode = tree.options.defaultFindMode ?? TreeFindMode.Highlight;
    model.onDidSplice(this.onDidSpliceModel, this, this.disposables);
  }

  open() {
    if (this.widget) {
      this.widget.focus();
      this.widget.select();
      return;
    }

    this.mode = this.tree.options.defaultFindMode ?? TreeFindMode.Highlight;
    this.widget = new FindWidget(this.view.getHTMLElement(), this.tree, this.contextViewProvider, this.mode, this.styles);
    this.enabledDisposables.add(this.widget);
    this.widget.onDidChangeValue(this.onDidChangeValue, this, this.enabledDisposables);
    this.widget.onDidChangeMode(mode => this.mode = mode, undefined, this.enabledDisposables);
    this.widget.onDidDisable(this.close, this, this.enabledDisposables);
    this.widget.layout(this.width);
    this.widget.focus();

    this._onDidChangeOpenState.fire(true);
  }

  close() {
    if (!this.widget) {
      return;
    }

    this.widget = undefined;
    this.enabledDisposables.dispose();
    this.enabledDisposables = new _common_lifecycle__WEBPACK_IMPORTED_MODULE_19__.DisposableStore();
    this.onDidChangeValue('');
    this.tree.domFocus();

    this._onDidChangeOpenState.fire(false);
  }

  onDidChangeValue(pattern) {
    this._pattern = pattern;

    this._onDidChangePattern.fire(pattern);

    this.filter.pattern = pattern;
    this.tree.refilter();

    if (pattern) {
      this.tree.focusNext(0, true, undefined, node => !_common_filters__WEBPACK_IMPORTED_MODULE_17__.FuzzyScore.isDefault(node.filterData));
    }

    const focus = this.tree.getFocus();

    if (focus.length > 0) {
      const element = focus[0];

      if (this.tree.getRelativeTop(element) === null) {
        this.tree.reveal(element, 0.5);
      }
    }

    this.render();
  }

  onDidSpliceModel() {
    if (!this.widget || this.pattern.length === 0) {
      return;
    }

    this.tree.refilter();
    this.render();
  }

  render() {
    const noMatches = this.filter.totalCount > 0 && this.filter.matchCount === 0;

    if (this.pattern && noMatches) {
      this.widget?.showMessage({
        type: _browser_ui_inputbox_inputBox__WEBPACK_IMPORTED_MODULE_5__.MessageType.WARNING,
        content: (0,_common_nls__WEBPACK_IMPORTED_MODULE_23__.localize)('not found', "No elements found.")
      });
    } else {
      this.widget?.clearMessage();
    }
  }

  shouldAllowFocus(node) {
    if (!this.widget || !this.pattern || this._mode === TreeFindMode.Filter) {
      return true;
    }

    if (this.filter.totalCount > 0 && this.filter.matchCount <= 1) {
      return true;
    }

    return !_common_filters__WEBPACK_IMPORTED_MODULE_17__.FuzzyScore.isDefault(node.filterData);
  }

  style(styles) {
    this.styles = styles;
    this.widget?.style(styles);
  }

  layout(width) {
    this.width = width;
    this.widget?.layout(width);
  }

  dispose() {
    this._onDidChangePattern.dispose();

    this.enabledDisposables.dispose();
    this.disposables.dispose();
  }

}

function asTreeMouseEvent(event) {
  let target = _browser_ui_tree_tree__WEBPACK_IMPORTED_MODULE_10__.TreeMouseEventTarget.Unknown;

  if ((0,_browser_dom__WEBPACK_IMPORTED_MODULE_0__.hasParentWithClass)(event.browserEvent.target, 'monaco-tl-twistie', 'monaco-tl-row')) {
    target = _browser_ui_tree_tree__WEBPACK_IMPORTED_MODULE_10__.TreeMouseEventTarget.Twistie;
  } else if ((0,_browser_dom__WEBPACK_IMPORTED_MODULE_0__.hasParentWithClass)(event.browserEvent.target, 'monaco-tl-contents', 'monaco-tl-row')) {
    target = _browser_ui_tree_tree__WEBPACK_IMPORTED_MODULE_10__.TreeMouseEventTarget.Element;
  } else if ((0,_browser_dom__WEBPACK_IMPORTED_MODULE_0__.hasParentWithClass)(event.browserEvent.target, 'monaco-tree-type-filter', 'monaco-list')) {
    target = _browser_ui_tree_tree__WEBPACK_IMPORTED_MODULE_10__.TreeMouseEventTarget.Filter;
  }

  return {
    browserEvent: event.browserEvent,
    element: event.element ? event.element.element : null,
    target
  };
}

function asTreeContextMenuEvent(event) {
  return {
    element: event.element ? event.element.element : null,
    browserEvent: event.browserEvent,
    anchor: event.anchor
  };
}

function dfs(node, fn) {
  fn(node);
  node.children.forEach(child => dfs(child, fn));
}
/**
 * The trait concept needs to exist at the tree level, because collapsed
 * tree nodes will not be known by the list.
 */


class Trait {
  nodes = [];
  _onDidChange = new _common_event__WEBPACK_IMPORTED_MODULE_16__.Emitter();
  onDidChange = this._onDidChange.event;

  get nodeSet() {
    if (!this._nodeSet) {
      this._nodeSet = this.createNodeSet();
    }

    return this._nodeSet;
  }

  constructor(getFirstViewElementWithTrait, identityProvider) {
    this.getFirstViewElementWithTrait = getFirstViewElementWithTrait;
    this.identityProvider = identityProvider;
  }

  set(nodes, browserEvent) {
    if (!browserEvent?.__forceEvent && (0,_common_arrays__WEBPACK_IMPORTED_MODULE_12__.equals)(this.nodes, nodes)) {
      return;
    }

    this._set(nodes, false, browserEvent);
  }

  _set(nodes, silent, browserEvent) {
    this.nodes = [...nodes];
    this.elements = undefined;
    this._nodeSet = undefined;

    if (!silent) {
      const that = this;

      this._onDidChange.fire({
        get elements() {
          return that.get();
        },

        browserEvent
      });
    }
  }

  get() {
    if (!this.elements) {
      this.elements = this.nodes.map(node => node.element);
    }

    return [...this.elements];
  }

  getNodes() {
    return this.nodes;
  }

  has(node) {
    return this.nodeSet.has(node);
  }

  onDidModelSplice({
    insertedNodes,
    deletedNodes
  }) {
    if (!this.identityProvider) {
      const set = this.createNodeSet();

      const visit = node => set.delete(node);

      deletedNodes.forEach(node => dfs(node, visit));
      this.set([...set.values()]);
      return;
    }

    const deletedNodesIdSet = new Set();

    const deletedNodesVisitor = node => deletedNodesIdSet.add(this.identityProvider.getId(node.element).toString());

    deletedNodes.forEach(node => dfs(node, deletedNodesVisitor));
    const insertedNodesMap = new Map();

    const insertedNodesVisitor = node => insertedNodesMap.set(this.identityProvider.getId(node.element).toString(), node);

    insertedNodes.forEach(node => dfs(node, insertedNodesVisitor));
    const nodes = [];

    for (const node of this.nodes) {
      const id = this.identityProvider.getId(node.element).toString();
      const wasDeleted = deletedNodesIdSet.has(id);

      if (!wasDeleted) {
        nodes.push(node);
      } else {
        const insertedNode = insertedNodesMap.get(id);

        if (insertedNode) {
          nodes.push(insertedNode);
        }
      }
    }

    if (this.nodes.length > 0 && nodes.length === 0) {
      const node = this.getFirstViewElementWithTrait();

      if (node) {
        nodes.push(node);
      }
    }

    this._set(nodes, true);
  }

  createNodeSet() {
    const set = new Set();

    for (const node of this.nodes) {
      set.add(node);
    }

    return set;
  }

}

class TreeNodeListMouseController extends _browser_ui_list_listWidget__WEBPACK_IMPORTED_MODULE_7__.MouseController {
  constructor(list, tree) {
    super(list);
    this.tree = tree;
  }

  onViewPointer(e) {
    if ((0,_browser_ui_list_listWidget__WEBPACK_IMPORTED_MODULE_7__.isButton)(e.browserEvent.target) || (0,_browser_ui_list_listWidget__WEBPACK_IMPORTED_MODULE_7__.isInputElement)(e.browserEvent.target) || (0,_browser_ui_list_listWidget__WEBPACK_IMPORTED_MODULE_7__.isMonacoEditor)(e.browserEvent.target)) {
      return;
    }

    const node = e.element;

    if (!node) {
      return super.onViewPointer(e);
    }

    if (this.isSelectionRangeChangeEvent(e) || this.isSelectionSingleChangeEvent(e)) {
      return super.onViewPointer(e);
    }

    const target = e.browserEvent.target;
    const onTwistie = target.classList.contains('monaco-tl-twistie') || target.classList.contains('monaco-icon-label') && target.classList.contains('folder-icon') && e.browserEvent.offsetX < 16;
    let expandOnlyOnTwistieClick = false;

    if (typeof this.tree.expandOnlyOnTwistieClick === 'function') {
      expandOnlyOnTwistieClick = this.tree.expandOnlyOnTwistieClick(node.element);
    } else {
      expandOnlyOnTwistieClick = !!this.tree.expandOnlyOnTwistieClick;
    }

    if (expandOnlyOnTwistieClick && !onTwistie && e.browserEvent.detail !== 2) {
      return super.onViewPointer(e);
    }

    if (!this.tree.expandOnDoubleClick && e.browserEvent.detail === 2) {
      return super.onViewPointer(e);
    }

    if (node.collapsible) {
      const model = this.tree.model; // internal

      const location = model.getNodeLocation(node);
      const recursive = e.browserEvent.altKey;
      this.tree.setFocus([location]);
      model.setCollapsed(location, undefined, recursive);

      if (expandOnlyOnTwistieClick && onTwistie) {
        return;
      }
    }

    super.onViewPointer(e);
  }

  onDoubleClick(e) {
    const onTwistie = e.browserEvent.target.classList.contains('monaco-tl-twistie');

    if (onTwistie || !this.tree.expandOnDoubleClick) {
      return;
    }

    super.onDoubleClick(e);
  }

}

/**
 * We use this List subclass to restore selection and focus as nodes
 * get rendered in the list, possibly due to a node expand() call.
 */
class TreeNodeList extends _browser_ui_list_listWidget__WEBPACK_IMPORTED_MODULE_7__.List {
  constructor(user, container, virtualDelegate, renderers, focusTrait, selectionTrait, anchorTrait, options) {
    super(user, container, virtualDelegate, renderers, options);
    this.focusTrait = focusTrait;
    this.selectionTrait = selectionTrait;
    this.anchorTrait = anchorTrait;
  }

  createMouseController(options) {
    return new TreeNodeListMouseController(this, options.tree);
  }

  splice(start, deleteCount, elements = []) {
    super.splice(start, deleteCount, elements);

    if (elements.length === 0) {
      return;
    }

    const additionalFocus = [];
    const additionalSelection = [];
    let anchor;
    elements.forEach((node, index) => {
      if (this.focusTrait.has(node)) {
        additionalFocus.push(start + index);
      }

      if (this.selectionTrait.has(node)) {
        additionalSelection.push(start + index);
      }

      if (this.anchorTrait.has(node)) {
        anchor = start + index;
      }
    });

    if (additionalFocus.length > 0) {
      super.setFocus((0,_common_arrays__WEBPACK_IMPORTED_MODULE_12__.distinct)([...super.getFocus(), ...additionalFocus]));
    }

    if (additionalSelection.length > 0) {
      super.setSelection((0,_common_arrays__WEBPACK_IMPORTED_MODULE_12__.distinct)([...super.getSelection(), ...additionalSelection]));
    }

    if (typeof anchor === 'number') {
      super.setAnchor(anchor);
    }
  }

  setFocus(indexes, browserEvent, fromAPI = false) {
    super.setFocus(indexes, browserEvent);

    if (!fromAPI) {
      this.focusTrait.set(indexes.map(i => this.element(i)), browserEvent);
    }
  }

  setSelection(indexes, browserEvent, fromAPI = false) {
    super.setSelection(indexes, browserEvent);

    if (!fromAPI) {
      this.selectionTrait.set(indexes.map(i => this.element(i)), browserEvent);
    }
  }

  setAnchor(index, fromAPI = false) {
    super.setAnchor(index);

    if (!fromAPI) {
      if (typeof index === 'undefined') {
        this.anchorTrait.set([]);
      } else {
        this.anchorTrait.set([this.element(index)]);
      }
    }
  }

}

class AbstractTree {
  eventBufferer = new _common_event__WEBPACK_IMPORTED_MODULE_16__.EventBufferer();
  onDidChangeFindOpenState = _common_event__WEBPACK_IMPORTED_MODULE_16__.Event.None;
  disposables = new _common_lifecycle__WEBPACK_IMPORTED_MODULE_19__.DisposableStore();

  get onDidScroll() {
    return this.view.onDidScroll;
  }

  get onDidChangeFocus() {
    return this.eventBufferer.wrapEvent(this.focus.onDidChange);
  }

  get onDidChangeSelection() {
    return this.eventBufferer.wrapEvent(this.selection.onDidChange);
  }

  get onMouseClick() {
    return _common_event__WEBPACK_IMPORTED_MODULE_16__.Event.map(this.view.onMouseClick, asTreeMouseEvent);
  }

  get onMouseDblClick() {
    return _common_event__WEBPACK_IMPORTED_MODULE_16__.Event.filter(_common_event__WEBPACK_IMPORTED_MODULE_16__.Event.map(this.view.onMouseDblClick, asTreeMouseEvent), e => e.target !== _browser_ui_tree_tree__WEBPACK_IMPORTED_MODULE_10__.TreeMouseEventTarget.Filter);
  }

  get onContextMenu() {
    return _common_event__WEBPACK_IMPORTED_MODULE_16__.Event.map(this.view.onContextMenu, asTreeContextMenuEvent);
  }

  get onTap() {
    return _common_event__WEBPACK_IMPORTED_MODULE_16__.Event.map(this.view.onTap, asTreeMouseEvent);
  }

  get onPointer() {
    return _common_event__WEBPACK_IMPORTED_MODULE_16__.Event.map(this.view.onPointer, asTreeMouseEvent);
  }

  get onKeyDown() {
    return this.view.onKeyDown;
  }

  get onKeyUp() {
    return this.view.onKeyUp;
  }

  get onKeyPress() {
    return this.view.onKeyPress;
  }

  get onDidFocus() {
    return this.view.onDidFocus;
  }

  get onDidBlur() {
    return this.view.onDidBlur;
  }

  get onDidChangeModel() {
    return _common_event__WEBPACK_IMPORTED_MODULE_16__.Event.signal(this.model.onDidSplice);
  }

  get onDidChangeCollapseState() {
    return this.model.onDidChangeCollapseState;
  }

  get onDidChangeRenderNodeCount() {
    return this.model.onDidChangeRenderNodeCount;
  }

  _onWillRefilter = new _common_event__WEBPACK_IMPORTED_MODULE_16__.Emitter();
  onWillRefilter = this._onWillRefilter.event;

  get findMode() {
    return this.findController?.mode ?? TreeFindMode.Highlight;
  }

  set findMode(findMode) {
    if (this.findController) {
      this.findController.mode = findMode;
    }
  }

  get onDidChangeFindPattern() {
    return this.findController ? this.findController.onDidChangePattern : _common_event__WEBPACK_IMPORTED_MODULE_16__.Event.None;
  }

  get expandOnDoubleClick() {
    return typeof this._options.expandOnDoubleClick === 'undefined' ? true : this._options.expandOnDoubleClick;
  }

  get expandOnlyOnTwistieClick() {
    return typeof this._options.expandOnlyOnTwistieClick === 'undefined' ? true : this._options.expandOnlyOnTwistieClick;
  }

  _onDidUpdateOptions = new _common_event__WEBPACK_IMPORTED_MODULE_16__.Emitter();
  onDidUpdateOptions = this._onDidUpdateOptions.event;

  get onDidDispose() {
    return this.view.onDidDispose;
  }

  constructor(_user, container, delegate, renderers, _options = {}) {
    this._user = _user;
    this._options = _options;
    const treeDelegate = new ComposedTreeDelegate(delegate);
    const onDidChangeCollapseStateRelay = new _common_event__WEBPACK_IMPORTED_MODULE_16__.Relay();
    const onDidChangeActiveNodes = new _common_event__WEBPACK_IMPORTED_MODULE_16__.Relay();
    const activeNodes = this.disposables.add(new EventCollection(onDidChangeActiveNodes.event));
    this.renderers = renderers.map(r => new TreeRenderer(r, () => this.model, onDidChangeCollapseStateRelay.event, activeNodes, _options));

    for (const r of this.renderers) {
      this.disposables.add(r);
    }

    let filter;

    if (_options.keyboardNavigationLabelProvider) {
      filter = new FindFilter(this, _options.keyboardNavigationLabelProvider, _options.filter);
      _options = { ..._options,
        filter: filter
      }; // TODO need typescript help here

      this.disposables.add(filter);
    }

    this.focus = new Trait(() => this.view.getFocusedElements()[0], _options.identityProvider);
    this.selection = new Trait(() => this.view.getSelectedElements()[0], _options.identityProvider);
    this.anchor = new Trait(() => this.view.getAnchorElement(), _options.identityProvider);
    this.view = new TreeNodeList(_user, container, treeDelegate, this.renderers, this.focus, this.selection, this.anchor, { ...asListOptions(() => this.model, _options),
      tree: this
    });
    this.model = this.createModel(_user, this.view, _options);
    onDidChangeCollapseStateRelay.input = this.model.onDidChangeCollapseState;
    const onDidModelSplice = _common_event__WEBPACK_IMPORTED_MODULE_16__.Event.forEach(this.model.onDidSplice, e => {
      this.eventBufferer.bufferEvents(() => {
        this.focus.onDidModelSplice(e);
        this.selection.onDidModelSplice(e);
      });
    }, this.disposables); // Make sure the `forEach` always runs

    onDidModelSplice(() => null, null, this.disposables); // Active nodes can change when the model changes or when focus or selection change.
    // We debounce it with 0 delay since these events may fire in the same stack and we only
    // want to run this once. It also doesn't matter if it runs on the next tick since it's only
    // a nice to have UI feature.

    onDidChangeActiveNodes.input = _common_event__WEBPACK_IMPORTED_MODULE_16__.Event.chain(_common_event__WEBPACK_IMPORTED_MODULE_16__.Event.any(onDidModelSplice, this.focus.onDidChange, this.selection.onDidChange)).debounce(() => null, 0).map(() => {
      const set = new Set();

      for (const node of this.focus.getNodes()) {
        set.add(node);
      }

      for (const node of this.selection.getNodes()) {
        set.add(node);
      }

      return [...set.values()];
    }).event;

    if (_options.keyboardSupport !== false) {
      const onKeyDown = _common_event__WEBPACK_IMPORTED_MODULE_16__.Event.chain(this.view.onKeyDown).filter(e => !(0,_browser_ui_list_listWidget__WEBPACK_IMPORTED_MODULE_7__.isInputElement)(e.target)).map(e => new _browser_keyboardEvent__WEBPACK_IMPORTED_MODULE_2__.StandardKeyboardEvent(e));
      onKeyDown.filter(e => e.keyCode === _common_keyCodes__WEBPACK_IMPORTED_MODULE_18__.KeyCode.LeftArrow).on(this.onLeftArrow, this, this.disposables);
      onKeyDown.filter(e => e.keyCode === _common_keyCodes__WEBPACK_IMPORTED_MODULE_18__.KeyCode.RightArrow).on(this.onRightArrow, this, this.disposables);
      onKeyDown.filter(e => e.keyCode === _common_keyCodes__WEBPACK_IMPORTED_MODULE_18__.KeyCode.Space).on(this.onSpace, this, this.disposables);
    }

    if ((_options.findWidgetEnabled ?? true) && _options.keyboardNavigationLabelProvider && _options.contextViewProvider) {
      this.findController = new FindController(this, this.model, this.view, filter, _options.contextViewProvider);

      this.focusNavigationFilter = node => this.findController.shouldAllowFocus(node);

      this.onDidChangeFindOpenState = this.findController.onDidChangeOpenState;
      this.disposables.add(this.findController);
      this.onDidChangeFindMode = this.findController.onDidChangeMode;
    } else {
      this.onDidChangeFindMode = _common_event__WEBPACK_IMPORTED_MODULE_16__.Event.None;
    }

    this.styleElement = (0,_browser_dom__WEBPACK_IMPORTED_MODULE_0__.createStyleSheet)(this.view.getHTMLElement());
    this.getHTMLElement().classList.toggle('always', this._options.renderIndentGuides === RenderIndentGuides.Always);
  }

  updateOptions(optionsUpdate = {}) {
    this._options = { ...this._options,
      ...optionsUpdate
    };

    for (const renderer of this.renderers) {
      renderer.updateOptions(optionsUpdate);
    }

    this.view.updateOptions(this._options);

    this._onDidUpdateOptions.fire(this._options);

    this.getHTMLElement().classList.toggle('always', this._options.renderIndentGuides === RenderIndentGuides.Always);
  }

  get options() {
    return this._options;
  }

  updateWidth(element) {
    const index = this.model.getListIndex(element);

    if (index === -1) {
      return;
    }

    this.view.updateWidth(index);
  } // Widget


  getHTMLElement() {
    return this.view.getHTMLElement();
  }

  get contentHeight() {
    return this.view.contentHeight;
  }

  get onDidChangeContentHeight() {
    return this.view.onDidChangeContentHeight;
  }

  get scrollTop() {
    return this.view.scrollTop;
  }

  set scrollTop(scrollTop) {
    this.view.scrollTop = scrollTop;
  }

  get scrollLeft() {
    return this.view.scrollLeft;
  }

  set scrollLeft(scrollLeft) {
    this.view.scrollLeft = scrollLeft;
  }

  get scrollHeight() {
    return this.view.scrollHeight;
  }

  get renderHeight() {
    return this.view.renderHeight;
  }

  get firstVisibleElement() {
    const index = this.view.firstVisibleIndex;

    if (index < 0 || index >= this.view.length) {
      return undefined;
    }

    const node = this.view.element(index);
    return node.element;
  }

  get lastVisibleElement() {
    const index = this.view.lastVisibleIndex;
    const node = this.view.element(index);
    return node.element;
  }

  get ariaLabel() {
    return this.view.ariaLabel;
  }

  set ariaLabel(value) {
    this.view.ariaLabel = value;
  }

  domFocus() {
    this.view.domFocus();
  }

  isDOMFocused() {
    return this.getHTMLElement() === document.activeElement;
  }

  layout(height, width) {
    this.view.layout(height, width);

    if ((0,_common_types__WEBPACK_IMPORTED_MODULE_21__.isNumber)(width)) {
      this.findController?.layout(width);
    }
  }

  style(styles) {
    const suffix = `.${this.view.domId}`;
    const content = [];

    if (styles.treeIndentGuidesStroke) {
      content.push(`.monaco-list${suffix}:hover .monaco-tl-indent > .indent-guide, .monaco-list${suffix}.always .monaco-tl-indent > .indent-guide  { border-color: ${styles.treeIndentGuidesStroke.transparent(0.4)}; }`);
      content.push(`.monaco-list${suffix} .monaco-tl-indent > .indent-guide.active { border-color: ${styles.treeIndentGuidesStroke}; }`);
    }

    this.styleElement.textContent = content.join('\n');
    this.findController?.style(styles);
    this.view.style(styles);
  } // Tree navigation


  getParentElement(location) {
    const parentRef = this.model.getParentNodeLocation(location);
    const parentNode = this.model.getNode(parentRef);
    return parentNode.element;
  }

  getFirstElementChild(location) {
    return this.model.getFirstElementChild(location);
  } // Tree


  getNode(location) {
    return this.model.getNode(location);
  }

  collapse(location, recursive = false) {
    return this.model.setCollapsed(location, true, recursive);
  }

  expand(location, recursive = false) {
    return this.model.setCollapsed(location, false, recursive);
  }

  toggleCollapsed(location, recursive = false) {
    return this.model.setCollapsed(location, undefined, recursive);
  }

  expandAll() {
    this.model.setCollapsed(this.model.rootRef, false, true);
  }

  collapseAll() {
    this.model.setCollapsed(this.model.rootRef, true, true);
  }

  isCollapsible(location) {
    return this.model.isCollapsible(location);
  }

  setCollapsible(location, collapsible) {
    return this.model.setCollapsible(location, collapsible);
  }

  isCollapsed(location) {
    return this.model.isCollapsed(location);
  }

  triggerTypeNavigation() {
    this.view.triggerTypeNavigation();
  }

  openFind() {
    this.findController?.open();
  }

  closeFind() {
    this.findController?.close();
  }

  refilter() {
    this._onWillRefilter.fire(undefined);

    this.model.refilter();
  }

  setAnchor(element) {
    if (typeof element === 'undefined') {
      return this.view.setAnchor(undefined);
    }

    const node = this.model.getNode(element);
    this.anchor.set([node]);
    const index = this.model.getListIndex(element);

    if (index > -1) {
      this.view.setAnchor(index, true);
    }
  }

  getAnchor() {
    return (0,_common_arrays__WEBPACK_IMPORTED_MODULE_12__.firstOrDefault)(this.anchor.get(), undefined);
  }

  setSelection(elements, browserEvent) {
    const nodes = elements.map(e => this.model.getNode(e));
    this.selection.set(nodes, browserEvent);
    const indexes = elements.map(e => this.model.getListIndex(e)).filter(i => i > -1);
    this.view.setSelection(indexes, browserEvent, true);
  }

  getSelection() {
    return this.selection.get();
  }

  setFocus(elements, browserEvent) {
    const nodes = elements.map(e => this.model.getNode(e));
    this.focus.set(nodes, browserEvent);
    const indexes = elements.map(e => this.model.getListIndex(e)).filter(i => i > -1);
    this.view.setFocus(indexes, browserEvent, true);
  }

  focusNext(n = 1, loop = false, browserEvent, filter = this.focusNavigationFilter) {
    this.view.focusNext(n, loop, browserEvent, filter);
  }

  focusPrevious(n = 1, loop = false, browserEvent, filter = this.focusNavigationFilter) {
    this.view.focusPrevious(n, loop, browserEvent, filter);
  }

  focusNextPage(browserEvent, filter = this.focusNavigationFilter) {
    return this.view.focusNextPage(browserEvent, filter);
  }

  focusPreviousPage(browserEvent, filter = this.focusNavigationFilter) {
    return this.view.focusPreviousPage(browserEvent, filter);
  }

  focusLast(browserEvent, filter = this.focusNavigationFilter) {
    this.view.focusLast(browserEvent, filter);
  }

  focusFirst(browserEvent, filter = this.focusNavigationFilter) {
    this.view.focusFirst(browserEvent, filter);
  }

  getFocus() {
    return this.focus.get();
  }

  reveal(location, relativeTop) {
    this.model.expandTo(location);
    const index = this.model.getListIndex(location);

    if (index === -1) {
      return;
    }

    this.view.reveal(index, relativeTop);
  }
  /**
   * Returns the relative position of an element rendered in the list.
   * Returns `null` if the element isn't *entirely* in the visible viewport.
   */


  getRelativeTop(location) {
    const index = this.model.getListIndex(location);

    if (index === -1) {
      return null;
    }

    return this.view.getRelativeTop(index);
  }

  getViewState(identityProvider = this.options.identityProvider) {
    if (!identityProvider) {
      throw new _browser_ui_tree_tree__WEBPACK_IMPORTED_MODULE_10__.TreeError(this._user, 'Can\'t get tree view state without an identity provider');
    }

    const getId = element => identityProvider.getId(element).toString();

    const state = AbstractTreeViewState.empty(this.scrollTop);

    for (const focus of this.getFocus()) {
      state.focus.add(getId(focus));
    }

    for (const selection of this.getSelection()) {
      state.selection.add(getId(selection));
    }

    const root = this.model.getNode();
    const queue = [root];

    while (queue.length > 0) {
      const node = queue.shift();

      if (node !== root && node.collapsible) {
        state.expanded[getId(node.element)] = node.collapsed ? 0 : 1;
      }

      queue.push(...node.children);
    }

    return state;
  } // List


  onLeftArrow(e) {
    e.preventDefault();
    e.stopPropagation();
    const nodes = this.view.getFocusedElements();

    if (nodes.length === 0) {
      return;
    }

    const node = nodes[0];
    const location = this.model.getNodeLocation(node);
    const didChange = this.model.setCollapsed(location, true);

    if (!didChange) {
      const parentLocation = this.model.getParentNodeLocation(location);

      if (!parentLocation) {
        return;
      }

      const parentListIndex = this.model.getListIndex(parentLocation);
      this.view.reveal(parentListIndex);
      this.view.setFocus([parentListIndex]);
    }
  }

  onRightArrow(e) {
    e.preventDefault();
    e.stopPropagation();
    const nodes = this.view.getFocusedElements();

    if (nodes.length === 0) {
      return;
    }

    const node = nodes[0];
    const location = this.model.getNodeLocation(node);
    const didChange = this.model.setCollapsed(location, false);

    if (!didChange) {
      if (!node.children.some(child => child.visible)) {
        return;
      }

      const [focusedIndex] = this.view.getFocus();
      const firstChildIndex = focusedIndex + 1;
      this.view.reveal(firstChildIndex);
      this.view.setFocus([firstChildIndex]);
    }
  }

  onSpace(e) {
    e.preventDefault();
    e.stopPropagation();
    const nodes = this.view.getFocusedElements();

    if (nodes.length === 0) {
      return;
    }

    const node = nodes[0];
    const location = this.model.getNodeLocation(node);
    const recursive = e.browserEvent.altKey;
    this.model.setCollapsed(location, undefined, recursive);
  }

  navigate(start) {
    return new TreeNavigator(this.view, this.model, start);
  }

  dispose() {
    (0,_common_lifecycle__WEBPACK_IMPORTED_MODULE_19__.dispose)(this.disposables);
    this.view.dispose();
  }

}

class TreeNavigator {
  constructor(view, model, start) {
    this.view = view;
    this.model = model;

    if (start) {
      this.index = this.model.getListIndex(start);
    } else {
      this.index = -1;
    }
  }

  current() {
    if (this.index < 0 || this.index >= this.view.length) {
      return null;
    }

    return this.view.element(this.index).element;
  }

  previous() {
    this.index--;
    return this.current();
  }

  next() {
    this.index++;
    return this.current();
  }

  first() {
    this.index = 0;
    return this.current();
  }

  last() {
    this.index = this.view.length - 1;
    return this.current();
  }

}

/***/ }),
/* 115 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ActionsOrientation": () => (/* binding */ ActionsOrientation),
/* harmony export */   "ActionBar": () => (/* binding */ ActionBar),
/* harmony export */   "prepareActions": () => (/* binding */ prepareActions)
/* harmony export */ });
/* harmony import */ var _browser_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(61);
/* harmony import */ var _browser_keyboardEvent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(63);
/* harmony import */ var _browser_ui_actionbar_actionViewItems__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(116);
/* harmony import */ var _common_actions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(150);
/* harmony import */ var _common_event__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(51);
/* harmony import */ var _common_keyCodes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(64);
/* harmony import */ var _common_lifecycle__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(54);
/* harmony import */ var _common_types__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(79);
/* harmony import */ var _actionbar_css__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(151);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









let ActionsOrientation;

(function (ActionsOrientation) {
  ActionsOrientation[ActionsOrientation["HORIZONTAL"] = 0] = "HORIZONTAL";
  ActionsOrientation[ActionsOrientation["VERTICAL"] = 1] = "VERTICAL";
})(ActionsOrientation || (ActionsOrientation = {}));

class ActionBar extends _common_lifecycle__WEBPACK_IMPORTED_MODULE_6__.Disposable {
  _actionRunnerDisposables = this._register(new _common_lifecycle__WEBPACK_IMPORTED_MODULE_6__.DisposableStore());
  // Trigger Key Tracking
  triggerKeyDown = false;
  focusable = true; // Elements

  _onDidBlur = this._register(new _common_event__WEBPACK_IMPORTED_MODULE_4__.Emitter());
  onDidBlur = this._onDidBlur.event;
  _onDidCancel = this._register(new _common_event__WEBPACK_IMPORTED_MODULE_4__.Emitter({
    onFirstListenerAdd: () => this.cancelHasListener = true
  }));
  onDidCancel = this._onDidCancel.event;
  cancelHasListener = false;
  _onDidRun = this._register(new _common_event__WEBPACK_IMPORTED_MODULE_4__.Emitter());
  onDidRun = this._onDidRun.event;
  _onWillRun = this._register(new _common_event__WEBPACK_IMPORTED_MODULE_4__.Emitter());
  onWillRun = this._onWillRun.event;

  constructor(container, options = {}) {
    super();
    this.options = options;
    this._context = options.context ?? null;
    this._orientation = this.options.orientation ?? ActionsOrientation.HORIZONTAL;
    this._triggerKeys = {
      keyDown: this.options.triggerKeys?.keyDown ?? false,
      keys: this.options.triggerKeys?.keys ?? [_common_keyCodes__WEBPACK_IMPORTED_MODULE_5__.KeyCode.Enter, _common_keyCodes__WEBPACK_IMPORTED_MODULE_5__.KeyCode.Space]
    };

    if (this.options.actionRunner) {
      this._actionRunner = this.options.actionRunner;
    } else {
      this._actionRunner = new _common_actions__WEBPACK_IMPORTED_MODULE_3__.ActionRunner();

      this._actionRunnerDisposables.add(this._actionRunner);
    }

    this._actionRunnerDisposables.add(this._actionRunner.onDidRun(e => this._onDidRun.fire(e)));

    this._actionRunnerDisposables.add(this._actionRunner.onWillRun(e => this._onWillRun.fire(e)));

    this.viewItems = [];
    this.viewItemDisposables = new Map();
    this.focusedItem = undefined;
    this.domNode = document.createElement('div');
    this.domNode.className = 'monaco-action-bar';

    if (options.animated !== false) {
      this.domNode.classList.add('animated');
    }

    let previousKeys;
    let nextKeys;

    switch (this._orientation) {
      case ActionsOrientation.HORIZONTAL:
        previousKeys = [_common_keyCodes__WEBPACK_IMPORTED_MODULE_5__.KeyCode.LeftArrow];
        nextKeys = [_common_keyCodes__WEBPACK_IMPORTED_MODULE_5__.KeyCode.RightArrow];
        break;

      case ActionsOrientation.VERTICAL:
        previousKeys = [_common_keyCodes__WEBPACK_IMPORTED_MODULE_5__.KeyCode.UpArrow];
        nextKeys = [_common_keyCodes__WEBPACK_IMPORTED_MODULE_5__.KeyCode.DownArrow];
        this.domNode.className += ' vertical';
        break;
    }

    this._register(_browser_dom__WEBPACK_IMPORTED_MODULE_0__.addDisposableListener(this.domNode, _browser_dom__WEBPACK_IMPORTED_MODULE_0__.EventType.KEY_DOWN, e => {
      const event = new _browser_keyboardEvent__WEBPACK_IMPORTED_MODULE_1__.StandardKeyboardEvent(e);
      let eventHandled = true;
      const focusedItem = typeof this.focusedItem === 'number' ? this.viewItems[this.focusedItem] : undefined;

      if (previousKeys && (event.equals(previousKeys[0]) || event.equals(previousKeys[1]))) {
        eventHandled = this.focusPrevious();
      } else if (nextKeys && (event.equals(nextKeys[0]) || event.equals(nextKeys[1]))) {
        eventHandled = this.focusNext();
      } else if (event.equals(_common_keyCodes__WEBPACK_IMPORTED_MODULE_5__.KeyCode.Escape) && this.cancelHasListener) {
        this._onDidCancel.fire();
      } else if (event.equals(_common_keyCodes__WEBPACK_IMPORTED_MODULE_5__.KeyCode.Home)) {
        eventHandled = this.focusFirst();
      } else if (event.equals(_common_keyCodes__WEBPACK_IMPORTED_MODULE_5__.KeyCode.End)) {
        eventHandled = this.focusLast();
      } else if (event.equals(_common_keyCodes__WEBPACK_IMPORTED_MODULE_5__.KeyCode.Tab) && focusedItem instanceof _browser_ui_actionbar_actionViewItems__WEBPACK_IMPORTED_MODULE_2__.BaseActionViewItem && focusedItem.trapsArrowNavigation) {
        eventHandled = this.focusNext();
      } else if (this.isTriggerKeyEvent(event)) {
        // Staying out of the else branch even if not triggered
        if (this._triggerKeys.keyDown) {
          this.doTrigger(event);
        } else {
          this.triggerKeyDown = true;
        }
      } else {
        eventHandled = false;
      }

      if (eventHandled) {
        event.preventDefault();
        event.stopPropagation();
      }
    }));

    this._register(_browser_dom__WEBPACK_IMPORTED_MODULE_0__.addDisposableListener(this.domNode, _browser_dom__WEBPACK_IMPORTED_MODULE_0__.EventType.KEY_UP, e => {
      const event = new _browser_keyboardEvent__WEBPACK_IMPORTED_MODULE_1__.StandardKeyboardEvent(e); // Run action on Enter/Space

      if (this.isTriggerKeyEvent(event)) {
        if (!this._triggerKeys.keyDown && this.triggerKeyDown) {
          this.triggerKeyDown = false;
          this.doTrigger(event);
        }

        event.preventDefault();
        event.stopPropagation();
      } // Recompute focused item
      else if (event.equals(_common_keyCodes__WEBPACK_IMPORTED_MODULE_5__.KeyCode.Tab) || event.equals(_common_keyCodes__WEBPACK_IMPORTED_MODULE_5__.KeyMod.Shift | _common_keyCodes__WEBPACK_IMPORTED_MODULE_5__.KeyCode.Tab)) {
        this.updateFocusedItem();
      }
    }));

    this.focusTracker = this._register(_browser_dom__WEBPACK_IMPORTED_MODULE_0__.trackFocus(this.domNode));

    this._register(this.focusTracker.onDidBlur(() => {
      if (_browser_dom__WEBPACK_IMPORTED_MODULE_0__.getActiveElement() === this.domNode || !_browser_dom__WEBPACK_IMPORTED_MODULE_0__.isAncestor(_browser_dom__WEBPACK_IMPORTED_MODULE_0__.getActiveElement(), this.domNode)) {
        this._onDidBlur.fire();

        this.focusedItem = undefined;
        this.previouslyFocusedItem = undefined;
        this.triggerKeyDown = false;
      }
    }));

    this._register(this.focusTracker.onDidFocus(() => this.updateFocusedItem()));

    this.actionsList = document.createElement('ul');
    this.actionsList.className = 'actions-container';
    this.actionsList.setAttribute('role', this.options.ariaRole || 'toolbar');

    if (this.options.ariaLabel) {
      this.actionsList.setAttribute('aria-label', this.options.ariaLabel);
    }

    this.domNode.appendChild(this.actionsList);
    container.appendChild(this.domNode);
  }

  refreshRole() {
    if (this.length() >= 2) {
      this.actionsList.setAttribute('role', this.options.ariaRole || 'toolbar');
    } else {
      this.actionsList.setAttribute('role', 'presentation');
    }
  }

  setAriaLabel(label) {
    if (label) {
      this.actionsList.setAttribute('aria-label', label);
    } else {
      this.actionsList.removeAttribute('aria-label');
    }
  } // Some action bars should not be focusable at times
  // When an action bar is not focusable make sure to make all the elements inside it not focusable
  // When an action bar is focusable again, make sure the first item can be focused


  setFocusable(focusable) {
    this.focusable = focusable;

    if (this.focusable) {
      const firstEnabled = this.viewItems.find(vi => vi instanceof _browser_ui_actionbar_actionViewItems__WEBPACK_IMPORTED_MODULE_2__.BaseActionViewItem && vi.isEnabled());

      if (firstEnabled instanceof _browser_ui_actionbar_actionViewItems__WEBPACK_IMPORTED_MODULE_2__.BaseActionViewItem) {
        firstEnabled.setFocusable(true);
      }
    } else {
      this.viewItems.forEach(vi => {
        if (vi instanceof _browser_ui_actionbar_actionViewItems__WEBPACK_IMPORTED_MODULE_2__.BaseActionViewItem) {
          vi.setFocusable(false);
        }
      });
    }
  }

  isTriggerKeyEvent(event) {
    let ret = false;

    this._triggerKeys.keys.forEach(keyCode => {
      ret = ret || event.equals(keyCode);
    });

    return ret;
  }

  updateFocusedItem() {
    for (let i = 0; i < this.actionsList.children.length; i++) {
      const elem = this.actionsList.children[i];

      if (_browser_dom__WEBPACK_IMPORTED_MODULE_0__.isAncestor(_browser_dom__WEBPACK_IMPORTED_MODULE_0__.getActiveElement(), elem)) {
        this.focusedItem = i;
        break;
      }
    }
  }

  get context() {
    return this._context;
  }

  set context(context) {
    this._context = context;
    this.viewItems.forEach(i => i.setActionContext(context));
  }

  get actionRunner() {
    return this._actionRunner;
  }

  set actionRunner(actionRunner) {
    this._actionRunner = actionRunner; // when setting a new `IActionRunner` make sure to dispose old listeners and
    // start to forward events from the new listener

    this._actionRunnerDisposables.clear();

    this._actionRunnerDisposables.add(this._actionRunner.onDidRun(e => this._onDidRun.fire(e)));

    this._actionRunnerDisposables.add(this._actionRunner.onWillRun(e => this._onWillRun.fire(e)));

    this.viewItems.forEach(item => item.actionRunner = actionRunner);
  }

  getContainer() {
    return this.domNode;
  }

  hasAction(action) {
    return this.viewItems.findIndex(candidate => candidate.action.id === action.id) !== -1;
  }

  getAction(indexOrElement) {
    // by index
    if (typeof indexOrElement === 'number') {
      return this.viewItems[indexOrElement]?.action;
    } // by element


    if (indexOrElement instanceof HTMLElement) {
      while (indexOrElement.parentElement !== this.actionsList) {
        if (!indexOrElement.parentElement) {
          return undefined;
        }

        indexOrElement = indexOrElement.parentElement;
      }

      for (let i = 0; i < this.actionsList.childNodes.length; i++) {
        if (this.actionsList.childNodes[i] === indexOrElement) {
          return this.viewItems[i].action;
        }
      }
    }

    return undefined;
  }

  push(arg, options = {}) {
    const actions = Array.isArray(arg) ? arg : [arg];
    let index = _common_types__WEBPACK_IMPORTED_MODULE_7__.isNumber(options.index) ? options.index : null;
    actions.forEach(action => {
      const actionViewItemElement = document.createElement('li');
      actionViewItemElement.className = 'action-item';
      actionViewItemElement.setAttribute('role', 'presentation');
      let item;

      if (this.options.actionViewItemProvider) {
        item = this.options.actionViewItemProvider(action);
      }

      if (!item) {
        item = new _browser_ui_actionbar_actionViewItems__WEBPACK_IMPORTED_MODULE_2__.ActionViewItem(this.context, action, {
          hoverDelegate: this.options.hoverDelegate,
          ...options
        });
      } // Prevent native context menu on actions


      if (!this.options.allowContextMenu) {
        this.viewItemDisposables.set(item, _browser_dom__WEBPACK_IMPORTED_MODULE_0__.addDisposableListener(actionViewItemElement, _browser_dom__WEBPACK_IMPORTED_MODULE_0__.EventType.CONTEXT_MENU, e => {
          _browser_dom__WEBPACK_IMPORTED_MODULE_0__.EventHelper.stop(e, true);
        }));
      }

      item.actionRunner = this._actionRunner;
      item.setActionContext(this.context);
      item.render(actionViewItemElement);

      if (this.focusable && item instanceof _browser_ui_actionbar_actionViewItems__WEBPACK_IMPORTED_MODULE_2__.BaseActionViewItem && this.viewItems.length === 0) {
        // We need to allow for the first enabled item to be focused on using tab navigation #106441
        item.setFocusable(true);
      }

      if (index === null || index < 0 || index >= this.actionsList.children.length) {
        this.actionsList.appendChild(actionViewItemElement);
        this.viewItems.push(item);
      } else {
        this.actionsList.insertBefore(actionViewItemElement, this.actionsList.children[index]);
        this.viewItems.splice(index, 0, item);
        index++;
      }
    });

    if (typeof this.focusedItem === 'number') {
      // After a clear actions might be re-added to simply toggle some actions. We should preserve focus #97128
      this.focus(this.focusedItem);
    }

    this.refreshRole();
  }

  getWidth(index) {
    if (index >= 0 && index < this.actionsList.children.length) {
      const item = this.actionsList.children.item(index);

      if (item) {
        return item.clientWidth;
      }
    }

    return 0;
  }

  getHeight(index) {
    if (index >= 0 && index < this.actionsList.children.length) {
      const item = this.actionsList.children.item(index);

      if (item) {
        return item.clientHeight;
      }
    }

    return 0;
  }

  pull(index) {
    if (index >= 0 && index < this.viewItems.length) {
      this.actionsList.removeChild(this.actionsList.childNodes[index]);
      this.viewItemDisposables.get(this.viewItems[index])?.dispose();
      this.viewItemDisposables.delete(this.viewItems[index]);
      (0,_common_lifecycle__WEBPACK_IMPORTED_MODULE_6__.dispose)(this.viewItems.splice(index, 1));
      this.refreshRole();
    }
  }

  clear() {
    (0,_common_lifecycle__WEBPACK_IMPORTED_MODULE_6__.dispose)(this.viewItems);
    (0,_common_lifecycle__WEBPACK_IMPORTED_MODULE_6__.dispose)(this.viewItemDisposables.values());
    this.viewItemDisposables.clear();
    this.viewItems = [];
    _browser_dom__WEBPACK_IMPORTED_MODULE_0__.clearNode(this.actionsList);
    this.refreshRole();
  }

  length() {
    return this.viewItems.length;
  }

  isEmpty() {
    return this.viewItems.length === 0;
  }

  focus(arg) {
    let selectFirst = false;
    let index = undefined;

    if (arg === undefined) {
      selectFirst = true;
    } else if (typeof arg === 'number') {
      index = arg;
    } else if (typeof arg === 'boolean') {
      selectFirst = arg;
    }

    if (selectFirst && typeof this.focusedItem === 'undefined') {
      const firstEnabled = this.viewItems.findIndex(item => item.isEnabled()); // Focus the first enabled item

      this.focusedItem = firstEnabled === -1 ? undefined : firstEnabled;
      this.updateFocus(undefined, undefined, true);
    } else {
      if (index !== undefined) {
        this.focusedItem = index;
      }

      this.updateFocus(undefined, undefined, true);
    }
  }

  focusFirst() {
    this.focusedItem = this.length() - 1;
    return this.focusNext(true);
  }

  focusLast() {
    this.focusedItem = 0;
    return this.focusPrevious(true);
  }

  focusNext(forceLoop) {
    if (typeof this.focusedItem === 'undefined') {
      this.focusedItem = this.viewItems.length - 1;
    } else if (this.viewItems.length <= 1) {
      return false;
    }

    const startIndex = this.focusedItem;
    let item;

    do {
      if (!forceLoop && this.options.preventLoopNavigation && this.focusedItem + 1 >= this.viewItems.length) {
        this.focusedItem = startIndex;
        return false;
      }

      this.focusedItem = (this.focusedItem + 1) % this.viewItems.length;
      item = this.viewItems[this.focusedItem];
    } while (this.focusedItem !== startIndex && (this.options.focusOnlyEnabledItems && !item.isEnabled() || item.action.id === _common_actions__WEBPACK_IMPORTED_MODULE_3__.Separator.ID));

    this.updateFocus();
    return true;
  }

  focusPrevious(forceLoop) {
    if (typeof this.focusedItem === 'undefined') {
      this.focusedItem = 0;
    } else if (this.viewItems.length <= 1) {
      return false;
    }

    const startIndex = this.focusedItem;
    let item;

    do {
      this.focusedItem = this.focusedItem - 1;

      if (this.focusedItem < 0) {
        if (!forceLoop && this.options.preventLoopNavigation) {
          this.focusedItem = startIndex;
          return false;
        }

        this.focusedItem = this.viewItems.length - 1;
      }

      item = this.viewItems[this.focusedItem];
    } while (this.focusedItem !== startIndex && (this.options.focusOnlyEnabledItems && !item.isEnabled() || item.action.id === _common_actions__WEBPACK_IMPORTED_MODULE_3__.Separator.ID));

    this.updateFocus(true);
    return true;
  }

  updateFocus(fromRight, preventScroll, forceFocus = false) {
    if (typeof this.focusedItem === 'undefined') {
      this.actionsList.focus({
        preventScroll
      });
    }

    if (this.previouslyFocusedItem !== undefined && this.previouslyFocusedItem !== this.focusedItem) {
      this.viewItems[this.previouslyFocusedItem]?.blur();
    }

    const actionViewItem = this.focusedItem !== undefined && this.viewItems[this.focusedItem];

    if (actionViewItem) {
      let focusItem = true;

      if (!_common_types__WEBPACK_IMPORTED_MODULE_7__.isFunction(actionViewItem.focus)) {
        focusItem = false;
      }

      if (this.options.focusOnlyEnabledItems && _common_types__WEBPACK_IMPORTED_MODULE_7__.isFunction(actionViewItem.isEnabled) && !actionViewItem.isEnabled()) {
        focusItem = false;
      }

      if (actionViewItem.action.id === _common_actions__WEBPACK_IMPORTED_MODULE_3__.Separator.ID) {
        focusItem = false;
      }

      if (!focusItem) {
        this.actionsList.focus({
          preventScroll
        });
        this.previouslyFocusedItem = undefined;
      } else if (forceFocus || this.previouslyFocusedItem !== this.focusedItem) {
        actionViewItem.focus(fromRight);
        this.previouslyFocusedItem = this.focusedItem;
      }
    }
  }

  doTrigger(event) {
    if (typeof this.focusedItem === 'undefined') {
      return; //nothing to focus
    } // trigger action


    const actionViewItem = this.viewItems[this.focusedItem];

    if (actionViewItem instanceof _browser_ui_actionbar_actionViewItems__WEBPACK_IMPORTED_MODULE_2__.BaseActionViewItem) {
      const context = actionViewItem._context === null || actionViewItem._context === undefined ? event : actionViewItem._context;
      this.run(actionViewItem._action, context);
    }
  }

  async run(action, context) {
    await this._actionRunner.run(action, context);
  }

  dispose() {
    (0,_common_lifecycle__WEBPACK_IMPORTED_MODULE_6__.dispose)(this.viewItems);
    this.viewItems = [];
    this.getContainer().remove();
    super.dispose();
  }

}
function prepareActions(actions) {
  if (!actions.length) {
    return actions;
  } // Clean up leading separators


  let firstIndexOfAction = -1;

  for (let i = 0; i < actions.length; i++) {
    if (actions[i].id === _common_actions__WEBPACK_IMPORTED_MODULE_3__.Separator.ID) {
      continue;
    }

    firstIndexOfAction = i;
    break;
  }

  if (firstIndexOfAction === -1) {
    return [];
  }

  actions = actions.slice(firstIndexOfAction); // Clean up trailing separators

  for (let h = actions.length - 1; h >= 0; h--) {
    const isSeparator = actions[h].id === _common_actions__WEBPACK_IMPORTED_MODULE_3__.Separator.ID;

    if (isSeparator) {
      actions.splice(h, 1);
    } else {
      break;
    }
  } // Clean up separator duplicates


  let foundAction = false;

  for (let k = actions.length - 1; k >= 0; k--) {
    const isSeparator = actions[k].id === _common_actions__WEBPACK_IMPORTED_MODULE_3__.Separator.ID;

    if (isSeparator && !foundAction) {
      actions.splice(k, 1);
    } else if (!isSeparator) {
      foundAction = true;
    } else if (isSeparator) {
      foundAction = false;
    }
  }

  return actions;
}

/***/ }),
/* 116 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseActionViewItem": () => (/* binding */ BaseActionViewItem),
/* harmony export */   "ActionViewItem": () => (/* binding */ ActionViewItem),
/* harmony export */   "SelectActionViewItem": () => (/* binding */ SelectActionViewItem)
/* harmony export */ });
/* harmony import */ var _browser_browser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(50);
/* harmony import */ var _browser_dnd__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(60);
/* harmony import */ var _browser_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(61);
/* harmony import */ var _browser_touch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(86);
/* harmony import */ var _browser_ui_iconLabel_iconLabelHover__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(117);
/* harmony import */ var _browser_ui_selectBox_selectBox__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(124);
/* harmony import */ var _common_actions__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(150);
/* harmony import */ var _common_lifecycle__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(54);
/* harmony import */ var _common_platform__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(58);
/* harmony import */ var _common_types__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(79);
/* harmony import */ var _actionbar_css__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(151);
/* harmony import */ var _common_nls__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(59);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/












class BaseActionViewItem extends _common_lifecycle__WEBPACK_IMPORTED_MODULE_7__.Disposable {
  get action() {
    return this._action;
  }

  constructor(context, action, options = {}) {
    super();
    this.options = options;
    this._context = context || this;
    this._action = action;

    if (action instanceof _common_actions__WEBPACK_IMPORTED_MODULE_6__.Action) {
      this._register(action.onDidChange(event => {
        if (!this.element) {
          // we have not been rendered yet, so there
          // is no point in updating the UI
          return;
        }

        this.handleActionChangeEvent(event);
      }));
    }
  }

  handleActionChangeEvent(event) {
    if (event.enabled !== undefined) {
      this.updateEnabled();
    }

    if (event.checked !== undefined) {
      this.updateChecked();
    }

    if (event.class !== undefined) {
      this.updateClass();
    }

    if (event.label !== undefined) {
      this.updateLabel();
      this.updateTooltip();
    }

    if (event.tooltip !== undefined) {
      this.updateTooltip();
    }
  }

  get actionRunner() {
    if (!this._actionRunner) {
      this._actionRunner = this._register(new _common_actions__WEBPACK_IMPORTED_MODULE_6__.ActionRunner());
    }

    return this._actionRunner;
  }

  set actionRunner(actionRunner) {
    this._actionRunner = actionRunner;
  }

  isEnabled() {
    return this._action.enabled;
  }

  setActionContext(newContext) {
    this._context = newContext;
  }

  render(container) {
    const element = this.element = container;

    this._register(_browser_touch__WEBPACK_IMPORTED_MODULE_3__.Gesture.addTarget(container));

    const enableDragging = this.options && this.options.draggable;

    if (enableDragging) {
      container.draggable = true;

      if (_browser_browser__WEBPACK_IMPORTED_MODULE_0__.isFirefox) {
        // Firefox: requires to set a text data transfer to get going
        this._register((0,_browser_dom__WEBPACK_IMPORTED_MODULE_2__.addDisposableListener)(container, _browser_dom__WEBPACK_IMPORTED_MODULE_2__.EventType.DRAG_START, e => e.dataTransfer?.setData(_browser_dnd__WEBPACK_IMPORTED_MODULE_1__.DataTransfers.TEXT, this._action.label)));
      }
    }

    this._register((0,_browser_dom__WEBPACK_IMPORTED_MODULE_2__.addDisposableListener)(element, _browser_touch__WEBPACK_IMPORTED_MODULE_3__.EventType.Tap, e => this.onClick(e, true))); // Preserve focus on tap #125470


    this._register((0,_browser_dom__WEBPACK_IMPORTED_MODULE_2__.addDisposableListener)(element, _browser_dom__WEBPACK_IMPORTED_MODULE_2__.EventType.MOUSE_DOWN, e => {
      if (!enableDragging) {
        _browser_dom__WEBPACK_IMPORTED_MODULE_2__.EventHelper.stop(e, true); // do not run when dragging is on because that would disable it
      }

      if (this._action.enabled && e.button === 0) {
        element.classList.add('active');
      }
    }));

    if (_common_platform__WEBPACK_IMPORTED_MODULE_8__.isMacintosh) {
      // macOS: allow to trigger the button when holding Ctrl+key and pressing the
      // main mouse button. This is for scenarios where e.g. some interaction forces
      // the Ctrl+key to be pressed and hold but the user still wants to interact
      // with the actions (for example quick access in quick navigation mode).
      this._register((0,_browser_dom__WEBPACK_IMPORTED_MODULE_2__.addDisposableListener)(element, _browser_dom__WEBPACK_IMPORTED_MODULE_2__.EventType.CONTEXT_MENU, e => {
        if (e.button === 0 && e.ctrlKey === true) {
          this.onClick(e);
        }
      }));
    }

    this._register((0,_browser_dom__WEBPACK_IMPORTED_MODULE_2__.addDisposableListener)(element, _browser_dom__WEBPACK_IMPORTED_MODULE_2__.EventType.CLICK, e => {
      _browser_dom__WEBPACK_IMPORTED_MODULE_2__.EventHelper.stop(e, true); // menus do not use the click event

      if (!(this.options && this.options.isMenu)) {
        this.onClick(e);
      }
    }));

    this._register((0,_browser_dom__WEBPACK_IMPORTED_MODULE_2__.addDisposableListener)(element, _browser_dom__WEBPACK_IMPORTED_MODULE_2__.EventType.DBLCLICK, e => {
      _browser_dom__WEBPACK_IMPORTED_MODULE_2__.EventHelper.stop(e, true);
    }));

    [_browser_dom__WEBPACK_IMPORTED_MODULE_2__.EventType.MOUSE_UP, _browser_dom__WEBPACK_IMPORTED_MODULE_2__.EventType.MOUSE_OUT].forEach(event => {
      this._register((0,_browser_dom__WEBPACK_IMPORTED_MODULE_2__.addDisposableListener)(element, event, e => {
        _browser_dom__WEBPACK_IMPORTED_MODULE_2__.EventHelper.stop(e);
        element.classList.remove('active');
      }));
    });
  }

  onClick(event, preserveFocus = false) {
    _browser_dom__WEBPACK_IMPORTED_MODULE_2__.EventHelper.stop(event, true);
    const context = _common_types__WEBPACK_IMPORTED_MODULE_9__.isUndefinedOrNull(this._context) ? this.options?.useEventAsContext ? event : {
      preserveFocus
    } : this._context;
    this.actionRunner.run(this._action, context);
  } // Only set the tabIndex on the element once it is about to get focused
  // That way this element wont be a tab stop when it is not needed #106441


  focus() {
    if (this.element) {
      this.element.tabIndex = 0;
      this.element.focus();
      this.element.classList.add('focused');
    }
  }

  isFocused() {
    return !!this.element?.classList.contains('focused');
  }

  blur() {
    if (this.element) {
      this.element.blur();
      this.element.tabIndex = -1;
      this.element.classList.remove('focused');
    }
  }

  setFocusable(focusable) {
    if (this.element) {
      this.element.tabIndex = focusable ? 0 : -1;
    }
  }

  get trapsArrowNavigation() {
    return false;
  }

  updateEnabled() {// implement in subclass
  }

  updateLabel() {// implement in subclass
  }

  getTooltip() {
    return this.action.tooltip;
  }

  updateTooltip() {
    if (!this.element) {
      return;
    }

    const title = this.getTooltip() ?? '';
    this.updateAriaLabel();

    if (!this.options.hoverDelegate) {
      this.element.title = title;
    } else {
      this.element.title = '';

      if (!this.customHover) {
        this.customHover = (0,_browser_ui_iconLabel_iconLabelHover__WEBPACK_IMPORTED_MODULE_4__.setupCustomHover)(this.options.hoverDelegate, this.element, title);

        this._store.add(this.customHover);
      } else {
        this.customHover.update(title);
      }
    }
  }

  updateAriaLabel() {
    if (this.element) {
      const title = this.getTooltip() ?? '';
      this.element.setAttribute('aria-label', title);
    }
  }

  updateClass() {// implement in subclass
  }

  updateChecked() {// implement in subclass
  }

  dispose() {
    if (this.element) {
      this.element.remove();
      this.element = undefined;
    }

    super.dispose();
  }

}
class ActionViewItem extends BaseActionViewItem {
  constructor(context, action, options = {}) {
    super(context, action, options);
    this.options = options;
    this.options.icon = options.icon !== undefined ? options.icon : false;
    this.options.label = options.label !== undefined ? options.label : true;
    this.cssClass = '';
  }

  render(container) {
    super.render(container);

    if (this.element) {
      this.label = (0,_browser_dom__WEBPACK_IMPORTED_MODULE_2__.append)(this.element, (0,_browser_dom__WEBPACK_IMPORTED_MODULE_2__.$)('a.action-label'));
    }

    if (this.label) {
      if (this._action.id === _common_actions__WEBPACK_IMPORTED_MODULE_6__.Separator.ID) {
        this.label.setAttribute('role', 'presentation'); // A separator is a presentation item
      } else {
        if (this.options.isMenu) {
          this.label.setAttribute('role', 'menuitem');
        } else {
          this.label.setAttribute('role', 'button');
        }
      }
    }

    if (this.options.label && this.options.keybinding && this.element) {
      (0,_browser_dom__WEBPACK_IMPORTED_MODULE_2__.append)(this.element, (0,_browser_dom__WEBPACK_IMPORTED_MODULE_2__.$)('span.keybinding')).textContent = this.options.keybinding;
    }

    this.updateClass();
    this.updateLabel();
    this.updateTooltip();
    this.updateEnabled();
    this.updateChecked();
  } // Only set the tabIndex on the element once it is about to get focused
  // That way this element wont be a tab stop when it is not needed #106441


  focus() {
    if (this.label) {
      this.label.tabIndex = 0;
      this.label.focus();
    }
  }

  isFocused() {
    return !!this.label && this.label?.tabIndex === 0;
  }

  blur() {
    if (this.label) {
      this.label.tabIndex = -1;
    }
  }

  setFocusable(focusable) {
    if (this.label) {
      this.label.tabIndex = focusable ? 0 : -1;
    }
  }

  updateLabel() {
    if (this.options.label && this.label) {
      this.label.textContent = this.action.label;
    }
  }

  getTooltip() {
    let title = null;

    if (this.action.tooltip) {
      title = this.action.tooltip;
    } else if (!this.options.label && this.action.label && this.options.icon) {
      title = this.action.label;

      if (this.options.keybinding) {
        title = _common_nls__WEBPACK_IMPORTED_MODULE_11__.localize({
          key: 'titleLabel',
          comment: ['action title', 'action keybinding']
        }, "{0} ({1})", title, this.options.keybinding);
      }
    }

    return title ?? undefined;
  }

  updateClass() {
    if (this.cssClass && this.label) {
      this.label.classList.remove(...this.cssClass.split(' '));
    }

    if (this.options.icon) {
      this.cssClass = this.action.class;

      if (this.label) {
        this.label.classList.add('codicon');

        if (this.cssClass) {
          this.label.classList.add(...this.cssClass.split(' '));
        }
      }

      this.updateEnabled();
    } else {
      this.label?.classList.remove('codicon');
    }
  }

  updateEnabled() {
    if (this.action.enabled) {
      if (this.label) {
        this.label.removeAttribute('aria-disabled');
        this.label.classList.remove('disabled');
      }

      this.element?.classList.remove('disabled');
    } else {
      if (this.label) {
        this.label.setAttribute('aria-disabled', 'true');
        this.label.classList.add('disabled');
      }

      this.element?.classList.add('disabled');
    }
  }

  updateAriaLabel() {
    if (this.label) {
      const title = this.getTooltip() ?? '';
      this.label.setAttribute('aria-label', title);
    }
  }

  updateChecked() {
    if (this.label) {
      if (this.action.checked) {
        this.label.classList.add('checked');
      } else {
        this.label.classList.remove('checked');
      }
    }
  }

}
class SelectActionViewItem extends BaseActionViewItem {
  constructor(ctx, action, options, selected, contextViewProvider, selectBoxOptions) {
    super(ctx, action);
    this.selectBox = new _browser_ui_selectBox_selectBox__WEBPACK_IMPORTED_MODULE_5__.SelectBox(options, selected, contextViewProvider, undefined, selectBoxOptions);
    this.selectBox.setFocusable(false);

    this._register(this.selectBox);

    this.registerListeners();
  }

  setOptions(options, selected) {
    this.selectBox.setOptions(options, selected);
  }

  select(index) {
    this.selectBox.select(index);
  }

  registerListeners() {
    this._register(this.selectBox.onDidSelect(e => {
      this.actionRunner.run(this._action, this.getActionContext(e.selected, e.index));
    }));
  }

  getActionContext(option, index) {
    return option;
  }

  setFocusable(focusable) {
    this.selectBox.setFocusable(focusable);
  }

  focus() {
    this.selectBox?.focus();
  }

  blur() {
    this.selectBox?.blur();
  }

  render(container) {
    this.selectBox.render(container);
  }

}

/***/ }),
/* 117 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "setupNativeHover": () => (/* binding */ setupNativeHover),
/* harmony export */   "setupCustomHover": () => (/* binding */ setupCustomHover)
/* harmony export */ });
/* harmony import */ var _browser_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(61);
/* harmony import */ var _browser_ui_hover_hoverWidget__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(118);
/* harmony import */ var _common_async__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(68);
/* harmony import */ var _common_cancellation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(69);
/* harmony import */ var _common_htmlContent__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(120);
/* harmony import */ var _common_iconLabels__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(121);
/* harmony import */ var _common_lifecycle__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(54);
/* harmony import */ var _common_types__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(79);
/* harmony import */ var _common_nls__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(59);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









function setupNativeHover(htmlElement, tooltip) {
  if ((0,_common_types__WEBPACK_IMPORTED_MODULE_7__.isString)(tooltip)) {
    // Icons don't render in the native hover so we strip them out
    htmlElement.title = (0,_common_iconLabels__WEBPACK_IMPORTED_MODULE_5__.stripIcons)(tooltip);
  } else if (tooltip?.markdownNotSupportedFallback) {
    htmlElement.title = tooltip.markdownNotSupportedFallback;
  } else {
    htmlElement.removeAttribute('title');
  }
}

class UpdatableHoverWidget {
  constructor(hoverDelegate, target, fadeInAnimation) {
    this.hoverDelegate = hoverDelegate;
    this.target = target;
    this.fadeInAnimation = fadeInAnimation;
  }

  async update(content, focus, options) {
    if (this._cancellationTokenSource) {
      // there's an computation ongoing, cancel it
      this._cancellationTokenSource.dispose(true);

      this._cancellationTokenSource = undefined;
    }

    if (this.isDisposed) {
      return;
    }

    let resolvedContent;

    if (content === undefined || (0,_common_types__WEBPACK_IMPORTED_MODULE_7__.isString)(content) || content instanceof HTMLElement) {
      resolvedContent = content;
    } else if (!(0,_common_types__WEBPACK_IMPORTED_MODULE_7__.isFunction)(content.markdown)) {
      resolvedContent = content.markdown ?? content.markdownNotSupportedFallback;
    } else {
      // compute the content, potentially long-running
      // show 'Loading' if no hover is up yet
      if (!this._hoverWidget) {
        this.show((0,_common_nls__WEBPACK_IMPORTED_MODULE_8__.localize)('iconLabel.loading', "Loading..."), focus);
      } // compute the content


      this._cancellationTokenSource = new _common_cancellation__WEBPACK_IMPORTED_MODULE_3__.CancellationTokenSource();
      const token = this._cancellationTokenSource.token;
      resolvedContent = await content.markdown(token);

      if (resolvedContent === undefined) {
        resolvedContent = content.markdownNotSupportedFallback;
      }

      if (this.isDisposed || token.isCancellationRequested) {
        // either the widget has been closed in the meantime
        // or there has been a new call to `update`
        return;
      }
    }

    this.show(resolvedContent, focus, options);
  }

  show(content, focus, options) {
    const oldHoverWidget = this._hoverWidget;

    if (this.hasContent(content)) {
      const hoverOptions = {
        content,
        target: this.target,
        showPointer: this.hoverDelegate.placement === 'element',
        hoverPosition: _browser_ui_hover_hoverWidget__WEBPACK_IMPORTED_MODULE_1__.HoverPosition.BELOW,
        skipFadeInAnimation: !this.fadeInAnimation || !!oldHoverWidget,
        // do not fade in if the hover is already showing
        ...options
      };
      this._hoverWidget = this.hoverDelegate.showHover(hoverOptions, focus);
    }

    oldHoverWidget?.dispose();
  }

  hasContent(content) {
    if (!content) {
      return false;
    }

    if ((0,_common_htmlContent__WEBPACK_IMPORTED_MODULE_4__.isMarkdownString)(content)) {
      return !!content.value;
    }

    return true;
  }

  get isDisposed() {
    return this._hoverWidget?.isDisposed;
  }

  dispose() {
    this._hoverWidget?.dispose();
    this._cancellationTokenSource?.dispose(true);
    this._cancellationTokenSource = undefined;
  }

}

function setupCustomHover(hoverDelegate, htmlElement, content, options) {
  let hoverPreparation;
  let hoverWidget;

  const hideHover = (disposeWidget, disposePreparation) => {
    if (disposeWidget) {
      hoverWidget?.dispose();
      hoverWidget = undefined;
    }

    if (disposePreparation) {
      hoverPreparation?.dispose();
      hoverPreparation = undefined;
    }

    hoverDelegate.onDidHideHover?.();
  };

  const triggerShowHover = (delay, focus, target) => {
    return new _common_async__WEBPACK_IMPORTED_MODULE_2__.TimeoutTimer(async () => {
      if (!hoverWidget || hoverWidget.isDisposed) {
        hoverWidget = new UpdatableHoverWidget(hoverDelegate, target || htmlElement, delay > 0);
        await hoverWidget.update(content, focus, options);
      }
    }, delay);
  };

  const onMouseOver = () => {
    if (hoverPreparation) {
      return;
    }

    const toDispose = new _common_lifecycle__WEBPACK_IMPORTED_MODULE_6__.DisposableStore();

    const onMouseLeave = e => hideHover(false, e.fromElement === htmlElement);

    toDispose.add(_browser_dom__WEBPACK_IMPORTED_MODULE_0__.addDisposableListener(htmlElement, _browser_dom__WEBPACK_IMPORTED_MODULE_0__.EventType.MOUSE_LEAVE, onMouseLeave, true));

    const onMouseDown = () => hideHover(true, true);

    toDispose.add(_browser_dom__WEBPACK_IMPORTED_MODULE_0__.addDisposableListener(htmlElement, _browser_dom__WEBPACK_IMPORTED_MODULE_0__.EventType.MOUSE_DOWN, onMouseDown, true));
    const target = {
      targetElements: [htmlElement],
      dispose: () => {}
    };

    if (hoverDelegate.placement === undefined || hoverDelegate.placement === 'mouse') {
      // track the mouse position
      const onMouseMove = e => {
        target.x = e.x + 10;

        if (e.target instanceof HTMLElement && e.target.classList.contains('action-label')) {
          hideHover(true, true);
        }
      };

      toDispose.add(_browser_dom__WEBPACK_IMPORTED_MODULE_0__.addDisposableListener(htmlElement, _browser_dom__WEBPACK_IMPORTED_MODULE_0__.EventType.MOUSE_MOVE, onMouseMove, true));
    }

    toDispose.add(triggerShowHover(hoverDelegate.delay, false, target));
    hoverPreparation = toDispose;
  };

  const mouseOverDomEmitter = _browser_dom__WEBPACK_IMPORTED_MODULE_0__.addDisposableListener(htmlElement, _browser_dom__WEBPACK_IMPORTED_MODULE_0__.EventType.MOUSE_OVER, onMouseOver, true);
  const hover = {
    show: focus => {
      hideHover(false, true); // terminate a ongoing mouse over preparation

      triggerShowHover(0, focus); // show hover immediately
    },
    hide: () => {
      hideHover(true, true);
    },
    update: async (newContent, hoverOptions) => {
      content = newContent;
      await hoverWidget?.update(content, undefined, hoverOptions);
    },
    dispose: () => {
      mouseOverDomEmitter.dispose();
      hideHover(true, true);
    }
  };
  return hover;
}

/***/ }),
/* 118 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HoverPosition": () => (/* binding */ HoverPosition),
/* harmony export */   "HoverWidget": () => (/* binding */ HoverWidget),
/* harmony export */   "HoverAction": () => (/* binding */ HoverAction)
/* harmony export */ });
/* harmony import */ var _browser_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(61);
/* harmony import */ var _browser_keyboardEvent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(63);
/* harmony import */ var _browser_ui_scrollbar_scrollableElement__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(94);
/* harmony import */ var _common_keyCodes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(64);
/* harmony import */ var _common_lifecycle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(54);
/* harmony import */ var _hover_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(119);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






const $ = _browser_dom__WEBPACK_IMPORTED_MODULE_0__.$;
let HoverPosition;

(function (HoverPosition) {
  HoverPosition[HoverPosition["LEFT"] = 0] = "LEFT";
  HoverPosition[HoverPosition["RIGHT"] = 1] = "RIGHT";
  HoverPosition[HoverPosition["BELOW"] = 2] = "BELOW";
  HoverPosition[HoverPosition["ABOVE"] = 3] = "ABOVE";
})(HoverPosition || (HoverPosition = {}));

class HoverWidget extends _common_lifecycle__WEBPACK_IMPORTED_MODULE_4__.Disposable {
  constructor() {
    super();
    this.containerDomNode = document.createElement('div');
    this.containerDomNode.className = 'monaco-hover';
    this.containerDomNode.tabIndex = 0;
    this.containerDomNode.setAttribute('role', 'tooltip');
    this.contentsDomNode = document.createElement('div');
    this.contentsDomNode.className = 'monaco-hover-content';
    this.scrollbar = this._register(new _browser_ui_scrollbar_scrollableElement__WEBPACK_IMPORTED_MODULE_2__.DomScrollableElement(this.contentsDomNode, {
      consumeMouseWheelIfScrollbarIsNeeded: true
    }));
    this.containerDomNode.appendChild(this.scrollbar.getDomNode());
  }

  onContentsChanged() {
    this.scrollbar.scanDomNode();
  }

}
class HoverAction extends _common_lifecycle__WEBPACK_IMPORTED_MODULE_4__.Disposable {
  static render(parent, actionOptions, keybindingLabel) {
    return new HoverAction(parent, actionOptions, keybindingLabel);
  }

  constructor(parent, actionOptions, keybindingLabel) {
    super();
    this.actionContainer = _browser_dom__WEBPACK_IMPORTED_MODULE_0__.append(parent, $('div.action-container'));
    this.actionContainer.setAttribute('tabindex', '0');
    this.action = _browser_dom__WEBPACK_IMPORTED_MODULE_0__.append(this.actionContainer, $('a.action'));
    this.action.setAttribute('role', 'button');

    if (actionOptions.iconClass) {
      _browser_dom__WEBPACK_IMPORTED_MODULE_0__.append(this.action, $(`span.icon.${actionOptions.iconClass}`));
    }

    const label = _browser_dom__WEBPACK_IMPORTED_MODULE_0__.append(this.action, $('span'));
    label.textContent = keybindingLabel ? `${actionOptions.label} (${keybindingLabel})` : actionOptions.label;

    this._register(_browser_dom__WEBPACK_IMPORTED_MODULE_0__.addDisposableListener(this.actionContainer, _browser_dom__WEBPACK_IMPORTED_MODULE_0__.EventType.CLICK, e => {
      e.stopPropagation();
      e.preventDefault();
      actionOptions.run(this.actionContainer);
    }));

    this._register(_browser_dom__WEBPACK_IMPORTED_MODULE_0__.addDisposableListener(this.actionContainer, _browser_dom__WEBPACK_IMPORTED_MODULE_0__.EventType.KEY_UP, e => {
      const event = new _browser_keyboardEvent__WEBPACK_IMPORTED_MODULE_1__.StandardKeyboardEvent(e);

      if (event.equals(_common_keyCodes__WEBPACK_IMPORTED_MODULE_3__.KeyCode.Enter)) {
        e.stopPropagation();
        e.preventDefault();
        actionOptions.run(this.actionContainer);
      }
    }));

    this.setEnabled(true);
  }

  setEnabled(enabled) {
    if (enabled) {
      this.actionContainer.classList.remove('disabled');
      this.actionContainer.removeAttribute('aria-disabled');
    } else {
      this.actionContainer.classList.add('disabled');
      this.actionContainer.setAttribute('aria-disabled', 'true');
    }
  }

}

/***/ }),
/* 119 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),
/* 120 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MarkdownStringTextNewlineStyle": () => (/* binding */ MarkdownStringTextNewlineStyle),
/* harmony export */   "MarkdownString": () => (/* binding */ MarkdownString),
/* harmony export */   "isEmptyMarkdownString": () => (/* binding */ isEmptyMarkdownString),
/* harmony export */   "isMarkdownString": () => (/* binding */ isMarkdownString),
/* harmony export */   "markdownStringEqual": () => (/* binding */ markdownStringEqual),
/* harmony export */   "escapeMarkdownSyntaxTokens": () => (/* binding */ escapeMarkdownSyntaxTokens),
/* harmony export */   "escapeDoubleQuotes": () => (/* binding */ escapeDoubleQuotes),
/* harmony export */   "removeMarkdownEscapes": () => (/* binding */ removeMarkdownEscapes),
/* harmony export */   "parseHrefAndDimensions": () => (/* binding */ parseHrefAndDimensions)
/* harmony export */ });
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);
/* harmony import */ var _iconLabels__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(121);
/* harmony import */ var _resources__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(70);
/* harmony import */ var _strings__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(75);
/* harmony import */ var _uri__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(81);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





let MarkdownStringTextNewlineStyle;

(function (MarkdownStringTextNewlineStyle) {
  MarkdownStringTextNewlineStyle[MarkdownStringTextNewlineStyle["Paragraph"] = 0] = "Paragraph";
  MarkdownStringTextNewlineStyle[MarkdownStringTextNewlineStyle["Break"] = 1] = "Break";
})(MarkdownStringTextNewlineStyle || (MarkdownStringTextNewlineStyle = {}));

class MarkdownString {
  constructor(value = '', isTrustedOrOptions = false) {
    this.value = value;

    if (typeof this.value !== 'string') {
      throw (0,_errors__WEBPACK_IMPORTED_MODULE_0__.illegalArgument)('value');
    }

    if (typeof isTrustedOrOptions === 'boolean') {
      this.isTrusted = isTrustedOrOptions;
      this.supportThemeIcons = false;
      this.supportHtml = false;
    } else {
      this.isTrusted = isTrustedOrOptions.isTrusted ?? undefined;
      this.supportThemeIcons = isTrustedOrOptions.supportThemeIcons ?? false;
      this.supportHtml = isTrustedOrOptions.supportHtml ?? false;
    }
  }

  appendText(value, newlineStyle = MarkdownStringTextNewlineStyle.Paragraph) {
    this.value += escapeMarkdownSyntaxTokens(this.supportThemeIcons ? (0,_iconLabels__WEBPACK_IMPORTED_MODULE_1__.escapeIcons)(value) : value).replace(/([ \t]+)/g, (_match, g1) => '&nbsp;'.repeat(g1.length)).replace(/\>/gm, '\\>').replace(/\n/g, newlineStyle === MarkdownStringTextNewlineStyle.Break ? '\\\n' : '\n\n');
    return this;
  }

  appendMarkdown(value) {
    this.value += value;
    return this;
  }

  appendCodeblock(langId, code) {
    this.value += '\n```';
    this.value += langId;
    this.value += '\n';
    this.value += code;
    this.value += '\n```\n';
    return this;
  }

  appendLink(target, label, title) {
    this.value += '[';
    this.value += this._escape(label, ']');
    this.value += '](';
    this.value += this._escape(String(target), ')');

    if (title) {
      this.value += ` "${this._escape(this._escape(title, '"'), ')')}"`;
    }

    this.value += ')';
    return this;
  }

  _escape(value, ch) {
    const r = new RegExp((0,_strings__WEBPACK_IMPORTED_MODULE_3__.escapeRegExpCharacters)(ch), 'g');
    return value.replace(r, (match, offset) => {
      if (value.charAt(offset - 1) !== '\\') {
        return `\\${match}`;
      } else {
        return match;
      }
    });
  }

}
function isEmptyMarkdownString(oneOrMany) {
  if (isMarkdownString(oneOrMany)) {
    return !oneOrMany.value;
  } else if (Array.isArray(oneOrMany)) {
    return oneOrMany.every(isEmptyMarkdownString);
  } else {
    return true;
  }
}
function isMarkdownString(thing) {
  if (thing instanceof MarkdownString) {
    return true;
  } else if (thing && typeof thing === 'object') {
    return typeof thing.value === 'string' && (typeof thing.isTrusted === 'boolean' || thing.isTrusted === undefined) && (typeof thing.supportThemeIcons === 'boolean' || thing.supportThemeIcons === undefined);
  }

  return false;
}
function markdownStringEqual(a, b) {
  if (a === b) {
    return true;
  } else if (!a || !b) {
    return false;
  } else {
    return a.value === b.value && a.isTrusted === b.isTrusted && a.supportThemeIcons === b.supportThemeIcons && a.supportHtml === b.supportHtml && (a.baseUri === b.baseUri || !!a.baseUri && !!b.baseUri && (0,_resources__WEBPACK_IMPORTED_MODULE_2__.isEqual)(_uri__WEBPACK_IMPORTED_MODULE_4__.URI.from(a.baseUri), _uri__WEBPACK_IMPORTED_MODULE_4__.URI.from(b.baseUri)));
  }
}
function escapeMarkdownSyntaxTokens(text) {
  // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash
  return text.replace(/[\\`*_{}[\]()#+\-!]/g, '\\$&');
}
function escapeDoubleQuotes(input) {
  return input.replace(/"/g, '&quot;');
}
function removeMarkdownEscapes(text) {
  if (!text) {
    return text;
  }

  return text.replace(/\\([\\`*_{}[\]()#+\-.!])/g, '$1');
}
function parseHrefAndDimensions(href) {
  const dimensions = [];
  const splitted = href.split('|').map(s => s.trim());
  href = splitted[0];
  const parameters = splitted[1];

  if (parameters) {
    const heightFromParams = /height=(\d+)/.exec(parameters);
    const widthFromParams = /width=(\d+)/.exec(parameters);
    const height = heightFromParams ? heightFromParams[1] : '';
    const width = widthFromParams ? widthFromParams[1] : '';
    const widthIsFinite = isFinite(parseInt(width));
    const heightIsFinite = isFinite(parseInt(height));

    if (widthIsFinite) {
      dimensions.push(`width="${width}"`);
    }

    if (heightIsFinite) {
      dimensions.push(`height="${height}"`);
    }
  }

  return {
    href,
    dimensions
  };
}

/***/ }),
/* 121 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "iconStartMarker": () => (/* binding */ iconStartMarker),
/* harmony export */   "escapeIcons": () => (/* binding */ escapeIcons),
/* harmony export */   "markdownEscapeEscapedIcons": () => (/* binding */ markdownEscapeEscapedIcons),
/* harmony export */   "stripIcons": () => (/* binding */ stripIcons),
/* harmony export */   "parseLabelWithIcons": () => (/* binding */ parseLabelWithIcons),
/* harmony export */   "matchesFuzzyIconAware": () => (/* binding */ matchesFuzzyIconAware)
/* harmony export */ });
/* harmony import */ var _codicons__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(104);
/* harmony import */ var _filters__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(122);
/* harmony import */ var _strings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(75);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/



const iconStartMarker = '$(';
const iconsRegex = new RegExp(`\\$\\(${_codicons__WEBPACK_IMPORTED_MODULE_0__.CSSIcon.iconNameExpression}(?:${_codicons__WEBPACK_IMPORTED_MODULE_0__.CSSIcon.iconModifierExpression})?\\)`, 'g'); // no capturing groups

const iconNameCharacterRegexp = new RegExp(_codicons__WEBPACK_IMPORTED_MODULE_0__.CSSIcon.iconNameCharacter);
const escapeIconsRegex = new RegExp(`(\\\\)?${iconsRegex.source}`, 'g');
function escapeIcons(text) {
  return text.replace(escapeIconsRegex, (match, escaped) => escaped ? match : `\\${match}`);
}
const markdownEscapedIconsRegex = new RegExp(`\\\\${iconsRegex.source}`, 'g');
function markdownEscapeEscapedIcons(text) {
  // Need to add an extra \ for escaping in markdown
  return text.replace(markdownEscapedIconsRegex, match => `\\${match}`);
}
const stripIconsRegex = new RegExp(`(\\s)?(\\\\)?${iconsRegex.source}(\\s)?`, 'g');
function stripIcons(text) {
  if (text.indexOf(iconStartMarker) === -1) {
    return text;
  }

  return text.replace(stripIconsRegex, (match, preWhitespace, escaped, postWhitespace) => escaped ? match : preWhitespace || postWhitespace || '');
}
function parseLabelWithIcons(text) {
  const firstIconIndex = text.indexOf(iconStartMarker);

  if (firstIconIndex === -1) {
    return {
      text
    }; // return early if the word does not include an icon
  }

  return doParseLabelWithIcons(text, firstIconIndex);
}

function doParseLabelWithIcons(text, firstIconIndex) {
  const iconOffsets = [];
  let textWithoutIcons = '';

  function appendChars(chars) {
    if (chars) {
      textWithoutIcons += chars;

      for (const _ of chars) {
        iconOffsets.push(iconsOffset); // make sure to fill in icon offsets
      }
    }
  }

  let currentIconStart = -1;
  let currentIconValue = '';
  let iconsOffset = 0;
  let char;
  let nextChar;
  let offset = firstIconIndex;
  const length = text.length; // Append all characters until the first icon

  appendChars(text.substr(0, firstIconIndex)); // example: $(file-symlink-file) my cool $(other-icon) entry

  while (offset < length) {
    char = text[offset];
    nextChar = text[offset + 1]; // beginning of icon: some value $( <--

    if (char === iconStartMarker[0] && nextChar === iconStartMarker[1]) {
      currentIconStart = offset; // if we had a previous potential icon value without
      // the closing ')', it was actually not an icon and
      // so we have to add it to the actual value

      appendChars(currentIconValue);
      currentIconValue = iconStartMarker;
      offset++; // jump over '('
    } // end of icon: some value $(some-icon) <--
    else if (char === ')' && currentIconStart !== -1) {
      const currentIconLength = offset - currentIconStart + 1; // +1 to include the closing ')'

      iconsOffset += currentIconLength;
      currentIconStart = -1;
      currentIconValue = '';
    } // within icon
    else if (currentIconStart !== -1) {
      // Make sure this is a real icon name
      if (iconNameCharacterRegexp.test(char)) {
        currentIconValue += char;
      } else {
        // This is not a real icon, treat it as text
        appendChars(currentIconValue);
        currentIconStart = -1;
        currentIconValue = '';
      }
    } // any value outside of icon
    else {
      appendChars(char);
    }

    offset++;
  } // if we had a previous potential icon value without
  // the closing ')', it was actually not an icon and
  // so we have to add it to the actual value


  appendChars(currentIconValue);
  return {
    text: textWithoutIcons,
    iconOffsets
  };
}

function matchesFuzzyIconAware(query, target, enableSeparateSubstringMatching = false) {
  const {
    text,
    iconOffsets
  } = target; // Return early if there are no icon markers in the word to match against

  if (!iconOffsets || iconOffsets.length === 0) {
    return (0,_filters__WEBPACK_IMPORTED_MODULE_1__.matchesFuzzy)(query, text, enableSeparateSubstringMatching);
  } // Trim the word to match against because it could have leading
  // whitespace now if the word started with an icon


  const wordToMatchAgainstWithoutIconsTrimmed = (0,_strings__WEBPACK_IMPORTED_MODULE_2__.ltrim)(text, ' ');
  const leadingWhitespaceOffset = text.length - wordToMatchAgainstWithoutIconsTrimmed.length; // match on value without icon

  const matches = (0,_filters__WEBPACK_IMPORTED_MODULE_1__.matchesFuzzy)(query, wordToMatchAgainstWithoutIconsTrimmed, enableSeparateSubstringMatching); // Map matches back to offsets with icon and trimming

  if (matches) {
    for (const match of matches) {
      const iconOffset = iconOffsets[match.start + leadingWhitespaceOffset]
      /* icon offsets at index */
      + leadingWhitespaceOffset
      /* overall leading whitespace offset */
      ;
      match.start += iconOffset;
      match.end += iconOffset;
    }
  }

  return matches;
}

/***/ }),
/* 122 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "or": () => (/* binding */ or),
/* harmony export */   "matchesStrictPrefix": () => (/* binding */ matchesStrictPrefix),
/* harmony export */   "matchesPrefix": () => (/* binding */ matchesPrefix),
/* harmony export */   "matchesContiguousSubString": () => (/* binding */ matchesContiguousSubString),
/* harmony export */   "matchesSubString": () => (/* binding */ matchesSubString),
/* harmony export */   "isUpper": () => (/* binding */ isUpper),
/* harmony export */   "matchesCamelCase": () => (/* binding */ matchesCamelCase),
/* harmony export */   "matchesWords": () => (/* binding */ matchesWords),
/* harmony export */   "matchesFuzzy": () => (/* binding */ matchesFuzzy),
/* harmony export */   "matchesFuzzy2": () => (/* binding */ matchesFuzzy2),
/* harmony export */   "anyScore": () => (/* binding */ anyScore),
/* harmony export */   "createMatches": () => (/* binding */ createMatches),
/* harmony export */   "isPatternInWord": () => (/* binding */ isPatternInWord),
/* harmony export */   "FuzzyScore": () => (/* binding */ FuzzyScore),
/* harmony export */   "FuzzyScoreOptions": () => (/* binding */ FuzzyScoreOptions),
/* harmony export */   "fuzzyScore": () => (/* binding */ fuzzyScore),
/* harmony export */   "fuzzyScoreGracefulAggressive": () => (/* binding */ fuzzyScoreGracefulAggressive),
/* harmony export */   "fuzzyScoreGraceful": () => (/* binding */ fuzzyScoreGraceful)
/* harmony export */ });
/* harmony import */ var _charCode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(71);
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(123);
/* harmony import */ var _strings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(75);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/



// Combined filters

/**
 * @returns A filter which combines the provided set
 * of filters with an or. The *first* filters that
 * matches defined the return value of the returned
 * filter.
 */
function or(...filter) {
  return function (word, wordToMatchAgainst) {
    for (let i = 0, len = filter.length; i < len; i++) {
      const match = filter[i](word, wordToMatchAgainst);

      if (match) {
        return match;
      }
    }

    return null;
  };
} // Prefix

const matchesStrictPrefix = _matchesPrefix.bind(undefined, false);
const matchesPrefix = _matchesPrefix.bind(undefined, true);

function _matchesPrefix(ignoreCase, word, wordToMatchAgainst) {
  if (!wordToMatchAgainst || wordToMatchAgainst.length < word.length) {
    return null;
  }

  let matches;

  if (ignoreCase) {
    matches = _strings__WEBPACK_IMPORTED_MODULE_2__.startsWithIgnoreCase(wordToMatchAgainst, word);
  } else {
    matches = wordToMatchAgainst.indexOf(word) === 0;
  }

  if (!matches) {
    return null;
  }

  return word.length > 0 ? [{
    start: 0,
    end: word.length
  }] : [];
} // Contiguous Substring


function matchesContiguousSubString(word, wordToMatchAgainst) {
  const index = wordToMatchAgainst.toLowerCase().indexOf(word.toLowerCase());

  if (index === -1) {
    return null;
  }

  return [{
    start: index,
    end: index + word.length
  }];
} // Substring

function matchesSubString(word, wordToMatchAgainst) {
  return _matchesSubString(word.toLowerCase(), wordToMatchAgainst.toLowerCase(), 0, 0);
}

function _matchesSubString(word, wordToMatchAgainst, i, j) {
  if (i === word.length) {
    return [];
  } else if (j === wordToMatchAgainst.length) {
    return null;
  } else {
    if (word[i] === wordToMatchAgainst[j]) {
      let result = null;

      if (result = _matchesSubString(word, wordToMatchAgainst, i + 1, j + 1)) {
        return join({
          start: j,
          end: j + 1
        }, result);
      }

      return null;
    }

    return _matchesSubString(word, wordToMatchAgainst, i, j + 1);
  }
} // CamelCase


function isLower(code) {
  return _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.a <= code && code <= _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.z;
}

function isUpper(code) {
  return _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.A <= code && code <= _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Z;
}

function isNumber(code) {
  return _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Digit0 <= code && code <= _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Digit9;
}

function isWhitespace(code) {
  return code === _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Space || code === _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Tab || code === _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.LineFeed || code === _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.CarriageReturn;
}

const wordSeparators = new Set(); // These are chosen as natural word separators based on writen text.
// It is a subset of the word separators used by the monaco editor.

'()[]{}<>`\'"-/;:,.?!'.split('').forEach(s => wordSeparators.add(s.charCodeAt(0)));

function isWordSeparator(code) {
  return isWhitespace(code) || wordSeparators.has(code);
}

function charactersMatch(codeA, codeB) {
  return codeA === codeB || isWordSeparator(codeA) && isWordSeparator(codeB);
}

function isAlphanumeric(code) {
  return isLower(code) || isUpper(code) || isNumber(code);
}

function join(head, tail) {
  if (tail.length === 0) {
    tail = [head];
  } else if (head.end === tail[0].start) {
    tail[0].start = head.start;
  } else {
    tail.unshift(head);
  }

  return tail;
}

function nextAnchor(camelCaseWord, start) {
  for (let i = start; i < camelCaseWord.length; i++) {
    const c = camelCaseWord.charCodeAt(i);

    if (isUpper(c) || isNumber(c) || i > 0 && !isAlphanumeric(camelCaseWord.charCodeAt(i - 1))) {
      return i;
    }
  }

  return camelCaseWord.length;
}

function _matchesCamelCase(word, camelCaseWord, i, j) {
  if (i === word.length) {
    return [];
  } else if (j === camelCaseWord.length) {
    return null;
  } else if (word[i] !== camelCaseWord[j].toLowerCase()) {
    return null;
  } else {
    let result = null;
    let nextUpperIndex = j + 1;
    result = _matchesCamelCase(word, camelCaseWord, i + 1, j + 1);

    while (!result && (nextUpperIndex = nextAnchor(camelCaseWord, nextUpperIndex)) < camelCaseWord.length) {
      result = _matchesCamelCase(word, camelCaseWord, i + 1, nextUpperIndex);
      nextUpperIndex++;
    }

    return result === null ? null : join({
      start: j,
      end: j + 1
    }, result);
  }
}

// Heuristic to avoid computing camel case matcher for words that don't
// look like camelCaseWords.
function analyzeCamelCaseWord(word) {
  let upper = 0,
      lower = 0,
      alpha = 0,
      numeric = 0,
      code = 0;

  for (let i = 0; i < word.length; i++) {
    code = word.charCodeAt(i);

    if (isUpper(code)) {
      upper++;
    }

    if (isLower(code)) {
      lower++;
    }

    if (isAlphanumeric(code)) {
      alpha++;
    }

    if (isNumber(code)) {
      numeric++;
    }
  }

  const upperPercent = upper / word.length;
  const lowerPercent = lower / word.length;
  const alphaPercent = alpha / word.length;
  const numericPercent = numeric / word.length;
  return {
    upperPercent,
    lowerPercent,
    alphaPercent,
    numericPercent
  };
}

function isUpperCaseWord(analysis) {
  const {
    upperPercent,
    lowerPercent
  } = analysis;
  return lowerPercent === 0 && upperPercent > 0.6;
}

function isCamelCaseWord(analysis) {
  const {
    upperPercent,
    lowerPercent,
    alphaPercent,
    numericPercent
  } = analysis;
  return lowerPercent > 0.2 && upperPercent < 0.8 && alphaPercent > 0.6 && numericPercent < 0.2;
} // Heuristic to avoid computing camel case matcher for words that don't
// look like camel case patterns.


function isCamelCasePattern(word) {
  let upper = 0,
      lower = 0,
      code = 0,
      whitespace = 0;

  for (let i = 0; i < word.length; i++) {
    code = word.charCodeAt(i);

    if (isUpper(code)) {
      upper++;
    }

    if (isLower(code)) {
      lower++;
    }

    if (isWhitespace(code)) {
      whitespace++;
    }
  }

  if ((upper === 0 || lower === 0) && whitespace === 0) {
    return word.length <= 30;
  } else {
    return upper <= 5;
  }
}

function matchesCamelCase(word, camelCaseWord) {
  if (!camelCaseWord) {
    return null;
  }

  camelCaseWord = camelCaseWord.trim();

  if (camelCaseWord.length === 0) {
    return null;
  }

  if (!isCamelCasePattern(word)) {
    return null;
  }

  if (camelCaseWord.length > 60) {
    return null;
  }

  const analysis = analyzeCamelCaseWord(camelCaseWord);

  if (!isCamelCaseWord(analysis)) {
    if (!isUpperCaseWord(analysis)) {
      return null;
    }

    camelCaseWord = camelCaseWord.toLowerCase();
  }

  let result = null;
  let i = 0;
  word = word.toLowerCase();

  while (i < camelCaseWord.length && (result = _matchesCamelCase(word, camelCaseWord, 0, i)) === null) {
    i = nextAnchor(camelCaseWord, i + 1);
  }

  return result;
} // Matches beginning of words supporting non-ASCII languages
// If `contiguous` is true then matches word with beginnings of the words in the target. E.g. "pul" will match "Git: Pull"
// Otherwise also matches sub string of the word with beginnings of the words in the target. E.g. "gp" or "g p" will match "Git: Pull"
// Useful in cases where the target is words (e.g. command labels)

function matchesWords(word, target, contiguous = false) {
  if (!target || target.length === 0) {
    return null;
  }

  let result = null;
  let i = 0;
  word = word.toLowerCase();
  target = target.toLowerCase();

  while (i < target.length && (result = _matchesWords(word, target, 0, i, contiguous)) === null) {
    i = nextWord(target, i + 1);
  }

  return result;
}

function _matchesWords(word, target, i, j, contiguous) {
  if (i === word.length) {
    return [];
  } else if (j === target.length) {
    return null;
  } else if (!charactersMatch(word.charCodeAt(i), target.charCodeAt(j))) {
    return null;
  } else {
    let result = null;
    let nextWordIndex = j + 1;
    result = _matchesWords(word, target, i + 1, j + 1, contiguous);

    if (!contiguous) {
      while (!result && (nextWordIndex = nextWord(target, nextWordIndex)) < target.length) {
        result = _matchesWords(word, target, i + 1, nextWordIndex, contiguous);
        nextWordIndex++;
      }
    }

    if (!result) {
      return null;
    } // If the characters don't exactly match, then they must be word separators (see charactersMatch(...)).
    // We don't want to include this in the matches but we don't want to throw the target out all together so we return `result`.


    if (word.charCodeAt(i) !== target.charCodeAt(j)) {
      return result;
    }

    return join({
      start: j,
      end: j + 1
    }, result);
  }
}

function nextWord(word, start) {
  for (let i = start; i < word.length; i++) {
    if (isWordSeparator(word.charCodeAt(i)) || i > 0 && isWordSeparator(word.charCodeAt(i - 1))) {
      return i;
    }
  }

  return word.length;
} // Fuzzy


const fuzzyContiguousFilter = or(matchesPrefix, matchesCamelCase, matchesContiguousSubString);
const fuzzySeparateFilter = or(matchesPrefix, matchesCamelCase, matchesSubString);
const fuzzyRegExpCache = new _map__WEBPACK_IMPORTED_MODULE_1__.LRUCache(10000); // bounded to 10000 elements

function matchesFuzzy(word, wordToMatchAgainst, enableSeparateSubstringMatching = false) {
  if (typeof word !== 'string' || typeof wordToMatchAgainst !== 'string') {
    return null; // return early for invalid input
  } // Form RegExp for wildcard matches


  let regexp = fuzzyRegExpCache.get(word);

  if (!regexp) {
    regexp = new RegExp(_strings__WEBPACK_IMPORTED_MODULE_2__.convertSimple2RegExpPattern(word), 'i');
    fuzzyRegExpCache.set(word, regexp);
  } // RegExp Filter


  const match = regexp.exec(wordToMatchAgainst);

  if (match) {
    return [{
      start: match.index,
      end: match.index + match[0].length
    }];
  } // Default Filter


  return enableSeparateSubstringMatching ? fuzzySeparateFilter(word, wordToMatchAgainst) : fuzzyContiguousFilter(word, wordToMatchAgainst);
}
/**
 * Match pattern against word in a fuzzy way. As in IntelliSense and faster and more
 * powerful than `matchesFuzzy`
 */

function matchesFuzzy2(pattern, word) {
  const score = fuzzyScore(pattern, pattern.toLowerCase(), 0, word, word.toLowerCase(), 0, {
    firstMatchCanBeWeak: true,
    boostFullMatch: true
  });
  return score ? createMatches(score) : null;
}
function anyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos) {
  const max = Math.min(13, pattern.length);

  for (; patternPos < max; patternPos++) {
    const result = fuzzyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, {
      firstMatchCanBeWeak: false,
      boostFullMatch: true
    });

    if (result) {
      return result;
    }
  }

  return [0, wordPos];
} //#region --- fuzzyScore ---

function createMatches(score) {
  if (typeof score === 'undefined') {
    return [];
  }

  const res = [];
  const wordPos = score[1];

  for (let i = score.length - 1; i > 1; i--) {
    const pos = score[i] + wordPos;
    const last = res[res.length - 1];

    if (last && last.end === pos) {
      last.end = pos + 1;
    } else {
      res.push({
        start: pos,
        end: pos + 1
      });
    }
  }

  return res;
}
const _maxLen = 128;

function initTable() {
  const table = [];
  const row = [];

  for (let i = 0; i <= _maxLen; i++) {
    row[i] = 0;
  }

  for (let i = 0; i <= _maxLen; i++) {
    table.push(row.slice(0));
  }

  return table;
}

function initArr(maxLen) {
  const row = [];

  for (let i = 0; i <= maxLen; i++) {
    row[i] = 0;
  }

  return row;
}

const _minWordMatchPos = initArr(2 * _maxLen); // min word position for a certain pattern position


const _maxWordMatchPos = initArr(2 * _maxLen); // max word position for a certain pattern position


const _diag = initTable(); // the length of a contiguous diagonal match


const _table = initTable();

const _arrows = initTable();

const _debug = false;

function printTable(table, pattern, patternLen, word, wordLen) {
  function pad(s, n, pad = ' ') {
    while (s.length < n) {
      s = pad + s;
    }

    return s;
  }

  let ret = ` |   |${word.split('').map(c => pad(c, 3)).join('|')}\n`;

  for (let i = 0; i <= patternLen; i++) {
    if (i === 0) {
      ret += ' |';
    } else {
      ret += `${pattern[i - 1]}|`;
    }

    ret += table[i].slice(0, wordLen + 1).map(n => pad(n.toString(), 3)).join('|') + '\n';
  }

  return ret;
}

function printTables(pattern, patternStart, word, wordStart) {
  pattern = pattern.substr(patternStart);
  word = word.substr(wordStart);
  console.log(printTable(_table, pattern, pattern.length, word, word.length));
  console.log(printTable(_arrows, pattern, pattern.length, word, word.length));
  console.log(printTable(_diag, pattern, pattern.length, word, word.length));
}

function isSeparatorAtPos(value, index) {
  if (index < 0 || index >= value.length) {
    return false;
  }

  const code = value.codePointAt(index);

  switch (code) {
    case _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Underline:
    case _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Dash:
    case _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Period:
    case _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Space:
    case _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Slash:
    case _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Backslash:
    case _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.SingleQuote:
    case _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.DoubleQuote:
    case _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Colon:
    case _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.DollarSign:
    case _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.LessThan:
    case _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.GreaterThan:
    case _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.OpenParen:
    case _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.CloseParen:
    case _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.OpenSquareBracket:
    case _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.CloseSquareBracket:
    case _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.OpenCurlyBrace:
    case _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.CloseCurlyBrace:
      return true;

    case undefined:
      return false;

    default:
      if (_strings__WEBPACK_IMPORTED_MODULE_2__.isEmojiImprecise(code)) {
        return true;
      }

      return false;
  }
}

function isWhitespaceAtPos(value, index) {
  if (index < 0 || index >= value.length) {
    return false;
  }

  const code = value.charCodeAt(index);

  switch (code) {
    case _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Space:
    case _charCode__WEBPACK_IMPORTED_MODULE_0__.CharCode.Tab:
      return true;

    default:
      return false;
  }
}

function isUpperCaseAtPos(pos, word, wordLow) {
  return word[pos] !== wordLow[pos];
}

function isPatternInWord(patternLow, patternPos, patternLen, wordLow, wordPos, wordLen, fillMinWordPosArr = false) {
  while (patternPos < patternLen && wordPos < wordLen) {
    if (patternLow[patternPos] === wordLow[wordPos]) {
      if (fillMinWordPosArr) {
        // Remember the min word position for each pattern position
        _minWordMatchPos[patternPos] = wordPos;
      }

      patternPos += 1;
    }

    wordPos += 1;
  }

  return patternPos === patternLen; // pattern must be exhausted
}
var Arrow;
/**
 * An array representing a fuzzy match.
 *
 * 0. the score
 * 1. the offset at which matching started
 * 2. `<match_pos_N>`
 * 3. `<match_pos_1>`
 * 4. `<match_pos_0>` etc
 */

(function (Arrow) {
  Arrow[Arrow["Diag"] = 1] = "Diag";
  Arrow[Arrow["Left"] = 2] = "Left";
  Arrow[Arrow["LeftLeft"] = 3] = "LeftLeft";
})(Arrow || (Arrow = {}));

let FuzzyScore;

(function (_FuzzyScore) {
  const Default = _FuzzyScore.Default = [-100, 0];

  function isDefault(score) {
    return !score || score.length === 2 && score[0] === -100 && score[1] === 0;
  }

  _FuzzyScore.isDefault = isDefault;
})(FuzzyScore || (FuzzyScore = {}));

class FuzzyScoreOptions {
  static default = {
    boostFullMatch: true,
    firstMatchCanBeWeak: false
  };

  constructor(firstMatchCanBeWeak, boostFullMatch) {
    this.firstMatchCanBeWeak = firstMatchCanBeWeak;
    this.boostFullMatch = boostFullMatch;
  }

}
function fuzzyScore(pattern, patternLow, patternStart, word, wordLow, wordStart, options = FuzzyScoreOptions.default) {
  const patternLen = pattern.length > _maxLen ? _maxLen : pattern.length;
  const wordLen = word.length > _maxLen ? _maxLen : word.length;

  if (patternStart >= patternLen || wordStart >= wordLen || patternLen - patternStart > wordLen - wordStart) {
    return undefined;
  } // Run a simple check if the characters of pattern occur
  // (in order) at all in word. If that isn't the case we
  // stop because no match will be possible


  if (!isPatternInWord(patternLow, patternStart, patternLen, wordLow, wordStart, wordLen, true)) {
    return undefined;
  } // Find the max matching word position for each pattern position
  // NOTE: the min matching word position was filled in above, in the `isPatternInWord` call


  _fillInMaxWordMatchPos(patternLen, wordLen, patternStart, wordStart, patternLow, wordLow);

  let row = 1;
  let column = 1;
  let patternPos = patternStart;
  let wordPos = wordStart;
  const hasStrongFirstMatch = [false]; // There will be a match, fill in tables

  for (row = 1, patternPos = patternStart; patternPos < patternLen; row++, patternPos++) {
    // Reduce search space to possible matching word positions and to possible access from next row
    const minWordMatchPos = _minWordMatchPos[patternPos];
    const maxWordMatchPos = _maxWordMatchPos[patternPos];
    const nextMaxWordMatchPos = patternPos + 1 < patternLen ? _maxWordMatchPos[patternPos + 1] : wordLen;

    for (column = minWordMatchPos - wordStart + 1, wordPos = minWordMatchPos; wordPos < nextMaxWordMatchPos; column++, wordPos++) {
      let score = Number.MIN_SAFE_INTEGER;
      let canComeDiag = false;

      if (wordPos <= maxWordMatchPos) {
        score = _doScore(pattern, patternLow, patternPos, patternStart, word, wordLow, wordPos, wordLen, wordStart, _diag[row - 1][column - 1] === 0, hasStrongFirstMatch);
      }

      let diagScore = 0;

      if (score !== Number.MAX_SAFE_INTEGER) {
        canComeDiag = true;
        diagScore = score + _table[row - 1][column - 1];
      }

      const canComeLeft = wordPos > minWordMatchPos;
      const leftScore = canComeLeft ? _table[row][column - 1] + (_diag[row][column - 1] > 0 ? -5 : 0) : 0; // penalty for a gap start

      const canComeLeftLeft = wordPos > minWordMatchPos + 1 && _diag[row][column - 1] > 0;
      const leftLeftScore = canComeLeftLeft ? _table[row][column - 2] + (_diag[row][column - 2] > 0 ? -5 : 0) : 0; // penalty for a gap start

      if (canComeLeftLeft && (!canComeLeft || leftLeftScore >= leftScore) && (!canComeDiag || leftLeftScore >= diagScore)) {
        // always prefer choosing left left to jump over a diagonal because that means a match is earlier in the word
        _table[row][column] = leftLeftScore;
        _arrows[row][column] = Arrow.LeftLeft;
        _diag[row][column] = 0;
      } else if (canComeLeft && (!canComeDiag || leftScore >= diagScore)) {
        // always prefer choosing left since that means a match is earlier in the word
        _table[row][column] = leftScore;
        _arrows[row][column] = Arrow.Left;
        _diag[row][column] = 0;
      } else if (canComeDiag) {
        _table[row][column] = diagScore;
        _arrows[row][column] = Arrow.Diag;
        _diag[row][column] = _diag[row - 1][column - 1] + 1;
      } else {
        throw new Error(`not possible`);
      }
    }
  }

  if (_debug) {
    printTables(pattern, patternStart, word, wordStart);
  }

  if (!hasStrongFirstMatch[0] && !options.firstMatchCanBeWeak) {
    return undefined;
  }

  row--;
  column--;
  const result = [_table[row][column], wordStart];
  let backwardsDiagLength = 0;
  let maxMatchColumn = 0;

  while (row >= 1) {
    // Find the column where we go diagonally up
    let diagColumn = column;

    do {
      const arrow = _arrows[row][diagColumn];

      if (arrow === Arrow.LeftLeft) {
        diagColumn = diagColumn - 2;
      } else if (arrow === Arrow.Left) {
        diagColumn = diagColumn - 1;
      } else {
        // found the diagonal
        break;
      }
    } while (diagColumn >= 1); // Overturn the "forwards" decision if keeping the "backwards" diagonal would give a better match


    if (backwardsDiagLength > 1 // only if we would have a contiguous match of 3 characters
    && patternLow[patternStart + row - 1] === wordLow[wordStart + column - 1] // only if we can do a contiguous match diagonally
    && !isUpperCaseAtPos(diagColumn + wordStart - 1, word, wordLow) // only if the forwards chose diagonal is not an uppercase
    && backwardsDiagLength + 1 > _diag[row][diagColumn] // only if our contiguous match would be longer than the "forwards" contiguous match
    ) {
      diagColumn = column;
    }

    if (diagColumn === column) {
      // this is a contiguous match
      backwardsDiagLength++;
    } else {
      backwardsDiagLength = 1;
    }

    if (!maxMatchColumn) {
      // remember the last matched column
      maxMatchColumn = diagColumn;
    }

    row--;
    column = diagColumn - 1;
    result.push(column);
  }

  if (wordLen === patternLen && options.boostFullMatch) {
    // the word matches the pattern with all characters!
    // giving the score a total match boost (to come up ahead other words)
    result[0] += 2;
  } // Add 1 penalty for each skipped character in the word


  const skippedCharsCount = maxMatchColumn - patternLen;
  result[0] -= skippedCharsCount;
  return result;
}

function _fillInMaxWordMatchPos(patternLen, wordLen, patternStart, wordStart, patternLow, wordLow) {
  let patternPos = patternLen - 1;
  let wordPos = wordLen - 1;

  while (patternPos >= patternStart && wordPos >= wordStart) {
    if (patternLow[patternPos] === wordLow[wordPos]) {
      _maxWordMatchPos[patternPos] = wordPos;
      patternPos--;
    }

    wordPos--;
  }
}

function _doScore(pattern, patternLow, patternPos, patternStart, word, wordLow, wordPos, wordLen, wordStart, newMatchStart, outFirstMatchStrong) {
  if (patternLow[patternPos] !== wordLow[wordPos]) {
    return Number.MIN_SAFE_INTEGER;
  }

  let score = 1;
  let isGapLocation = false;

  if (wordPos === patternPos - patternStart) {
    // common prefix: `foobar <-> foobaz`
    //                            ^^^^^
    score = pattern[patternPos] === word[wordPos] ? 7 : 5;
  } else if (isUpperCaseAtPos(wordPos, word, wordLow) && (wordPos === 0 || !isUpperCaseAtPos(wordPos - 1, word, wordLow))) {
    // hitting upper-case: `foo <-> forOthers`
    //                              ^^ ^
    score = pattern[patternPos] === word[wordPos] ? 7 : 5;
    isGapLocation = true;
  } else if (isSeparatorAtPos(wordLow, wordPos) && (wordPos === 0 || !isSeparatorAtPos(wordLow, wordPos - 1))) {
    // hitting a separator: `. <-> foo.bar`
    //                                ^
    score = 5;
  } else if (isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1)) {
    // post separator: `foo <-> bar_foo`
    //                              ^^^
    score = 5;
    isGapLocation = true;
  }

  if (score > 1 && patternPos === patternStart) {
    outFirstMatchStrong[0] = true;
  }

  if (!isGapLocation) {
    isGapLocation = isUpperCaseAtPos(wordPos, word, wordLow) || isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1);
  } //


  if (patternPos === patternStart) {
    // first character in pattern
    if (wordPos > wordStart) {
      // the first pattern character would match a word character that is not at the word start
      // so introduce a penalty to account for the gap preceding this match
      score -= isGapLocation ? 3 : 5;
    }
  } else {
    if (newMatchStart) {
      // this would be the beginning of a new match (i.e. there would be a gap before this location)
      score += isGapLocation ? 2 : 0;
    } else {
      // this is part of a contiguous match, so give it a slight bonus, but do so only if it would not be a preferred gap location
      score += isGapLocation ? 0 : 1;
    }
  }

  if (wordPos + 1 === wordLen) {
    // we always penalize gaps, but this gives unfair advantages to a match that would match the last character in the word
    // so pretend there is a gap after the last character in the word to normalize things
    score -= isGapLocation ? 3 : 5;
  }

  return score;
} //#endregion
//#region --- graceful ---


function fuzzyScoreGracefulAggressive(pattern, lowPattern, patternPos, word, lowWord, wordPos, options) {
  return fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, true, options);
}
function fuzzyScoreGraceful(pattern, lowPattern, patternPos, word, lowWord, wordPos, options) {
  return fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, false, options);
}

function fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, aggressive, options) {
  let top = fuzzyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, options);

  if (top && !aggressive) {
    // when using the original pattern yield a result we`
    // return it unless we are aggressive and try to find
    // a better alignment, e.g. `cno` -> `^co^ns^ole` or `^c^o^nsole`.
    return top;
  }

  if (pattern.length >= 3) {
    // When the pattern is long enough then try a few (max 7)
    // permutations of the pattern to find a better match. The
    // permutations only swap neighbouring characters, e.g
    // `cnoso` becomes `conso`, `cnsoo`, `cnoos`.
    const tries = Math.min(7, pattern.length - 1);

    for (let movingPatternPos = patternPos + 1; movingPatternPos < tries; movingPatternPos++) {
      const newPattern = nextTypoPermutation(pattern, movingPatternPos);

      if (newPattern) {
        const candidate = fuzzyScore(newPattern, newPattern.toLowerCase(), patternPos, word, lowWord, wordPos, options);

        if (candidate) {
          candidate[0] -= 3; // permutation penalty

          if (!top || candidate[0] > top[0]) {
            top = candidate;
          }
        }
      }
    }
  }

  return top;
}

function nextTypoPermutation(pattern, patternPos) {
  if (patternPos + 1 >= pattern.length) {
    return undefined;
  }

  const swap1 = pattern[patternPos];
  const swap2 = pattern[patternPos + 1];

  if (swap1 === swap2) {
    return undefined;
  }

  return pattern.slice(0, patternPos) + swap2 + swap1 + pattern.slice(patternPos + 2);
} //#endregion

/***/ }),
/* 123 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getOrSet": () => (/* binding */ getOrSet),
/* harmony export */   "mapToString": () => (/* binding */ mapToString),
/* harmony export */   "setToString": () => (/* binding */ setToString),
/* harmony export */   "StringIterator": () => (/* binding */ StringIterator),
/* harmony export */   "ConfigKeysIterator": () => (/* binding */ ConfigKeysIterator),
/* harmony export */   "PathIterator": () => (/* binding */ PathIterator),
/* harmony export */   "UriIterator": () => (/* binding */ UriIterator),
/* harmony export */   "TernarySearchTree": () => (/* binding */ TernarySearchTree),
/* harmony export */   "ResourceMap": () => (/* binding */ ResourceMap),
/* harmony export */   "ResourceSet": () => (/* binding */ ResourceSet),
/* harmony export */   "Touch": () => (/* binding */ Touch),
/* harmony export */   "LinkedMap": () => (/* binding */ LinkedMap),
/* harmony export */   "LRUCache": () => (/* binding */ LRUCache)
/* harmony export */ });
/* harmony import */ var _arrays__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(87);
/* harmony import */ var _charCode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(71);
/* harmony import */ var _strings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(75);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/



function getOrSet(map, key, value) {
  let result = map.get(key);

  if (result === undefined) {
    result = value;
    map.set(key, result);
  }

  return result;
}
function mapToString(map) {
  const entries = [];
  map.forEach((value, key) => {
    entries.push(`${key} => ${value}`);
  });
  return `Map(${map.size}) {${entries.join(', ')}}`;
}
function setToString(set) {
  const entries = [];
  set.forEach(value => {
    entries.push(value);
  });
  return `Set(${set.size}) {${entries.join(', ')}}`;
}
class StringIterator {
  _value = '';
  _pos = 0;

  reset(key) {
    this._value = key;
    this._pos = 0;
    return this;
  }

  next() {
    this._pos += 1;
    return this;
  }

  hasNext() {
    return this._pos < this._value.length - 1;
  }

  cmp(a) {
    const aCode = a.charCodeAt(0);

    const thisCode = this._value.charCodeAt(this._pos);

    return aCode - thisCode;
  }

  value() {
    return this._value[this._pos];
  }

}
class ConfigKeysIterator {
  constructor(_caseSensitive = true) {
    this._caseSensitive = _caseSensitive;
  }

  reset(key) {
    this._value = key;
    this._from = 0;
    this._to = 0;
    return this.next();
  }

  hasNext() {
    return this._to < this._value.length;
  }

  next() {
    // this._data = key.split(/[\\/]/).filter(s => !!s);
    this._from = this._to;
    let justSeps = true;

    for (; this._to < this._value.length; this._to++) {
      const ch = this._value.charCodeAt(this._to);

      if (ch === _charCode__WEBPACK_IMPORTED_MODULE_1__.CharCode.Period) {
        if (justSeps) {
          this._from++;
        } else {
          break;
        }
      } else {
        justSeps = false;
      }
    }

    return this;
  }

  cmp(a) {
    return this._caseSensitive ? (0,_strings__WEBPACK_IMPORTED_MODULE_2__.compareSubstring)(a, this._value, 0, a.length, this._from, this._to) : (0,_strings__WEBPACK_IMPORTED_MODULE_2__.compareSubstringIgnoreCase)(a, this._value, 0, a.length, this._from, this._to);
  }

  value() {
    return this._value.substring(this._from, this._to);
  }

}
class PathIterator {
  constructor(_splitOnBackslash = true, _caseSensitive = true) {
    this._splitOnBackslash = _splitOnBackslash;
    this._caseSensitive = _caseSensitive;
  }

  reset(key) {
    this._from = 0;
    this._to = 0;
    this._value = key;
    this._valueLen = key.length;

    for (let pos = key.length - 1; pos >= 0; pos--, this._valueLen--) {
      const ch = this._value.charCodeAt(pos);

      if (!(ch === _charCode__WEBPACK_IMPORTED_MODULE_1__.CharCode.Slash || this._splitOnBackslash && ch === _charCode__WEBPACK_IMPORTED_MODULE_1__.CharCode.Backslash)) {
        break;
      }
    }

    return this.next();
  }

  hasNext() {
    return this._to < this._valueLen;
  }

  next() {
    // this._data = key.split(/[\\/]/).filter(s => !!s);
    this._from = this._to;
    let justSeps = true;

    for (; this._to < this._valueLen; this._to++) {
      const ch = this._value.charCodeAt(this._to);

      if (ch === _charCode__WEBPACK_IMPORTED_MODULE_1__.CharCode.Slash || this._splitOnBackslash && ch === _charCode__WEBPACK_IMPORTED_MODULE_1__.CharCode.Backslash) {
        if (justSeps) {
          this._from++;
        } else {
          break;
        }
      } else {
        justSeps = false;
      }
    }

    return this;
  }

  cmp(a) {
    return this._caseSensitive ? (0,_strings__WEBPACK_IMPORTED_MODULE_2__.compareSubstring)(a, this._value, 0, a.length, this._from, this._to) : (0,_strings__WEBPACK_IMPORTED_MODULE_2__.compareSubstringIgnoreCase)(a, this._value, 0, a.length, this._from, this._to);
  }

  value() {
    return this._value.substring(this._from, this._to);
  }

}
var UriIteratorState;

(function (UriIteratorState) {
  UriIteratorState[UriIteratorState["Scheme"] = 1] = "Scheme";
  UriIteratorState[UriIteratorState["Authority"] = 2] = "Authority";
  UriIteratorState[UriIteratorState["Path"] = 3] = "Path";
  UriIteratorState[UriIteratorState["Query"] = 4] = "Query";
  UriIteratorState[UriIteratorState["Fragment"] = 5] = "Fragment";
})(UriIteratorState || (UriIteratorState = {}));

class UriIterator {
  _states = [];
  _stateIdx = 0;

  constructor(_ignorePathCasing, _ignoreQueryAndFragment) {
    this._ignorePathCasing = _ignorePathCasing;
    this._ignoreQueryAndFragment = _ignoreQueryAndFragment;
  }

  reset(key) {
    this._value = key;
    this._states = [];

    if (this._value.scheme) {
      this._states.push(UriIteratorState.Scheme);
    }

    if (this._value.authority) {
      this._states.push(UriIteratorState.Authority);
    }

    if (this._value.path) {
      this._pathIterator = new PathIterator(false, !this._ignorePathCasing(key));

      this._pathIterator.reset(key.path);

      if (this._pathIterator.value()) {
        this._states.push(UriIteratorState.Path);
      }
    }

    if (!this._ignoreQueryAndFragment(key)) {
      if (this._value.query) {
        this._states.push(UriIteratorState.Query);
      }

      if (this._value.fragment) {
        this._states.push(UriIteratorState.Fragment);
      }
    }

    this._stateIdx = 0;
    return this;
  }

  next() {
    if (this._states[this._stateIdx] === UriIteratorState.Path && this._pathIterator.hasNext()) {
      this._pathIterator.next();
    } else {
      this._stateIdx += 1;
    }

    return this;
  }

  hasNext() {
    return this._states[this._stateIdx] === UriIteratorState.Path && this._pathIterator.hasNext() || this._stateIdx < this._states.length - 1;
  }

  cmp(a) {
    if (this._states[this._stateIdx] === UriIteratorState.Scheme) {
      return (0,_strings__WEBPACK_IMPORTED_MODULE_2__.compareIgnoreCase)(a, this._value.scheme);
    } else if (this._states[this._stateIdx] === UriIteratorState.Authority) {
      return (0,_strings__WEBPACK_IMPORTED_MODULE_2__.compareIgnoreCase)(a, this._value.authority);
    } else if (this._states[this._stateIdx] === UriIteratorState.Path) {
      return this._pathIterator.cmp(a);
    } else if (this._states[this._stateIdx] === UriIteratorState.Query) {
      return (0,_strings__WEBPACK_IMPORTED_MODULE_2__.compare)(a, this._value.query);
    } else if (this._states[this._stateIdx] === UriIteratorState.Fragment) {
      return (0,_strings__WEBPACK_IMPORTED_MODULE_2__.compare)(a, this._value.fragment);
    }

    throw new Error();
  }

  value() {
    if (this._states[this._stateIdx] === UriIteratorState.Scheme) {
      return this._value.scheme;
    } else if (this._states[this._stateIdx] === UriIteratorState.Authority) {
      return this._value.authority;
    } else if (this._states[this._stateIdx] === UriIteratorState.Path) {
      return this._pathIterator.value();
    } else if (this._states[this._stateIdx] === UriIteratorState.Query) {
      return this._value.query;
    } else if (this._states[this._stateIdx] === UriIteratorState.Fragment) {
      return this._value.fragment;
    }

    throw new Error();
  }

}

class TernarySearchTreeNode {
  height = 1;

  isEmpty() {
    return !this.left && !this.mid && !this.right && !this.value;
  }

  rotateLeft() {
    const tmp = this.right;
    this.right = tmp.left;
    tmp.left = this;
    this.updateHeight();
    tmp.updateHeight();
    return tmp;
  }

  rotateRight() {
    const tmp = this.left;
    this.left = tmp.right;
    tmp.right = this;
    this.updateHeight();
    tmp.updateHeight();
    return tmp;
  }

  updateHeight() {
    this.height = 1 + Math.max(this.heightLeft, this.heightRight);
  }

  balanceFactor() {
    return this.heightRight - this.heightLeft;
  }

  get heightLeft() {
    return this.left?.height ?? 0;
  }

  get heightRight() {
    return this.right?.height ?? 0;
  }

}

var Dir;

(function (Dir) {
  Dir[Dir["Left"] = -1] = "Left";
  Dir[Dir["Mid"] = 0] = "Mid";
  Dir[Dir["Right"] = 1] = "Right";
})(Dir || (Dir = {}));

class TernarySearchTree {
  static forUris(ignorePathCasing = () => false, ignoreQueryAndFragment = () => false) {
    return new TernarySearchTree(new UriIterator(ignorePathCasing, ignoreQueryAndFragment));
  }

  static forPaths(ignorePathCasing = false) {
    return new TernarySearchTree(new PathIterator(undefined, !ignorePathCasing));
  }

  static forStrings() {
    return new TernarySearchTree(new StringIterator());
  }

  static forConfigKeys() {
    return new TernarySearchTree(new ConfigKeysIterator());
  }

  constructor(segments) {
    this._iter = segments;
  }

  clear() {
    this._root = undefined;
  }
  /**
   * Fill the tree with the same value of the given keys
   */


  fill(values, keys) {
    if (keys) {
      const arr = keys.slice(0);
      (0,_arrays__WEBPACK_IMPORTED_MODULE_0__.shuffle)(arr);

      for (const k of arr) {
        this.set(k, values);
      }
    } else {
      const arr = values.slice(0);
      (0,_arrays__WEBPACK_IMPORTED_MODULE_0__.shuffle)(arr);

      for (const entry of arr) {
        this.set(entry[0], entry[1]);
      }
    }
  }

  set(key, element) {
    const iter = this._iter.reset(key);

    let node;

    if (!this._root) {
      this._root = new TernarySearchTreeNode();
      this._root.segment = iter.value();
    }

    const stack = []; // find insert_node

    node = this._root;

    while (true) {
      const val = iter.cmp(node.segment);

      if (val > 0) {
        // left
        if (!node.left) {
          node.left = new TernarySearchTreeNode();
          node.left.segment = iter.value();
        }

        stack.push([Dir.Left, node]);
        node = node.left;
      } else if (val < 0) {
        // right
        if (!node.right) {
          node.right = new TernarySearchTreeNode();
          node.right.segment = iter.value();
        }

        stack.push([Dir.Right, node]);
        node = node.right;
      } else if (iter.hasNext()) {
        // mid
        iter.next();

        if (!node.mid) {
          node.mid = new TernarySearchTreeNode();
          node.mid.segment = iter.value();
        }

        stack.push([Dir.Mid, node]);
        node = node.mid;
      } else {
        break;
      }
    } // set value


    const oldElement = node.value;
    node.value = element;
    node.key = key; // balance

    for (let i = stack.length - 1; i >= 0; i--) {
      const node = stack[i][1];
      node.updateHeight();
      const bf = node.balanceFactor();

      if (bf < -1 || bf > 1) {
        // needs rotate
        const d1 = stack[i][0];
        const d2 = stack[i + 1][0];

        if (d1 === Dir.Right && d2 === Dir.Right) {
          //right, right -> rotate left
          stack[i][1] = node.rotateLeft();
        } else if (d1 === Dir.Left && d2 === Dir.Left) {
          // left, left -> rotate right
          stack[i][1] = node.rotateRight();
        } else if (d1 === Dir.Right && d2 === Dir.Left) {
          // right, left -> double rotate right, left
          node.right = stack[i + 1][1] = stack[i + 1][1].rotateRight();
          stack[i][1] = node.rotateLeft();
        } else if (d1 === Dir.Left && d2 === Dir.Right) {
          // left, right -> double rotate left, right
          node.left = stack[i + 1][1] = stack[i + 1][1].rotateLeft();
          stack[i][1] = node.rotateRight();
        } else {
          throw new Error();
        } // patch path to parent


        if (i > 0) {
          switch (stack[i - 1][0]) {
            case Dir.Left:
              stack[i - 1][1].left = stack[i][1];
              break;

            case Dir.Right:
              stack[i - 1][1].right = stack[i][1];
              break;

            case Dir.Mid:
              stack[i - 1][1].mid = stack[i][1];
              break;
          }
        } else {
          this._root = stack[0][1];
        }
      }
    }

    return oldElement;
  }

  get(key) {
    return this._getNode(key)?.value;
  }

  _getNode(key) {
    const iter = this._iter.reset(key);

    let node = this._root;

    while (node) {
      const val = iter.cmp(node.segment);

      if (val > 0) {
        // left
        node = node.left;
      } else if (val < 0) {
        // right
        node = node.right;
      } else if (iter.hasNext()) {
        // mid
        iter.next();
        node = node.mid;
      } else {
        break;
      }
    }

    return node;
  }

  has(key) {
    const node = this._getNode(key);

    return !(node?.value === undefined && node?.mid === undefined);
  }

  delete(key) {
    return this._delete(key, false);
  }

  deleteSuperstr(key) {
    return this._delete(key, true);
  }

  _delete(key, superStr) {
    const iter = this._iter.reset(key);

    const stack = [];
    let node = this._root; // find node

    while (node) {
      const val = iter.cmp(node.segment);

      if (val > 0) {
        // left
        stack.push([Dir.Left, node]);
        node = node.left;
      } else if (val < 0) {
        // right
        stack.push([Dir.Right, node]);
        node = node.right;
      } else if (iter.hasNext()) {
        // mid
        iter.next();
        stack.push([Dir.Mid, node]);
        node = node.mid;
      } else {
        break;
      }
    }

    if (!node) {
      // node not found
      return;
    }

    if (superStr) {
      // removing children, reset height
      node.left = undefined;
      node.mid = undefined;
      node.right = undefined;
      node.height = 1;
    } else {
      // removing element
      node.key = undefined;
      node.value = undefined;
    } // BST node removal


    if (!node.mid && !node.value) {
      if (node.left && node.right) {
        // full node
        const min = this._min(node.right);

        const {
          key,
          value,
          segment
        } = min;

        this._delete(min.key, false);

        node.key = key;
        node.value = value;
        node.segment = segment;
      } else {
        // empty or half empty
        const newChild = node.left ?? node.right;

        if (stack.length > 0) {
          const [dir, parent] = stack[stack.length - 1];

          switch (dir) {
            case Dir.Left:
              parent.left = newChild;
              break;

            case Dir.Mid:
              parent.mid = newChild;
              break;

            case Dir.Right:
              parent.right = newChild;
              break;
          }
        } else {
          this._root = newChild;
        }
      }
    } // AVL balance


    for (let i = stack.length - 1; i >= 0; i--) {
      const node = stack[i][1];
      node.updateHeight();
      const bf = node.balanceFactor();

      if (bf > 1) {
        // right heavy
        if (node.right.balanceFactor() >= 0) {
          // right, right -> rotate left
          stack[i][1] = node.rotateLeft();
        } else {
          // right, left -> double rotate
          node.right = node.right.rotateRight();
          stack[i][1] = node.rotateLeft();
        }
      } else if (bf < -1) {
        // left heavy
        if (node.left.balanceFactor() <= 0) {
          // left, left -> rotate right
          stack[i][1] = node.rotateRight();
        } else {
          // left, right -> double rotate
          node.left = node.left.rotateLeft();
          stack[i][1] = node.rotateRight();
        }
      } // patch path to parent


      if (i > 0) {
        switch (stack[i - 1][0]) {
          case Dir.Left:
            stack[i - 1][1].left = stack[i][1];
            break;

          case Dir.Right:
            stack[i - 1][1].right = stack[i][1];
            break;

          case Dir.Mid:
            stack[i - 1][1].mid = stack[i][1];
            break;
        }
      } else {
        this._root = stack[0][1];
      }
    }
  }

  _min(node) {
    while (node.left) {
      node = node.left;
    }

    return node;
  }

  findSubstr(key) {
    const iter = this._iter.reset(key);

    let node = this._root;
    let candidate = undefined;

    while (node) {
      const val = iter.cmp(node.segment);

      if (val > 0) {
        // left
        node = node.left;
      } else if (val < 0) {
        // right
        node = node.right;
      } else if (iter.hasNext()) {
        // mid
        iter.next();
        candidate = node.value || candidate;
        node = node.mid;
      } else {
        break;
      }
    }

    return node && node.value || candidate;
  }

  findSuperstr(key) {
    const iter = this._iter.reset(key);

    let node = this._root;

    while (node) {
      const val = iter.cmp(node.segment);

      if (val > 0) {
        // left
        node = node.left;
      } else if (val < 0) {
        // right
        node = node.right;
      } else if (iter.hasNext()) {
        // mid
        iter.next();
        node = node.mid;
      } else {
        // collect
        if (!node.mid) {
          return undefined;
        } else {
          return this._entries(node.mid);
        }
      }
    }

    return undefined;
  }

  forEach(callback) {
    for (const [key, value] of this) {
      callback(value, key);
    }
  }

  *[Symbol.iterator]() {
    yield* this._entries(this._root);
  }

  _entries(node) {
    const result = [];

    this._dfsEntries(node, result);

    return result[Symbol.iterator]();
  }

  _dfsEntries(node, bucket) {
    // DFS
    if (!node) {
      return;
    }

    if (node.left) {
      this._dfsEntries(node.left, bucket);
    }

    if (node.value) {
      bucket.push([node.key, node.value]);
    }

    if (node.mid) {
      this._dfsEntries(node.mid, bucket);
    }

    if (node.right) {
      this._dfsEntries(node.right, bucket);
    }
  } // for debug/testing


  _isBalanced() {
    const nodeIsBalanced = node => {
      if (!node) {
        return true;
      }

      const bf = node.balanceFactor();

      if (bf < -1 || bf > 1) {
        return false;
      }

      return nodeIsBalanced(node.left) && nodeIsBalanced(node.right);
    };

    return nodeIsBalanced(this._root);
  }

}

class ResourceMapEntry {
  constructor(uri, value) {
    this.uri = uri;
    this.value = value;
  }

}

class ResourceMap {
  static defaultToKey = resource => resource.toString();
  [Symbol.toStringTag] = 'ResourceMap';

  constructor(mapOrKeyFn, toKey) {
    if (mapOrKeyFn instanceof ResourceMap) {
      this.map = new Map(mapOrKeyFn.map);
      this.toKey = toKey ?? ResourceMap.defaultToKey;
    } else {
      this.map = new Map();
      this.toKey = mapOrKeyFn ?? ResourceMap.defaultToKey;
    }
  }

  set(resource, value) {
    this.map.set(this.toKey(resource), new ResourceMapEntry(resource, value));
    return this;
  }

  get(resource) {
    return this.map.get(this.toKey(resource))?.value;
  }

  has(resource) {
    return this.map.has(this.toKey(resource));
  }

  get size() {
    return this.map.size;
  }

  clear() {
    this.map.clear();
  }

  delete(resource) {
    return this.map.delete(this.toKey(resource));
  }

  forEach(clb, thisArg) {
    if (typeof thisArg !== 'undefined') {
      clb = clb.bind(thisArg);
    }

    for (const [_, entry] of this.map) {
      clb(entry.value, entry.uri, this);
    }
  }

  *values() {
    for (const entry of this.map.values()) {
      yield entry.value;
    }
  }

  *keys() {
    for (const entry of this.map.values()) {
      yield entry.uri;
    }
  }

  *entries() {
    for (const entry of this.map.values()) {
      yield [entry.uri, entry.value];
    }
  }

  *[Symbol.iterator]() {
    for (const [, entry] of this.map) {
      yield [entry.uri, entry.value];
    }
  }

}
class ResourceSet {
  [Symbol.toStringTag] = 'ResourceSet';

  constructor(entriesOrKey, toKey) {
    if (!entriesOrKey || typeof entriesOrKey === 'function') {
      this._map = new ResourceMap(entriesOrKey);
    } else {
      this._map = new ResourceMap(toKey);
      entriesOrKey.forEach(this.add, this);
    }
  }

  get size() {
    return this._map.size;
  }

  add(value) {
    this._map.set(value, value);

    return this;
  }

  clear() {
    this._map.clear();
  }

  delete(value) {
    return this._map.delete(value);
  }

  forEach(callbackfn, thisArg) {
    this._map.forEach((_value, key) => callbackfn.call(thisArg, key, key, this));
  }

  has(value) {
    return this._map.has(value);
  }

  entries() {
    return this._map.entries();
  }

  keys() {
    return this._map.keys();
  }

  values() {
    return this._map.keys();
  }

  [Symbol.iterator]() {
    return this.keys();
  }

}
let Touch;

(function (Touch) {
  Touch[Touch["None"] = 0] = "None";
  Touch[Touch["AsOld"] = 1] = "AsOld";
  Touch[Touch["AsNew"] = 2] = "AsNew";
})(Touch || (Touch = {}));

class LinkedMap {
  [Symbol.toStringTag] = 'LinkedMap';

  constructor() {
    this._map = new Map();
    this._head = undefined;
    this._tail = undefined;
    this._size = 0;
    this._state = 0;
  }

  clear() {
    this._map.clear();

    this._head = undefined;
    this._tail = undefined;
    this._size = 0;
    this._state++;
  }

  isEmpty() {
    return !this._head && !this._tail;
  }

  get size() {
    return this._size;
  }

  get first() {
    return this._head?.value;
  }

  get last() {
    return this._tail?.value;
  }

  has(key) {
    return this._map.has(key);
  }

  get(key, touch = Touch.None) {
    const item = this._map.get(key);

    if (!item) {
      return undefined;
    }

    if (touch !== Touch.None) {
      this.touch(item, touch);
    }

    return item.value;
  }

  set(key, value, touch = Touch.None) {
    let item = this._map.get(key);

    if (item) {
      item.value = value;

      if (touch !== Touch.None) {
        this.touch(item, touch);
      }
    } else {
      item = {
        key,
        value,
        next: undefined,
        previous: undefined
      };

      switch (touch) {
        case Touch.None:
          this.addItemLast(item);
          break;

        case Touch.AsOld:
          this.addItemFirst(item);
          break;

        case Touch.AsNew:
          this.addItemLast(item);
          break;

        default:
          this.addItemLast(item);
          break;
      }

      this._map.set(key, item);

      this._size++;
    }

    return this;
  }

  delete(key) {
    return !!this.remove(key);
  }

  remove(key) {
    const item = this._map.get(key);

    if (!item) {
      return undefined;
    }

    this._map.delete(key);

    this.removeItem(item);
    this._size--;
    return item.value;
  }

  shift() {
    if (!this._head && !this._tail) {
      return undefined;
    }

    if (!this._head || !this._tail) {
      throw new Error('Invalid list');
    }

    const item = this._head;

    this._map.delete(item.key);

    this.removeItem(item);
    this._size--;
    return item.value;
  }

  forEach(callbackfn, thisArg) {
    const state = this._state;
    let current = this._head;

    while (current) {
      if (thisArg) {
        callbackfn.bind(thisArg)(current.value, current.key, this);
      } else {
        callbackfn(current.value, current.key, this);
      }

      if (this._state !== state) {
        throw new Error(`LinkedMap got modified during iteration.`);
      }

      current = current.next;
    }
  }

  keys() {
    const map = this;
    const state = this._state;
    let current = this._head;
    const iterator = {
      [Symbol.iterator]() {
        return iterator;
      },

      next() {
        if (map._state !== state) {
          throw new Error(`LinkedMap got modified during iteration.`);
        }

        if (current) {
          const result = {
            value: current.key,
            done: false
          };
          current = current.next;
          return result;
        } else {
          return {
            value: undefined,
            done: true
          };
        }
      }

    };
    return iterator;
  }

  values() {
    const map = this;
    const state = this._state;
    let current = this._head;
    const iterator = {
      [Symbol.iterator]() {
        return iterator;
      },

      next() {
        if (map._state !== state) {
          throw new Error(`LinkedMap got modified during iteration.`);
        }

        if (current) {
          const result = {
            value: current.value,
            done: false
          };
          current = current.next;
          return result;
        } else {
          return {
            value: undefined,
            done: true
          };
        }
      }

    };
    return iterator;
  }

  entries() {
    const map = this;
    const state = this._state;
    let current = this._head;
    const iterator = {
      [Symbol.iterator]() {
        return iterator;
      },

      next() {
        if (map._state !== state) {
          throw new Error(`LinkedMap got modified during iteration.`);
        }

        if (current) {
          const result = {
            value: [current.key, current.value],
            done: false
          };
          current = current.next;
          return result;
        } else {
          return {
            value: undefined,
            done: true
          };
        }
      }

    };
    return iterator;
  }

  [Symbol.iterator]() {
    return this.entries();
  }

  trimOld(newSize) {
    if (newSize >= this.size) {
      return;
    }

    if (newSize === 0) {
      this.clear();
      return;
    }

    let current = this._head;
    let currentSize = this.size;

    while (current && currentSize > newSize) {
      this._map.delete(current.key);

      current = current.next;
      currentSize--;
    }

    this._head = current;
    this._size = currentSize;

    if (current) {
      current.previous = undefined;
    }

    this._state++;
  }

  addItemFirst(item) {
    // First time Insert
    if (!this._head && !this._tail) {
      this._tail = item;
    } else if (!this._head) {
      throw new Error('Invalid list');
    } else {
      item.next = this._head;
      this._head.previous = item;
    }

    this._head = item;
    this._state++;
  }

  addItemLast(item) {
    // First time Insert
    if (!this._head && !this._tail) {
      this._head = item;
    } else if (!this._tail) {
      throw new Error('Invalid list');
    } else {
      item.previous = this._tail;
      this._tail.next = item;
    }

    this._tail = item;
    this._state++;
  }

  removeItem(item) {
    if (item === this._head && item === this._tail) {
      this._head = undefined;
      this._tail = undefined;
    } else if (item === this._head) {
      // This can only happen if size === 1 which is handled
      // by the case above.
      if (!item.next) {
        throw new Error('Invalid list');
      }

      item.next.previous = undefined;
      this._head = item.next;
    } else if (item === this._tail) {
      // This can only happen if size === 1 which is handled
      // by the case above.
      if (!item.previous) {
        throw new Error('Invalid list');
      }

      item.previous.next = undefined;
      this._tail = item.previous;
    } else {
      const next = item.next;
      const previous = item.previous;

      if (!next || !previous) {
        throw new Error('Invalid list');
      }

      next.previous = previous;
      previous.next = next;
    }

    item.next = undefined;
    item.previous = undefined;
    this._state++;
  }

  touch(item, touch) {
    if (!this._head || !this._tail) {
      throw new Error('Invalid list');
    }

    if (touch !== Touch.AsOld && touch !== Touch.AsNew) {
      return;
    }

    if (touch === Touch.AsOld) {
      if (item === this._head) {
        return;
      }

      const next = item.next;
      const previous = item.previous; // Unlink the item

      if (item === this._tail) {
        // previous must be defined since item was not head but is tail
        // So there are more than on item in the map
        previous.next = undefined;
        this._tail = previous;
      } else {
        // Both next and previous are not undefined since item was neither head nor tail.
        next.previous = previous;
        previous.next = next;
      } // Insert the node at head


      item.previous = undefined;
      item.next = this._head;
      this._head.previous = item;
      this._head = item;
      this._state++;
    } else if (touch === Touch.AsNew) {
      if (item === this._tail) {
        return;
      }

      const next = item.next;
      const previous = item.previous; // Unlink the item.

      if (item === this._head) {
        // next must be defined since item was not tail but is head
        // So there are more than on item in the map
        next.previous = undefined;
        this._head = next;
      } else {
        // Both next and previous are not undefined since item was neither head nor tail.
        next.previous = previous;
        previous.next = next;
      }

      item.next = undefined;
      item.previous = this._tail;
      this._tail.next = item;
      this._tail = item;
      this._state++;
    }
  }

  toJSON() {
    const data = [];
    this.forEach((value, key) => {
      data.push([key, value]);
    });
    return data;
  }

  fromJSON(data) {
    this.clear();

    for (const [key, value] of data) {
      this.set(key, value);
    }
  }

}
class LRUCache extends LinkedMap {
  constructor(limit, ratio = 1) {
    super();
    this._limit = limit;
    this._ratio = Math.min(Math.max(0, ratio), 1);
  }

  get limit() {
    return this._limit;
  }

  set limit(limit) {
    this._limit = limit;
    this.checkTrim();
  }

  get ratio() {
    return this._ratio;
  }

  set ratio(ratio) {
    this._ratio = Math.min(Math.max(0, ratio), 1);
    this.checkTrim();
  }

  get(key, touch = Touch.AsNew) {
    return super.get(key, touch);
  }

  peek(key) {
    return super.get(key, Touch.None);
  }

  set(key, value) {
    super.set(key, value, Touch.AsNew);
    this.checkTrim();
    return this;
  }

  checkTrim() {
    if (this.size > this._limit) {
      this.trimOld(Math.round(this._limit * this._ratio));
    }
  }

}

/***/ }),
/* 124 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "defaultStyles": () => (/* binding */ defaultStyles),
/* harmony export */   "SelectBox": () => (/* binding */ SelectBox)
/* harmony export */ });
/* harmony import */ var _browser_ui_selectBox_selectBoxCustom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(125);
/* harmony import */ var _browser_ui_selectBox_selectBoxNative__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(148);
/* harmony import */ var _browser_ui_widget__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(100);
/* harmony import */ var _common_color__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(91);
/* harmony import */ var _common_objects__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(134);
/* harmony import */ var _common_platform__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(58);
/* harmony import */ var _selectBox_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(149);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






 // Public SelectBox interface - Calls routed to appropriate select implementation class

const defaultStyles = {
  selectBackground: _common_color__WEBPACK_IMPORTED_MODULE_3__.Color.fromHex('#3C3C3C'),
  selectForeground: _common_color__WEBPACK_IMPORTED_MODULE_3__.Color.fromHex('#F0F0F0'),
  selectBorder: _common_color__WEBPACK_IMPORTED_MODULE_3__.Color.fromHex('#3C3C3C')
};
class SelectBox extends _browser_ui_widget__WEBPACK_IMPORTED_MODULE_2__.Widget {
  constructor(options, selected, contextViewProvider, styles = (0,_common_objects__WEBPACK_IMPORTED_MODULE_4__.deepClone)(defaultStyles), selectBoxOptions) {
    super(); // Default to native SelectBox for OSX unless overridden

    if (_common_platform__WEBPACK_IMPORTED_MODULE_5__.isMacintosh && !selectBoxOptions?.useCustomDrawn) {
      this.selectBoxDelegate = new _browser_ui_selectBox_selectBoxNative__WEBPACK_IMPORTED_MODULE_1__.SelectBoxNative(options, selected, styles, selectBoxOptions);
    } else {
      this.selectBoxDelegate = new _browser_ui_selectBox_selectBoxCustom__WEBPACK_IMPORTED_MODULE_0__.SelectBoxList(options, selected, contextViewProvider, styles, selectBoxOptions);
    }

    this._register(this.selectBoxDelegate);
  } // Public SelectBox Methods - routed through delegate interface


  get onDidSelect() {
    return this.selectBoxDelegate.onDidSelect;
  }

  setOptions(options, selected) {
    this.selectBoxDelegate.setOptions(options, selected);
  }

  select(index) {
    this.selectBoxDelegate.select(index);
  }

  setAriaLabel(label) {
    this.selectBoxDelegate.setAriaLabel(label);
  }

  focus() {
    this.selectBoxDelegate.focus();
  }

  blur() {
    this.selectBoxDelegate.blur();
  }

  setFocusable(focusable) {
    this.selectBoxDelegate.setFocusable(focusable);
  }

  render(container) {
    this.selectBoxDelegate.render(container);
  }

  style(styles) {
    this.selectBoxDelegate.style(styles);
  }

  applyStyles() {
    this.selectBoxDelegate.applyStyles();
  }

}

/***/ }),
/* 125 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SelectBoxList": () => (/* binding */ SelectBoxList)
/* harmony export */ });
/* harmony import */ var _browser_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(61);
/* harmony import */ var _browser_event__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(85);
/* harmony import */ var _browser_keyboardEvent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(63);
/* harmony import */ var _browser_markdownRenderer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(126);
/* harmony import */ var _browser_ui_contextview_contextview__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(135);
/* harmony import */ var _browser_ui_list_listWidget__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(138);
/* harmony import */ var _common_arrays__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(87);
/* harmony import */ var _common_event__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(51);
/* harmony import */ var _common_keyCodes__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(64);
/* harmony import */ var _common_lifecycle__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(54);
/* harmony import */ var _common_platform__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(58);
/* harmony import */ var _common_scrollable__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(102);
/* harmony import */ var _selectBoxCustom_css__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(147);
/* harmony import */ var _common_nls__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(59);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/














const $ = _browser_dom__WEBPACK_IMPORTED_MODULE_0__.$;
const SELECT_OPTION_ENTRY_TEMPLATE_ID = 'selectOption.entry.template';

class SelectListRenderer {
  get templateId() {
    return SELECT_OPTION_ENTRY_TEMPLATE_ID;
  }

  renderTemplate(container) {
    const data = Object.create(null);
    data.disposables = [];
    data.root = container;
    data.text = _browser_dom__WEBPACK_IMPORTED_MODULE_0__.append(container, $('.option-text'));
    data.detail = _browser_dom__WEBPACK_IMPORTED_MODULE_0__.append(container, $('.option-detail'));
    data.decoratorRight = _browser_dom__WEBPACK_IMPORTED_MODULE_0__.append(container, $('.option-decorator-right'));
    return data;
  }

  renderElement(element, index, templateData) {
    const data = templateData;
    const text = element.text;
    const detail = element.detail;
    const decoratorRight = element.decoratorRight;
    const isDisabled = element.isDisabled;
    data.text.textContent = text;
    data.detail.textContent = !!detail ? detail : '';
    data.decoratorRight.innerText = !!decoratorRight ? decoratorRight : ''; // pseudo-select disabled option

    if (isDisabled) {
      data.root.classList.add('option-disabled');
    } else {
      // Make sure we do class removal from prior template rendering
      data.root.classList.remove('option-disabled');
    }
  }

  disposeTemplate(templateData) {
    templateData.disposables = (0,_common_lifecycle__WEBPACK_IMPORTED_MODULE_9__.dispose)(templateData.disposables);
  }

}

class SelectBoxList extends _common_lifecycle__WEBPACK_IMPORTED_MODULE_9__.Disposable {
  static DEFAULT_DROPDOWN_MINIMUM_BOTTOM_MARGIN = 32;
  static DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN = 2;
  static DEFAULT_MINIMUM_VISIBLE_OPTIONS = 3;
  options = [];
  _currentSelection = 0;
  _hasDetails = false;
  _skipLayout = false;
  _sticky = false; // for dev purposes only

  constructor(options, selected, contextViewProvider, styles, selectBoxOptions) {
    super();
    this._isVisible = false;
    this.selectBoxOptions = selectBoxOptions || Object.create(null);

    if (typeof this.selectBoxOptions.minBottomMargin !== 'number') {
      this.selectBoxOptions.minBottomMargin = SelectBoxList.DEFAULT_DROPDOWN_MINIMUM_BOTTOM_MARGIN;
    } else if (this.selectBoxOptions.minBottomMargin < 0) {
      this.selectBoxOptions.minBottomMargin = 0;
    }

    this.selectElement = document.createElement('select'); // Use custom CSS vars for padding calculation

    this.selectElement.className = 'monaco-select-box monaco-select-box-dropdown-padding';

    if (typeof this.selectBoxOptions.ariaLabel === 'string') {
      this.selectElement.setAttribute('aria-label', this.selectBoxOptions.ariaLabel);
    }

    if (typeof this.selectBoxOptions.ariaDescription === 'string') {
      this.selectElement.setAttribute('aria-description', this.selectBoxOptions.ariaDescription);
    }

    this._onDidSelect = new _common_event__WEBPACK_IMPORTED_MODULE_7__.Emitter();

    this._register(this._onDidSelect);

    this.styles = styles;
    this.registerListeners();
    this.constructSelectDropDown(contextViewProvider);
    this.selected = selected || 0;

    if (options) {
      this.setOptions(options, selected);
    }
  } // IDelegate - List renderer


  getHeight() {
    return 18;
  }

  getTemplateId() {
    return SELECT_OPTION_ENTRY_TEMPLATE_ID;
  }

  constructSelectDropDown(contextViewProvider) {
    // SetUp ContextView container to hold select Dropdown
    this.contextViewProvider = contextViewProvider;
    this.selectDropDownContainer = _browser_dom__WEBPACK_IMPORTED_MODULE_0__.$('.monaco-select-box-dropdown-container'); // Use custom CSS vars for padding calculation (shared with parent select)

    this.selectDropDownContainer.classList.add('monaco-select-box-dropdown-padding'); // Setup container for select option details

    this.selectionDetailsPane = _browser_dom__WEBPACK_IMPORTED_MODULE_0__.append(this.selectDropDownContainer, $('.select-box-details-pane')); // Create span flex box item/div we can measure and control

    const widthControlOuterDiv = _browser_dom__WEBPACK_IMPORTED_MODULE_0__.append(this.selectDropDownContainer, $('.select-box-dropdown-container-width-control'));
    const widthControlInnerDiv = _browser_dom__WEBPACK_IMPORTED_MODULE_0__.append(widthControlOuterDiv, $('.width-control-div'));
    this.widthControlElement = document.createElement('span');
    this.widthControlElement.className = 'option-text-width-control';
    _browser_dom__WEBPACK_IMPORTED_MODULE_0__.append(widthControlInnerDiv, this.widthControlElement); // Always default to below position

    this._dropDownPosition = _browser_ui_contextview_contextview__WEBPACK_IMPORTED_MODULE_4__.AnchorPosition.BELOW; // Inline stylesheet for themes

    this.styleElement = _browser_dom__WEBPACK_IMPORTED_MODULE_0__.createStyleSheet(this.selectDropDownContainer); // Prevent dragging of dropdown #114329

    this.selectDropDownContainer.setAttribute('draggable', 'true');

    this._register(_browser_dom__WEBPACK_IMPORTED_MODULE_0__.addDisposableListener(this.selectDropDownContainer, _browser_dom__WEBPACK_IMPORTED_MODULE_0__.EventType.DRAG_START, e => {
      _browser_dom__WEBPACK_IMPORTED_MODULE_0__.EventHelper.stop(e, true);
    }));
  }

  registerListeners() {
    // Parent native select keyboard listeners
    this._register(_browser_dom__WEBPACK_IMPORTED_MODULE_0__.addStandardDisposableListener(this.selectElement, 'change', e => {
      this.selected = e.target.selectedIndex;

      this._onDidSelect.fire({
        index: e.target.selectedIndex,
        selected: e.target.value
      });

      if (!!this.options[this.selected] && !!this.options[this.selected].text) {
        this.selectElement.title = this.options[this.selected].text;
      }
    })); // Have to implement both keyboard and mouse controllers to handle disabled options
    // Intercept mouse events to override normal select actions on parents


    this._register(_browser_dom__WEBPACK_IMPORTED_MODULE_0__.addDisposableListener(this.selectElement, _browser_dom__WEBPACK_IMPORTED_MODULE_0__.EventType.CLICK, e => {
      _browser_dom__WEBPACK_IMPORTED_MODULE_0__.EventHelper.stop(e);

      if (this._isVisible) {
        this.hideSelectDropDown(true);
      } else {
        this.showSelectDropDown();
      }
    }));

    this._register(_browser_dom__WEBPACK_IMPORTED_MODULE_0__.addDisposableListener(this.selectElement, _browser_dom__WEBPACK_IMPORTED_MODULE_0__.EventType.MOUSE_DOWN, e => {
      _browser_dom__WEBPACK_IMPORTED_MODULE_0__.EventHelper.stop(e);
    })); // Intercept touch events
    // The following implementation is slightly different from the mouse event handlers above.
    // Use the following helper variable, otherwise the list flickers.


    let listIsVisibleOnTouchStart;

    this._register(_browser_dom__WEBPACK_IMPORTED_MODULE_0__.addDisposableListener(this.selectElement, 'touchstart', e => {
      listIsVisibleOnTouchStart = this._isVisible;
    }));

    this._register(_browser_dom__WEBPACK_IMPORTED_MODULE_0__.addDisposableListener(this.selectElement, 'touchend', e => {
      _browser_dom__WEBPACK_IMPORTED_MODULE_0__.EventHelper.stop(e);

      if (listIsVisibleOnTouchStart) {
        this.hideSelectDropDown(true);
      } else {
        this.showSelectDropDown();
      }
    })); // Intercept keyboard handling


    this._register(_browser_dom__WEBPACK_IMPORTED_MODULE_0__.addDisposableListener(this.selectElement, _browser_dom__WEBPACK_IMPORTED_MODULE_0__.EventType.KEY_DOWN, e => {
      const event = new _browser_keyboardEvent__WEBPACK_IMPORTED_MODULE_2__.StandardKeyboardEvent(e);
      let showDropDown = false; // Create and drop down select list on keyboard select

      if (_common_platform__WEBPACK_IMPORTED_MODULE_10__.isMacintosh) {
        if (event.keyCode === _common_keyCodes__WEBPACK_IMPORTED_MODULE_8__.KeyCode.DownArrow || event.keyCode === _common_keyCodes__WEBPACK_IMPORTED_MODULE_8__.KeyCode.UpArrow || event.keyCode === _common_keyCodes__WEBPACK_IMPORTED_MODULE_8__.KeyCode.Space || event.keyCode === _common_keyCodes__WEBPACK_IMPORTED_MODULE_8__.KeyCode.Enter) {
          showDropDown = true;
        }
      } else {
        if (event.keyCode === _common_keyCodes__WEBPACK_IMPORTED_MODULE_8__.KeyCode.DownArrow && event.altKey || event.keyCode === _common_keyCodes__WEBPACK_IMPORTED_MODULE_8__.KeyCode.UpArrow && event.altKey || event.keyCode === _common_keyCodes__WEBPACK_IMPORTED_MODULE_8__.KeyCode.Space || event.keyCode === _common_keyCodes__WEBPACK_IMPORTED_MODULE_8__.KeyCode.Enter) {
          showDropDown = true;
        }
      }

      if (showDropDown) {
        this.showSelectDropDown();
        _browser_dom__WEBPACK_IMPORTED_MODULE_0__.EventHelper.stop(e, true);
      }
    }));
  }

  get onDidSelect() {
    return this._onDidSelect.event;
  }

  setOptions(options, selected) {
    if (!_common_arrays__WEBPACK_IMPORTED_MODULE_6__.equals(this.options, options)) {
      this.options = options;
      this.selectElement.options.length = 0;
      this._hasDetails = false;
      this.options.forEach((option, index) => {
        this.selectElement.add(this.createOption(option.text, index, option.isDisabled));

        if (typeof option.description === 'string') {
          this._hasDetails = true;
        }
      });
    }

    if (selected !== undefined) {
      this.select(selected); // Set current = selected since this is not necessarily a user exit

      this._currentSelection = this.selected;
    }
  }

  setOptionsList() {
    // Mirror options in drop-down
    // Populate select list for non-native select mode
    this.selectList?.splice(0, this.selectList.length, this.options);
  }

  select(index) {
    if (index >= 0 && index < this.options.length) {
      this.selected = index;
    } else if (index > this.options.length - 1) {
      // Adjust index to end of list
      // This could make client out of sync with the select
      this.select(this.options.length - 1);
    } else if (this.selected < 0) {
      this.selected = 0;
    }

    this.selectElement.selectedIndex = this.selected;

    if (!!this.options[this.selected] && !!this.options[this.selected].text) {
      this.selectElement.title = this.options[this.selected].text;
    }
  }

  setAriaLabel(label) {
    this.selectBoxOptions.ariaLabel = label;
    this.selectElement.setAttribute('aria-label', this.selectBoxOptions.ariaLabel);
  }

  focus() {
    if (this.selectElement) {
      this.selectElement.tabIndex = 0;
      this.selectElement.focus();
    }
  }

  blur() {
    if (this.selectElement) {
      this.selectElement.tabIndex = -1;
      this.selectElement.blur();
    }
  }

  setFocusable(focusable) {
    this.selectElement.tabIndex = focusable ? 0 : -1;
  }

  render(container) {
    this.container = container;
    container.classList.add('select-container');
    container.appendChild(this.selectElement);
    this.applyStyles();
  }

  style(styles) {
    const content = [];
    this.styles = styles; // Style non-native select mode

    if (this.styles.listFocusBackground) {
      content.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.focused { background-color: ${this.styles.listFocusBackground} !important; }`);
    }

    if (this.styles.listFocusForeground) {
      content.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.focused { color: ${this.styles.listFocusForeground} !important; }`);
    }

    if (this.styles.decoratorRightForeground) {
      content.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row:not(.focused) .option-decorator-right { color: ${this.styles.decoratorRightForeground}; }`);
    }

    if (this.styles.selectBackground && this.styles.selectBorder && !this.styles.selectBorder.equals(this.styles.selectBackground)) {
      content.push(`.monaco-select-box-dropdown-container { border: 1px solid ${this.styles.selectBorder} } `);
      content.push(`.monaco-select-box-dropdown-container > .select-box-details-pane.border-top { border-top: 1px solid ${this.styles.selectBorder} } `);
      content.push(`.monaco-select-box-dropdown-container > .select-box-details-pane.border-bottom { border-bottom: 1px solid ${this.styles.selectBorder} } `);
    } else if (this.styles.selectListBorder) {
      content.push(`.monaco-select-box-dropdown-container > .select-box-details-pane.border-top { border-top: 1px solid ${this.styles.selectListBorder} } `);
      content.push(`.monaco-select-box-dropdown-container > .select-box-details-pane.border-bottom { border-bottom: 1px solid ${this.styles.selectListBorder} } `);
    } // Hover foreground - ignore for disabled options


    if (this.styles.listHoverForeground) {
      content.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row:not(.option-disabled):not(.focused):hover { color: ${this.styles.listHoverForeground} !important; }`);
    } // Hover background - ignore for disabled options


    if (this.styles.listHoverBackground) {
      content.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row:not(.option-disabled):not(.focused):hover { background-color: ${this.styles.listHoverBackground} !important; }`);
    } // Match quick input outline styles - ignore for disabled options


    if (this.styles.listFocusOutline) {
      content.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.focused { outline: 1.6px dotted ${this.styles.listFocusOutline} !important; outline-offset: -1.6px !important; }`);
    }

    if (this.styles.listHoverOutline) {
      content.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row:not(.option-disabled):not(.focused):hover { outline: 1.6px dashed ${this.styles.listHoverOutline} !important; outline-offset: -1.6px !important; }`);
    } // Clear list styles on focus and on hover for disabled options


    content.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.option-disabled.focused { background-color: transparent !important; color: inherit !important; outline: none !important; }`);
    content.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.option-disabled:hover { background-color: transparent !important; color: inherit !important; outline: none !important; }`);
    this.styleElement.textContent = content.join('\n');
    this.applyStyles();
  }

  applyStyles() {
    // Style parent select
    if (this.selectElement) {
      const background = this.styles.selectBackground ? this.styles.selectBackground.toString() : '';
      const foreground = this.styles.selectForeground ? this.styles.selectForeground.toString() : '';
      const border = this.styles.selectBorder ? this.styles.selectBorder.toString() : '';
      this.selectElement.style.backgroundColor = background;
      this.selectElement.style.color = foreground;
      this.selectElement.style.borderColor = border;
    } // Style drop down select list (non-native mode only)


    if (this.selectList) {
      this.styleList();
    }
  }

  styleList() {
    if (this.selectList) {
      const background = this.styles.selectBackground ? this.styles.selectBackground.toString() : '';
      this.selectList.style({});
      const listBackground = this.styles.selectListBackground ? this.styles.selectListBackground.toString() : background;
      this.selectDropDownListContainer.style.backgroundColor = listBackground;
      this.selectionDetailsPane.style.backgroundColor = listBackground;
      const optionsBorder = this.styles.focusBorder ? this.styles.focusBorder.toString() : '';
      this.selectDropDownContainer.style.outlineColor = optionsBorder;
      this.selectDropDownContainer.style.outlineOffset = '-1px';
    }
  }

  createOption(value, index, disabled) {
    const option = document.createElement('option');
    option.value = value;
    option.text = value;
    option.disabled = !!disabled;
    return option;
  } // ContextView dropdown methods


  showSelectDropDown() {
    this.selectionDetailsPane.innerText = '';

    if (!this.contextViewProvider || this._isVisible) {
      return;
    } // Lazily create and populate list only at open, moved from constructor


    this.createSelectList(this.selectDropDownContainer);
    this.setOptionsList(); // This allows us to flip the position based on measurement
    // Set drop-down position above/below from required height and margins
    // If pre-layout cannot fit at least one option do not show drop-down

    this.contextViewProvider.showContextView({
      getAnchor: () => this.selectElement,
      render: container => this.renderSelectDropDown(container, true),
      layout: () => {
        this.layoutSelectDropDown();
      },
      onHide: () => {
        this.selectDropDownContainer.classList.remove('visible');
        this.selectElement.classList.remove('synthetic-focus');
      },
      anchorPosition: this._dropDownPosition
    }, this.selectBoxOptions.optionsAsChildren ? this.container : undefined); // Hide so we can relay out

    this._isVisible = true;
    this.hideSelectDropDown(false);
    this.contextViewProvider.showContextView({
      getAnchor: () => this.selectElement,
      render: container => this.renderSelectDropDown(container),
      layout: () => this.layoutSelectDropDown(),
      onHide: () => {
        this.selectDropDownContainer.classList.remove('visible');
        this.selectElement.classList.remove('synthetic-focus');
      },
      anchorPosition: this._dropDownPosition
    }, this.selectBoxOptions.optionsAsChildren ? this.container : undefined); // Track initial selection the case user escape, blur

    this._currentSelection = this.selected;
    this._isVisible = true;
    this.selectElement.setAttribute('aria-expanded', 'true');
  }

  hideSelectDropDown(focusSelect) {
    if (!this.contextViewProvider || !this._isVisible) {
      return;
    }

    this._isVisible = false;
    this.selectElement.setAttribute('aria-expanded', 'false');

    if (focusSelect) {
      this.selectElement.focus();
    }

    this.contextViewProvider.hideContextView();
  }

  renderSelectDropDown(container, preLayoutPosition) {
    container.appendChild(this.selectDropDownContainer); // Pre-Layout allows us to change position

    this.layoutSelectDropDown(preLayoutPosition);
    return {
      dispose: () => {
        // contextView will dispose itself if moving from one View to another
        try {
          container.removeChild(this.selectDropDownContainer); // remove to take out the CSS rules we add
        } catch (error) {// Ignore, removed already by change of focus
        }
      }
    };
  } // Iterate over detailed descriptions, find max height


  measureMaxDetailsHeight() {
    let maxDetailsPaneHeight = 0;
    this.options.forEach((_option, index) => {
      this.updateDetail(index);

      if (this.selectionDetailsPane.offsetHeight > maxDetailsPaneHeight) {
        maxDetailsPaneHeight = this.selectionDetailsPane.offsetHeight;
      }
    });
    return maxDetailsPaneHeight;
  }

  layoutSelectDropDown(preLayoutPosition) {
    // Avoid recursion from layout called in onListFocus
    if (this._skipLayout) {
      return false;
    } // Layout ContextView drop down select list and container
    // Have to manage our vertical overflow, sizing, position below or above
    // Position has to be determined and set prior to contextView instantiation


    if (this.selectList) {
      // Make visible to enable measurements
      this.selectDropDownContainer.classList.add('visible');
      const selectPosition = _browser_dom__WEBPACK_IMPORTED_MODULE_0__.getDomNodePagePosition(this.selectElement);
      const styles = getComputedStyle(this.selectElement);
      const verticalPadding = parseFloat(styles.getPropertyValue('--dropdown-padding-top')) + parseFloat(styles.getPropertyValue('--dropdown-padding-bottom'));
      const maxSelectDropDownHeightBelow = window.innerHeight - selectPosition.top - selectPosition.height - (this.selectBoxOptions.minBottomMargin || 0);
      const maxSelectDropDownHeightAbove = selectPosition.top - SelectBoxList.DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN; // Determine optimal width - min(longest option), opt(parent select, excluding margins), max(ContextView controlled)

      const selectWidth = this.selectElement.offsetWidth;
      const selectMinWidth = this.setWidthControlElement(this.widthControlElement);
      const selectOptimalWidth = Math.max(selectMinWidth, Math.round(selectWidth)).toString() + 'px';
      this.selectDropDownContainer.style.width = selectOptimalWidth; // Get initial list height and determine space above and below

      this.selectList.getHTMLElement().style.height = '';
      this.selectList.layout();
      let listHeight = this.selectList.contentHeight;
      const maxDetailsPaneHeight = this._hasDetails ? this.measureMaxDetailsHeight() : 0;
      const minRequiredDropDownHeight = listHeight + verticalPadding + maxDetailsPaneHeight;
      const maxVisibleOptionsBelow = Math.floor((maxSelectDropDownHeightBelow - verticalPadding - maxDetailsPaneHeight) / this.getHeight());
      const maxVisibleOptionsAbove = Math.floor((maxSelectDropDownHeightAbove - verticalPadding - maxDetailsPaneHeight) / this.getHeight()); // If we are only doing pre-layout check/adjust position only
      // Calculate vertical space available, flip up if insufficient
      // Use reflected padding on parent select, ContextView style
      // properties not available before DOM attachment

      if (preLayoutPosition) {
        // Check if select moved out of viewport , do not open
        // If at least one option cannot be shown, don't open the drop-down or hide/remove if open
        if (selectPosition.top + selectPosition.height > window.innerHeight - 22 || selectPosition.top < SelectBoxList.DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN || maxVisibleOptionsBelow < 1 && maxVisibleOptionsAbove < 1) {
          // Indicate we cannot open
          return false;
        } // Determine if we have to flip up
        // Always show complete list items - never more than Max available vertical height


        if (maxVisibleOptionsBelow < SelectBoxList.DEFAULT_MINIMUM_VISIBLE_OPTIONS && maxVisibleOptionsAbove > maxVisibleOptionsBelow && this.options.length > maxVisibleOptionsBelow) {
          this._dropDownPosition = _browser_ui_contextview_contextview__WEBPACK_IMPORTED_MODULE_4__.AnchorPosition.ABOVE;
          this.selectDropDownContainer.removeChild(this.selectDropDownListContainer);
          this.selectDropDownContainer.removeChild(this.selectionDetailsPane);
          this.selectDropDownContainer.appendChild(this.selectionDetailsPane);
          this.selectDropDownContainer.appendChild(this.selectDropDownListContainer);
          this.selectionDetailsPane.classList.remove('border-top');
          this.selectionDetailsPane.classList.add('border-bottom');
        } else {
          this._dropDownPosition = _browser_ui_contextview_contextview__WEBPACK_IMPORTED_MODULE_4__.AnchorPosition.BELOW;
          this.selectDropDownContainer.removeChild(this.selectDropDownListContainer);
          this.selectDropDownContainer.removeChild(this.selectionDetailsPane);
          this.selectDropDownContainer.appendChild(this.selectDropDownListContainer);
          this.selectDropDownContainer.appendChild(this.selectionDetailsPane);
          this.selectionDetailsPane.classList.remove('border-bottom');
          this.selectionDetailsPane.classList.add('border-top');
        } // Do full layout on showSelectDropDown only


        return true;
      } // Check if select out of viewport or cutting into status bar


      if (selectPosition.top + selectPosition.height > window.innerHeight - 22 || selectPosition.top < SelectBoxList.DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN || this._dropDownPosition === _browser_ui_contextview_contextview__WEBPACK_IMPORTED_MODULE_4__.AnchorPosition.BELOW && maxVisibleOptionsBelow < 1 || this._dropDownPosition === _browser_ui_contextview_contextview__WEBPACK_IMPORTED_MODULE_4__.AnchorPosition.ABOVE && maxVisibleOptionsAbove < 1) {
        // Cannot properly layout, close and hide
        this.hideSelectDropDown(true);
        return false;
      } // SetUp list dimensions and layout - account for container padding
      // Use position to check above or below available space


      if (this._dropDownPosition === _browser_ui_contextview_contextview__WEBPACK_IMPORTED_MODULE_4__.AnchorPosition.BELOW) {
        if (this._isVisible && maxVisibleOptionsBelow + maxVisibleOptionsAbove < 1) {
          // If drop-down is visible, must be doing a DOM re-layout, hide since we don't fit
          // Hide drop-down, hide contextview, focus on parent select
          this.hideSelectDropDown(true);
          return false;
        } // Adjust list height to max from select bottom to margin (default/minBottomMargin)


        if (minRequiredDropDownHeight > maxSelectDropDownHeightBelow) {
          listHeight = maxVisibleOptionsBelow * this.getHeight();
        }
      } else {
        if (minRequiredDropDownHeight > maxSelectDropDownHeightAbove) {
          listHeight = maxVisibleOptionsAbove * this.getHeight();
        }
      } // Set adjusted list height and relayout


      this.selectList.layout(listHeight);
      this.selectList.domFocus(); // Finally set focus on selected item

      if (this.selectList.length > 0) {
        this.selectList.setFocus([this.selected || 0]);
        this.selectList.reveal(this.selectList.getFocus()[0] || 0);
      }

      if (this._hasDetails) {
        // Leave the selectDropDownContainer to size itself according to children (list + details) - #57447
        this.selectList.getHTMLElement().style.height = listHeight + verticalPadding + 'px';
        this.selectDropDownContainer.style.height = '';
      } else {
        this.selectDropDownContainer.style.height = listHeight + verticalPadding + 'px';
      }

      this.updateDetail(this.selected);
      this.selectDropDownContainer.style.width = selectOptimalWidth; // Maintain focus outline on parent select as well as list container - tabindex for focus

      this.selectDropDownListContainer.setAttribute('tabindex', '0');
      this.selectElement.classList.add('synthetic-focus');
      this.selectDropDownContainer.classList.add('synthetic-focus');
      return true;
    } else {
      return false;
    }
  }

  setWidthControlElement(container) {
    let elementWidth = 0;

    if (container) {
      let longest = 0;
      let longestLength = 0;
      this.options.forEach((option, index) => {
        const detailLength = !!option.detail ? option.detail.length : 0;
        const rightDecoratorLength = !!option.decoratorRight ? option.decoratorRight.length : 0;
        const len = option.text.length + detailLength + rightDecoratorLength;

        if (len > longestLength) {
          longest = index;
          longestLength = len;
        }
      });
      container.textContent = this.options[longest].text + (!!this.options[longest].decoratorRight ? this.options[longest].decoratorRight + ' ' : '');
      elementWidth = _browser_dom__WEBPACK_IMPORTED_MODULE_0__.getTotalWidth(container);
    }

    return elementWidth;
  }

  createSelectList(parent) {
    // If we have already constructive list on open, skip
    if (this.selectList) {
      return;
    } // SetUp container for list


    this.selectDropDownListContainer = _browser_dom__WEBPACK_IMPORTED_MODULE_0__.append(parent, $('.select-box-dropdown-list-container'));
    this.listRenderer = new SelectListRenderer();
    this.selectList = new _browser_ui_list_listWidget__WEBPACK_IMPORTED_MODULE_5__.List('SelectBoxCustom', this.selectDropDownListContainer, this, [this.listRenderer], {
      useShadows: false,
      verticalScrollMode: _common_scrollable__WEBPACK_IMPORTED_MODULE_11__.ScrollbarVisibility.Visible,
      keyboardSupport: false,
      mouseSupport: false,
      accessibilityProvider: {
        getAriaLabel: element => {
          let label = element.text;

          if (element.detail) {
            label += `. ${element.detail}`;
          }

          if (element.decoratorRight) {
            label += `. ${element.decoratorRight}`;
          }

          if (element.description) {
            label += `. ${element.description}`;
          }

          return label;
        },
        getWidgetAriaLabel: () => (0,_common_nls__WEBPACK_IMPORTED_MODULE_13__.localize)({
          key: 'selectBox',
          comment: ['Behave like native select dropdown element.']
        }, "Select Box"),
        getRole: () => 'option',
        getWidgetRole: () => 'listbox'
      }
    });

    if (this.selectBoxOptions.ariaLabel) {
      this.selectList.ariaLabel = this.selectBoxOptions.ariaLabel;
    } // SetUp list keyboard controller - control navigation, disabled items, focus


    const onKeyDown = this._register(new _browser_event__WEBPACK_IMPORTED_MODULE_1__.DomEmitter(this.selectDropDownListContainer, 'keydown'));

    const onSelectDropDownKeyDown = _common_event__WEBPACK_IMPORTED_MODULE_7__.Event.chain(onKeyDown.event).filter(() => this.selectList.length > 0).map(e => new _browser_keyboardEvent__WEBPACK_IMPORTED_MODULE_2__.StandardKeyboardEvent(e));

    this._register(onSelectDropDownKeyDown.filter(e => e.keyCode === _common_keyCodes__WEBPACK_IMPORTED_MODULE_8__.KeyCode.Enter).on(e => this.onEnter(e), this));

    this._register(onSelectDropDownKeyDown.filter(e => e.keyCode === _common_keyCodes__WEBPACK_IMPORTED_MODULE_8__.KeyCode.Tab).on(e => this.onEnter(e), this)); // Tab should behave the same as enter, #79339


    this._register(onSelectDropDownKeyDown.filter(e => e.keyCode === _common_keyCodes__WEBPACK_IMPORTED_MODULE_8__.KeyCode.Escape).on(e => this.onEscape(e), this));

    this._register(onSelectDropDownKeyDown.filter(e => e.keyCode === _common_keyCodes__WEBPACK_IMPORTED_MODULE_8__.KeyCode.UpArrow).on(e => this.onUpArrow(e), this));

    this._register(onSelectDropDownKeyDown.filter(e => e.keyCode === _common_keyCodes__WEBPACK_IMPORTED_MODULE_8__.KeyCode.DownArrow).on(e => this.onDownArrow(e), this));

    this._register(onSelectDropDownKeyDown.filter(e => e.keyCode === _common_keyCodes__WEBPACK_IMPORTED_MODULE_8__.KeyCode.PageDown).on(this.onPageDown, this));

    this._register(onSelectDropDownKeyDown.filter(e => e.keyCode === _common_keyCodes__WEBPACK_IMPORTED_MODULE_8__.KeyCode.PageUp).on(this.onPageUp, this));

    this._register(onSelectDropDownKeyDown.filter(e => e.keyCode === _common_keyCodes__WEBPACK_IMPORTED_MODULE_8__.KeyCode.Home).on(this.onHome, this));

    this._register(onSelectDropDownKeyDown.filter(e => e.keyCode === _common_keyCodes__WEBPACK_IMPORTED_MODULE_8__.KeyCode.End).on(this.onEnd, this));

    this._register(onSelectDropDownKeyDown.filter(e => e.keyCode >= _common_keyCodes__WEBPACK_IMPORTED_MODULE_8__.KeyCode.Digit0 && e.keyCode <= _common_keyCodes__WEBPACK_IMPORTED_MODULE_8__.KeyCode.KeyZ || e.keyCode >= _common_keyCodes__WEBPACK_IMPORTED_MODULE_8__.KeyCode.Semicolon && e.keyCode <= _common_keyCodes__WEBPACK_IMPORTED_MODULE_8__.KeyCode.NumpadDivide).on(this.onCharacter, this)); // SetUp list mouse controller - control navigation, disabled items, focus


    this._register(_browser_dom__WEBPACK_IMPORTED_MODULE_0__.addDisposableListener(this.selectList.getHTMLElement(), _browser_dom__WEBPACK_IMPORTED_MODULE_0__.EventType.POINTER_UP, e => this.onPointerUp(e)));

    this._register(this.selectList.onMouseOver(e => typeof e.index !== 'undefined' && this.selectList.setFocus([e.index])));

    this._register(this.selectList.onDidChangeFocus(e => this.onListFocus(e)));

    this._register(_browser_dom__WEBPACK_IMPORTED_MODULE_0__.addDisposableListener(this.selectDropDownContainer, _browser_dom__WEBPACK_IMPORTED_MODULE_0__.EventType.FOCUS_OUT, e => {
      if (!this._isVisible || _browser_dom__WEBPACK_IMPORTED_MODULE_0__.isAncestor(e.relatedTarget, this.selectDropDownContainer)) {
        return;
      }

      this.onListBlur();
    }));

    this.selectList.getHTMLElement().setAttribute('aria-label', this.selectBoxOptions.ariaLabel || '');
    this.selectList.getHTMLElement().setAttribute('aria-expanded', 'true');
    this.styleList();
  } // List methods
  // List mouse controller - active exit, select option, fire onDidSelect if change, return focus to parent select
  // Also takes in touchend events


  onPointerUp(e) {
    if (!this.selectList.length) {
      return;
    }

    _browser_dom__WEBPACK_IMPORTED_MODULE_0__.EventHelper.stop(e);
    const target = e.target;

    if (!target) {
      return;
    } // Check our mouse event is on an option (not scrollbar)


    if (target.classList.contains('slider')) {
      return;
    }

    const listRowElement = target.closest('.monaco-list-row');

    if (!listRowElement) {
      return;
    }

    const index = Number(listRowElement.getAttribute('data-index'));
    const disabled = listRowElement.classList.contains('option-disabled'); // Ignore mouse selection of disabled options

    if (index >= 0 && index < this.options.length && !disabled) {
      this.selected = index;
      this.select(this.selected);
      this.selectList.setFocus([this.selected]);
      this.selectList.reveal(this.selectList.getFocus()[0]); // Only fire if selection change

      if (this.selected !== this._currentSelection) {
        // Set current = selected
        this._currentSelection = this.selected;

        this._onDidSelect.fire({
          index: this.selectElement.selectedIndex,
          selected: this.options[this.selected].text
        });

        if (!!this.options[this.selected] && !!this.options[this.selected].text) {
          this.selectElement.title = this.options[this.selected].text;
        }
      }

      this.hideSelectDropDown(true);
    }
  } // List Exit - passive - implicit no selection change, hide drop-down


  onListBlur() {
    if (this._sticky) {
      return;
    }

    if (this.selected !== this._currentSelection) {
      // Reset selected to current if no change
      this.select(this._currentSelection);
    }

    this.hideSelectDropDown(false);
  }

  renderDescriptionMarkdown(text, actionHandler) {
    const cleanRenderedMarkdown = element => {
      for (let i = 0; i < element.childNodes.length; i++) {
        const child = element.childNodes.item(i);
        const tagName = child.tagName && child.tagName.toLowerCase();

        if (tagName === 'img') {
          element.removeChild(child);
        } else {
          cleanRenderedMarkdown(child);
        }
      }
    };

    const rendered = (0,_browser_markdownRenderer__WEBPACK_IMPORTED_MODULE_3__.renderMarkdown)({
      value: text,
      supportThemeIcons: true
    }, {
      actionHandler
    });
    rendered.element.classList.add('select-box-description-markdown');
    cleanRenderedMarkdown(rendered.element);
    return rendered.element;
  } // List Focus Change - passive - update details pane with newly focused element's data


  onListFocus(e) {
    // Skip during initial layout
    if (!this._isVisible || !this._hasDetails) {
      return;
    }

    this.updateDetail(e.indexes[0]);
  }

  updateDetail(selectedIndex) {
    this.selectionDetailsPane.innerText = '';
    const option = this.options[selectedIndex];
    const description = option?.description ?? '';
    const descriptionIsMarkdown = option?.descriptionIsMarkdown ?? false;

    if (description) {
      if (descriptionIsMarkdown) {
        const actionHandler = option.descriptionMarkdownActionHandler;
        this.selectionDetailsPane.appendChild(this.renderDescriptionMarkdown(description, actionHandler));
      } else {
        this.selectionDetailsPane.innerText = description;
      }

      this.selectionDetailsPane.style.display = 'block';
    } else {
      this.selectionDetailsPane.style.display = 'none';
    } // Avoid recursion


    this._skipLayout = true;
    this.contextViewProvider.layout();
    this._skipLayout = false;
  } // List keyboard controller
  // List exit - active - hide ContextView dropdown, reset selection, return focus to parent select


  onEscape(e) {
    _browser_dom__WEBPACK_IMPORTED_MODULE_0__.EventHelper.stop(e); // Reset selection to value when opened

    this.select(this._currentSelection);
    this.hideSelectDropDown(true);
  } // List exit - active - hide ContextView dropdown, return focus to parent select, fire onDidSelect if change


  onEnter(e) {
    _browser_dom__WEBPACK_IMPORTED_MODULE_0__.EventHelper.stop(e); // Only fire if selection change

    if (this.selected !== this._currentSelection) {
      this._currentSelection = this.selected;

      this._onDidSelect.fire({
        index: this.selectElement.selectedIndex,
        selected: this.options[this.selected].text
      });

      if (!!this.options[this.selected] && !!this.options[this.selected].text) {
        this.selectElement.title = this.options[this.selected].text;
      }
    }

    this.hideSelectDropDown(true);
  } // List navigation - have to handle a disabled option (jump over)


  onDownArrow(e) {
    if (this.selected < this.options.length - 1) {
      _browser_dom__WEBPACK_IMPORTED_MODULE_0__.EventHelper.stop(e, true); // Skip disabled options

      const nextOptionDisabled = this.options[this.selected + 1].isDisabled;

      if (nextOptionDisabled && this.options.length > this.selected + 2) {
        this.selected += 2;
      } else if (nextOptionDisabled) {
        return;
      } else {
        this.selected++;
      } // Set focus/selection - only fire event when closing drop-down or on blur


      this.select(this.selected);
      this.selectList.setFocus([this.selected]);
      this.selectList.reveal(this.selectList.getFocus()[0]);
    }
  }

  onUpArrow(e) {
    if (this.selected > 0) {
      _browser_dom__WEBPACK_IMPORTED_MODULE_0__.EventHelper.stop(e, true); // Skip disabled options

      const previousOptionDisabled = this.options[this.selected - 1].isDisabled;

      if (previousOptionDisabled && this.selected > 1) {
        this.selected -= 2;
      } else {
        this.selected--;
      } // Set focus/selection - only fire event when closing drop-down or on blur


      this.select(this.selected);
      this.selectList.setFocus([this.selected]);
      this.selectList.reveal(this.selectList.getFocus()[0]);
    }
  }

  onPageUp(e) {
    _browser_dom__WEBPACK_IMPORTED_MODULE_0__.EventHelper.stop(e);
    this.selectList.focusPreviousPage(); // Allow scrolling to settle

    setTimeout(() => {
      this.selected = this.selectList.getFocus()[0]; // Shift selection down if we land on a disabled option

      if (this.options[this.selected].isDisabled && this.selected < this.options.length - 1) {
        this.selected++;
        this.selectList.setFocus([this.selected]);
      }

      this.selectList.reveal(this.selected);
      this.select(this.selected);
    }, 1);
  }

  onPageDown(e) {
    _browser_dom__WEBPACK_IMPORTED_MODULE_0__.EventHelper.stop(e);
    this.selectList.focusNextPage(); // Allow scrolling to settle

    setTimeout(() => {
      this.selected = this.selectList.getFocus()[0]; // Shift selection up if we land on a disabled option

      if (this.options[this.selected].isDisabled && this.selected > 0) {
        this.selected--;
        this.selectList.setFocus([this.selected]);
      }

      this.selectList.reveal(this.selected);
      this.select(this.selected);
    }, 1);
  }

  onHome(e) {
    _browser_dom__WEBPACK_IMPORTED_MODULE_0__.EventHelper.stop(e);

    if (this.options.length < 2) {
      return;
    }

    this.selected = 0;

    if (this.options[this.selected].isDisabled && this.selected > 1) {
      this.selected++;
    }

    this.selectList.setFocus([this.selected]);
    this.selectList.reveal(this.selected);
    this.select(this.selected);
  }

  onEnd(e) {
    _browser_dom__WEBPACK_IMPORTED_MODULE_0__.EventHelper.stop(e);

    if (this.options.length < 2) {
      return;
    }

    this.selected = this.options.length - 1;

    if (this.options[this.selected].isDisabled && this.selected > 1) {
      this.selected--;
    }

    this.selectList.setFocus([this.selected]);
    this.selectList.reveal(this.selected);
    this.select(this.selected);
  } // Mimic option first character navigation of native select


  onCharacter(e) {
    const ch = _common_keyCodes__WEBPACK_IMPORTED_MODULE_8__.KeyCodeUtils.toString(e.keyCode);
    let optionIndex = -1;

    for (let i = 0; i < this.options.length - 1; i++) {
      optionIndex = (i + this.selected + 1) % this.options.length;

      if (this.options[optionIndex].text.charAt(0).toUpperCase() === ch && !this.options[optionIndex].isDisabled) {
        this.select(optionIndex);
        this.selectList.setFocus([optionIndex]);
        this.selectList.reveal(this.selectList.getFocus()[0]);
        _browser_dom__WEBPACK_IMPORTED_MODULE_0__.EventHelper.stop(e);
        break;
      }
    }
  }

  dispose() {
    this.hideSelectDropDown(false);
    super.dispose();
  }

}

/***/ }),
/* 126 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "renderMarkdown": () => (/* binding */ renderMarkdown),
/* harmony export */   "allowedMarkdownAttr": () => (/* binding */ allowedMarkdownAttr),
/* harmony export */   "renderStringAsPlaintext": () => (/* binding */ renderStringAsPlaintext),
/* harmony export */   "renderMarkdownAsPlaintext": () => (/* binding */ renderMarkdownAsPlaintext)
/* harmony export */ });
/* harmony import */ var _browser_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(61);
/* harmony import */ var _browser_dompurify_dompurify__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(83);
/* harmony import */ var _browser_dompurify_dompurify__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_browser_dompurify_dompurify__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _browser_event__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(85);
/* harmony import */ var _browser_formattedTextRenderer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(127);
/* harmony import */ var _browser_mouseEvent__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(66);
/* harmony import */ var _browser_ui_iconLabel_iconLabels__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(128);
/* harmony import */ var _common_errors__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(52);
/* harmony import */ var _common_event__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(51);
/* harmony import */ var _common_htmlContent__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(120);
/* harmony import */ var _common_iconLabels__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(121);
/* harmony import */ var _common_idGenerator__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(129);
/* harmony import */ var _common_lazy__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(77);
/* harmony import */ var _common_lifecycle__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(54);
/* harmony import */ var _common_marked_marked__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(130);
/* harmony import */ var _common_marked_marked__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(_common_marked_marked__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var _common_marshalling__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(131);
/* harmony import */ var _common_network__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(80);
/* harmony import */ var _common_objects__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(134);
/* harmony import */ var _common_resources__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(70);
/* harmony import */ var _common_strings__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(75);
/* harmony import */ var _common_uri__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(81);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/




















const defaultMarkedRenderers = Object.freeze({
  image: (href, title, text) => {
    let dimensions = [];
    let attributes = [];

    if (href) {
      ({
        href,
        dimensions
      } = (0,_common_htmlContent__WEBPACK_IMPORTED_MODULE_8__.parseHrefAndDimensions)(href));
      attributes.push(`src="${(0,_common_htmlContent__WEBPACK_IMPORTED_MODULE_8__.escapeDoubleQuotes)(href)}"`);
    }

    if (text) {
      attributes.push(`alt="${(0,_common_htmlContent__WEBPACK_IMPORTED_MODULE_8__.escapeDoubleQuotes)(text)}"`);
    }

    if (title) {
      attributes.push(`title="${(0,_common_htmlContent__WEBPACK_IMPORTED_MODULE_8__.escapeDoubleQuotes)(title)}"`);
    }

    if (dimensions.length) {
      attributes = attributes.concat(dimensions);
    }

    return '<img ' + attributes.join(' ') + '>';
  },
  paragraph: text => {
    return `<p>${text}</p>`;
  },
  link: (href, title, text) => {
    if (typeof href !== 'string') {
      return '';
    } // Remove markdown escapes. Workaround for https://github.com/chjj/marked/issues/829


    if (href === text) {
      // raw link case
      text = (0,_common_htmlContent__WEBPACK_IMPORTED_MODULE_8__.removeMarkdownEscapes)(text);
    }

    title = typeof title === 'string' ? (0,_common_htmlContent__WEBPACK_IMPORTED_MODULE_8__.escapeDoubleQuotes)((0,_common_htmlContent__WEBPACK_IMPORTED_MODULE_8__.removeMarkdownEscapes)(title)) : '';
    href = (0,_common_htmlContent__WEBPACK_IMPORTED_MODULE_8__.removeMarkdownEscapes)(href); // HTML Encode href

    href = href.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
    return `<a href="${href}" title="${title || href}">${text}</a>`;
  }
});
/**
 * Low-level way create a html element from a markdown string.
 *
 * **Note** that for most cases you should be using [`MarkdownRenderer`](./src/vs/editor/contrib/markdownRenderer/browser/markdownRenderer.ts)
 * which comes with support for pretty code block rendering and which uses the default way of handling links.
 */

function renderMarkdown(markdown, options = {}, markedOptions = {}) {
  const disposables = new _common_lifecycle__WEBPACK_IMPORTED_MODULE_12__.DisposableStore();
  let isDisposed = false;
  const element = (0,_browser_formattedTextRenderer__WEBPACK_IMPORTED_MODULE_3__.createElement)(options);

  const _uriMassage = function (part) {
    let data;

    try {
      data = (0,_common_marshalling__WEBPACK_IMPORTED_MODULE_14__.parse)(decodeURIComponent(part));
    } catch (e) {// ignore
    }

    if (!data) {
      return part;
    }

    data = (0,_common_objects__WEBPACK_IMPORTED_MODULE_16__.cloneAndChange)(data, value => {
      if (markdown.uris && markdown.uris[value]) {
        return _common_uri__WEBPACK_IMPORTED_MODULE_19__.URI.revive(markdown.uris[value]);
      } else {
        return undefined;
      }
    });
    return encodeURIComponent(JSON.stringify(data));
  };

  const _href = function (href, isDomUri) {
    const data = markdown.uris && markdown.uris[href];
    let uri = _common_uri__WEBPACK_IMPORTED_MODULE_19__.URI.revive(data);

    if (isDomUri) {
      if (href.startsWith(_common_network__WEBPACK_IMPORTED_MODULE_15__.Schemas.data + ':')) {
        return href;
      }

      if (!uri) {
        uri = _common_uri__WEBPACK_IMPORTED_MODULE_19__.URI.parse(href);
      } // this URI will end up as "src"-attribute of a dom node
      // and because of that special rewriting needs to be done
      // so that the URI uses a protocol that's understood by
      // browsers (like http or https)


      return _common_network__WEBPACK_IMPORTED_MODULE_15__.FileAccess.asBrowserUri(uri).toString(true);
    }

    if (!uri) {
      return href;
    }

    if (_common_uri__WEBPACK_IMPORTED_MODULE_19__.URI.parse(href).toString() === uri.toString()) {
      return href; // no transformation performed
    }

    if (uri.query) {
      uri = uri.with({
        query: _uriMassage(uri.query)
      });
    }

    return uri.toString();
  };

  const renderer = new _common_marked_marked__WEBPACK_IMPORTED_MODULE_13__.marked.Renderer();
  renderer.image = defaultMarkedRenderers.image;
  renderer.link = defaultMarkedRenderers.link;
  renderer.paragraph = defaultMarkedRenderers.paragraph; // Will collect [id, renderedElement] tuples

  const codeBlocks = [];

  if (options.codeBlockRenderer) {
    renderer.code = (code, lang) => {
      const id = _common_idGenerator__WEBPACK_IMPORTED_MODULE_10__.defaultGenerator.nextId();
      const value = options.codeBlockRenderer(postProcessCodeBlockLanguageId(lang), code);
      codeBlocks.push(value.then(element => [id, element]));
      return `<div class="code" data-code="${id}">${(0,_common_strings__WEBPACK_IMPORTED_MODULE_18__.escape)(code)}</div>`;
    };
  }

  if (options.actionHandler) {
    const onClick = options.actionHandler.disposables.add(new _browser_event__WEBPACK_IMPORTED_MODULE_2__.DomEmitter(element, 'click'));
    const onAuxClick = options.actionHandler.disposables.add(new _browser_event__WEBPACK_IMPORTED_MODULE_2__.DomEmitter(element, 'auxclick'));
    options.actionHandler.disposables.add(_common_event__WEBPACK_IMPORTED_MODULE_7__.Event.any(onClick.event, onAuxClick.event)(e => {
      const mouseEvent = new _browser_mouseEvent__WEBPACK_IMPORTED_MODULE_4__.StandardMouseEvent(e);

      if (!mouseEvent.leftButton && !mouseEvent.middleButton) {
        return;
      }

      let target = mouseEvent.target;

      if (target.tagName !== 'A') {
        target = target.parentElement;

        if (!target || target.tagName !== 'A') {
          return;
        }
      }

      try {
        let href = target.dataset['href'];

        if (href) {
          if (markdown.baseUri) {
            href = resolveWithBaseUri(_common_uri__WEBPACK_IMPORTED_MODULE_19__.URI.from(markdown.baseUri), href);
          }

          options.actionHandler.callback(href, mouseEvent);
        }
      } catch (err) {
        (0,_common_errors__WEBPACK_IMPORTED_MODULE_6__.onUnexpectedError)(err);
      } finally {
        mouseEvent.preventDefault();
      }
    }));
  }

  if (!markdown.supportHtml) {
    // TODO: Can we deprecated this in favor of 'supportHtml'?
    // Use our own sanitizer so that we can let through only spans.
    // Otherwise, we'd be letting all html be rendered.
    // If we want to allow markdown permitted tags, then we can delete sanitizer and sanitize.
    // We always pass the output through dompurify after this so that we don't rely on
    // marked for sanitization.
    markedOptions.sanitizer = html => {
      const match = markdown.isTrusted ? html.match(/^(<span[^>]+>)|(<\/\s*span>)$/) : undefined;
      return match ? html : '';
    };

    markedOptions.sanitize = true;
    markedOptions.silent = true;
  }

  markedOptions.renderer = renderer; // values that are too long will freeze the UI

  let value = markdown.value ?? '';

  if (value.length > 100_000) {
    value = `${value.substr(0, 100_000)}`;
  } // escape theme icons


  if (markdown.supportThemeIcons) {
    value = (0,_common_iconLabels__WEBPACK_IMPORTED_MODULE_9__.markdownEscapeEscapedIcons)(value);
  }

  let renderedMarkdown = _common_marked_marked__WEBPACK_IMPORTED_MODULE_13__.marked.parse(value, markedOptions); // Rewrite theme icons

  if (markdown.supportThemeIcons) {
    const elements = (0,_browser_ui_iconLabel_iconLabels__WEBPACK_IMPORTED_MODULE_5__.renderLabelWithIcons)(renderedMarkdown);
    renderedMarkdown = elements.map(e => typeof e === 'string' ? e : e.outerHTML).join('');
  }

  const htmlParser = new DOMParser();
  const markdownHtmlDoc = htmlParser.parseFromString(sanitizeRenderedMarkdown(markdown, renderedMarkdown), 'text/html');
  markdownHtmlDoc.body.querySelectorAll('img').forEach(img => {
    const src = img.getAttribute('src'); // Get the raw 'src' attribute value as text, not the resolved 'src'

    if (src) {
      let href = src;

      try {
        if (markdown.baseUri) {
          // absolute or relative local path, or file: uri
          href = resolveWithBaseUri(_common_uri__WEBPACK_IMPORTED_MODULE_19__.URI.from(markdown.baseUri), href);
        }
      } catch (err) {}

      img.src = _href(href, true);
    }
  });
  markdownHtmlDoc.body.querySelectorAll('a').forEach(a => {
    const href = a.getAttribute('href'); // Get the raw 'href' attribute value as text, not the resolved 'href'

    a.setAttribute('href', ''); // Clear out href. We use the `data-href` for handling clicks instead

    if (!href || /^data:|javascript:/i.test(href) || /^command:/i.test(href) && !markdown.isTrusted || /^command:(\/\/\/)?_workbench\.downloadResource/i.test(href)) {
      // drop the link
      a.replaceWith(...a.childNodes);
    } else {
      let resolvedHref = _href(href, false);

      if (markdown.baseUri) {
        resolvedHref = resolveWithBaseUri(_common_uri__WEBPACK_IMPORTED_MODULE_19__.URI.from(markdown.baseUri), href);
      }

      a.dataset.href = resolvedHref;
    }
  });
  element.innerHTML = sanitizeRenderedMarkdown(markdown, markdownHtmlDoc.body.innerHTML);

  if (codeBlocks.length > 0) {
    Promise.all(codeBlocks).then(tuples => {
      if (isDisposed) {
        return;
      }

      const renderedElements = new Map(tuples);
      const placeholderElements = element.querySelectorAll(`div[data-code]`);

      for (const placeholderElement of placeholderElements) {
        const renderedElement = renderedElements.get(placeholderElement.dataset['code'] ?? '');

        if (renderedElement) {
          _browser_dom__WEBPACK_IMPORTED_MODULE_0__.reset(placeholderElement, renderedElement);
        }
      }

      options.asyncRenderCallback?.();
    });
  } // signal size changes for image tags


  if (options.asyncRenderCallback) {
    for (const img of element.getElementsByTagName('img')) {
      const listener = disposables.add(_browser_dom__WEBPACK_IMPORTED_MODULE_0__.addDisposableListener(img, 'load', () => {
        listener.dispose();
        options.asyncRenderCallback();
      }));
    }
  }

  return {
    element,
    dispose: () => {
      isDisposed = true;
      disposables.dispose();
    }
  };
}

function postProcessCodeBlockLanguageId(lang) {
  if (!lang) {
    return '';
  }

  const parts = lang.split(/[\s+|:|,|\{|\?]/, 1);

  if (parts.length) {
    return parts[0];
  }

  return lang;
}

function resolveWithBaseUri(baseUri, href) {
  const hasScheme = /^\w[\w\d+.-]*:/.test(href);

  if (hasScheme) {
    return href;
  }

  if (baseUri.path.endsWith('/')) {
    return (0,_common_resources__WEBPACK_IMPORTED_MODULE_17__.resolvePath)(baseUri, href).toString();
  } else {
    return (0,_common_resources__WEBPACK_IMPORTED_MODULE_17__.resolvePath)((0,_common_resources__WEBPACK_IMPORTED_MODULE_17__.dirname)(baseUri), href).toString();
  }
}

function sanitizeRenderedMarkdown(options, renderedMarkdown) {
  const {
    config,
    allowedSchemes
  } = getSanitizerOptions(options);
  _browser_dompurify_dompurify__WEBPACK_IMPORTED_MODULE_1__.addHook('uponSanitizeAttribute', (element, e) => {
    if (e.attrName === 'style' || e.attrName === 'class') {
      if (element.tagName === 'SPAN') {
        if (e.attrName === 'style') {
          e.keepAttr = /^(color\:#[0-9a-fA-F]+;)?(background-color\:#[0-9a-fA-F]+;)?$/.test(e.attrValue);
          return;
        } else if (e.attrName === 'class') {
          e.keepAttr = /^codicon codicon-[a-z\-]+( codicon-modifier-[a-z\-]+)?$/.test(e.attrValue);
          return;
        }
      }

      e.keepAttr = false;
      return;
    }
  });
  const hook = _browser_dom__WEBPACK_IMPORTED_MODULE_0__.hookDomPurifyHrefAndSrcSanitizer(allowedSchemes);

  try {
    return _browser_dompurify_dompurify__WEBPACK_IMPORTED_MODULE_1__.sanitize(renderedMarkdown, { ...config,
      RETURN_TRUSTED_TYPE: true
    });
  } finally {
    _browser_dompurify_dompurify__WEBPACK_IMPORTED_MODULE_1__.removeHook('uponSanitizeAttribute');
    hook.dispose();
  }
}

const allowedMarkdownAttr = ['align', 'alt', 'class', 'controls', 'data-code', 'data-href', 'height', 'href', 'loop', 'muted', 'playsinline', 'poster', 'src', 'style', 'target', 'title', 'width'];

function getSanitizerOptions(options) {
  const allowedSchemes = [_common_network__WEBPACK_IMPORTED_MODULE_15__.Schemas.http, _common_network__WEBPACK_IMPORTED_MODULE_15__.Schemas.https, _common_network__WEBPACK_IMPORTED_MODULE_15__.Schemas.mailto, _common_network__WEBPACK_IMPORTED_MODULE_15__.Schemas.data, _common_network__WEBPACK_IMPORTED_MODULE_15__.Schemas.file, _common_network__WEBPACK_IMPORTED_MODULE_15__.Schemas.vscodeFileResource, _common_network__WEBPACK_IMPORTED_MODULE_15__.Schemas.vscodeRemote, _common_network__WEBPACK_IMPORTED_MODULE_15__.Schemas.vscodeRemoteResource];

  if (options.isTrusted) {
    allowedSchemes.push(_common_network__WEBPACK_IMPORTED_MODULE_15__.Schemas.command);
  }

  return {
    config: {
      // allowedTags should included everything that markdown renders to.
      // Since we have our own sanitize function for marked, it's possible we missed some tag so let dompurify make sure.
      // HTML tags that can result from markdown are from reading https://spec.commonmark.org/0.29/
      // HTML table tags that can result from markdown are from https://github.github.com/gfm/#tables-extension-
      ALLOWED_TAGS: [..._browser_dom__WEBPACK_IMPORTED_MODULE_0__.basicMarkupHtmlTags],
      ALLOWED_ATTR: allowedMarkdownAttr,
      ALLOW_UNKNOWN_PROTOCOLS: true
    },
    allowedSchemes
  };
}
/**
 * Strips all markdown from `string`, if it's an IMarkdownString. For example
 * `# Header` would be output as `Header`. If it's not, the string is returned.
 */


function renderStringAsPlaintext(string) {
  return typeof string === 'string' ? string : renderMarkdownAsPlaintext(string);
}
/**
 * Strips all markdown from `markdown`. For example `# Header` would be output as `Header`.
 */

function renderMarkdownAsPlaintext(markdown) {
  // values that are too long will freeze the UI
  let value = markdown.value ?? '';

  if (value.length > 100_000) {
    value = `${value.substr(0, 100_000)}`;
  }

  const html = _common_marked_marked__WEBPACK_IMPORTED_MODULE_13__.marked.parse(value, {
    renderer: plainTextRenderer.getValue()
  }).replace(/&(#\d+|[a-zA-Z]+);/g, m => unescapeInfo.get(m) ?? m);
  return sanitizeRenderedMarkdown({
    isTrusted: false
  }, html).toString();
}
const unescapeInfo = new Map([['&quot;', '"'], ['&nbsp;', ' '], ['&amp;', '&'], ['&#39;', '\''], ['&lt;', '<'], ['&gt;', '>']]);
const plainTextRenderer = new _common_lazy__WEBPACK_IMPORTED_MODULE_11__.Lazy(() => {
  const renderer = new _common_marked_marked__WEBPACK_IMPORTED_MODULE_13__.marked.Renderer();

  renderer.code = code => {
    return code;
  };

  renderer.blockquote = quote => {
    return quote;
  };

  renderer.html = _html => {
    return '';
  };

  renderer.heading = (text, _level, _raw) => {
    return text + '\n';
  };

  renderer.hr = () => {
    return '';
  };

  renderer.list = (body, _ordered) => {
    return body;
  };

  renderer.listitem = text => {
    return text + '\n';
  };

  renderer.paragraph = text => {
    return text + '\n';
  };

  renderer.table = (header, body) => {
    return header + body + '\n';
  };

  renderer.tablerow = content => {
    return content;
  };

  renderer.tablecell = (content, _flags) => {
    return content + ' ';
  };

  renderer.strong = text => {
    return text;
  };

  renderer.em = text => {
    return text;
  };

  renderer.codespan = code => {
    return code;
  };

  renderer.br = () => {
    return '\n';
  };

  renderer.del = text => {
    return text;
  };

  renderer.image = (_href, _title, _text) => {
    return '';
  };

  renderer.text = text => {
    return text;
  };

  renderer.link = (_href, _title, text) => {
    return text;
  };

  return renderer;
});

/***/ }),
/* 127 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "renderText": () => (/* binding */ renderText),
/* harmony export */   "renderFormattedText": () => (/* binding */ renderFormattedText),
/* harmony export */   "createElement": () => (/* binding */ createElement)
/* harmony export */ });
/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(61);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

function renderText(text, options = {}) {
  const element = createElement(options);
  element.textContent = text;
  return element;
}
function renderFormattedText(formattedText, options = {}) {
  const element = createElement(options);

  _renderFormattedText(element, parseFormattedText(formattedText, !!options.renderCodeSegments), options.actionHandler, options.renderCodeSegments);

  return element;
}
function createElement(options) {
  const tagName = options.inline ? 'span' : 'div';
  const element = document.createElement(tagName);

  if (options.className) {
    element.className = options.className;
  }

  return element;
}

class StringStream {
  constructor(source) {
    this.source = source;
    this.index = 0;
  }

  eos() {
    return this.index >= this.source.length;
  }

  next() {
    const next = this.peek();
    this.advance();
    return next;
  }

  peek() {
    return this.source[this.index];
  }

  advance() {
    this.index++;
  }

}

var FormatType;

(function (FormatType) {
  FormatType[FormatType["Invalid"] = 0] = "Invalid";
  FormatType[FormatType["Root"] = 1] = "Root";
  FormatType[FormatType["Text"] = 2] = "Text";
  FormatType[FormatType["Bold"] = 3] = "Bold";
  FormatType[FormatType["Italics"] = 4] = "Italics";
  FormatType[FormatType["Action"] = 5] = "Action";
  FormatType[FormatType["ActionClose"] = 6] = "ActionClose";
  FormatType[FormatType["Code"] = 7] = "Code";
  FormatType[FormatType["NewLine"] = 8] = "NewLine";
})(FormatType || (FormatType = {}));

function _renderFormattedText(element, treeNode, actionHandler, renderCodeSegments) {
  let child;

  if (treeNode.type === FormatType.Text) {
    child = document.createTextNode(treeNode.content || '');
  } else if (treeNode.type === FormatType.Bold) {
    child = document.createElement('b');
  } else if (treeNode.type === FormatType.Italics) {
    child = document.createElement('i');
  } else if (treeNode.type === FormatType.Code && renderCodeSegments) {
    child = document.createElement('code');
  } else if (treeNode.type === FormatType.Action && actionHandler) {
    const a = document.createElement('a');
    actionHandler.disposables.add(_dom__WEBPACK_IMPORTED_MODULE_0__.addStandardDisposableListener(a, 'click', event => {
      actionHandler.callback(String(treeNode.index), event);
    }));
    child = a;
  } else if (treeNode.type === FormatType.NewLine) {
    child = document.createElement('br');
  } else if (treeNode.type === FormatType.Root) {
    child = element;
  }

  if (child && element !== child) {
    element.appendChild(child);
  }

  if (child && Array.isArray(treeNode.children)) {
    treeNode.children.forEach(nodeChild => {
      _renderFormattedText(child, nodeChild, actionHandler, renderCodeSegments);
    });
  }
}

function parseFormattedText(content, parseCodeSegments) {
  const root = {
    type: FormatType.Root,
    children: []
  };
  let actionViewItemIndex = 0;
  let current = root;
  const stack = [];
  const stream = new StringStream(content);

  while (!stream.eos()) {
    let next = stream.next();
    const isEscapedFormatType = next === '\\' && formatTagType(stream.peek(), parseCodeSegments) !== FormatType.Invalid;

    if (isEscapedFormatType) {
      next = stream.next(); // unread the backslash if it escapes a format tag type
    }

    if (!isEscapedFormatType && isFormatTag(next, parseCodeSegments) && next === stream.peek()) {
      stream.advance();

      if (current.type === FormatType.Text) {
        current = stack.pop();
      }

      const type = formatTagType(next, parseCodeSegments);

      if (current.type === type || current.type === FormatType.Action && type === FormatType.ActionClose) {
        current = stack.pop();
      } else {
        const newCurrent = {
          type: type,
          children: []
        };

        if (type === FormatType.Action) {
          newCurrent.index = actionViewItemIndex;
          actionViewItemIndex++;
        }

        current.children.push(newCurrent);
        stack.push(current);
        current = newCurrent;
      }
    } else if (next === '\n') {
      if (current.type === FormatType.Text) {
        current = stack.pop();
      }

      current.children.push({
        type: FormatType.NewLine
      });
    } else {
      if (current.type !== FormatType.Text) {
        const textCurrent = {
          type: FormatType.Text,
          content: next
        };
        current.children.push(textCurrent);
        stack.push(current);
        current = textCurrent;
      } else {
        current.content += next;
      }
    }
  }

  if (current.type === FormatType.Text) {
    current = stack.pop();
  }

  if (stack.length) {// incorrectly formatted string literal
  }

  return root;
}

function isFormatTag(char, supportCodeSegments) {
  return formatTagType(char, supportCodeSegments) !== FormatType.Invalid;
}

function formatTagType(char, supportCodeSegments) {
  switch (char) {
    case '*':
      return FormatType.Bold;

    case '_':
      return FormatType.Italics;

    case '[':
      return FormatType.Action;

    case ']':
      return FormatType.ActionClose;

    case '`':
      return supportCodeSegments ? FormatType.Code : FormatType.Invalid;

    default:
      return FormatType.Invalid;
  }
}

/***/ }),
/* 128 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "renderLabelWithIcons": () => (/* binding */ renderLabelWithIcons),
/* harmony export */   "renderIcon": () => (/* binding */ renderIcon)
/* harmony export */ });
/* harmony import */ var _browser_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(61);
/* harmony import */ var _common_codicons__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(104);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


const labelWithIconsRegex = new RegExp(`(\\\\)?\\$\\((${_common_codicons__WEBPACK_IMPORTED_MODULE_1__.CSSIcon.iconNameExpression}(?:${_common_codicons__WEBPACK_IMPORTED_MODULE_1__.CSSIcon.iconModifierExpression})?)\\)`, 'g');
function renderLabelWithIcons(text) {
  const elements = new Array();
  let match;
  let textStart = 0,
      textStop = 0;

  while ((match = labelWithIconsRegex.exec(text)) !== null) {
    textStop = match.index || 0;

    if (textStart < textStop) {
      elements.push(text.substring(textStart, textStop));
    }

    textStart = (match.index || 0) + match[0].length;
    const [, escaped, codicon] = match;
    elements.push(escaped ? `$(${codicon})` : renderIcon({
      id: codicon
    }));
  }

  if (textStart < text.length) {
    elements.push(text.substring(textStart));
  }

  return elements;
}
function renderIcon(icon) {
  const node = _browser_dom__WEBPACK_IMPORTED_MODULE_0__.$(`span`);
  node.classList.add(..._common_codicons__WEBPACK_IMPORTED_MODULE_1__.CSSIcon.asClassNameArray(icon));
  return node;
}

/***/ }),
/* 129 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IdGenerator": () => (/* binding */ IdGenerator),
/* harmony export */   "defaultGenerator": () => (/* binding */ defaultGenerator)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
class IdGenerator {
  constructor(prefix) {
    this._prefix = prefix;
    this._lastId = 0;
  }

  nextId() {
    return this._prefix + ++this._lastId;
  }

}
const defaultGenerator = new IdGenerator('id#');

/***/ }),
/* 130 */
/***/ (function(__unused_webpack_module, exports) {

/**
 * marked - a markdown parser
 * Copyright (c) 2011-2022, Christopher Jeffrey. (MIT Licensed)
 * https://github.com/markedjs/marked
 */

/**
 * DO NOT EDIT THIS FILE
 * The code in this file is generated from files in ./src/
 */

// ESM-uncomment-begin
// let __marked_exports = {};
// (function() {
//   function define(deps, factory) {
//     factory(__marked_exports);
//   }
//   define.amd = true;
// ESM-uncomment-end

 (function (global, factory) {
   true ? factory(exports) :
  0;
})(this, (function (exports) { 'use strict';

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);

    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      return function () {
        if (i >= o.length) return {
          done: true
        };
        return {
          done: false,
          value: o[i++]
        };
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function getDefaults() {
    return {
      async: false,
      baseUrl: null,
      breaks: false,
      extensions: null,
      gfm: true,
      headerIds: true,
      headerPrefix: '',
      highlight: null,
      langPrefix: 'language-',
      mangle: true,
      pedantic: false,
      renderer: null,
      sanitize: false,
      sanitizer: null,
      silent: false,
      smartLists: false,
      smartypants: false,
      tokenizer: null,
      walkTokens: null,
      xhtml: false
    };
  }
  exports.defaults = getDefaults();
  function changeDefaults(newDefaults) {
    exports.defaults = newDefaults;
  }

  /**
   * Helpers
   */
  var escapeTest = /[&<>"']/;
  var escapeReplace = /[&<>"']/g;
  var escapeTestNoEncode = /[<>"']|&(?!#?\w+;)/;
  var escapeReplaceNoEncode = /[<>"']|&(?!#?\w+;)/g;
  var escapeReplacements = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;'
  };

  var getEscapeReplacement = function getEscapeReplacement(ch) {
    return escapeReplacements[ch];
  };

  function escape(html, encode) {
    if (encode) {
      if (escapeTest.test(html)) {
        return html.replace(escapeReplace, getEscapeReplacement);
      }
    } else {
      if (escapeTestNoEncode.test(html)) {
        return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
      }
    }

    return html;
  }
  var unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
  /**
   * @param {string} html
   */

  function unescape(html) {
    // explicitly match decimal, hex, and named HTML entities
    return html.replace(unescapeTest, function (_, n) {
      n = n.toLowerCase();
      if (n === 'colon') return ':';

      if (n.charAt(0) === '#') {
        return n.charAt(1) === 'x' ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));
      }

      return '';
    });
  }
  var caret = /(^|[^\[])\^/g;
  /**
   * @param {string | RegExp} regex
   * @param {string} opt
   */

  function edit(regex, opt) {
    regex = typeof regex === 'string' ? regex : regex.source;
    opt = opt || '';
    var obj = {
      replace: function replace(name, val) {
        val = val.source || val;
        val = val.replace(caret, '$1');
        regex = regex.replace(name, val);
        return obj;
      },
      getRegex: function getRegex() {
        return new RegExp(regex, opt);
      }
    };
    return obj;
  }
  var nonWordAndColonTest = /[^\w:]/g;
  var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
  /**
   * @param {boolean} sanitize
   * @param {string} base
   * @param {string} href
   */

  function cleanUrl(sanitize, base, href) {
    if (sanitize) {
      var prot;

      try {
        prot = decodeURIComponent(unescape(href)).replace(nonWordAndColonTest, '').toLowerCase();
      } catch (e) {
        return null;
      }

      if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {
        return null;
      }
    }

    if (base && !originIndependentUrl.test(href)) {
      href = resolveUrl(base, href);
    }

    try {
      href = encodeURI(href).replace(/%25/g, '%');
    } catch (e) {
      return null;
    }

    return href;
  }
  var baseUrls = {};
  var justDomain = /^[^:]+:\/*[^/]*$/;
  var protocol = /^([^:]+:)[\s\S]*$/;
  var domain = /^([^:]+:\/*[^/]*)[\s\S]*$/;
  /**
   * @param {string} base
   * @param {string} href
   */

  function resolveUrl(base, href) {
    if (!baseUrls[' ' + base]) {
      // we can ignore everything in base after the last slash of its path component,
      // but we might need to add _that_
      // https://tools.ietf.org/html/rfc3986#section-3
      if (justDomain.test(base)) {
        baseUrls[' ' + base] = base + '/';
      } else {
        baseUrls[' ' + base] = rtrim(base, '/', true);
      }
    }

    base = baseUrls[' ' + base];
    var relativeBase = base.indexOf(':') === -1;

    if (href.substring(0, 2) === '//') {
      if (relativeBase) {
        return href;
      }

      return base.replace(protocol, '$1') + href;
    } else if (href.charAt(0) === '/') {
      if (relativeBase) {
        return href;
      }

      return base.replace(domain, '$1') + href;
    } else {
      return base + href;
    }
  }
  var noopTest = {
    exec: function noopTest() {}
  };
  function merge(obj) {
    var i = 1,
        target,
        key;

    for (; i < arguments.length; i++) {
      target = arguments[i];

      for (key in target) {
        if (Object.prototype.hasOwnProperty.call(target, key)) {
          obj[key] = target[key];
        }
      }
    }

    return obj;
  }
  function splitCells(tableRow, count) {
    // ensure that every cell-delimiting pipe has a space
    // before it to distinguish it from an escaped pipe
    var row = tableRow.replace(/\|/g, function (match, offset, str) {
      var escaped = false,
          curr = offset;

      while (--curr >= 0 && str[curr] === '\\') {
        escaped = !escaped;
      }

      if (escaped) {
        // odd number of slashes means | is escaped
        // so we leave it alone
        return '|';
      } else {
        // add space before unescaped |
        return ' |';
      }
    }),
        cells = row.split(/ \|/);
    var i = 0; // First/last cell in a row cannot be empty if it has no leading/trailing pipe

    if (!cells[0].trim()) {
      cells.shift();
    }

    if (cells.length > 0 && !cells[cells.length - 1].trim()) {
      cells.pop();
    }

    if (cells.length > count) {
      cells.splice(count);
    } else {
      while (cells.length < count) {
        cells.push('');
      }
    }

    for (; i < cells.length; i++) {
      // leading or trailing whitespace is ignored per the gfm spec
      cells[i] = cells[i].trim().replace(/\\\|/g, '|');
    }

    return cells;
  }
  /**
   * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').
   * /c*$/ is vulnerable to REDOS.
   *
   * @param {string} str
   * @param {string} c
   * @param {boolean} invert Remove suffix of non-c chars instead. Default falsey.
   */

  function rtrim(str, c, invert) {
    var l = str.length;

    if (l === 0) {
      return '';
    } // Length of suffix matching the invert condition.


    var suffLen = 0; // Step left until we fail to match the invert condition.

    while (suffLen < l) {
      var currChar = str.charAt(l - suffLen - 1);

      if (currChar === c && !invert) {
        suffLen++;
      } else if (currChar !== c && invert) {
        suffLen++;
      } else {
        break;
      }
    }

    return str.slice(0, l - suffLen);
  }
  function findClosingBracket(str, b) {
    if (str.indexOf(b[1]) === -1) {
      return -1;
    }

    var l = str.length;
    var level = 0,
        i = 0;

    for (; i < l; i++) {
      if (str[i] === '\\') {
        i++;
      } else if (str[i] === b[0]) {
        level++;
      } else if (str[i] === b[1]) {
        level--;

        if (level < 0) {
          return i;
        }
      }
    }

    return -1;
  }
  function checkSanitizeDeprecation(opt) {
    if (opt && opt.sanitize && !opt.silent) {
      console.warn('marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options');
    }
  } // copied from https://stackoverflow.com/a/5450113/806777

  /**
   * @param {string} pattern
   * @param {number} count
   */

  function repeatString(pattern, count) {
    if (count < 1) {
      return '';
    }

    var result = '';

    while (count > 1) {
      if (count & 1) {
        result += pattern;
      }

      count >>= 1;
      pattern += pattern;
    }

    return result + pattern;
  }

  function outputLink(cap, link, raw, lexer) {
    var href = link.href;
    var title = link.title ? escape(link.title) : null;
    var text = cap[1].replace(/\\([\[\]])/g, '$1');

    if (cap[0].charAt(0) !== '!') {
      lexer.state.inLink = true;
      var token = {
        type: 'link',
        raw: raw,
        href: href,
        title: title,
        text: text,
        tokens: lexer.inlineTokens(text)
      };
      lexer.state.inLink = false;
      return token;
    }

    return {
      type: 'image',
      raw: raw,
      href: href,
      title: title,
      text: escape(text)
    };
  }

  function indentCodeCompensation(raw, text) {
    var matchIndentToCode = raw.match(/^(\s+)(?:```)/);

    if (matchIndentToCode === null) {
      return text;
    }

    var indentToCode = matchIndentToCode[1];
    return text.split('\n').map(function (node) {
      var matchIndentInNode = node.match(/^\s+/);

      if (matchIndentInNode === null) {
        return node;
      }

      var indentInNode = matchIndentInNode[0];

      if (indentInNode.length >= indentToCode.length) {
        return node.slice(indentToCode.length);
      }

      return node;
    }).join('\n');
  }
  /**
   * Tokenizer
   */


  var Tokenizer = /*#__PURE__*/function () {
    function Tokenizer(options) {
      this.options = options || exports.defaults;
    }

    var _proto = Tokenizer.prototype;

    _proto.space = function space(src) {
      var cap = this.rules.block.newline.exec(src);

      if (cap && cap[0].length > 0) {
        return {
          type: 'space',
          raw: cap[0]
        };
      }
    };

    _proto.code = function code(src) {
      var cap = this.rules.block.code.exec(src);

      if (cap) {
        var text = cap[0].replace(/^ {1,4}/gm, '');
        return {
          type: 'code',
          raw: cap[0],
          codeBlockStyle: 'indented',
          text: !this.options.pedantic ? rtrim(text, '\n') : text
        };
      }
    };

    _proto.fences = function fences(src) {
      var cap = this.rules.block.fences.exec(src);

      if (cap) {
        var raw = cap[0];
        var text = indentCodeCompensation(raw, cap[3] || '');
        return {
          type: 'code',
          raw: raw,
          lang: cap[2] ? cap[2].trim() : cap[2],
          text: text
        };
      }
    };

    _proto.heading = function heading(src) {
      var cap = this.rules.block.heading.exec(src);

      if (cap) {
        var text = cap[2].trim(); // remove trailing #s

        if (/#$/.test(text)) {
          var trimmed = rtrim(text, '#');

          if (this.options.pedantic) {
            text = trimmed.trim();
          } else if (!trimmed || / $/.test(trimmed)) {
            // CommonMark requires space before trailing #s
            text = trimmed.trim();
          }
        }

        return {
          type: 'heading',
          raw: cap[0],
          depth: cap[1].length,
          text: text,
          tokens: this.lexer.inline(text)
        };
      }
    };

    _proto.hr = function hr(src) {
      var cap = this.rules.block.hr.exec(src);

      if (cap) {
        return {
          type: 'hr',
          raw: cap[0]
        };
      }
    };

    _proto.blockquote = function blockquote(src) {
      var cap = this.rules.block.blockquote.exec(src);

      if (cap) {
        var text = cap[0].replace(/^ *>[ \t]?/gm, '');
        return {
          type: 'blockquote',
          raw: cap[0],
          tokens: this.lexer.blockTokens(text, []),
          text: text
        };
      }
    };

    _proto.list = function list(src) {
      var cap = this.rules.block.list.exec(src);

      if (cap) {
        var raw, istask, ischecked, indent, i, blankLine, endsWithBlankLine, line, nextLine, rawLine, itemContents, endEarly;
        var bull = cap[1].trim();
        var isordered = bull.length > 1;
        var list = {
          type: 'list',
          raw: '',
          ordered: isordered,
          start: isordered ? +bull.slice(0, -1) : '',
          loose: false,
          items: []
        };
        bull = isordered ? "\\d{1,9}\\" + bull.slice(-1) : "\\" + bull;

        if (this.options.pedantic) {
          bull = isordered ? bull : '[*+-]';
        } // Get next list item


        var itemRegex = new RegExp("^( {0,3}" + bull + ")((?:[\t ][^\\n]*)?(?:\\n|$))"); // Check if current bullet point can start a new List Item

        while (src) {
          endEarly = false;

          if (!(cap = itemRegex.exec(src))) {
            break;
          }

          if (this.rules.block.hr.test(src)) {
            // End list if bullet was actually HR (possibly move into itemRegex?)
            break;
          }

          raw = cap[0];
          src = src.substring(raw.length);
          line = cap[2].split('\n', 1)[0];
          nextLine = src.split('\n', 1)[0];

          if (this.options.pedantic) {
            indent = 2;
            itemContents = line.trimLeft();
          } else {
            indent = cap[2].search(/[^ ]/); // Find first non-space char

            indent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent

            itemContents = line.slice(indent);
            indent += cap[1].length;
          }

          blankLine = false;

          if (!line && /^ *$/.test(nextLine)) {
            // Items begin with at most one blank line
            raw += nextLine + '\n';
            src = src.substring(nextLine.length + 1);
            endEarly = true;
          }

          if (!endEarly) {
            var nextBulletRegex = new RegExp("^ {0," + Math.min(3, indent - 1) + "}(?:[*+-]|\\d{1,9}[.)])((?: [^\\n]*)?(?:\\n|$))");
            var hrRegex = new RegExp("^ {0," + Math.min(3, indent - 1) + "}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)");
            var fencesBeginRegex = new RegExp("^ {0," + Math.min(3, indent - 1) + "}(?:```|~~~)");
            var headingBeginRegex = new RegExp("^ {0," + Math.min(3, indent - 1) + "}#"); // Check if following lines should be included in List Item

            while (src) {
              rawLine = src.split('\n', 1)[0];
              line = rawLine; // Re-align to follow commonmark nesting rules

              if (this.options.pedantic) {
                line = line.replace(/^ {1,4}(?=( {4})*[^ ])/g, '  ');
              } // End list item if found code fences


              if (fencesBeginRegex.test(line)) {
                break;
              } // End list item if found start of new heading


              if (headingBeginRegex.test(line)) {
                break;
              } // End list item if found start of new bullet


              if (nextBulletRegex.test(line)) {
                break;
              } // Horizontal rule found


              if (hrRegex.test(src)) {
                break;
              }

              if (line.search(/[^ ]/) >= indent || !line.trim()) {
                // Dedent if possible
                itemContents += '\n' + line.slice(indent);
              } else if (!blankLine) {
                // Until blank line, item doesn't need indentation
                itemContents += '\n' + line;
              } else {
                // Otherwise, improper indentation ends this item
                break;
              }

              if (!blankLine && !line.trim()) {
                // Check if current line is blank
                blankLine = true;
              }

              raw += rawLine + '\n';
              src = src.substring(rawLine.length + 1);
            }
          }

          if (!list.loose) {
            // If the previous item ended with a blank line, the list is loose
            if (endsWithBlankLine) {
              list.loose = true;
            } else if (/\n *\n *$/.test(raw)) {
              endsWithBlankLine = true;
            }
          } // Check for task list items


          if (this.options.gfm) {
            istask = /^\[[ xX]\] /.exec(itemContents);

            if (istask) {
              ischecked = istask[0] !== '[ ] ';
              itemContents = itemContents.replace(/^\[[ xX]\] +/, '');
            }
          }

          list.items.push({
            type: 'list_item',
            raw: raw,
            task: !!istask,
            checked: ischecked,
            loose: false,
            text: itemContents
          });
          list.raw += raw;
        } // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic


        list.items[list.items.length - 1].raw = raw.trimRight();
        list.items[list.items.length - 1].text = itemContents.trimRight();
        list.raw = list.raw.trimRight();
        var l = list.items.length; // Item child tokens handled here at end because we needed to have the final item to trim it first

        for (i = 0; i < l; i++) {
          this.lexer.state.top = false;
          list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);
          var spacers = list.items[i].tokens.filter(function (t) {
            return t.type === 'space';
          });
          var hasMultipleLineBreaks = spacers.every(function (t) {
            var chars = t.raw.split('');
            var lineBreaks = 0;

            for (var _iterator = _createForOfIteratorHelperLoose(chars), _step; !(_step = _iterator()).done;) {
              var _char = _step.value;

              if (_char === '\n') {
                lineBreaks += 1;
              }

              if (lineBreaks > 1) {
                return true;
              }
            }

            return false;
          });

          if (!list.loose && spacers.length && hasMultipleLineBreaks) {
            // Having a single line break doesn't mean a list is loose. A single line break is terminating the last list item
            list.loose = true;
            list.items[i].loose = true;
          }
        }

        return list;
      }
    };

    _proto.html = function html(src) {
      var cap = this.rules.block.html.exec(src);

      if (cap) {
        var token = {
          type: 'html',
          raw: cap[0],
          pre: !this.options.sanitizer && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),
          text: cap[0]
        };

        if (this.options.sanitize) {
          var text = this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]);
          token.type = 'paragraph';
          token.text = text;
          token.tokens = this.lexer.inline(text);
        }

        return token;
      }
    };

    _proto.def = function def(src) {
      var cap = this.rules.block.def.exec(src);

      if (cap) {
        if (cap[3]) cap[3] = cap[3].substring(1, cap[3].length - 1);
        var tag = cap[1].toLowerCase().replace(/\s+/g, ' ');
        return {
          type: 'def',
          tag: tag,
          raw: cap[0],
          href: cap[2],
          title: cap[3]
        };
      }
    };

    _proto.table = function table(src) {
      var cap = this.rules.block.table.exec(src);

      if (cap) {
        var item = {
          type: 'table',
          header: splitCells(cap[1]).map(function (c) {
            return {
              text: c
            };
          }),
          align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
          rows: cap[3] && cap[3].trim() ? cap[3].replace(/\n[ \t]*$/, '').split('\n') : []
        };

        if (item.header.length === item.align.length) {
          item.raw = cap[0];
          var l = item.align.length;
          var i, j, k, row;

          for (i = 0; i < l; i++) {
            if (/^ *-+: *$/.test(item.align[i])) {
              item.align[i] = 'right';
            } else if (/^ *:-+: *$/.test(item.align[i])) {
              item.align[i] = 'center';
            } else if (/^ *:-+ *$/.test(item.align[i])) {
              item.align[i] = 'left';
            } else {
              item.align[i] = null;
            }
          }

          l = item.rows.length;

          for (i = 0; i < l; i++) {
            item.rows[i] = splitCells(item.rows[i], item.header.length).map(function (c) {
              return {
                text: c
              };
            });
          } // parse child tokens inside headers and cells
          // header child tokens


          l = item.header.length;

          for (j = 0; j < l; j++) {
            item.header[j].tokens = this.lexer.inline(item.header[j].text);
          } // cell child tokens


          l = item.rows.length;

          for (j = 0; j < l; j++) {
            row = item.rows[j];

            for (k = 0; k < row.length; k++) {
              row[k].tokens = this.lexer.inline(row[k].text);
            }
          }

          return item;
        }
      }
    };

    _proto.lheading = function lheading(src) {
      var cap = this.rules.block.lheading.exec(src);

      if (cap) {
        return {
          type: 'heading',
          raw: cap[0],
          depth: cap[2].charAt(0) === '=' ? 1 : 2,
          text: cap[1],
          tokens: this.lexer.inline(cap[1])
        };
      }
    };

    _proto.paragraph = function paragraph(src) {
      var cap = this.rules.block.paragraph.exec(src);

      if (cap) {
        var text = cap[1].charAt(cap[1].length - 1) === '\n' ? cap[1].slice(0, -1) : cap[1];
        return {
          type: 'paragraph',
          raw: cap[0],
          text: text,
          tokens: this.lexer.inline(text)
        };
      }
    };

    _proto.text = function text(src) {
      var cap = this.rules.block.text.exec(src);

      if (cap) {
        return {
          type: 'text',
          raw: cap[0],
          text: cap[0],
          tokens: this.lexer.inline(cap[0])
        };
      }
    };

    _proto.escape = function escape$1(src) {
      var cap = this.rules.inline.escape.exec(src);

      if (cap) {
        return {
          type: 'escape',
          raw: cap[0],
          text: escape(cap[1])
        };
      }
    };

    _proto.tag = function tag(src) {
      var cap = this.rules.inline.tag.exec(src);

      if (cap) {
        if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {
          this.lexer.state.inLink = true;
        } else if (this.lexer.state.inLink && /^<\/a>/i.test(cap[0])) {
          this.lexer.state.inLink = false;
        }

        if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
          this.lexer.state.inRawBlock = true;
        } else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
          this.lexer.state.inRawBlock = false;
        }

        return {
          type: this.options.sanitize ? 'text' : 'html',
          raw: cap[0],
          inLink: this.lexer.state.inLink,
          inRawBlock: this.lexer.state.inRawBlock,
          text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0]
        };
      }
    };

    _proto.link = function link(src) {
      var cap = this.rules.inline.link.exec(src);

      if (cap) {
        var trimmedUrl = cap[2].trim();

        if (!this.options.pedantic && /^</.test(trimmedUrl)) {
          // commonmark requires matching angle brackets
          if (!/>$/.test(trimmedUrl)) {
            return;
          } // ending angle bracket cannot be escaped


          var rtrimSlash = rtrim(trimmedUrl.slice(0, -1), '\\');

          if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
            return;
          }
        } else {
          // find closing parenthesis
          var lastParenIndex = findClosingBracket(cap[2], '()');

          if (lastParenIndex > -1) {
            var start = cap[0].indexOf('!') === 0 ? 5 : 4;
            var linkLen = start + cap[1].length + lastParenIndex;
            cap[2] = cap[2].substring(0, lastParenIndex);
            cap[0] = cap[0].substring(0, linkLen).trim();
            cap[3] = '';
          }
        }

        var href = cap[2];
        var title = '';

        if (this.options.pedantic) {
          // split pedantic href and title
          var link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);

          if (link) {
            href = link[1];
            title = link[3];
          }
        } else {
          title = cap[3] ? cap[3].slice(1, -1) : '';
        }

        href = href.trim();

        if (/^</.test(href)) {
          if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
            // pedantic allows starting angle bracket without ending angle bracket
            href = href.slice(1);
          } else {
            href = href.slice(1, -1);
          }
        }

        return outputLink(cap, {
          href: href ? href.replace(this.rules.inline._escapes, '$1') : href,
          title: title ? title.replace(this.rules.inline._escapes, '$1') : title
        }, cap[0], this.lexer);
      }
    };

    _proto.reflink = function reflink(src, links) {
      var cap;

      if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
        var link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
        link = links[link.toLowerCase()];

        if (!link || !link.href) {
          var text = cap[0].charAt(0);
          return {
            type: 'text',
            raw: text,
            text: text
          };
        }

        return outputLink(cap, link, cap[0], this.lexer);
      }
    };

    _proto.emStrong = function emStrong(src, maskedSrc, prevChar) {
      if (prevChar === void 0) {
        prevChar = '';
      }

      var match = this.rules.inline.emStrong.lDelim.exec(src);
      if (!match) return; // _ can't be between two alphanumerics. \p{L}\p{N} includes non-english alphabet/numbers as well

      if (match[3] && prevChar.match(/(?:[0-9A-Za-z\xAA\xB2\xB3\xB5\xB9\xBA\xBC-\xBE\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u0660-\u0669\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0966-\u096F\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09E6-\u09F1\u09F4-\u09F9\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A66-\u0A6F\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AE6-\u0AEF\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B66-\u0B6F\u0B71-\u0B77\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0BE6-\u0BF2\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C66-\u0C6F\u0C78-\u0C7E\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CE6-\u0CEF\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D58-\u0D61\u0D66-\u0D78\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DE6-\u0DEF\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F20-\u0F33\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F-\u1049\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u1090-\u1099\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1369-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A16\u1A20-\u1A54\u1A80-\u1A89\u1A90-\u1A99\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B50-\u1B59\u1B83-\u1BA0\u1BAE-\u1BE5\u1C00-\u1C23\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2070\u2071\u2074-\u2079\u207F-\u2089\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2150-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2CFD\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3192-\u3195\u31A0-\u31BF\u31F0-\u31FF\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA830-\uA835\uA840-\uA873\uA882-\uA8B3\uA8D0-\uA8D9\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA900-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF-\uA9D9\uA9E0-\uA9E4\uA9E6-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDE80-\uDE9C\uDEA0-\uDED0\uDEE1-\uDEFB\uDF00-\uDF23\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC58-\uDC76\uDC79-\uDC9E\uDCA7-\uDCAF\uDCE0-\uDCF2\uDCF4\uDCF5\uDCFB-\uDD1B\uDD20-\uDD39\uDD80-\uDDB7\uDDBC-\uDDCF\uDDD2-\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE40-\uDE48\uDE60-\uDE7E\uDE80-\uDE9F\uDEC0-\uDEC7\uDEC9-\uDEE4\uDEEB-\uDEEF\uDF00-\uDF35\uDF40-\uDF55\uDF58-\uDF72\uDF78-\uDF91\uDFA9-\uDFAF]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDCFA-\uDD23\uDD30-\uDD39\uDE60-\uDE7E\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF27\uDF30-\uDF45\uDF51-\uDF54\uDF70-\uDF81\uDFB0-\uDFCB\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC52-\uDC6F\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD03-\uDD26\uDD36-\uDD3F\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDD0-\uDDDA\uDDDC\uDDE1-\uDDF4\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDEF0-\uDEF9\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC50-\uDC59\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE50-\uDE59\uDE80-\uDEAA\uDEB8\uDEC0-\uDEC9\uDF00-\uDF1A\uDF30-\uDF3B\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCF2\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDD50-\uDD59\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC50-\uDC6C\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD50-\uDD59\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDDA0-\uDDA9\uDEE0-\uDEF2\uDFB0\uDFC0-\uDFD4]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDE70-\uDEBE\uDEC0-\uDEC9\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF50-\uDF59\uDF5B-\uDF61\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE96\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD834[\uDEE0-\uDEF3\uDF60-\uDF78]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD40-\uDD49\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB\uDEF0-\uDEF9]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDCC7-\uDCCF\uDD00-\uDD43\uDD4B\uDD50-\uDD59]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD83C[\uDD00-\uDD0C]|\uD83E[\uDFF0-\uDFF9]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])/)) return;
      var nextChar = match[1] || match[2] || '';

      if (!nextChar || nextChar && (prevChar === '' || this.rules.inline.punctuation.exec(prevChar))) {
        var lLength = match[0].length - 1;
        var rDelim,
            rLength,
            delimTotal = lLength,
            midDelimTotal = 0;
        var endReg = match[0][0] === '*' ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
        endReg.lastIndex = 0; // Clip maskedSrc to same section of string as src (move to lexer?)

        maskedSrc = maskedSrc.slice(-1 * src.length + lLength);

        while ((match = endReg.exec(maskedSrc)) != null) {
          rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
          if (!rDelim) continue; // skip single * in __abc*abc__

          rLength = rDelim.length;

          if (match[3] || match[4]) {
            // found another Left Delim
            delimTotal += rLength;
            continue;
          } else if (match[5] || match[6]) {
            // either Left or Right Delim
            if (lLength % 3 && !((lLength + rLength) % 3)) {
              midDelimTotal += rLength;
              continue; // CommonMark Emphasis Rules 9-10
            }
          }

          delimTotal -= rLength;
          if (delimTotal > 0) continue; // Haven't found enough closing delimiters
          // Remove extra characters. *a*** -> *a*

          rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal); // Create `em` if smallest delimiter has odd char count. *a***

          if (Math.min(lLength, rLength) % 2) {
            var _text = src.slice(1, lLength + match.index + rLength);

            return {
              type: 'em',
              raw: src.slice(0, lLength + match.index + rLength + 1),
              text: _text,
              tokens: this.lexer.inlineTokens(_text)
            };
          } // Create 'strong' if smallest delimiter has even char count. **a***


          var text = src.slice(2, lLength + match.index + rLength - 1);
          return {
            type: 'strong',
            raw: src.slice(0, lLength + match.index + rLength + 1),
            text: text,
            tokens: this.lexer.inlineTokens(text)
          };
        }
      }
    };

    _proto.codespan = function codespan(src) {
      var cap = this.rules.inline.code.exec(src);

      if (cap) {
        var text = cap[2].replace(/\n/g, ' ');
        var hasNonSpaceChars = /[^ ]/.test(text);
        var hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);

        if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
          text = text.substring(1, text.length - 1);
        }

        text = escape(text, true);
        return {
          type: 'codespan',
          raw: cap[0],
          text: text
        };
      }
    };

    _proto.br = function br(src) {
      var cap = this.rules.inline.br.exec(src);

      if (cap) {
        return {
          type: 'br',
          raw: cap[0]
        };
      }
    };

    _proto.del = function del(src) {
      var cap = this.rules.inline.del.exec(src);

      if (cap) {
        return {
          type: 'del',
          raw: cap[0],
          text: cap[2],
          tokens: this.lexer.inlineTokens(cap[2])
        };
      }
    };

    _proto.autolink = function autolink(src, mangle) {
      var cap = this.rules.inline.autolink.exec(src);

      if (cap) {
        var text, href;

        if (cap[2] === '@') {
          text = escape(this.options.mangle ? mangle(cap[1]) : cap[1]);
          href = 'mailto:' + text;
        } else {
          text = escape(cap[1]);
          href = text;
        }

        return {
          type: 'link',
          raw: cap[0],
          text: text,
          href: href,
          tokens: [{
            type: 'text',
            raw: text,
            text: text
          }]
        };
      }
    };

    _proto.url = function url(src, mangle) {
      var cap;

      if (cap = this.rules.inline.url.exec(src)) {
        var text, href;

        if (cap[2] === '@') {
          text = escape(this.options.mangle ? mangle(cap[0]) : cap[0]);
          href = 'mailto:' + text;
        } else {
          // do extended autolink path validation
          var prevCapZero;

          do {
            prevCapZero = cap[0];
            cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
          } while (prevCapZero !== cap[0]);

          text = escape(cap[0]);

          if (cap[1] === 'www.') {
            href = 'http://' + text;
          } else {
            href = text;
          }
        }

        return {
          type: 'link',
          raw: cap[0],
          text: text,
          href: href,
          tokens: [{
            type: 'text',
            raw: text,
            text: text
          }]
        };
      }
    };

    _proto.inlineText = function inlineText(src, smartypants) {
      var cap = this.rules.inline.text.exec(src);

      if (cap) {
        var text;

        if (this.lexer.state.inRawBlock) {
          text = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0];
        } else {
          text = escape(this.options.smartypants ? smartypants(cap[0]) : cap[0]);
        }

        return {
          type: 'text',
          raw: cap[0],
          text: text
        };
      }
    };

    return Tokenizer;
  }();

  /**
   * Block-Level Grammar
   */

  var block = {
    newline: /^(?: *(?:\n|$))+/,
    code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
    fences: /^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
    hr: /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,
    heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
    blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
    list: /^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/,
    html: '^ {0,3}(?:' // optional indentation
    + '<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)' // (1)
    + '|comment[^\\n]*(\\n+|$)' // (2)
    + '|<\\?[\\s\\S]*?(?:\\?>\\n*|$)' // (3)
    + '|<![A-Z][\\s\\S]*?(?:>\\n*|$)' // (4)
    + '|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)' // (5)
    + '|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)' // (6)
    + '|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)' // (7) open tag
    + '|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)' // (7) closing tag
    + ')',
    def: /^ {0,3}\[(label)\]: *(?:\n *)?<?([^\s>]+)>?(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
    table: noopTest,
    lheading: /^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/,
    // regex template, placeholders will be replaced according to different paragraph
    // interruption rules of commonmark and the original markdown spec:
    _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
    text: /^[^\n]+/
  };
  block._label = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
  block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
  block.def = edit(block.def).replace('label', block._label).replace('title', block._title).getRegex();
  block.bullet = /(?:[*+-]|\d{1,9}[.)])/;
  block.listItemStart = edit(/^( *)(bull) */).replace('bull', block.bullet).getRegex();
  block.list = edit(block.list).replace(/bull/g, block.bullet).replace('hr', '\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))').replace('def', '\\n+(?=' + block.def.source + ')').getRegex();
  block._tag = 'address|article|aside|base|basefont|blockquote|body|caption' + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption' + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe' + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option' + '|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr' + '|track|ul';
  block._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
  block.html = edit(block.html, 'i').replace('comment', block._comment).replace('tag', block._tag).replace('attribute', / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
  block.paragraph = edit(block._paragraph).replace('hr', block.hr).replace('heading', ' {0,3}#{1,6} ').replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs
  .replace('|table', '').replace('blockquote', ' {0,3}>').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
  .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)').replace('tag', block._tag) // pars can be interrupted by type (6) html blocks
  .getRegex();
  block.blockquote = edit(block.blockquote).replace('paragraph', block.paragraph).getRegex();
  /**
   * Normal Block Grammar
   */

  block.normal = merge({}, block);
  /**
   * GFM Block Grammar
   */

  block.gfm = merge({}, block.normal, {
    table: '^ *([^\\n ].*\\|.*)\\n' // Header
    + ' {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?' // Align
    + '(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)' // Cells

  });
  block.gfm.table = edit(block.gfm.table).replace('hr', block.hr).replace('heading', ' {0,3}#{1,6} ').replace('blockquote', ' {0,3}>').replace('code', ' {4}[^\\n]').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
  .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)').replace('tag', block._tag) // tables can be interrupted by type (6) html blocks
  .getRegex();
  block.gfm.paragraph = edit(block._paragraph).replace('hr', block.hr).replace('heading', ' {0,3}#{1,6} ').replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs
  .replace('table', block.gfm.table) // interrupt paragraphs with table
  .replace('blockquote', ' {0,3}>').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
  .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)').replace('tag', block._tag) // pars can be interrupted by type (6) html blocks
  .getRegex();
  /**
   * Pedantic grammar (original John Gruber's loose markdown specification)
   */

  block.pedantic = merge({}, block.normal, {
    html: edit('^ *(?:comment *(?:\\n|\\s*$)' + '|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)' // closed tag
    + '|<tag(?:"[^"]*"|\'[^\']*\'|\\s[^\'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))').replace('comment', block._comment).replace(/tag/g, '(?!(?:' + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub' + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)' + '\\b)\\w+(?!:|[^\\w\\s@]*@)\\b').getRegex(),
    def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
    heading: /^(#{1,6})(.*)(?:\n+|$)/,
    fences: noopTest,
    // fences not supported
    paragraph: edit(block.normal._paragraph).replace('hr', block.hr).replace('heading', ' *#{1,6} *[^\n]').replace('lheading', block.lheading).replace('blockquote', ' {0,3}>').replace('|fences', '').replace('|list', '').replace('|html', '').getRegex()
  });
  /**
   * Inline-Level Grammar
   */

  var inline = {
    escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
    autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
    url: noopTest,
    tag: '^comment' + '|^</[a-zA-Z][\\w:-]*\\s*>' // self-closing tag
    + '|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>' // open tag
    + '|^<\\?[\\s\\S]*?\\?>' // processing instruction, e.g. <?php ?>
    + '|^<![a-zA-Z]+\\s[\\s\\S]*?>' // declaration, e.g. <!DOCTYPE html>
    + '|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>',
    // CDATA section
    link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
    reflink: /^!?\[(label)\]\[(ref)\]/,
    nolink: /^!?\[(ref)\](?:\[\])?/,
    reflinkSearch: 'reflink|nolink(?!\\()',
    emStrong: {
      lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,
      //        (1) and (2) can only be a Right Delimiter. (3) and (4) can only be Left.  (5) and (6) can be either Left or Right.
      //          () Skip orphan inside strong  () Consume to delim (1) #***                (2) a***#, a***                   (3) #***a, ***a                 (4) ***#              (5) #***#                 (6) a***a
      rDelimAst: /^[^_*]*?\_\_[^_*]*?\*[^_*]*?(?=\_\_)|[^*]+(?=[^*])|[punct_](\*+)(?=[\s]|$)|[^punct*_\s](\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|[^punct*_\s](\*+)(?=[^punct*_\s])/,
      rDelimUnd: /^[^_*]*?\*\*[^_*]*?\_[^_*]*?(?=\*\*)|[^_]+(?=[^_])|[punct*](\_+)(?=[\s]|$)|[^punct*_\s](\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/ // ^- Not allowed for _

    },
    code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
    br: /^( {2,}|\\)\n(?!\s*$)/,
    del: noopTest,
    text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
    punctuation: /^([\spunctuation])/
  }; // list of punctuation marks from CommonMark spec
  // without * and _ to handle the different emphasis markers * and _

  inline._punctuation = '!"#$%&\'()+\\-.,/:;<=>?@\\[\\]`^{|}~';
  inline.punctuation = edit(inline.punctuation).replace(/punctuation/g, inline._punctuation).getRegex(); // sequences em should skip over [title](link), `code`, <html>

  inline.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g;
  inline.escapedEmSt = /\\\*|\\_/g;
  inline._comment = edit(block._comment).replace('(?:-->|$)', '-->').getRegex();
  inline.emStrong.lDelim = edit(inline.emStrong.lDelim).replace(/punct/g, inline._punctuation).getRegex();
  inline.emStrong.rDelimAst = edit(inline.emStrong.rDelimAst, 'g').replace(/punct/g, inline._punctuation).getRegex();
  inline.emStrong.rDelimUnd = edit(inline.emStrong.rDelimUnd, 'g').replace(/punct/g, inline._punctuation).getRegex();
  inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
  inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
  inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
  inline.autolink = edit(inline.autolink).replace('scheme', inline._scheme).replace('email', inline._email).getRegex();
  inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
  inline.tag = edit(inline.tag).replace('comment', inline._comment).replace('attribute', inline._attribute).getRegex();
  inline._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
  inline._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
  inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
  inline.link = edit(inline.link).replace('label', inline._label).replace('href', inline._href).replace('title', inline._title).getRegex();
  inline.reflink = edit(inline.reflink).replace('label', inline._label).replace('ref', block._label).getRegex();
  inline.nolink = edit(inline.nolink).replace('ref', block._label).getRegex();
  inline.reflinkSearch = edit(inline.reflinkSearch, 'g').replace('reflink', inline.reflink).replace('nolink', inline.nolink).getRegex();
  /**
   * Normal Inline Grammar
   */

  inline.normal = merge({}, inline);
  /**
   * Pedantic Inline Grammar
   */

  inline.pedantic = merge({}, inline.normal, {
    strong: {
      start: /^__|\*\*/,
      middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
      endAst: /\*\*(?!\*)/g,
      endUnd: /__(?!_)/g
    },
    em: {
      start: /^_|\*/,
      middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
      endAst: /\*(?!\*)/g,
      endUnd: /_(?!_)/g
    },
    link: edit(/^!?\[(label)\]\((.*?)\)/).replace('label', inline._label).getRegex(),
    reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace('label', inline._label).getRegex()
  });
  /**
   * GFM Inline Grammar
   */

  inline.gfm = merge({}, inline.normal, {
    escape: edit(inline.escape).replace('])', '~|])').getRegex(),
    _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
    url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
    _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
    del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
    text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
  });
  inline.gfm.url = edit(inline.gfm.url, 'i').replace('email', inline.gfm._extended_email).getRegex();
  /**
   * GFM + Line Breaks Inline Grammar
   */

  inline.breaks = merge({}, inline.gfm, {
    br: edit(inline.br).replace('{2,}', '*').getRegex(),
    text: edit(inline.gfm.text).replace('\\b_', '\\b_| {2,}\\n').replace(/\{2,\}/g, '*').getRegex()
  });

  /**
   * smartypants text replacement
   * @param {string} text
   */

  function smartypants(text) {
    return text // em-dashes
    .replace(/---/g, "\u2014") // en-dashes
    .replace(/--/g, "\u2013") // opening singles
    .replace(/(^|[-\u2014/(\[{"\s])'/g, "$1\u2018") // closing singles & apostrophes
    .replace(/'/g, "\u2019") // opening doubles
    .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1\u201C") // closing doubles
    .replace(/"/g, "\u201D") // ellipses
    .replace(/\.{3}/g, "\u2026");
  }
  /**
   * mangle email addresses
   * @param {string} text
   */


  function mangle(text) {
    var out = '',
        i,
        ch;
    var l = text.length;

    for (i = 0; i < l; i++) {
      ch = text.charCodeAt(i);

      if (Math.random() > 0.5) {
        ch = 'x' + ch.toString(16);
      }

      out += '&#' + ch + ';';
    }

    return out;
  }
  /**
   * Block Lexer
   */


  var Lexer = /*#__PURE__*/function () {
    function Lexer(options) {
      this.tokens = [];
      this.tokens.links = Object.create(null);
      this.options = options || exports.defaults;
      this.options.tokenizer = this.options.tokenizer || new Tokenizer();
      this.tokenizer = this.options.tokenizer;
      this.tokenizer.options = this.options;
      this.tokenizer.lexer = this;
      this.inlineQueue = [];
      this.state = {
        inLink: false,
        inRawBlock: false,
        top: true
      };
      var rules = {
        block: block.normal,
        inline: inline.normal
      };

      if (this.options.pedantic) {
        rules.block = block.pedantic;
        rules.inline = inline.pedantic;
      } else if (this.options.gfm) {
        rules.block = block.gfm;

        if (this.options.breaks) {
          rules.inline = inline.breaks;
        } else {
          rules.inline = inline.gfm;
        }
      }

      this.tokenizer.rules = rules;
    }
    /**
     * Expose Rules
     */


    /**
     * Static Lex Method
     */
    Lexer.lex = function lex(src, options) {
      var lexer = new Lexer(options);
      return lexer.lex(src);
    }
    /**
     * Static Lex Inline Method
     */
    ;

    Lexer.lexInline = function lexInline(src, options) {
      var lexer = new Lexer(options);
      return lexer.inlineTokens(src);
    }
    /**
     * Preprocessing
     */
    ;

    var _proto = Lexer.prototype;

    _proto.lex = function lex(src) {
      src = src.replace(/\r\n|\r/g, '\n');
      this.blockTokens(src, this.tokens);
      var next;

      while (next = this.inlineQueue.shift()) {
        this.inlineTokens(next.src, next.tokens);
      }

      return this.tokens;
    }
    /**
     * Lexing
     */
    ;

    _proto.blockTokens = function blockTokens(src, tokens) {
      var _this = this;

      if (tokens === void 0) {
        tokens = [];
      }

      if (this.options.pedantic) {
        src = src.replace(/\t/g, '    ').replace(/^ +$/gm, '');
      } else {
        src = src.replace(/^( *)(\t+)/gm, function (_, leading, tabs) {
          return leading + '    '.repeat(tabs.length);
        });
      }

      var token, lastToken, cutSrc, lastParagraphClipped;

      while (src) {
        if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some(function (extTokenizer) {
          if (token = extTokenizer.call({
            lexer: _this
          }, src, tokens)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            return true;
          }

          return false;
        })) {
          continue;
        } // newline


        if (token = this.tokenizer.space(src)) {
          src = src.substring(token.raw.length);

          if (token.raw.length === 1 && tokens.length > 0) {
            // if there's a single \n as a spacer, it's terminating the last line,
            // so move it there so that we don't get unecessary paragraph tags
            tokens[tokens.length - 1].raw += '\n';
          } else {
            tokens.push(token);
          }

          continue;
        } // code


        if (token = this.tokenizer.code(src)) {
          src = src.substring(token.raw.length);
          lastToken = tokens[tokens.length - 1]; // An indented code block cannot interrupt a paragraph.

          if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {
            lastToken.raw += '\n' + token.raw;
            lastToken.text += '\n' + token.text;
            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
          } else {
            tokens.push(token);
          }

          continue;
        } // fences


        if (token = this.tokenizer.fences(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // heading


        if (token = this.tokenizer.heading(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // hr


        if (token = this.tokenizer.hr(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // blockquote


        if (token = this.tokenizer.blockquote(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // list


        if (token = this.tokenizer.list(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // html


        if (token = this.tokenizer.html(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // def


        if (token = this.tokenizer.def(src)) {
          src = src.substring(token.raw.length);
          lastToken = tokens[tokens.length - 1];

          if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {
            lastToken.raw += '\n' + token.raw;
            lastToken.text += '\n' + token.raw;
            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
          } else if (!this.tokens.links[token.tag]) {
            this.tokens.links[token.tag] = {
              href: token.href,
              title: token.title
            };
          }

          continue;
        } // table (gfm)


        if (token = this.tokenizer.table(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // lheading


        if (token = this.tokenizer.lheading(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // top-level paragraph
        // prevent paragraph consuming extensions by clipping 'src' to extension start


        cutSrc = src;

        if (this.options.extensions && this.options.extensions.startBlock) {
          (function () {
            var startIndex = Infinity;
            var tempSrc = src.slice(1);
            var tempStart = void 0;

            _this.options.extensions.startBlock.forEach(function (getStartIndex) {
              tempStart = getStartIndex.call({
                lexer: this
              }, tempSrc);

              if (typeof tempStart === 'number' && tempStart >= 0) {
                startIndex = Math.min(startIndex, tempStart);
              }
            });

            if (startIndex < Infinity && startIndex >= 0) {
              cutSrc = src.substring(0, startIndex + 1);
            }
          })();
        }

        if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
          lastToken = tokens[tokens.length - 1];

          if (lastParagraphClipped && lastToken.type === 'paragraph') {
            lastToken.raw += '\n' + token.raw;
            lastToken.text += '\n' + token.text;
            this.inlineQueue.pop();
            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
          } else {
            tokens.push(token);
          }

          lastParagraphClipped = cutSrc.length !== src.length;
          src = src.substring(token.raw.length);
          continue;
        } // text


        if (token = this.tokenizer.text(src)) {
          src = src.substring(token.raw.length);
          lastToken = tokens[tokens.length - 1];

          if (lastToken && lastToken.type === 'text') {
            lastToken.raw += '\n' + token.raw;
            lastToken.text += '\n' + token.text;
            this.inlineQueue.pop();
            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
          } else {
            tokens.push(token);
          }

          continue;
        }

        if (src) {
          var errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);

          if (this.options.silent) {
            console.error(errMsg);
            break;
          } else {
            throw new Error(errMsg);
          }
        }
      }

      this.state.top = true;
      return tokens;
    };

    _proto.inline = function inline(src, tokens) {
      if (tokens === void 0) {
        tokens = [];
      }

      this.inlineQueue.push({
        src: src,
        tokens: tokens
      });
      return tokens;
    }
    /**
     * Lexing/Compiling
     */
    ;

    _proto.inlineTokens = function inlineTokens(src, tokens) {
      var _this2 = this;

      if (tokens === void 0) {
        tokens = [];
      }

      var token, lastToken, cutSrc; // String with links masked to avoid interference with em and strong

      var maskedSrc = src;
      var match;
      var keepPrevChar, prevChar; // Mask out reflinks

      if (this.tokens.links) {
        var links = Object.keys(this.tokens.links);

        if (links.length > 0) {
          while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
            if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {
              maskedSrc = maskedSrc.slice(0, match.index) + '[' + repeatString('a', match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
            }
          }
        }
      } // Mask out other blocks


      while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
        maskedSrc = maskedSrc.slice(0, match.index) + '[' + repeatString('a', match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
      } // Mask out escaped em & strong delimiters


      while ((match = this.tokenizer.rules.inline.escapedEmSt.exec(maskedSrc)) != null) {
        maskedSrc = maskedSrc.slice(0, match.index) + '++' + maskedSrc.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);
      }

      while (src) {
        if (!keepPrevChar) {
          prevChar = '';
        }

        keepPrevChar = false; // extensions

        if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some(function (extTokenizer) {
          if (token = extTokenizer.call({
            lexer: _this2
          }, src, tokens)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            return true;
          }

          return false;
        })) {
          continue;
        } // escape


        if (token = this.tokenizer.escape(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // tag


        if (token = this.tokenizer.tag(src)) {
          src = src.substring(token.raw.length);
          lastToken = tokens[tokens.length - 1];

          if (lastToken && token.type === 'text' && lastToken.type === 'text') {
            lastToken.raw += token.raw;
            lastToken.text += token.text;
          } else {
            tokens.push(token);
          }

          continue;
        } // link


        if (token = this.tokenizer.link(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // reflink, nolink


        if (token = this.tokenizer.reflink(src, this.tokens.links)) {
          src = src.substring(token.raw.length);
          lastToken = tokens[tokens.length - 1];

          if (lastToken && token.type === 'text' && lastToken.type === 'text') {
            lastToken.raw += token.raw;
            lastToken.text += token.text;
          } else {
            tokens.push(token);
          }

          continue;
        } // em & strong


        if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // code


        if (token = this.tokenizer.codespan(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // br


        if (token = this.tokenizer.br(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // del (gfm)


        if (token = this.tokenizer.del(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // autolink


        if (token = this.tokenizer.autolink(src, mangle)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // url (gfm)


        if (!this.state.inLink && (token = this.tokenizer.url(src, mangle))) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // text
        // prevent inlineText consuming extensions by clipping 'src' to extension start


        cutSrc = src;

        if (this.options.extensions && this.options.extensions.startInline) {
          (function () {
            var startIndex = Infinity;
            var tempSrc = src.slice(1);
            var tempStart = void 0;

            _this2.options.extensions.startInline.forEach(function (getStartIndex) {
              tempStart = getStartIndex.call({
                lexer: this
              }, tempSrc);

              if (typeof tempStart === 'number' && tempStart >= 0) {
                startIndex = Math.min(startIndex, tempStart);
              }
            });

            if (startIndex < Infinity && startIndex >= 0) {
              cutSrc = src.substring(0, startIndex + 1);
            }
          })();
        }

        if (token = this.tokenizer.inlineText(cutSrc, smartypants)) {
          src = src.substring(token.raw.length);

          if (token.raw.slice(-1) !== '_') {
            // Track prevChar before string of ____ started
            prevChar = token.raw.slice(-1);
          }

          keepPrevChar = true;
          lastToken = tokens[tokens.length - 1];

          if (lastToken && lastToken.type === 'text') {
            lastToken.raw += token.raw;
            lastToken.text += token.text;
          } else {
            tokens.push(token);
          }

          continue;
        }

        if (src) {
          var errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);

          if (this.options.silent) {
            console.error(errMsg);
            break;
          } else {
            throw new Error(errMsg);
          }
        }
      }

      return tokens;
    };

    _createClass(Lexer, null, [{
      key: "rules",
      get: function get() {
        return {
          block: block,
          inline: inline
        };
      }
    }]);

    return Lexer;
  }();

  /**
   * Renderer
   */

  var Renderer = /*#__PURE__*/function () {
    function Renderer(options) {
      this.options = options || exports.defaults;
    }

    var _proto = Renderer.prototype;

    _proto.code = function code(_code, infostring, escaped) {
      var lang = (infostring || '').match(/\S*/)[0];

      if (this.options.highlight) {
        var out = this.options.highlight(_code, lang);

        if (out != null && out !== _code) {
          escaped = true;
          _code = out;
        }
      }

      _code = _code.replace(/\n$/, '') + '\n';

      if (!lang) {
        return '<pre><code>' + (escaped ? _code : escape(_code, true)) + '</code></pre>\n';
      }

      return '<pre><code class="' + this.options.langPrefix + escape(lang, true) + '">' + (escaped ? _code : escape(_code, true)) + '</code></pre>\n';
    }
    /**
     * @param {string} quote
     */
    ;

    _proto.blockquote = function blockquote(quote) {
      return "<blockquote>\n" + quote + "</blockquote>\n";
    };

    _proto.html = function html(_html) {
      return _html;
    }
    /**
     * @param {string} text
     * @param {string} level
     * @param {string} raw
     * @param {any} slugger
     */
    ;

    _proto.heading = function heading(text, level, raw, slugger) {
      if (this.options.headerIds) {
        var id = this.options.headerPrefix + slugger.slug(raw);
        return "<h" + level + " id=\"" + id + "\">" + text + "</h" + level + ">\n";
      } // ignore IDs


      return "<h" + level + ">" + text + "</h" + level + ">\n";
    };

    _proto.hr = function hr() {
      return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
    };

    _proto.list = function list(body, ordered, start) {
      var type = ordered ? 'ol' : 'ul',
          startatt = ordered && start !== 1 ? ' start="' + start + '"' : '';
      return '<' + type + startatt + '>\n' + body + '</' + type + '>\n';
    }
    /**
     * @param {string} text
     */
    ;

    _proto.listitem = function listitem(text) {
      return "<li>" + text + "</li>\n";
    };

    _proto.checkbox = function checkbox(checked) {
      return '<input ' + (checked ? 'checked="" ' : '') + 'disabled="" type="checkbox"' + (this.options.xhtml ? ' /' : '') + '> ';
    }
    /**
     * @param {string} text
     */
    ;

    _proto.paragraph = function paragraph(text) {
      return "<p>" + text + "</p>\n";
    }
    /**
     * @param {string} header
     * @param {string} body
     */
    ;

    _proto.table = function table(header, body) {
      if (body) body = "<tbody>" + body + "</tbody>";
      return '<table>\n' + '<thead>\n' + header + '</thead>\n' + body + '</table>\n';
    }
    /**
     * @param {string} content
     */
    ;

    _proto.tablerow = function tablerow(content) {
      return "<tr>\n" + content + "</tr>\n";
    };

    _proto.tablecell = function tablecell(content, flags) {
      var type = flags.header ? 'th' : 'td';
      var tag = flags.align ? "<" + type + " align=\"" + flags.align + "\">" : "<" + type + ">";
      return tag + content + ("</" + type + ">\n");
    }
    /**
     * span level renderer
     * @param {string} text
     */
    ;

    _proto.strong = function strong(text) {
      return "<strong>" + text + "</strong>";
    }
    /**
     * @param {string} text
     */
    ;

    _proto.em = function em(text) {
      return "<em>" + text + "</em>";
    }
    /**
     * @param {string} text
     */
    ;

    _proto.codespan = function codespan(text) {
      return "<code>" + text + "</code>";
    };

    _proto.br = function br() {
      return this.options.xhtml ? '<br/>' : '<br>';
    }
    /**
     * @param {string} text
     */
    ;

    _proto.del = function del(text) {
      return "<del>" + text + "</del>";
    }
    /**
     * @param {string} href
     * @param {string} title
     * @param {string} text
     */
    ;

    _proto.link = function link(href, title, text) {
      href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);

      if (href === null) {
        return text;
      }

      var out = '<a href="' + escape(href) + '"';

      if (title) {
        out += ' title="' + title + '"';
      }

      out += '>' + text + '</a>';
      return out;
    }
    /**
     * @param {string} href
     * @param {string} title
     * @param {string} text
     */
    ;

    _proto.image = function image(href, title, text) {
      href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);

      if (href === null) {
        return text;
      }

      var out = "<img src=\"" + href + "\" alt=\"" + text + "\"";

      if (title) {
        out += " title=\"" + title + "\"";
      }

      out += this.options.xhtml ? '/>' : '>';
      return out;
    };

    _proto.text = function text(_text) {
      return _text;
    };

    return Renderer;
  }();

  /**
   * TextRenderer
   * returns only the textual part of the token
   */
  var TextRenderer = /*#__PURE__*/function () {
    function TextRenderer() {}

    var _proto = TextRenderer.prototype;

    // no need for block level renderers
    _proto.strong = function strong(text) {
      return text;
    };

    _proto.em = function em(text) {
      return text;
    };

    _proto.codespan = function codespan(text) {
      return text;
    };

    _proto.del = function del(text) {
      return text;
    };

    _proto.html = function html(text) {
      return text;
    };

    _proto.text = function text(_text) {
      return _text;
    };

    _proto.link = function link(href, title, text) {
      return '' + text;
    };

    _proto.image = function image(href, title, text) {
      return '' + text;
    };

    _proto.br = function br() {
      return '';
    };

    return TextRenderer;
  }();

  /**
   * Slugger generates header id
   */
  var Slugger = /*#__PURE__*/function () {
    function Slugger() {
      this.seen = {};
    }
    /**
     * @param {string} value
     */


    var _proto = Slugger.prototype;

    _proto.serialize = function serialize(value) {
      return value.toLowerCase().trim() // remove html tags
      .replace(/<[!\/a-z].*?>/ig, '') // remove unwanted chars
      .replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, '').replace(/\s/g, '-');
    }
    /**
     * Finds the next safe (unique) slug to use
     * @param {string} originalSlug
     * @param {boolean} isDryRun
     */
    ;

    _proto.getNextSafeSlug = function getNextSafeSlug(originalSlug, isDryRun) {
      var slug = originalSlug;
      var occurenceAccumulator = 0;

      if (this.seen.hasOwnProperty(slug)) {
        occurenceAccumulator = this.seen[originalSlug];

        do {
          occurenceAccumulator++;
          slug = originalSlug + '-' + occurenceAccumulator;
        } while (this.seen.hasOwnProperty(slug));
      }

      if (!isDryRun) {
        this.seen[originalSlug] = occurenceAccumulator;
        this.seen[slug] = 0;
      }

      return slug;
    }
    /**
     * Convert string to unique id
     * @param {object} [options]
     * @param {boolean} [options.dryrun] Generates the next unique slug without
     * updating the internal accumulator.
     */
    ;

    _proto.slug = function slug(value, options) {
      if (options === void 0) {
        options = {};
      }

      var slug = this.serialize(value);
      return this.getNextSafeSlug(slug, options.dryrun);
    };

    return Slugger;
  }();

  /**
   * Parsing & Compiling
   */

  var Parser = /*#__PURE__*/function () {
    function Parser(options) {
      this.options = options || exports.defaults;
      this.options.renderer = this.options.renderer || new Renderer();
      this.renderer = this.options.renderer;
      this.renderer.options = this.options;
      this.textRenderer = new TextRenderer();
      this.slugger = new Slugger();
    }
    /**
     * Static Parse Method
     */


    Parser.parse = function parse(tokens, options) {
      var parser = new Parser(options);
      return parser.parse(tokens);
    }
    /**
     * Static Parse Inline Method
     */
    ;

    Parser.parseInline = function parseInline(tokens, options) {
      var parser = new Parser(options);
      return parser.parseInline(tokens);
    }
    /**
     * Parse Loop
     */
    ;

    var _proto = Parser.prototype;

    _proto.parse = function parse(tokens, top) {
      if (top === void 0) {
        top = true;
      }

      var out = '',
          i,
          j,
          k,
          l2,
          l3,
          row,
          cell,
          header,
          body,
          token,
          ordered,
          start,
          loose,
          itemBody,
          item,
          checked,
          task,
          checkbox,
          ret;
      var l = tokens.length;

      for (i = 0; i < l; i++) {
        token = tokens[i]; // Run any renderer extensions

        if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
          ret = this.options.extensions.renderers[token.type].call({
            parser: this
          }, token);

          if (ret !== false || !['space', 'hr', 'heading', 'code', 'table', 'blockquote', 'list', 'html', 'paragraph', 'text'].includes(token.type)) {
            out += ret || '';
            continue;
          }
        }

        switch (token.type) {
          case 'space':
            {
              continue;
            }

          case 'hr':
            {
              out += this.renderer.hr();
              continue;
            }

          case 'heading':
            {
              out += this.renderer.heading(this.parseInline(token.tokens), token.depth, unescape(this.parseInline(token.tokens, this.textRenderer)), this.slugger);
              continue;
            }

          case 'code':
            {
              out += this.renderer.code(token.text, token.lang, token.escaped);
              continue;
            }

          case 'table':
            {
              header = ''; // header

              cell = '';
              l2 = token.header.length;

              for (j = 0; j < l2; j++) {
                cell += this.renderer.tablecell(this.parseInline(token.header[j].tokens), {
                  header: true,
                  align: token.align[j]
                });
              }

              header += this.renderer.tablerow(cell);
              body = '';
              l2 = token.rows.length;

              for (j = 0; j < l2; j++) {
                row = token.rows[j];
                cell = '';
                l3 = row.length;

                for (k = 0; k < l3; k++) {
                  cell += this.renderer.tablecell(this.parseInline(row[k].tokens), {
                    header: false,
                    align: token.align[k]
                  });
                }

                body += this.renderer.tablerow(cell);
              }

              out += this.renderer.table(header, body);
              continue;
            }

          case 'blockquote':
            {
              body = this.parse(token.tokens);
              out += this.renderer.blockquote(body);
              continue;
            }

          case 'list':
            {
              ordered = token.ordered;
              start = token.start;
              loose = token.loose;
              l2 = token.items.length;
              body = '';

              for (j = 0; j < l2; j++) {
                item = token.items[j];
                checked = item.checked;
                task = item.task;
                itemBody = '';

                if (item.task) {
                  checkbox = this.renderer.checkbox(checked);

                  if (loose) {
                    if (item.tokens.length > 0 && item.tokens[0].type === 'paragraph') {
                      item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;

                      if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {
                        item.tokens[0].tokens[0].text = checkbox + ' ' + item.tokens[0].tokens[0].text;
                      }
                    } else {
                      item.tokens.unshift({
                        type: 'text',
                        text: checkbox
                      });
                    }
                  } else {
                    itemBody += checkbox;
                  }
                }

                itemBody += this.parse(item.tokens, loose);
                body += this.renderer.listitem(itemBody, task, checked);
              }

              out += this.renderer.list(body, ordered, start);
              continue;
            }

          case 'html':
            {
              // TODO parse inline content if parameter markdown=1
              out += this.renderer.html(token.text);
              continue;
            }

          case 'paragraph':
            {
              out += this.renderer.paragraph(this.parseInline(token.tokens));
              continue;
            }

          case 'text':
            {
              body = token.tokens ? this.parseInline(token.tokens) : token.text;

              while (i + 1 < l && tokens[i + 1].type === 'text') {
                token = tokens[++i];
                body += '\n' + (token.tokens ? this.parseInline(token.tokens) : token.text);
              }

              out += top ? this.renderer.paragraph(body) : body;
              continue;
            }

          default:
            {
              var errMsg = 'Token with "' + token.type + '" type was not found.';

              if (this.options.silent) {
                console.error(errMsg);
                return;
              } else {
                throw new Error(errMsg);
              }
            }
        }
      }

      return out;
    }
    /**
     * Parse Inline Tokens
     */
    ;

    _proto.parseInline = function parseInline(tokens, renderer) {
      renderer = renderer || this.renderer;
      var out = '',
          i,
          token,
          ret;
      var l = tokens.length;

      for (i = 0; i < l; i++) {
        token = tokens[i]; // Run any renderer extensions

        if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
          ret = this.options.extensions.renderers[token.type].call({
            parser: this
          }, token);

          if (ret !== false || !['escape', 'html', 'link', 'image', 'strong', 'em', 'codespan', 'br', 'del', 'text'].includes(token.type)) {
            out += ret || '';
            continue;
          }
        }

        switch (token.type) {
          case 'escape':
            {
              out += renderer.text(token.text);
              break;
            }

          case 'html':
            {
              out += renderer.html(token.text);
              break;
            }

          case 'link':
            {
              out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));
              break;
            }

          case 'image':
            {
              out += renderer.image(token.href, token.title, token.text);
              break;
            }

          case 'strong':
            {
              out += renderer.strong(this.parseInline(token.tokens, renderer));
              break;
            }

          case 'em':
            {
              out += renderer.em(this.parseInline(token.tokens, renderer));
              break;
            }

          case 'codespan':
            {
              out += renderer.codespan(token.text);
              break;
            }

          case 'br':
            {
              out += renderer.br();
              break;
            }

          case 'del':
            {
              out += renderer.del(this.parseInline(token.tokens, renderer));
              break;
            }

          case 'text':
            {
              out += renderer.text(token.text);
              break;
            }

          default:
            {
              var errMsg = 'Token with "' + token.type + '" type was not found.';

              if (this.options.silent) {
                console.error(errMsg);
                return;
              } else {
                throw new Error(errMsg);
              }
            }
        }
      }

      return out;
    };

    return Parser;
  }();

  /**
   * Marked
   */

  function marked(src, opt, callback) {
    // throw error in case of non string input
    if (typeof src === 'undefined' || src === null) {
      throw new Error('marked(): input parameter is undefined or null');
    }

    if (typeof src !== 'string') {
      throw new Error('marked(): input parameter is of type ' + Object.prototype.toString.call(src) + ', string expected');
    }

    if (typeof opt === 'function') {
      callback = opt;
      opt = null;
    }

    opt = merge({}, marked.defaults, opt || {});
    checkSanitizeDeprecation(opt);

    if (callback) {
      var highlight = opt.highlight;
      var tokens;

      try {
        tokens = Lexer.lex(src, opt);
      } catch (e) {
        return callback(e);
      }

      var done = function done(err) {
        var out;

        if (!err) {
          try {
            if (opt.walkTokens) {
              marked.walkTokens(tokens, opt.walkTokens);
            }

            out = Parser.parse(tokens, opt);
          } catch (e) {
            err = e;
          }
        }

        opt.highlight = highlight;
        return err ? callback(err) : callback(null, out);
      };

      if (!highlight || highlight.length < 3) {
        return done();
      }

      delete opt.highlight;
      if (!tokens.length) return done();
      var pending = 0;
      marked.walkTokens(tokens, function (token) {
        if (token.type === 'code') {
          pending++;
          setTimeout(function () {
            highlight(token.text, token.lang, function (err, code) {
              if (err) {
                return done(err);
              }

              if (code != null && code !== token.text) {
                token.text = code;
                token.escaped = true;
              }

              pending--;

              if (pending === 0) {
                done();
              }
            });
          }, 0);
        }
      });

      if (pending === 0) {
        done();
      }

      return;
    }

    function onError(e) {
      e.message += '\nPlease report this to https://github.com/markedjs/marked.';

      if (opt.silent) {
        return '<p>An error occurred:</p><pre>' + escape(e.message + '', true) + '</pre>';
      }

      throw e;
    }

    try {
      var _tokens = Lexer.lex(src, opt);

      if (opt.walkTokens) {
        if (opt.async) {
          return Promise.all(marked.walkTokens(_tokens, opt.walkTokens)).then(function () {
            return Parser.parse(_tokens, opt);
          })["catch"](onError);
        }

        marked.walkTokens(_tokens, opt.walkTokens);
      }

      return Parser.parse(_tokens, opt);
    } catch (e) {
      onError(e);
    }
  }
  /**
   * Options
   */

  marked.options = marked.setOptions = function (opt) {
    merge(marked.defaults, opt);
    changeDefaults(marked.defaults);
    return marked;
  };

  marked.getDefaults = getDefaults;
  marked.defaults = exports.defaults;
  /**
   * Use Extension
   */

  marked.use = function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var opts = merge.apply(void 0, [{}].concat(args));
    var extensions = marked.defaults.extensions || {
      renderers: {},
      childTokens: {}
    };
    var hasExtensions;
    args.forEach(function (pack) {
      // ==-- Parse "addon" extensions --== //
      if (pack.extensions) {
        hasExtensions = true;
        pack.extensions.forEach(function (ext) {
          if (!ext.name) {
            throw new Error('extension name required');
          }

          if (ext.renderer) {
            // Renderer extensions
            var prevRenderer = extensions.renderers ? extensions.renderers[ext.name] : null;

            if (prevRenderer) {
              // Replace extension with func to run new extension but fall back if false
              extensions.renderers[ext.name] = function () {
                for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                  args[_key2] = arguments[_key2];
                }

                var ret = ext.renderer.apply(this, args);

                if (ret === false) {
                  ret = prevRenderer.apply(this, args);
                }

                return ret;
              };
            } else {
              extensions.renderers[ext.name] = ext.renderer;
            }
          }

          if (ext.tokenizer) {
            // Tokenizer Extensions
            if (!ext.level || ext.level !== 'block' && ext.level !== 'inline') {
              throw new Error("extension level must be 'block' or 'inline'");
            }

            if (extensions[ext.level]) {
              extensions[ext.level].unshift(ext.tokenizer);
            } else {
              extensions[ext.level] = [ext.tokenizer];
            }

            if (ext.start) {
              // Function to check for start of token
              if (ext.level === 'block') {
                if (extensions.startBlock) {
                  extensions.startBlock.push(ext.start);
                } else {
                  extensions.startBlock = [ext.start];
                }
              } else if (ext.level === 'inline') {
                if (extensions.startInline) {
                  extensions.startInline.push(ext.start);
                } else {
                  extensions.startInline = [ext.start];
                }
              }
            }
          }

          if (ext.childTokens) {
            // Child tokens to be visited by walkTokens
            extensions.childTokens[ext.name] = ext.childTokens;
          }
        });
      } // ==-- Parse "overwrite" extensions --== //


      if (pack.renderer) {
        (function () {
          var renderer = marked.defaults.renderer || new Renderer();

          var _loop = function _loop(prop) {
            var prevRenderer = renderer[prop]; // Replace renderer with func to run extension, but fall back if false

            renderer[prop] = function () {
              for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                args[_key3] = arguments[_key3];
              }

              var ret = pack.renderer[prop].apply(renderer, args);

              if (ret === false) {
                ret = prevRenderer.apply(renderer, args);
              }

              return ret;
            };
          };

          for (var prop in pack.renderer) {
            _loop(prop);
          }

          opts.renderer = renderer;
        })();
      }

      if (pack.tokenizer) {
        (function () {
          var tokenizer = marked.defaults.tokenizer || new Tokenizer();

          var _loop2 = function _loop2(prop) {
            var prevTokenizer = tokenizer[prop]; // Replace tokenizer with func to run extension, but fall back if false

            tokenizer[prop] = function () {
              for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
                args[_key4] = arguments[_key4];
              }

              var ret = pack.tokenizer[prop].apply(tokenizer, args);

              if (ret === false) {
                ret = prevTokenizer.apply(tokenizer, args);
              }

              return ret;
            };
          };

          for (var prop in pack.tokenizer) {
            _loop2(prop);
          }

          opts.tokenizer = tokenizer;
        })();
      } // ==-- Parse WalkTokens extensions --== //


      if (pack.walkTokens) {
        var _walkTokens = marked.defaults.walkTokens;

        opts.walkTokens = function (token) {
          var values = [];
          values.push(pack.walkTokens.call(this, token));

          if (_walkTokens) {
            values = values.concat(_walkTokens.call(this, token));
          }

          return values;
        };
      }

      if (hasExtensions) {
        opts.extensions = extensions;
      }

      marked.setOptions(opts);
    });
  };
  /**
   * Run callback for every token
   */


  marked.walkTokens = function (tokens, callback) {
    var values = [];

    var _loop3 = function _loop3() {
      var token = _step.value;
      values = values.concat(callback.call(marked, token));

      switch (token.type) {
        case 'table':
          {
            for (var _iterator2 = _createForOfIteratorHelperLoose(token.header), _step2; !(_step2 = _iterator2()).done;) {
              var cell = _step2.value;
              values = values.concat(marked.walkTokens(cell.tokens, callback));
            }

            for (var _iterator3 = _createForOfIteratorHelperLoose(token.rows), _step3; !(_step3 = _iterator3()).done;) {
              var row = _step3.value;

              for (var _iterator4 = _createForOfIteratorHelperLoose(row), _step4; !(_step4 = _iterator4()).done;) {
                var _cell = _step4.value;
                values = values.concat(marked.walkTokens(_cell.tokens, callback));
              }
            }

            break;
          }

        case 'list':
          {
            values = values.concat(marked.walkTokens(token.items, callback));
            break;
          }

        default:
          {
            if (marked.defaults.extensions && marked.defaults.extensions.childTokens && marked.defaults.extensions.childTokens[token.type]) {
              // Walk any extensions
              marked.defaults.extensions.childTokens[token.type].forEach(function (childTokens) {
                values = values.concat(marked.walkTokens(token[childTokens], callback));
              });
            } else if (token.tokens) {
              values = values.concat(marked.walkTokens(token.tokens, callback));
            }
          }
      }
    };

    for (var _iterator = _createForOfIteratorHelperLoose(tokens), _step; !(_step = _iterator()).done;) {
      _loop3();
    }

    return values;
  };
  /**
   * Parse Inline
   * @param {string} src
   */


  marked.parseInline = function (src, opt) {
    // throw error in case of non string input
    if (typeof src === 'undefined' || src === null) {
      throw new Error('marked.parseInline(): input parameter is undefined or null');
    }

    if (typeof src !== 'string') {
      throw new Error('marked.parseInline(): input parameter is of type ' + Object.prototype.toString.call(src) + ', string expected');
    }

    opt = merge({}, marked.defaults, opt || {});
    checkSanitizeDeprecation(opt);

    try {
      var tokens = Lexer.lexInline(src, opt);

      if (opt.walkTokens) {
        marked.walkTokens(tokens, opt.walkTokens);
      }

      return Parser.parseInline(tokens, opt);
    } catch (e) {
      e.message += '\nPlease report this to https://github.com/markedjs/marked.';

      if (opt.silent) {
        return '<p>An error occurred:</p><pre>' + escape(e.message + '', true) + '</pre>';
      }

      throw e;
    }
  };
  /**
   * Expose
   */


  marked.Parser = Parser;
  marked.parser = Parser.parse;
  marked.Renderer = Renderer;
  marked.TextRenderer = TextRenderer;
  marked.Lexer = Lexer;
  marked.lexer = Lexer.lex;
  marked.Tokenizer = Tokenizer;
  marked.Slugger = Slugger;
  marked.parse = marked;
  var options = marked.options;
  var setOptions = marked.setOptions;
  var use = marked.use;
  var walkTokens = marked.walkTokens;
  var parseInline = marked.parseInline;
  var parse = marked;
  var parser = Parser.parse;
  var lexer = Lexer.lex;

  exports.Lexer = Lexer;
  exports.Parser = Parser;
  exports.Renderer = Renderer;
  exports.Slugger = Slugger;
  exports.TextRenderer = TextRenderer;
  exports.Tokenizer = Tokenizer;
  exports.getDefaults = getDefaults;
  exports.lexer = lexer;
  exports.marked = marked;
  exports.options = options;
  exports.parse = parse;
  exports.parseInline = parseInline;
  exports.parser = parser;
  exports.setOptions = setOptions;
  exports.use = use;
  exports.walkTokens = walkTokens;

  Object.defineProperty(exports, '__esModule', { value: true });

}));

// ESM-uncomment-begin
// })();
// export var marked = (__marked_exports || exports);
// ESM-uncomment-end


/***/ }),
/* 131 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "stringify": () => (/* binding */ stringify),
/* harmony export */   "parse": () => (/* binding */ parse),
/* harmony export */   "revive": () => (/* binding */ revive)
/* harmony export */ });
/* harmony import */ var _buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(132);
/* harmony import */ var _strings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(75);
/* harmony import */ var _uri__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(81);
/* harmony import */ var _marshallingIds__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(82);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/




function stringify(obj) {
  return JSON.stringify(obj, replacer);
}
function parse(text) {
  let data = JSON.parse(text);
  data = revive(data);
  return data;
}

function replacer(key, value) {
  // URI is done via toJSON-member
  if (value instanceof RegExp) {
    return {
      $mid: _marshallingIds__WEBPACK_IMPORTED_MODULE_3__.MarshalledId.Regexp,
      source: value.source,
      flags: (0,_strings__WEBPACK_IMPORTED_MODULE_1__.regExpFlags)(value)
    };
  }

  return value;
}

function revive(obj, depth = 0) {
  if (!obj || depth > 200) {
    return obj;
  }

  if (typeof obj === 'object') {
    switch (obj.$mid) {
      case _marshallingIds__WEBPACK_IMPORTED_MODULE_3__.MarshalledId.Uri:
        return _uri__WEBPACK_IMPORTED_MODULE_2__.URI.revive(obj);

      case _marshallingIds__WEBPACK_IMPORTED_MODULE_3__.MarshalledId.Regexp:
        return new RegExp(obj.source, obj.flags);

      case _marshallingIds__WEBPACK_IMPORTED_MODULE_3__.MarshalledId.Date:
        return new Date(obj.source);
    }

    if (obj instanceof _buffer__WEBPACK_IMPORTED_MODULE_0__.VSBuffer || obj instanceof Uint8Array) {
      return obj;
    }

    if (Array.isArray(obj)) {
      for (let i = 0; i < obj.length; ++i) {
        obj[i] = revive(obj[i], depth + 1);
      }
    } else {
      // walk object
      for (const key in obj) {
        if (Object.hasOwnProperty.call(obj, key)) {
          obj[key] = revive(obj[key], depth + 1);
        }
      }
    }
  }

  return obj;
}

/***/ }),
/* 132 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "VSBuffer": () => (/* binding */ VSBuffer),
/* harmony export */   "readUInt16LE": () => (/* binding */ readUInt16LE),
/* harmony export */   "writeUInt16LE": () => (/* binding */ writeUInt16LE),
/* harmony export */   "readUInt32BE": () => (/* binding */ readUInt32BE),
/* harmony export */   "writeUInt32BE": () => (/* binding */ writeUInt32BE),
/* harmony export */   "readUInt32LE": () => (/* binding */ readUInt32LE),
/* harmony export */   "writeUInt32LE": () => (/* binding */ writeUInt32LE),
/* harmony export */   "readUInt8": () => (/* binding */ readUInt8),
/* harmony export */   "writeUInt8": () => (/* binding */ writeUInt8),
/* harmony export */   "readableToBuffer": () => (/* binding */ readableToBuffer),
/* harmony export */   "bufferToReadable": () => (/* binding */ bufferToReadable),
/* harmony export */   "streamToBuffer": () => (/* binding */ streamToBuffer),
/* harmony export */   "bufferedStreamToBuffer": () => (/* binding */ bufferedStreamToBuffer),
/* harmony export */   "bufferToStream": () => (/* binding */ bufferToStream),
/* harmony export */   "streamToBufferReadableStream": () => (/* binding */ streamToBufferReadableStream),
/* harmony export */   "newWriteableBufferStream": () => (/* binding */ newWriteableBufferStream),
/* harmony export */   "prefixedBufferReadable": () => (/* binding */ prefixedBufferReadable),
/* harmony export */   "prefixedBufferStream": () => (/* binding */ prefixedBufferStream),
/* harmony export */   "decodeBase64": () => (/* binding */ decodeBase64),
/* harmony export */   "encodeBase64": () => (/* binding */ encodeBase64)
/* harmony export */ });
/* harmony import */ var _stream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(133);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

const hasBuffer = typeof Buffer !== 'undefined';
let textEncoder;
let textDecoder;
class VSBuffer {
  /**
   * When running in a nodejs context, the backing store for the returned `VSBuffer` instance
   * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.
   */
  static alloc(byteLength) {
    if (hasBuffer) {
      return new VSBuffer(Buffer.allocUnsafe(byteLength));
    } else {
      return new VSBuffer(new Uint8Array(byteLength));
    }
  }
  /**
   * When running in a nodejs context, if `actual` is not a nodejs Buffer, the backing store for
   * the returned `VSBuffer` instance might use a nodejs Buffer allocated from node's Buffer pool,
   * which is not transferrable.
   */


  static wrap(actual) {
    if (hasBuffer && !Buffer.isBuffer(actual)) {
      // https://nodejs.org/dist/latest-v10.x/docs/api/buffer.html#buffer_class_method_buffer_from_arraybuffer_byteoffset_length
      // Create a zero-copy Buffer wrapper around the ArrayBuffer pointed to by the Uint8Array
      actual = Buffer.from(actual.buffer, actual.byteOffset, actual.byteLength);
    }

    return new VSBuffer(actual);
  }
  /**
   * When running in a nodejs context, the backing store for the returned `VSBuffer` instance
   * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.
   */


  static fromString(source, options) {
    const dontUseNodeBuffer = options?.dontUseNodeBuffer || false;

    if (!dontUseNodeBuffer && hasBuffer) {
      return new VSBuffer(Buffer.from(source));
    } else {
      if (!textEncoder) {
        textEncoder = new TextEncoder();
      }

      return new VSBuffer(textEncoder.encode(source));
    }
  }
  /**
   * When running in a nodejs context, the backing store for the returned `VSBuffer` instance
   * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.
   */


  static fromByteArray(source) {
    const result = VSBuffer.alloc(source.length);

    for (let i = 0, len = source.length; i < len; i++) {
      result.buffer[i] = source[i];
    }

    return result;
  }
  /**
   * When running in a nodejs context, the backing store for the returned `VSBuffer` instance
   * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.
   */


  static concat(buffers, totalLength) {
    if (typeof totalLength === 'undefined') {
      totalLength = 0;

      for (let i = 0, len = buffers.length; i < len; i++) {
        totalLength += buffers[i].byteLength;
      }
    }

    const ret = VSBuffer.alloc(totalLength);
    let offset = 0;

    for (let i = 0, len = buffers.length; i < len; i++) {
      const element = buffers[i];
      ret.set(element, offset);
      offset += element.byteLength;
    }

    return ret;
  }

  constructor(buffer) {
    this.buffer = buffer;
    this.byteLength = this.buffer.byteLength;
  }
  /**
   * When running in a nodejs context, the backing store for the returned `VSBuffer` instance
   * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.
   */


  clone() {
    const result = VSBuffer.alloc(this.byteLength);
    result.set(this);
    return result;
  }

  toString() {
    if (hasBuffer) {
      return this.buffer.toString();
    } else {
      if (!textDecoder) {
        textDecoder = new TextDecoder();
      }

      return textDecoder.decode(this.buffer);
    }
  }

  slice(start, end) {
    // IMPORTANT: use subarray instead of slice because TypedArray#slice
    // creates shallow copy and NodeBuffer#slice doesn't. The use of subarray
    // ensures the same, performance, behaviour.
    return new VSBuffer(this.buffer.subarray(start, end));
  }

  set(array, offset) {
    if (array instanceof VSBuffer) {
      this.buffer.set(array.buffer, offset);
    } else if (array instanceof Uint8Array) {
      this.buffer.set(array, offset);
    } else if (array instanceof ArrayBuffer) {
      this.buffer.set(new Uint8Array(array), offset);
    } else if (ArrayBuffer.isView(array)) {
      this.buffer.set(new Uint8Array(array.buffer, array.byteOffset, array.byteLength), offset);
    } else {
      throw new Error(`Unknown argument 'array'`);
    }
  }

  readUInt32BE(offset) {
    return readUInt32BE(this.buffer, offset);
  }

  writeUInt32BE(value, offset) {
    writeUInt32BE(this.buffer, value, offset);
  }

  readUInt32LE(offset) {
    return readUInt32LE(this.buffer, offset);
  }

  writeUInt32LE(value, offset) {
    writeUInt32LE(this.buffer, value, offset);
  }

  readUInt8(offset) {
    return readUInt8(this.buffer, offset);
  }

  writeUInt8(value, offset) {
    writeUInt8(this.buffer, value, offset);
  }

}
function readUInt16LE(source, offset) {
  return source[offset + 0] << 0 >>> 0 | source[offset + 1] << 8 >>> 0;
}
function writeUInt16LE(destination, value, offset) {
  destination[offset + 0] = value & 0b11111111;
  value = value >>> 8;
  destination[offset + 1] = value & 0b11111111;
}
function readUInt32BE(source, offset) {
  return source[offset] * 2 ** 24 + source[offset + 1] * 2 ** 16 + source[offset + 2] * 2 ** 8 + source[offset + 3];
}
function writeUInt32BE(destination, value, offset) {
  destination[offset + 3] = value;
  value = value >>> 8;
  destination[offset + 2] = value;
  value = value >>> 8;
  destination[offset + 1] = value;
  value = value >>> 8;
  destination[offset] = value;
}
function readUInt32LE(source, offset) {
  return source[offset + 0] << 0 >>> 0 | source[offset + 1] << 8 >>> 0 | source[offset + 2] << 16 >>> 0 | source[offset + 3] << 24 >>> 0;
}
function writeUInt32LE(destination, value, offset) {
  destination[offset + 0] = value & 0b11111111;
  value = value >>> 8;
  destination[offset + 1] = value & 0b11111111;
  value = value >>> 8;
  destination[offset + 2] = value & 0b11111111;
  value = value >>> 8;
  destination[offset + 3] = value & 0b11111111;
}
function readUInt8(source, offset) {
  return source[offset];
}
function writeUInt8(destination, value, offset) {
  destination[offset] = value;
}
function readableToBuffer(readable) {
  return _stream__WEBPACK_IMPORTED_MODULE_0__.consumeReadable(readable, chunks => VSBuffer.concat(chunks));
}
function bufferToReadable(buffer) {
  return _stream__WEBPACK_IMPORTED_MODULE_0__.toReadable(buffer);
}
function streamToBuffer(stream) {
  return _stream__WEBPACK_IMPORTED_MODULE_0__.consumeStream(stream, chunks => VSBuffer.concat(chunks));
}
async function bufferedStreamToBuffer(bufferedStream) {
  if (bufferedStream.ended) {
    return VSBuffer.concat(bufferedStream.buffer);
  }

  return VSBuffer.concat([// Include already read chunks...
  ...bufferedStream.buffer, // ...and all additional chunks
  await streamToBuffer(bufferedStream.stream)]);
}
function bufferToStream(buffer) {
  return _stream__WEBPACK_IMPORTED_MODULE_0__.toStream(buffer, chunks => VSBuffer.concat(chunks));
}
function streamToBufferReadableStream(stream) {
  return _stream__WEBPACK_IMPORTED_MODULE_0__.transform(stream, {
    data: data => typeof data === 'string' ? VSBuffer.fromString(data) : VSBuffer.wrap(data)
  }, chunks => VSBuffer.concat(chunks));
}
function newWriteableBufferStream(options) {
  return _stream__WEBPACK_IMPORTED_MODULE_0__.newWriteableStream(chunks => VSBuffer.concat(chunks), options);
}
function prefixedBufferReadable(prefix, readable) {
  return _stream__WEBPACK_IMPORTED_MODULE_0__.prefixedReadable(prefix, readable, chunks => VSBuffer.concat(chunks));
}
function prefixedBufferStream(prefix, stream) {
  return _stream__WEBPACK_IMPORTED_MODULE_0__.prefixedStream(prefix, stream, chunks => VSBuffer.concat(chunks));
}
/** Decodes base64 to a uint8 array. URL-encoded and unpadded base64 is allowed. */

function decodeBase64(encoded) {
  let building = 0;
  let remainder = 0;
  let bufi = 0; // The simpler way to do this is `Uint8Array.from(atob(str), c => c.charCodeAt(0))`,
  // but that's about 10-20x slower than this function in current Chromium versions.

  const buffer = new Uint8Array(Math.floor(encoded.length / 4 * 3));

  const append = value => {
    switch (remainder) {
      case 3:
        buffer[bufi++] = building | value;
        remainder = 0;
        break;

      case 2:
        buffer[bufi++] = building | value >>> 2;
        building = value << 6;
        remainder = 3;
        break;

      case 1:
        buffer[bufi++] = building | value >>> 4;
        building = value << 4;
        remainder = 2;
        break;

      default:
        building = value << 2;
        remainder = 1;
    }
  };

  for (let i = 0; i < encoded.length; i++) {
    const code = encoded.charCodeAt(i); // See https://datatracker.ietf.org/doc/html/rfc4648#section-4
    // This branchy code is about 3x faster than an indexOf on a base64 char string.

    if (code >= 65 && code <= 90) {
      append(code - 65); // A-Z starts ranges from char code 65 to 90
    } else if (code >= 97 && code <= 122) {
      append(code - 97 + 26); // a-z starts ranges from char code 97 to 122, starting at byte 26
    } else if (code >= 48 && code <= 57) {
      append(code - 48 + 52); // 0-9 starts ranges from char code 48 to 58, starting at byte 52
    } else if (code === 43 || code === 45) {
      append(62); // "+" or "-" for URLS
    } else if (code === 47 || code === 95) {
      append(63); // "/" or "_" for URLS
    } else if (code === 61) {
      break; // "="
    } else {
      throw new SyntaxError(`Unexpected base64 character ${encoded[i]}`);
    }
  }

  const unpadded = bufi;

  while (remainder > 0) {
    append(0);
  } // slice is needed to account for overestimation due to padding


  return VSBuffer.wrap(buffer).slice(0, unpadded);
}
const base64Alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
const base64UrlSafeAlphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';
/** Encodes a buffer to a base64 string. */

function encodeBase64({
  buffer
}, padded = true, urlSafe = false) {
  const dictionary = urlSafe ? base64UrlSafeAlphabet : base64Alphabet;
  let output = '';
  const remainder = buffer.byteLength % 3;
  let i = 0;

  for (; i < buffer.byteLength - remainder; i += 3) {
    const a = buffer[i + 0];
    const b = buffer[i + 1];
    const c = buffer[i + 2];
    output += dictionary[a >>> 2];
    output += dictionary[(a << 4 | b >>> 4) & 0b111111];
    output += dictionary[(b << 2 | c >>> 6) & 0b111111];
    output += dictionary[c & 0b111111];
  }

  if (remainder === 1) {
    const a = buffer[i + 0];
    output += dictionary[a >>> 2];
    output += dictionary[a << 4 & 0b111111];

    if (padded) {
      output += '==';
    }
  } else if (remainder === 2) {
    const a = buffer[i + 0];
    const b = buffer[i + 1];
    output += dictionary[a >>> 2];
    output += dictionary[(a << 4 | b >>> 4) & 0b111111];
    output += dictionary[b << 2 & 0b111111];

    if (padded) {
      output += '=';
    }
  }

  return output;
}

/***/ }),
/* 133 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isReadable": () => (/* binding */ isReadable),
/* harmony export */   "isReadableStream": () => (/* binding */ isReadableStream),
/* harmony export */   "isReadableBufferedStream": () => (/* binding */ isReadableBufferedStream),
/* harmony export */   "newWriteableStream": () => (/* binding */ newWriteableStream),
/* harmony export */   "consumeReadable": () => (/* binding */ consumeReadable),
/* harmony export */   "peekReadable": () => (/* binding */ peekReadable),
/* harmony export */   "consumeStream": () => (/* binding */ consumeStream),
/* harmony export */   "listenStream": () => (/* binding */ listenStream),
/* harmony export */   "peekStream": () => (/* binding */ peekStream),
/* harmony export */   "toStream": () => (/* binding */ toStream),
/* harmony export */   "emptyStream": () => (/* binding */ emptyStream),
/* harmony export */   "toReadable": () => (/* binding */ toReadable),
/* harmony export */   "transform": () => (/* binding */ transform),
/* harmony export */   "prefixedReadable": () => (/* binding */ prefixedReadable),
/* harmony export */   "prefixedStream": () => (/* binding */ prefixedStream)
/* harmony export */ });
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);
/* harmony import */ var _lifecycle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(54);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


/**
 * The payload that flows in readable stream events.
 */

function isReadable(obj) {
  const candidate = obj;

  if (!candidate) {
    return false;
  }

  return typeof candidate.read === 'function';
}
/**
 * A interface that emulates the API shape of a node.js writeable
 * stream for use in native and web environments.
 */

function isReadableStream(obj) {
  const candidate = obj;

  if (!candidate) {
    return false;
  }

  return [candidate.on, candidate.pause, candidate.resume, candidate.destroy].every(fn => typeof fn === 'function');
}
function isReadableBufferedStream(obj) {
  const candidate = obj;

  if (!candidate) {
    return false;
  }

  return isReadableStream(candidate.stream) && Array.isArray(candidate.buffer) && typeof candidate.ended === 'boolean';
}
function newWriteableStream(reducer, options) {
  return new WriteableStreamImpl(reducer, options);
}

class WriteableStreamImpl {
  state = {
    flowing: false,
    ended: false,
    destroyed: false
  };
  buffer = {
    data: [],
    error: []
  };
  listeners = {
    data: [],
    error: [],
    end: []
  };
  pendingWritePromises = [];

  constructor(reducer, options) {
    this.reducer = reducer;
    this.options = options;
  }

  pause() {
    if (this.state.destroyed) {
      return;
    }

    this.state.flowing = false;
  }

  resume() {
    if (this.state.destroyed) {
      return;
    }

    if (!this.state.flowing) {
      this.state.flowing = true; // emit buffered events

      this.flowData();
      this.flowErrors();
      this.flowEnd();
    }
  }

  write(data) {
    if (this.state.destroyed) {
      return;
    } // flowing: directly send the data to listeners


    if (this.state.flowing) {
      this.emitData(data);
    } // not yet flowing: buffer data until flowing
    else {
      this.buffer.data.push(data); // highWaterMark: if configured, signal back when buffer reached limits

      if (typeof this.options?.highWaterMark === 'number' && this.buffer.data.length > this.options.highWaterMark) {
        return new Promise(resolve => this.pendingWritePromises.push(resolve));
      }
    }
  }

  error(error) {
    if (this.state.destroyed) {
      return;
    } // flowing: directly send the error to listeners


    if (this.state.flowing) {
      this.emitError(error);
    } // not yet flowing: buffer errors until flowing
    else {
      this.buffer.error.push(error);
    }
  }

  end(result) {
    if (this.state.destroyed) {
      return;
    } // end with data if provided


    if (typeof result !== 'undefined') {
      this.write(result);
    } // flowing: send end event to listeners


    if (this.state.flowing) {
      this.emitEnd();
      this.destroy();
    } // not yet flowing: remember state
    else {
      this.state.ended = true;
    }
  }

  emitData(data) {
    this.listeners.data.slice(0).forEach(listener => listener(data)); // slice to avoid listener mutation from delivering event
  }

  emitError(error) {
    if (this.listeners.error.length === 0) {
      (0,_errors__WEBPACK_IMPORTED_MODULE_0__.onUnexpectedError)(error); // nobody listened to this error so we log it as unexpected
    } else {
      this.listeners.error.slice(0).forEach(listener => listener(error)); // slice to avoid listener mutation from delivering event
    }
  }

  emitEnd() {
    this.listeners.end.slice(0).forEach(listener => listener()); // slice to avoid listener mutation from delivering event
  }

  on(event, callback) {
    if (this.state.destroyed) {
      return;
    }

    switch (event) {
      case 'data':
        this.listeners.data.push(callback); // switch into flowing mode as soon as the first 'data'
        // listener is added and we are not yet in flowing mode

        this.resume();
        break;

      case 'end':
        this.listeners.end.push(callback); // emit 'end' event directly if we are flowing
        // and the end has already been reached
        //
        // finish() when it went through

        if (this.state.flowing && this.flowEnd()) {
          this.destroy();
        }

        break;

      case 'error':
        this.listeners.error.push(callback); // emit buffered 'error' events unless done already
        // now that we know that we have at least one listener

        if (this.state.flowing) {
          this.flowErrors();
        }

        break;
    }
  }

  removeListener(event, callback) {
    if (this.state.destroyed) {
      return;
    }

    let listeners = undefined;

    switch (event) {
      case 'data':
        listeners = this.listeners.data;
        break;

      case 'end':
        listeners = this.listeners.end;
        break;

      case 'error':
        listeners = this.listeners.error;
        break;
    }

    if (listeners) {
      const index = listeners.indexOf(callback);

      if (index >= 0) {
        listeners.splice(index, 1);
      }
    }
  }

  flowData() {
    if (this.buffer.data.length > 0) {
      const fullDataBuffer = this.reducer(this.buffer.data);
      this.emitData(fullDataBuffer);
      this.buffer.data.length = 0; // When the buffer is empty, resolve all pending writers

      const pendingWritePromises = [...this.pendingWritePromises];
      this.pendingWritePromises.length = 0;
      pendingWritePromises.forEach(pendingWritePromise => pendingWritePromise());
    }
  }

  flowErrors() {
    if (this.listeners.error.length > 0) {
      for (const error of this.buffer.error) {
        this.emitError(error);
      }

      this.buffer.error.length = 0;
    }
  }

  flowEnd() {
    if (this.state.ended) {
      this.emitEnd();
      return this.listeners.end.length > 0;
    }

    return false;
  }

  destroy() {
    if (!this.state.destroyed) {
      this.state.destroyed = true;
      this.state.ended = true;
      this.buffer.data.length = 0;
      this.buffer.error.length = 0;
      this.listeners.data.length = 0;
      this.listeners.error.length = 0;
      this.listeners.end.length = 0;
      this.pendingWritePromises.length = 0;
    }
  }

}
/**
 * Helper to fully read a T readable into a T.
 */


function consumeReadable(readable, reducer) {
  const chunks = [];
  let chunk;

  while ((chunk = readable.read()) !== null) {
    chunks.push(chunk);
  }

  return reducer(chunks);
}
/**
 * Helper to read a T readable up to a maximum of chunks. If the limit is
 * reached, will return a readable instead to ensure all data can still
 * be read.
 */

function peekReadable(readable, reducer, maxChunks) {
  const chunks = [];
  let chunk = undefined;

  while ((chunk = readable.read()) !== null && chunks.length < maxChunks) {
    chunks.push(chunk);
  } // If the last chunk is null, it means we reached the end of
  // the readable and return all the data at once


  if (chunk === null && chunks.length > 0) {
    return reducer(chunks);
  } // Otherwise, we still have a chunk, it means we reached the maxChunks
  // value and as such we return a new Readable that first returns
  // the existing read chunks and then continues with reading from
  // the underlying readable.


  return {
    read: () => {
      // First consume chunks from our array
      if (chunks.length > 0) {
        return chunks.shift();
      } // Then ensure to return our last read chunk


      if (typeof chunk !== 'undefined') {
        const lastReadChunk = chunk; // explicitly use undefined here to indicate that we consumed
        // the chunk, which could have either been null or valued.

        chunk = undefined;
        return lastReadChunk;
      } // Finally delegate back to the Readable


      return readable.read();
    }
  };
}
/**
 * Helper to fully read a T stream into a T or consuming
 * a stream fully, awaiting all the events without caring
 * about the data.
 */

function consumeStream(stream, reducer) {
  return new Promise((resolve, reject) => {
    const chunks = [];
    listenStream(stream, {
      onData: chunk => {
        if (reducer) {
          chunks.push(chunk);
        }
      },
      onError: error => {
        if (reducer) {
          reject(error);
        } else {
          resolve(undefined);
        }
      },
      onEnd: () => {
        if (reducer) {
          resolve(reducer(chunks));
        } else {
          resolve(undefined);
        }
      }
    });
  });
}

/**
 * Helper to listen to all events of a T stream in proper order.
 */
function listenStream(stream, listener) {
  let destroyed = false;
  stream.on('error', error => {
    if (!destroyed) {
      listener.onError(error);
    }
  });
  stream.on('end', () => {
    if (!destroyed) {
      listener.onEnd();
    }
  }); // Adding the `data` listener will turn the stream
  // into flowing mode. As such it is important to
  // add this listener last (DO NOT CHANGE!)

  stream.on('data', data => {
    if (!destroyed) {
      listener.onData(data);
    }
  });
  return (0,_lifecycle__WEBPACK_IMPORTED_MODULE_1__.toDisposable)(() => destroyed = true);
}
/**
 * Helper to peek up to `maxChunks` into a stream. The return type signals if
 * the stream has ended or not. If not, caller needs to add a `data` listener
 * to continue reading.
 */

function peekStream(stream, maxChunks) {
  return new Promise((resolve, reject) => {
    const streamListeners = new _lifecycle__WEBPACK_IMPORTED_MODULE_1__.DisposableStore();
    const buffer = []; // Data Listener

    const dataListener = chunk => {
      // Add to buffer
      buffer.push(chunk); // We reached maxChunks and thus need to return

      if (buffer.length > maxChunks) {
        // Dispose any listeners and ensure to pause the
        // stream so that it can be consumed again by caller
        streamListeners.dispose();
        stream.pause();
        return resolve({
          stream,
          buffer,
          ended: false
        });
      }
    }; // Error Listener


    const errorListener = error => {
      return reject(error);
    }; // End Listener


    const endListener = () => {
      return resolve({
        stream,
        buffer,
        ended: true
      });
    };

    streamListeners.add((0,_lifecycle__WEBPACK_IMPORTED_MODULE_1__.toDisposable)(() => stream.removeListener('error', errorListener)));
    stream.on('error', errorListener);
    streamListeners.add((0,_lifecycle__WEBPACK_IMPORTED_MODULE_1__.toDisposable)(() => stream.removeListener('end', endListener)));
    stream.on('end', endListener); // Important: leave the `data` listener last because
    // this can turn the stream into flowing mode and we
    // want `error` events to be received as well.

    streamListeners.add((0,_lifecycle__WEBPACK_IMPORTED_MODULE_1__.toDisposable)(() => stream.removeListener('data', dataListener)));
    stream.on('data', dataListener);
  });
}
/**
 * Helper to create a readable stream from an existing T.
 */

function toStream(t, reducer) {
  const stream = newWriteableStream(reducer);
  stream.end(t);
  return stream;
}
/**
 * Helper to create an empty stream
 */

function emptyStream() {
  const stream = newWriteableStream(() => {
    throw new Error('not supported');
  });
  stream.end();
  return stream;
}
/**
 * Helper to convert a T into a Readable<T>.
 */

function toReadable(t) {
  let consumed = false;
  return {
    read: () => {
      if (consumed) {
        return null;
      }

      consumed = true;
      return t;
    }
  };
}
/**
 * Helper to transform a readable stream into another stream.
 */

function transform(stream, transformer, reducer) {
  const target = newWriteableStream(reducer);
  listenStream(stream, {
    onData: data => target.write(transformer.data(data)),
    onError: error => target.error(transformer.error ? transformer.error(error) : error),
    onEnd: () => target.end()
  });
  return target;
}
/**
 * Helper to take an existing readable that will
 * have a prefix injected to the beginning.
 */

function prefixedReadable(prefix, readable, reducer) {
  let prefixHandled = false;
  return {
    read: () => {
      const chunk = readable.read(); // Handle prefix only once

      if (!prefixHandled) {
        prefixHandled = true; // If we have also a read-result, make
        // sure to reduce it to a single result

        if (chunk !== null) {
          return reducer([prefix, chunk]);
        } // Otherwise, just return prefix directly


        return prefix;
      }

      return chunk;
    }
  };
}
/**
 * Helper to take an existing stream that will
 * have a prefix injected to the beginning.
 */

function prefixedStream(prefix, stream, reducer) {
  let prefixHandled = false;
  const target = newWriteableStream(reducer);
  listenStream(stream, {
    onData: data => {
      // Handle prefix only once
      if (!prefixHandled) {
        prefixHandled = true;
        return target.write(reducer([prefix, data]));
      }

      return target.write(data);
    },
    onError: error => target.error(error),
    onEnd: () => {
      // Handle prefix only once
      if (!prefixHandled) {
        prefixHandled = true;
        target.write(prefix);
      }

      target.end();
    }
  });
  return target;
}

/***/ }),
/* 134 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "deepClone": () => (/* binding */ deepClone),
/* harmony export */   "deepFreeze": () => (/* binding */ deepFreeze),
/* harmony export */   "cloneAndChange": () => (/* binding */ cloneAndChange),
/* harmony export */   "mixin": () => (/* binding */ mixin),
/* harmony export */   "equals": () => (/* binding */ equals),
/* harmony export */   "safeStringify": () => (/* binding */ safeStringify),
/* harmony export */   "distinct": () => (/* binding */ distinct),
/* harmony export */   "getCaseInsensitive": () => (/* binding */ getCaseInsensitive),
/* harmony export */   "filter": () => (/* binding */ filter),
/* harmony export */   "getAllPropertyNames": () => (/* binding */ getAllPropertyNames),
/* harmony export */   "getAllMethodNames": () => (/* binding */ getAllMethodNames),
/* harmony export */   "createProxyObject": () => (/* binding */ createProxyObject)
/* harmony export */ });
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(79);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

function deepClone(obj) {
  if (!obj || typeof obj !== 'object') {
    return obj;
  }

  if (obj instanceof RegExp) {
    // See https://github.com/microsoft/TypeScript/issues/10990
    return obj;
  }

  const result = Array.isArray(obj) ? [] : {};
  Object.keys(obj).forEach(key => {
    if (obj[key] && typeof obj[key] === 'object') {
      result[key] = deepClone(obj[key]);
    } else {
      result[key] = obj[key];
    }
  });
  return result;
}
function deepFreeze(obj) {
  if (!obj || typeof obj !== 'object') {
    return obj;
  }

  const stack = [obj];

  while (stack.length > 0) {
    const obj = stack.shift();
    Object.freeze(obj);

    for (const key in obj) {
      if (_hasOwnProperty.call(obj, key)) {
        const prop = obj[key];

        if (typeof prop === 'object' && !Object.isFrozen(prop) && !(0,_types__WEBPACK_IMPORTED_MODULE_0__.isTypedArray)(prop)) {
          stack.push(prop);
        }
      }
    }
  }

  return obj;
}
const _hasOwnProperty = Object.prototype.hasOwnProperty;
function cloneAndChange(obj, changer) {
  return _cloneAndChange(obj, changer, new Set());
}

function _cloneAndChange(obj, changer, seen) {
  if ((0,_types__WEBPACK_IMPORTED_MODULE_0__.isUndefinedOrNull)(obj)) {
    return obj;
  }

  const changed = changer(obj);

  if (typeof changed !== 'undefined') {
    return changed;
  }

  if (Array.isArray(obj)) {
    const r1 = [];

    for (const e of obj) {
      r1.push(_cloneAndChange(e, changer, seen));
    }

    return r1;
  }

  if ((0,_types__WEBPACK_IMPORTED_MODULE_0__.isObject)(obj)) {
    if (seen.has(obj)) {
      throw new Error('Cannot clone recursive data-structure');
    }

    seen.add(obj);
    const r2 = {};

    for (const i2 in obj) {
      if (_hasOwnProperty.call(obj, i2)) {
        r2[i2] = _cloneAndChange(obj[i2], changer, seen);
      }
    }

    seen.delete(obj);
    return r2;
  }

  return obj;
}
/**
 * Copies all properties of source into destination. The optional parameter "overwrite" allows to control
 * if existing properties on the destination should be overwritten or not. Defaults to true (overwrite).
 */


function mixin(destination, source, overwrite = true) {
  if (!(0,_types__WEBPACK_IMPORTED_MODULE_0__.isObject)(destination)) {
    return source;
  }

  if ((0,_types__WEBPACK_IMPORTED_MODULE_0__.isObject)(source)) {
    Object.keys(source).forEach(key => {
      if (key in destination) {
        if (overwrite) {
          if ((0,_types__WEBPACK_IMPORTED_MODULE_0__.isObject)(destination[key]) && (0,_types__WEBPACK_IMPORTED_MODULE_0__.isObject)(source[key])) {
            mixin(destination[key], source[key], overwrite);
          } else {
            destination[key] = source[key];
          }
        }
      } else {
        destination[key] = source[key];
      }
    });
  }

  return destination;
}
function equals(one, other) {
  if (one === other) {
    return true;
  }

  if (one === null || one === undefined || other === null || other === undefined) {
    return false;
  }

  if (typeof one !== typeof other) {
    return false;
  }

  if (typeof one !== 'object') {
    return false;
  }

  if (Array.isArray(one) !== Array.isArray(other)) {
    return false;
  }

  let i;
  let key;

  if (Array.isArray(one)) {
    if (one.length !== other.length) {
      return false;
    }

    for (i = 0; i < one.length; i++) {
      if (!equals(one[i], other[i])) {
        return false;
      }
    }
  } else {
    const oneKeys = [];

    for (key in one) {
      oneKeys.push(key);
    }

    oneKeys.sort();
    const otherKeys = [];

    for (key in other) {
      otherKeys.push(key);
    }

    otherKeys.sort();

    if (!equals(oneKeys, otherKeys)) {
      return false;
    }

    for (i = 0; i < oneKeys.length; i++) {
      if (!equals(one[oneKeys[i]], other[oneKeys[i]])) {
        return false;
      }
    }
  }

  return true;
}
/**
 * Calls `JSON.Stringify` with a replacer to break apart any circular references.
 * This prevents `JSON`.stringify` from throwing the exception
 *  "Uncaught TypeError: Converting circular structure to JSON"
 */

function safeStringify(obj) {
  const seen = new Set();
  return JSON.stringify(obj, (key, value) => {
    if ((0,_types__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) || Array.isArray(value)) {
      if (seen.has(value)) {
        return '[Circular]';
      } else {
        seen.add(value);
      }
    }

    return value;
  });
}

/**
 * Returns an object that has keys for each value that is different in the base object. Keys
 * that do not exist in the target but in the base object are not considered.
 *
 * Note: This is not a deep-diffing method, so the values are strictly taken into the resulting
 * object if they differ.
 *
 * @param base the object to diff against
 * @param obj the object to use for diffing
 */
function distinct(base, target) {
  const result = Object.create(null);

  if (!base || !target) {
    return result;
  }

  const targetKeys = Object.keys(target);
  targetKeys.forEach(k => {
    const baseValue = base[k];
    const targetValue = target[k];

    if (!equals(baseValue, targetValue)) {
      result[k] = targetValue;
    }
  });
  return result;
}
function getCaseInsensitive(target, key) {
  const lowercaseKey = key.toLowerCase();
  const equivalentKey = Object.keys(target).find(k => k.toLowerCase() === lowercaseKey);
  return equivalentKey ? target[equivalentKey] : target[key];
}
function filter(obj, predicate) {
  const result = Object.create(null);

  for (const [key, value] of Object.entries(obj)) {
    if (predicate(key, value)) {
      result[key] = value;
    }
  }

  return result;
}
function getAllPropertyNames(obj) {
  let res = [];
  let proto = Object.getPrototypeOf(obj);

  while (Object.prototype !== proto) {
    res = res.concat(Object.getOwnPropertyNames(proto));
    proto = Object.getPrototypeOf(proto);
  }

  return res;
}
function getAllMethodNames(obj) {
  const methods = [];

  for (const prop of getAllPropertyNames(obj)) {
    if (typeof obj[prop] === 'function') {
      methods.push(prop);
    }
  }

  return methods;
}
function createProxyObject(methodNames, invoke) {
  const createProxyMethod = method => {
    return function () {
      const args = Array.prototype.slice.call(arguments, 0);
      return invoke(method, args);
    };
  };

  const result = {};

  for (const methodName of methodNames) {
    result[methodName] = createProxyMethod(methodName);
  }

  return result;
}

/***/ }),
/* 135 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ContextViewDOMPosition": () => (/* binding */ ContextViewDOMPosition),
/* harmony export */   "AnchorAlignment": () => (/* binding */ AnchorAlignment),
/* harmony export */   "AnchorPosition": () => (/* binding */ AnchorPosition),
/* harmony export */   "AnchorAxisAlignment": () => (/* binding */ AnchorAxisAlignment),
/* harmony export */   "LayoutAnchorPosition": () => (/* binding */ LayoutAnchorPosition),
/* harmony export */   "LayoutAnchorMode": () => (/* binding */ LayoutAnchorMode),
/* harmony export */   "layout": () => (/* binding */ layout),
/* harmony export */   "ContextView": () => (/* binding */ ContextView)
/* harmony export */ });
/* harmony import */ var _browser_canIUse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(62);
/* harmony import */ var _browser_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(61);
/* harmony import */ var _common_lifecycle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(54);
/* harmony import */ var _common_platform__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(58);
/* harmony import */ var _common_range__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(136);
/* harmony import */ var _contextview_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(137);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






let ContextViewDOMPosition;

(function (ContextViewDOMPosition) {
  ContextViewDOMPosition[ContextViewDOMPosition["ABSOLUTE"] = 1] = "ABSOLUTE";
  ContextViewDOMPosition[ContextViewDOMPosition["FIXED"] = 2] = "FIXED";
  ContextViewDOMPosition[ContextViewDOMPosition["FIXED_SHADOW"] = 3] = "FIXED_SHADOW";
})(ContextViewDOMPosition || (ContextViewDOMPosition = {}));

let AnchorAlignment;

(function (AnchorAlignment) {
  AnchorAlignment[AnchorAlignment["LEFT"] = 0] = "LEFT";
  AnchorAlignment[AnchorAlignment["RIGHT"] = 1] = "RIGHT";
})(AnchorAlignment || (AnchorAlignment = {}));

let AnchorPosition;

(function (AnchorPosition) {
  AnchorPosition[AnchorPosition["BELOW"] = 0] = "BELOW";
  AnchorPosition[AnchorPosition["ABOVE"] = 1] = "ABOVE";
})(AnchorPosition || (AnchorPosition = {}));

let AnchorAxisAlignment;

(function (AnchorAxisAlignment) {
  AnchorAxisAlignment[AnchorAxisAlignment["VERTICAL"] = 0] = "VERTICAL";
  AnchorAxisAlignment[AnchorAxisAlignment["HORIZONTAL"] = 1] = "HORIZONTAL";
})(AnchorAxisAlignment || (AnchorAxisAlignment = {}));

let LayoutAnchorPosition;

(function (LayoutAnchorPosition) {
  LayoutAnchorPosition[LayoutAnchorPosition["Before"] = 0] = "Before";
  LayoutAnchorPosition[LayoutAnchorPosition["After"] = 1] = "After";
})(LayoutAnchorPosition || (LayoutAnchorPosition = {}));

let LayoutAnchorMode;

(function (LayoutAnchorMode) {
  LayoutAnchorMode[LayoutAnchorMode["AVOID"] = 0] = "AVOID";
  LayoutAnchorMode[LayoutAnchorMode["ALIGN"] = 1] = "ALIGN";
})(LayoutAnchorMode || (LayoutAnchorMode = {}));

/**
 * Lays out a one dimensional view next to an anchor in a viewport.
 *
 * @returns The view offset within the viewport.
 */
function layout(viewportSize, viewSize, anchor) {
  const layoutAfterAnchorBoundary = anchor.mode === LayoutAnchorMode.ALIGN ? anchor.offset : anchor.offset + anchor.size;
  const layoutBeforeAnchorBoundary = anchor.mode === LayoutAnchorMode.ALIGN ? anchor.offset + anchor.size : anchor.offset;

  if (anchor.position === LayoutAnchorPosition.Before) {
    if (viewSize <= viewportSize - layoutAfterAnchorBoundary) {
      return layoutAfterAnchorBoundary; // happy case, lay it out after the anchor
    }

    if (viewSize <= layoutBeforeAnchorBoundary) {
      return layoutBeforeAnchorBoundary - viewSize; // ok case, lay it out before the anchor
    }

    return Math.max(viewportSize - viewSize, 0); // sad case, lay it over the anchor
  } else {
    if (viewSize <= layoutBeforeAnchorBoundary) {
      return layoutBeforeAnchorBoundary - viewSize; // happy case, lay it out before the anchor
    }

    if (viewSize <= viewportSize - layoutAfterAnchorBoundary) {
      return layoutAfterAnchorBoundary; // ok case, lay it out after the anchor
    }

    return 0; // sad case, lay it over the anchor
  }
}
class ContextView extends _common_lifecycle__WEBPACK_IMPORTED_MODULE_2__.Disposable {
  static BUBBLE_UP_EVENTS = ['click', 'keydown', 'focus', 'blur'];
  static BUBBLE_DOWN_EVENTS = ['click'];
  container = null;
  delegate = null;
  toDisposeOnClean = _common_lifecycle__WEBPACK_IMPORTED_MODULE_2__.Disposable.None;
  toDisposeOnSetContainer = _common_lifecycle__WEBPACK_IMPORTED_MODULE_2__.Disposable.None;
  shadowRoot = null;
  shadowRootHostElement = null;

  constructor(container, domPosition) {
    super();
    this.view = _browser_dom__WEBPACK_IMPORTED_MODULE_1__.$('.context-view');
    this.useFixedPosition = false;
    this.useShadowDOM = false;
    _browser_dom__WEBPACK_IMPORTED_MODULE_1__.hide(this.view);
    this.setContainer(container, domPosition);

    this._register((0,_common_lifecycle__WEBPACK_IMPORTED_MODULE_2__.toDisposable)(() => this.setContainer(null, ContextViewDOMPosition.ABSOLUTE)));
  }

  setContainer(container, domPosition) {
    if (this.container) {
      this.toDisposeOnSetContainer.dispose();

      if (this.shadowRoot) {
        this.shadowRoot.removeChild(this.view);
        this.shadowRoot = null;
        this.shadowRootHostElement?.remove();
        this.shadowRootHostElement = null;
      } else {
        this.container.removeChild(this.view);
      }

      this.container = null;
    }

    if (container) {
      this.container = container;
      this.useFixedPosition = domPosition !== ContextViewDOMPosition.ABSOLUTE;
      this.useShadowDOM = domPosition === ContextViewDOMPosition.FIXED_SHADOW;

      if (this.useShadowDOM) {
        this.shadowRootHostElement = _browser_dom__WEBPACK_IMPORTED_MODULE_1__.$('.shadow-root-host');
        this.container.appendChild(this.shadowRootHostElement);
        this.shadowRoot = this.shadowRootHostElement.attachShadow({
          mode: 'open'
        });
        const style = document.createElement('style');
        style.textContent = SHADOW_ROOT_CSS;
        this.shadowRoot.appendChild(style);
        this.shadowRoot.appendChild(this.view);
        this.shadowRoot.appendChild(_browser_dom__WEBPACK_IMPORTED_MODULE_1__.$('slot'));
      } else {
        this.container.appendChild(this.view);
      }

      const toDisposeOnSetContainer = new _common_lifecycle__WEBPACK_IMPORTED_MODULE_2__.DisposableStore();
      ContextView.BUBBLE_UP_EVENTS.forEach(event => {
        toDisposeOnSetContainer.add(_browser_dom__WEBPACK_IMPORTED_MODULE_1__.addStandardDisposableListener(this.container, event, e => {
          this.onDOMEvent(e, false);
        }));
      });
      ContextView.BUBBLE_DOWN_EVENTS.forEach(event => {
        toDisposeOnSetContainer.add(_browser_dom__WEBPACK_IMPORTED_MODULE_1__.addStandardDisposableListener(this.container, event, e => {
          this.onDOMEvent(e, true);
        }, true));
      });
      this.toDisposeOnSetContainer = toDisposeOnSetContainer;
    }
  }

  show(delegate) {
    if (this.isVisible()) {
      this.hide();
    } // Show static box


    _browser_dom__WEBPACK_IMPORTED_MODULE_1__.clearNode(this.view);
    this.view.className = 'context-view';
    this.view.style.top = '0px';
    this.view.style.left = '0px';
    this.view.style.zIndex = '2575';
    this.view.style.position = this.useFixedPosition ? 'fixed' : 'absolute';
    _browser_dom__WEBPACK_IMPORTED_MODULE_1__.show(this.view); // Render content

    this.toDisposeOnClean = delegate.render(this.view) || _common_lifecycle__WEBPACK_IMPORTED_MODULE_2__.Disposable.None; // Set active delegate

    this.delegate = delegate; // Layout

    this.doLayout(); // Focus

    this.delegate.focus?.();
  }

  getViewElement() {
    return this.view;
  }

  layout() {
    if (!this.isVisible()) {
      return;
    }

    if (this.delegate.canRelayout === false && !(_common_platform__WEBPACK_IMPORTED_MODULE_3__.isIOS && _browser_canIUse__WEBPACK_IMPORTED_MODULE_0__.BrowserFeatures.pointerEvents)) {
      this.hide();
      return;
    }

    if (this.delegate.layout) {
      this.delegate.layout();
    }

    this.doLayout();
  }

  doLayout() {
    // Check that we still have a delegate - this.delegate.layout may have hidden
    if (!this.isVisible()) {
      return;
    } // Get anchor


    const anchor = this.delegate.getAnchor(); // Compute around

    let around; // Get the element's position and size (to anchor the view)

    if (_browser_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement(anchor)) {
      const elementPosition = _browser_dom__WEBPACK_IMPORTED_MODULE_1__.getDomNodePagePosition(anchor); // In areas where zoom is applied to the element or its ancestors, we need to adjust the size of the element
      // e.g. The title bar has counter zoom behavior meaning it applies the inverse of zoom level.
      // Window Zoom Level: 1.5, Title Bar Zoom: 1/1.5, Size Multiplier: 1.5

      const zoom = _browser_dom__WEBPACK_IMPORTED_MODULE_1__.getDomNodeZoomLevel(anchor);
      around = {
        top: elementPosition.top * zoom,
        left: elementPosition.left * zoom,
        width: elementPosition.width * zoom,
        height: elementPosition.height * zoom
      };
    } else {
      around = {
        top: anchor.y,
        left: anchor.x,
        width: anchor.width || 1,
        height: anchor.height || 2
      };
    }

    const viewSizeWidth = _browser_dom__WEBPACK_IMPORTED_MODULE_1__.getTotalWidth(this.view);
    const viewSizeHeight = _browser_dom__WEBPACK_IMPORTED_MODULE_1__.getTotalHeight(this.view);
    const anchorPosition = this.delegate.anchorPosition || AnchorPosition.BELOW;
    const anchorAlignment = this.delegate.anchorAlignment || AnchorAlignment.LEFT;
    const anchorAxisAlignment = this.delegate.anchorAxisAlignment || AnchorAxisAlignment.VERTICAL;
    let top;
    let left;

    if (anchorAxisAlignment === AnchorAxisAlignment.VERTICAL) {
      const verticalAnchor = {
        offset: around.top - window.pageYOffset,
        size: around.height,
        position: anchorPosition === AnchorPosition.BELOW ? LayoutAnchorPosition.Before : LayoutAnchorPosition.After
      };
      const horizontalAnchor = {
        offset: around.left,
        size: around.width,
        position: anchorAlignment === AnchorAlignment.LEFT ? LayoutAnchorPosition.Before : LayoutAnchorPosition.After,
        mode: LayoutAnchorMode.ALIGN
      };
      top = layout(window.innerHeight, viewSizeHeight, verticalAnchor) + window.pageYOffset; // if view intersects vertically with anchor,  we must avoid the anchor

      if (_common_range__WEBPACK_IMPORTED_MODULE_4__.Range.intersects({
        start: top,
        end: top + viewSizeHeight
      }, {
        start: verticalAnchor.offset,
        end: verticalAnchor.offset + verticalAnchor.size
      })) {
        horizontalAnchor.mode = LayoutAnchorMode.AVOID;
      }

      left = layout(window.innerWidth, viewSizeWidth, horizontalAnchor);
    } else {
      const horizontalAnchor = {
        offset: around.left,
        size: around.width,
        position: anchorAlignment === AnchorAlignment.LEFT ? LayoutAnchorPosition.Before : LayoutAnchorPosition.After
      };
      const verticalAnchor = {
        offset: around.top,
        size: around.height,
        position: anchorPosition === AnchorPosition.BELOW ? LayoutAnchorPosition.Before : LayoutAnchorPosition.After,
        mode: LayoutAnchorMode.ALIGN
      };
      left = layout(window.innerWidth, viewSizeWidth, horizontalAnchor); // if view intersects horizontally with anchor, we must avoid the anchor

      if (_common_range__WEBPACK_IMPORTED_MODULE_4__.Range.intersects({
        start: left,
        end: left + viewSizeWidth
      }, {
        start: horizontalAnchor.offset,
        end: horizontalAnchor.offset + horizontalAnchor.size
      })) {
        verticalAnchor.mode = LayoutAnchorMode.AVOID;
      }

      top = layout(window.innerHeight, viewSizeHeight, verticalAnchor) + window.pageYOffset;
    }

    this.view.classList.remove('top', 'bottom', 'left', 'right');
    this.view.classList.add(anchorPosition === AnchorPosition.BELOW ? 'bottom' : 'top');
    this.view.classList.add(anchorAlignment === AnchorAlignment.LEFT ? 'left' : 'right');
    this.view.classList.toggle('fixed', this.useFixedPosition);
    const containerPosition = _browser_dom__WEBPACK_IMPORTED_MODULE_1__.getDomNodePagePosition(this.container);
    this.view.style.top = `${top - (this.useFixedPosition ? _browser_dom__WEBPACK_IMPORTED_MODULE_1__.getDomNodePagePosition(this.view).top : containerPosition.top)}px`;
    this.view.style.left = `${left - (this.useFixedPosition ? _browser_dom__WEBPACK_IMPORTED_MODULE_1__.getDomNodePagePosition(this.view).left : containerPosition.left)}px`;
    this.view.style.width = 'initial';
  }

  hide(data) {
    const delegate = this.delegate;
    this.delegate = null;

    if (delegate?.onHide) {
      delegate.onHide(data);
    }

    this.toDisposeOnClean.dispose();
    _browser_dom__WEBPACK_IMPORTED_MODULE_1__.hide(this.view);
  }

  isVisible() {
    return !!this.delegate;
  }

  onDOMEvent(e, onCapture) {
    if (this.delegate) {
      if (this.delegate.onDOMEvent) {
        this.delegate.onDOMEvent(e, document.activeElement);
      } else if (onCapture && !_browser_dom__WEBPACK_IMPORTED_MODULE_1__.isAncestor(e.target, this.container)) {
        this.hide();
      }
    }
  }

  dispose() {
    this.hide();
    super.dispose();
  }

}
const SHADOW_ROOT_CSS =
/* css */
`
	:host {
		all: initial; /* 1st rule so subsequent properties are reset. */
	}

	@font-face {
		font-family: "codicon";
		font-display: block;
		src: url("./codicon.ttf?5d4d76ab2ce5108968ad644d591a16a6") format("truetype");
	}

	.codicon[class*='codicon-'] {
		font: normal normal normal 16px/1 codicon;
		display: inline-block;
		text-decoration: none;
		text-rendering: auto;
		text-align: center;
		-webkit-font-smoothing: antialiased;
		-moz-osx-font-smoothing: grayscale;
		user-select: none;
		-webkit-user-select: none;
		-ms-user-select: none;
	}

	:host {
		font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "HelveticaNeue-Light", system-ui, "Ubuntu", "Droid Sans", sans-serif;
	}

	:host-context(.mac) { font-family: -apple-system, BlinkMacSystemFont, sans-serif; }
	:host-context(.mac:lang(zh-Hans)) { font-family: -apple-system, BlinkMacSystemFont, "PingFang SC", "Hiragino Sans GB", sans-serif; }
	:host-context(.mac:lang(zh-Hant)) { font-family: -apple-system, BlinkMacSystemFont, "PingFang TC", sans-serif; }
	:host-context(.mac:lang(ja)) { font-family: -apple-system, BlinkMacSystemFont, "Hiragino Kaku Gothic Pro", sans-serif; }
	:host-context(.mac:lang(ko)) { font-family: -apple-system, BlinkMacSystemFont, "Nanum Gothic", "Apple SD Gothic Neo", "AppleGothic", sans-serif; }

	:host-context(.windows) { font-family: "Segoe WPC", "Segoe UI", sans-serif; }
	:host-context(.windows:lang(zh-Hans)) { font-family: "Segoe WPC", "Segoe UI", "Microsoft YaHei", sans-serif; }
	:host-context(.windows:lang(zh-Hant)) { font-family: "Segoe WPC", "Segoe UI", "Microsoft Jhenghei", sans-serif; }
	:host-context(.windows:lang(ja)) { font-family: "Segoe WPC", "Segoe UI", "Yu Gothic UI", "Meiryo UI", sans-serif; }
	:host-context(.windows:lang(ko)) { font-family: "Segoe WPC", "Segoe UI", "Malgun Gothic", "Dotom", sans-serif; }

	:host-context(.linux) { font-family: system-ui, "Ubuntu", "Droid Sans", sans-serif; }
	:host-context(.linux:lang(zh-Hans)) { font-family: system-ui, "Ubuntu", "Droid Sans", "Source Han Sans SC", "Source Han Sans CN", "Source Han Sans", sans-serif; }
	:host-context(.linux:lang(zh-Hant)) { font-family: system-ui, "Ubuntu", "Droid Sans", "Source Han Sans TC", "Source Han Sans TW", "Source Han Sans", sans-serif; }
	:host-context(.linux:lang(ja)) { font-family: system-ui, "Ubuntu", "Droid Sans", "Source Han Sans J", "Source Han Sans JP", "Source Han Sans", sans-serif; }
	:host-context(.linux:lang(ko)) { font-family: system-ui, "Ubuntu", "Droid Sans", "Source Han Sans K", "Source Han Sans JR", "Source Han Sans", "UnDotum", "FBaekmuk Gulim", sans-serif; }
`;

/***/ }),
/* 136 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Range": () => (/* binding */ Range)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
let Range;

(function (_Range) {
  function intersect(one, other) {
    if (one.start >= other.end || other.start >= one.end) {
      return {
        start: 0,
        end: 0
      };
    }

    const start = Math.max(one.start, other.start);
    const end = Math.min(one.end, other.end);

    if (end - start <= 0) {
      return {
        start: 0,
        end: 0
      };
    }

    return {
      start,
      end
    };
  }

  _Range.intersect = intersect;

  function isEmpty(range) {
    return range.end - range.start <= 0;
  }

  _Range.isEmpty = isEmpty;

  function intersects(one, other) {
    return !isEmpty(intersect(one, other));
  }

  _Range.intersects = intersects;

  function relativeComplement(one, other) {
    const result = [];
    const first = {
      start: one.start,
      end: Math.min(other.start, one.end)
    };
    const second = {
      start: Math.max(other.end, one.start),
      end: one.end
    };

    if (!isEmpty(first)) {
      result.push(first);
    }

    if (!isEmpty(second)) {
      result.push(second);
    }

    return result;
  }

  _Range.relativeComplement = relativeComplement;
})(Range || (Range = {}));

/***/ }),
/* 137 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),
/* 138 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isInputElement": () => (/* binding */ isInputElement),
/* harmony export */   "isMonacoEditor": () => (/* binding */ isMonacoEditor),
/* harmony export */   "isButton": () => (/* binding */ isButton),
/* harmony export */   "TypeNavigationMode": () => (/* binding */ TypeNavigationMode),
/* harmony export */   "DefaultKeyboardNavigationDelegate": () => (/* binding */ DefaultKeyboardNavigationDelegate),
/* harmony export */   "isSelectionSingleChangeEvent": () => (/* binding */ isSelectionSingleChangeEvent),
/* harmony export */   "isSelectionRangeChangeEvent": () => (/* binding */ isSelectionRangeChangeEvent),
/* harmony export */   "MouseController": () => (/* binding */ MouseController),
/* harmony export */   "DefaultStyleController": () => (/* binding */ DefaultStyleController),
/* harmony export */   "List": () => (/* binding */ List)
/* harmony export */ });
/* harmony import */ var _browser_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(61);
/* harmony import */ var _browser_event__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(85);
/* harmony import */ var _browser_keyboardEvent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(63);
/* harmony import */ var _browser_touch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(86);
/* harmony import */ var _browser_ui_aria_aria__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(139);
/* harmony import */ var _browser_ui_list_splice__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(141);
/* harmony import */ var _common_arrays__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(87);
/* harmony import */ var _common_async__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(68);
/* harmony import */ var _common_color__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(91);
/* harmony import */ var _common_decorators__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(88);
/* harmony import */ var _common_event__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(51);
/* harmony import */ var _common_filters__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(122);
/* harmony import */ var _common_keyCodes__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(64);
/* harmony import */ var _common_lifecycle__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(54);
/* harmony import */ var _common_numbers__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(107);
/* harmony import */ var _common_objects__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(134);
/* harmony import */ var _common_platform__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(58);
/* harmony import */ var _common_types__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(79);
/* harmony import */ var _list_css__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(142);
/* harmony import */ var _list__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(143);
/* harmony import */ var _listView__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(144);
var _class, _class2, _class3;

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















class TraitRenderer {
  renderedElements = [];

  constructor(trait) {
    this.trait = trait;
  }

  get templateId() {
    return `template:${this.trait.name}`;
  }

  renderTemplate(container) {
    return container;
  }

  renderElement(element, index, templateData) {
    const renderedElementIndex = this.renderedElements.findIndex(el => el.templateData === templateData);

    if (renderedElementIndex >= 0) {
      const rendered = this.renderedElements[renderedElementIndex];
      this.trait.unrender(templateData);
      rendered.index = index;
    } else {
      const rendered = {
        index,
        templateData
      };
      this.renderedElements.push(rendered);
    }

    this.trait.renderIndex(index, templateData);
  }

  splice(start, deleteCount, insertCount) {
    const rendered = [];

    for (const renderedElement of this.renderedElements) {
      if (renderedElement.index < start) {
        rendered.push(renderedElement);
      } else if (renderedElement.index >= start + deleteCount) {
        rendered.push({
          index: renderedElement.index + insertCount - deleteCount,
          templateData: renderedElement.templateData
        });
      }
    }

    this.renderedElements = rendered;
  }

  renderIndexes(indexes) {
    for (const {
      index,
      templateData
    } of this.renderedElements) {
      if (indexes.indexOf(index) > -1) {
        this.trait.renderIndex(index, templateData);
      }
    }
  }

  disposeTemplate(templateData) {
    const index = this.renderedElements.findIndex(el => el.templateData === templateData);

    if (index < 0) {
      return;
    }

    this.renderedElements.splice(index, 1);
  }

}

let Trait = (_class = class Trait {
  length = 0;
  indexes = [];
  sortedIndexes = [];
  _onChange = new _common_event__WEBPACK_IMPORTED_MODULE_10__.Emitter();
  onChange = this._onChange.event;

  get name() {
    return this._trait;
  }

  get renderer() {
    return new TraitRenderer(this);
  }

  constructor(_trait) {
    this._trait = _trait;
  }

  splice(start, deleteCount, elements) {
    deleteCount = Math.max(0, Math.min(deleteCount, this.length - start));
    const diff = elements.length - deleteCount;
    const end = start + deleteCount;
    const sortedIndexes = [...this.sortedIndexes.filter(i => i < start), ...elements.map((hasTrait, i) => hasTrait ? i + start : -1).filter(i => i !== -1), ...this.sortedIndexes.filter(i => i >= end).map(i => i + diff)];
    const length = this.length + diff;

    if (this.sortedIndexes.length > 0 && sortedIndexes.length === 0 && length > 0) {
      const first = this.sortedIndexes.find(index => index >= start) ?? length - 1;
      sortedIndexes.push(Math.min(first, length - 1));
    }

    this.renderer.splice(start, deleteCount, elements.length);

    this._set(sortedIndexes, sortedIndexes);

    this.length = length;
  }

  renderIndex(index, container) {
    container.classList.toggle(this._trait, this.contains(index));
  }

  unrender(container) {
    container.classList.remove(this._trait);
  }
  /**
   * Sets the indexes which should have this trait.
   *
   * @param indexes Indexes which should have this trait.
   * @return The old indexes which had this trait.
   */


  set(indexes, browserEvent) {
    return this._set(indexes, [...indexes].sort(numericSort), browserEvent);
  }

  _set(indexes, sortedIndexes, browserEvent) {
    const result = this.indexes;
    const sortedResult = this.sortedIndexes;
    this.indexes = indexes;
    this.sortedIndexes = sortedIndexes;
    const toRender = disjunction(sortedResult, indexes);
    this.renderer.renderIndexes(toRender);

    this._onChange.fire({
      indexes,
      browserEvent
    });

    return result;
  }

  get() {
    return this.indexes;
  }

  contains(index) {
    return (0,_common_arrays__WEBPACK_IMPORTED_MODULE_6__.binarySearch)(this.sortedIndexes, index, numericSort) >= 0;
  }

  dispose() {
    (0,_common_lifecycle__WEBPACK_IMPORTED_MODULE_13__.dispose)(this._onChange);
  }

}, (_applyDecoratedDescriptor(_class.prototype, "renderer", [_common_decorators__WEBPACK_IMPORTED_MODULE_9__.memoize], Object.getOwnPropertyDescriptor(_class.prototype, "renderer"), _class.prototype)), _class);

class SelectionTrait extends Trait {
  constructor(setAriaSelected) {
    super('selected');
    this.setAriaSelected = setAriaSelected;
  }

  renderIndex(index, container) {
    super.renderIndex(index, container);

    if (this.setAriaSelected) {
      if (this.contains(index)) {
        container.setAttribute('aria-selected', 'true');
      } else {
        container.setAttribute('aria-selected', 'false');
      }
    }
  }

}
/**
 * The TraitSpliceable is used as a util class to be able
 * to preserve traits across splice calls, given an identity
 * provider.
 */


class TraitSpliceable {
  constructor(trait, view, identityProvider) {
    this.trait = trait;
    this.view = view;
    this.identityProvider = identityProvider;
  }

  splice(start, deleteCount, elements) {
    if (!this.identityProvider) {
      return this.trait.splice(start, deleteCount, elements.map(() => false));
    }

    const pastElementsWithTrait = this.trait.get().map(i => this.identityProvider.getId(this.view.element(i)).toString());
    const elementsWithTrait = elements.map(e => pastElementsWithTrait.indexOf(this.identityProvider.getId(e).toString()) > -1);
    this.trait.splice(start, deleteCount, elementsWithTrait);
  }

}

function isInputElement(e) {
  return e.tagName === 'INPUT' || e.tagName === 'TEXTAREA';
}
function isMonacoEditor(e) {
  if (e.classList.contains('monaco-editor')) {
    return true;
  }

  if (e.classList.contains('monaco-list')) {
    return false;
  }

  if (!e.parentElement) {
    return false;
  }

  return isMonacoEditor(e.parentElement);
}
function isButton(e) {
  if (e.tagName === 'A' && e.classList.contains('monaco-button') || e.tagName === 'DIV' && e.classList.contains('monaco-button-dropdown')) {
    return true;
  }

  if (e.classList.contains('monaco-list')) {
    return false;
  }

  if (!e.parentElement) {
    return false;
  }

  return isButton(e.parentElement);
}
let KeyboardController = (_class2 = class KeyboardController {
  disposables = new _common_lifecycle__WEBPACK_IMPORTED_MODULE_13__.DisposableStore();
  multipleSelectionDisposables = new _common_lifecycle__WEBPACK_IMPORTED_MODULE_13__.DisposableStore();

  get onKeyDown() {
    return this.disposables.add(_common_event__WEBPACK_IMPORTED_MODULE_10__.Event.chain(this.disposables.add(new _browser_event__WEBPACK_IMPORTED_MODULE_1__.DomEmitter(this.view.domNode, 'keydown')).event).filter(e => !isInputElement(e.target)).map(e => new _browser_keyboardEvent__WEBPACK_IMPORTED_MODULE_2__.StandardKeyboardEvent(e)));
  }

  constructor(list, view, options) {
    this.list = list;
    this.view = view;
    this.onKeyDown.filter(e => e.keyCode === _common_keyCodes__WEBPACK_IMPORTED_MODULE_12__.KeyCode.Enter).on(this.onEnter, this, this.disposables);
    this.onKeyDown.filter(e => e.keyCode === _common_keyCodes__WEBPACK_IMPORTED_MODULE_12__.KeyCode.UpArrow).on(this.onUpArrow, this, this.disposables);
    this.onKeyDown.filter(e => e.keyCode === _common_keyCodes__WEBPACK_IMPORTED_MODULE_12__.KeyCode.DownArrow).on(this.onDownArrow, this, this.disposables);
    this.onKeyDown.filter(e => e.keyCode === _common_keyCodes__WEBPACK_IMPORTED_MODULE_12__.KeyCode.PageUp).on(this.onPageUpArrow, this, this.disposables);
    this.onKeyDown.filter(e => e.keyCode === _common_keyCodes__WEBPACK_IMPORTED_MODULE_12__.KeyCode.PageDown).on(this.onPageDownArrow, this, this.disposables);
    this.onKeyDown.filter(e => e.keyCode === _common_keyCodes__WEBPACK_IMPORTED_MODULE_12__.KeyCode.Escape).on(this.onEscape, this, this.disposables);

    if (options.multipleSelectionSupport !== false) {
      this.onKeyDown.filter(e => (_common_platform__WEBPACK_IMPORTED_MODULE_16__.isMacintosh ? e.metaKey : e.ctrlKey) && e.keyCode === _common_keyCodes__WEBPACK_IMPORTED_MODULE_12__.KeyCode.KeyA).on(this.onCtrlA, this, this.multipleSelectionDisposables);
    }
  }

  updateOptions(optionsUpdate) {
    if (optionsUpdate.multipleSelectionSupport !== undefined) {
      this.multipleSelectionDisposables.clear();

      if (optionsUpdate.multipleSelectionSupport) {
        this.onKeyDown.filter(e => (_common_platform__WEBPACK_IMPORTED_MODULE_16__.isMacintosh ? e.metaKey : e.ctrlKey) && e.keyCode === _common_keyCodes__WEBPACK_IMPORTED_MODULE_12__.KeyCode.KeyA).on(this.onCtrlA, this, this.multipleSelectionDisposables);
      }
    }
  }

  onEnter(e) {
    e.preventDefault();
    e.stopPropagation();
    this.list.setSelection(this.list.getFocus(), e.browserEvent);
  }

  onUpArrow(e) {
    e.preventDefault();
    e.stopPropagation();
    this.list.focusPrevious(1, false, e.browserEvent);
    const el = this.list.getFocus()[0];
    this.list.setAnchor(el);
    this.list.reveal(el);
    this.view.domNode.focus();
  }

  onDownArrow(e) {
    e.preventDefault();
    e.stopPropagation();
    this.list.focusNext(1, false, e.browserEvent);
    const el = this.list.getFocus()[0];
    this.list.setAnchor(el);
    this.list.reveal(el);
    this.view.domNode.focus();
  }

  onPageUpArrow(e) {
    e.preventDefault();
    e.stopPropagation();
    this.list.focusPreviousPage(e.browserEvent);
    const el = this.list.getFocus()[0];
    this.list.setAnchor(el);
    this.list.reveal(el);
    this.view.domNode.focus();
  }

  onPageDownArrow(e) {
    e.preventDefault();
    e.stopPropagation();
    this.list.focusNextPage(e.browserEvent);
    const el = this.list.getFocus()[0];
    this.list.setAnchor(el);
    this.list.reveal(el);
    this.view.domNode.focus();
  }

  onCtrlA(e) {
    e.preventDefault();
    e.stopPropagation();
    this.list.setSelection((0,_common_arrays__WEBPACK_IMPORTED_MODULE_6__.range)(this.list.length), e.browserEvent);
    this.list.setAnchor(undefined);
    this.view.domNode.focus();
  }

  onEscape(e) {
    if (this.list.getSelection().length) {
      e.preventDefault();
      e.stopPropagation();
      this.list.setSelection([], e.browserEvent);
      this.list.setAnchor(undefined);
      this.view.domNode.focus();
    }
  }

  dispose() {
    this.disposables.dispose();
    this.multipleSelectionDisposables.dispose();
  }

}, (_applyDecoratedDescriptor(_class2.prototype, "onKeyDown", [_common_decorators__WEBPACK_IMPORTED_MODULE_9__.memoize], Object.getOwnPropertyDescriptor(_class2.prototype, "onKeyDown"), _class2.prototype)), _class2);
let TypeNavigationMode;

(function (TypeNavigationMode) {
  TypeNavigationMode[TypeNavigationMode["Automatic"] = 0] = "Automatic";
  TypeNavigationMode[TypeNavigationMode["Trigger"] = 1] = "Trigger";
})(TypeNavigationMode || (TypeNavigationMode = {}));

var TypeNavigationControllerState;

(function (TypeNavigationControllerState) {
  TypeNavigationControllerState[TypeNavigationControllerState["Idle"] = 0] = "Idle";
  TypeNavigationControllerState[TypeNavigationControllerState["Typing"] = 1] = "Typing";
})(TypeNavigationControllerState || (TypeNavigationControllerState = {}));

const DefaultKeyboardNavigationDelegate = new class {
  mightProducePrintableCharacter(event) {
    if (event.ctrlKey || event.metaKey || event.altKey) {
      return false;
    }

    return event.keyCode >= _common_keyCodes__WEBPACK_IMPORTED_MODULE_12__.KeyCode.KeyA && event.keyCode <= _common_keyCodes__WEBPACK_IMPORTED_MODULE_12__.KeyCode.KeyZ || event.keyCode >= _common_keyCodes__WEBPACK_IMPORTED_MODULE_12__.KeyCode.Digit0 && event.keyCode <= _common_keyCodes__WEBPACK_IMPORTED_MODULE_12__.KeyCode.Digit9 || event.keyCode >= _common_keyCodes__WEBPACK_IMPORTED_MODULE_12__.KeyCode.Numpad0 && event.keyCode <= _common_keyCodes__WEBPACK_IMPORTED_MODULE_12__.KeyCode.Numpad9 || event.keyCode >= _common_keyCodes__WEBPACK_IMPORTED_MODULE_12__.KeyCode.Semicolon && event.keyCode <= _common_keyCodes__WEBPACK_IMPORTED_MODULE_12__.KeyCode.Quote;
  }

}();

class TypeNavigationController {
  enabled = false;
  state = TypeNavigationControllerState.Idle;
  mode = TypeNavigationMode.Automatic;
  triggered = false;
  previouslyFocused = -1;
  enabledDisposables = new _common_lifecycle__WEBPACK_IMPORTED_MODULE_13__.DisposableStore();
  disposables = new _common_lifecycle__WEBPACK_IMPORTED_MODULE_13__.DisposableStore();

  constructor(list, view, keyboardNavigationLabelProvider, keyboardNavigationEventFilter, delegate) {
    this.list = list;
    this.view = view;
    this.keyboardNavigationLabelProvider = keyboardNavigationLabelProvider;
    this.keyboardNavigationEventFilter = keyboardNavigationEventFilter;
    this.delegate = delegate;
    this.updateOptions(list.options);
  }

  updateOptions(options) {
    if (options.typeNavigationEnabled ?? true) {
      this.enable();
    } else {
      this.disable();
    }

    this.mode = options.typeNavigationMode ?? TypeNavigationMode.Automatic;
  }

  trigger() {
    this.triggered = !this.triggered;
  }

  enable() {
    if (this.enabled) {
      return;
    }

    let typing = false;
    const onChar = this.enabledDisposables.add(_common_event__WEBPACK_IMPORTED_MODULE_10__.Event.chain(this.enabledDisposables.add(new _browser_event__WEBPACK_IMPORTED_MODULE_1__.DomEmitter(this.view.domNode, 'keydown')).event)).filter(e => !isInputElement(e.target)).filter(() => this.mode === TypeNavigationMode.Automatic || this.triggered).map(event => new _browser_keyboardEvent__WEBPACK_IMPORTED_MODULE_2__.StandardKeyboardEvent(event)).filter(e => typing || this.keyboardNavigationEventFilter(e)).filter(e => this.delegate.mightProducePrintableCharacter(e)).forEach(e => _browser_dom__WEBPACK_IMPORTED_MODULE_0__.EventHelper.stop(e, true)).map(event => event.browserEvent.key).event;
    const onClear = _common_event__WEBPACK_IMPORTED_MODULE_10__.Event.debounce(onChar, () => null, 800, undefined, undefined, this.enabledDisposables);
    const onInput = _common_event__WEBPACK_IMPORTED_MODULE_10__.Event.reduce(_common_event__WEBPACK_IMPORTED_MODULE_10__.Event.any(onChar, onClear), (r, i) => i === null ? null : (r || '') + i, undefined, this.enabledDisposables);
    onInput(this.onInput, this, this.enabledDisposables);
    onClear(this.onClear, this, this.enabledDisposables);
    onChar(() => typing = true, undefined, this.enabledDisposables);
    onClear(() => typing = false, undefined, this.enabledDisposables);
    this.enabled = true;
    this.triggered = false;
  }

  disable() {
    if (!this.enabled) {
      return;
    }

    this.enabledDisposables.clear();
    this.enabled = false;
    this.triggered = false;
  }

  onClear() {
    const focus = this.list.getFocus();

    if (focus.length > 0 && focus[0] === this.previouslyFocused) {
      // List: re-announce element on typing end since typed keys will interrupt aria label of focused element
      // Do not announce if there was a focus change at the end to prevent duplication https://github.com/microsoft/vscode/issues/95961
      const ariaLabel = this.list.options.accessibilityProvider?.getAriaLabel(this.list.element(focus[0]));

      if (ariaLabel) {
        (0,_browser_ui_aria_aria__WEBPACK_IMPORTED_MODULE_4__.alert)(ariaLabel);
      }
    }

    this.previouslyFocused = -1;
  }

  onInput(word) {
    if (!word) {
      this.state = TypeNavigationControllerState.Idle;
      this.triggered = false;
      return;
    }

    const focus = this.list.getFocus();
    const start = focus.length > 0 ? focus[0] : 0;
    const delta = this.state === TypeNavigationControllerState.Idle ? 1 : 0;
    this.state = TypeNavigationControllerState.Typing;

    for (let i = 0; i < this.list.length; i++) {
      const index = (start + i + delta) % this.list.length;
      const label = this.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(this.view.element(index));
      const labelStr = label && label.toString();

      if (typeof labelStr === 'undefined' || (0,_common_filters__WEBPACK_IMPORTED_MODULE_11__.matchesPrefix)(word, labelStr)) {
        this.previouslyFocused = start;
        this.list.setFocus([index]);
        this.list.reveal(index);
        return;
      }
    }
  }

  dispose() {
    this.disable();
    this.enabledDisposables.dispose();
    this.disposables.dispose();
  }

}

class DOMFocusController {
  disposables = new _common_lifecycle__WEBPACK_IMPORTED_MODULE_13__.DisposableStore();

  constructor(list, view) {
    this.list = list;
    this.view = view;
    const onKeyDown = this.disposables.add(_common_event__WEBPACK_IMPORTED_MODULE_10__.Event.chain(this.disposables.add(new _browser_event__WEBPACK_IMPORTED_MODULE_1__.DomEmitter(view.domNode, 'keydown')).event)).filter(e => !isInputElement(e.target)).map(e => new _browser_keyboardEvent__WEBPACK_IMPORTED_MODULE_2__.StandardKeyboardEvent(e));
    onKeyDown.filter(e => e.keyCode === _common_keyCodes__WEBPACK_IMPORTED_MODULE_12__.KeyCode.Tab && !e.ctrlKey && !e.metaKey && !e.shiftKey && !e.altKey).on(this.onTab, this, this.disposables);
  }

  onTab(e) {
    if (e.target !== this.view.domNode) {
      return;
    }

    const focus = this.list.getFocus();

    if (focus.length === 0) {
      return;
    }

    const focusedDomElement = this.view.domElement(focus[0]);

    if (!focusedDomElement) {
      return;
    }

    const tabIndexElement = focusedDomElement.querySelector('[tabIndex]');

    if (!tabIndexElement || !(tabIndexElement instanceof HTMLElement) || tabIndexElement.tabIndex === -1) {
      return;
    }

    const style = window.getComputedStyle(tabIndexElement);

    if (style.visibility === 'hidden' || style.display === 'none') {
      return;
    }

    e.preventDefault();
    e.stopPropagation();
    tabIndexElement.focus();
  }

  dispose() {
    this.disposables.dispose();
  }

}

function isSelectionSingleChangeEvent(event) {
  return _common_platform__WEBPACK_IMPORTED_MODULE_16__.isMacintosh ? event.browserEvent.metaKey : event.browserEvent.ctrlKey;
}
function isSelectionRangeChangeEvent(event) {
  return event.browserEvent.shiftKey;
}

function isMouseRightClick(event) {
  return event instanceof MouseEvent && event.button === 2;
}

const DefaultMultipleSelectionController = {
  isSelectionSingleChangeEvent,
  isSelectionRangeChangeEvent
};
class MouseController {
  disposables = new _common_lifecycle__WEBPACK_IMPORTED_MODULE_13__.DisposableStore();
  _onPointer = new _common_event__WEBPACK_IMPORTED_MODULE_10__.Emitter();
  onPointer = this._onPointer.event;

  constructor(list) {
    this.list = list;

    if (list.options.multipleSelectionSupport !== false) {
      this.multipleSelectionController = this.list.options.multipleSelectionController || DefaultMultipleSelectionController;
    }

    this.mouseSupport = typeof list.options.mouseSupport === 'undefined' || !!list.options.mouseSupport;

    if (this.mouseSupport) {
      list.onMouseDown(this.onMouseDown, this, this.disposables);
      list.onContextMenu(this.onContextMenu, this, this.disposables);
      list.onMouseDblClick(this.onDoubleClick, this, this.disposables);
      list.onTouchStart(this.onMouseDown, this, this.disposables);
      this.disposables.add(_browser_touch__WEBPACK_IMPORTED_MODULE_3__.Gesture.addTarget(list.getHTMLElement()));
    }

    _common_event__WEBPACK_IMPORTED_MODULE_10__.Event.any(list.onMouseClick, list.onMouseMiddleClick, list.onTap)(this.onViewPointer, this, this.disposables);
  }

  updateOptions(optionsUpdate) {
    if (optionsUpdate.multipleSelectionSupport !== undefined) {
      this.multipleSelectionController = undefined;

      if (optionsUpdate.multipleSelectionSupport) {
        this.multipleSelectionController = this.list.options.multipleSelectionController || DefaultMultipleSelectionController;
      }
    }
  }

  isSelectionSingleChangeEvent(event) {
    if (!this.multipleSelectionController) {
      return false;
    }

    return this.multipleSelectionController.isSelectionSingleChangeEvent(event);
  }

  isSelectionRangeChangeEvent(event) {
    if (!this.multipleSelectionController) {
      return false;
    }

    return this.multipleSelectionController.isSelectionRangeChangeEvent(event);
  }

  isSelectionChangeEvent(event) {
    return this.isSelectionSingleChangeEvent(event) || this.isSelectionRangeChangeEvent(event);
  }

  onMouseDown(e) {
    if (isMonacoEditor(e.browserEvent.target)) {
      return;
    }

    if (document.activeElement !== e.browserEvent.target) {
      this.list.domFocus();
    }
  }

  onContextMenu(e) {
    if (isMonacoEditor(e.browserEvent.target)) {
      return;
    }

    const focus = typeof e.index === 'undefined' ? [] : [e.index];
    this.list.setFocus(focus, e.browserEvent);
  }

  onViewPointer(e) {
    if (!this.mouseSupport) {
      return;
    }

    if (isInputElement(e.browserEvent.target) || isMonacoEditor(e.browserEvent.target)) {
      return;
    }

    const focus = e.index;

    if (typeof focus === 'undefined') {
      this.list.setFocus([], e.browserEvent);
      this.list.setSelection([], e.browserEvent);
      this.list.setAnchor(undefined);
      return;
    }

    if (this.isSelectionRangeChangeEvent(e)) {
      return this.changeSelection(e);
    }

    if (this.isSelectionChangeEvent(e)) {
      return this.changeSelection(e);
    }

    this.list.setFocus([focus], e.browserEvent);
    this.list.setAnchor(focus);

    if (!isMouseRightClick(e.browserEvent)) {
      this.list.setSelection([focus], e.browserEvent);
    }

    this._onPointer.fire(e);
  }

  onDoubleClick(e) {
    if (isInputElement(e.browserEvent.target) || isMonacoEditor(e.browserEvent.target)) {
      return;
    }

    if (this.isSelectionChangeEvent(e)) {
      return;
    }

    const focus = this.list.getFocus();
    this.list.setSelection(focus, e.browserEvent);
  }

  changeSelection(e) {
    const focus = e.index;
    let anchor = this.list.getAnchor();

    if (this.isSelectionRangeChangeEvent(e)) {
      if (typeof anchor === 'undefined') {
        const currentFocus = this.list.getFocus()[0];
        anchor = currentFocus ?? focus;
        this.list.setAnchor(anchor);
      }

      const min = Math.min(anchor, focus);
      const max = Math.max(anchor, focus);
      const rangeSelection = (0,_common_arrays__WEBPACK_IMPORTED_MODULE_6__.range)(min, max + 1);
      const selection = this.list.getSelection();
      const contiguousRange = getContiguousRangeContaining(disjunction(selection, [anchor]), anchor);

      if (contiguousRange.length === 0) {
        return;
      }

      const newSelection = disjunction(rangeSelection, relativeComplement(selection, contiguousRange));
      this.list.setSelection(newSelection, e.browserEvent);
      this.list.setFocus([focus], e.browserEvent);
    } else if (this.isSelectionSingleChangeEvent(e)) {
      const selection = this.list.getSelection();
      const newSelection = selection.filter(i => i !== focus);
      this.list.setFocus([focus]);
      this.list.setAnchor(focus);

      if (selection.length === newSelection.length) {
        this.list.setSelection([...newSelection, focus], e.browserEvent);
      } else {
        this.list.setSelection(newSelection, e.browserEvent);
      }
    }
  }

  dispose() {
    this.disposables.dispose();
  }

}
class DefaultStyleController {
  constructor(styleElement, selectorSuffix) {
    this.styleElement = styleElement;
    this.selectorSuffix = selectorSuffix;
  }

  style(styles) {
    const suffix = this.selectorSuffix && `.${this.selectorSuffix}`;
    const content = [];

    if (styles.listBackground) {
      if (styles.listBackground.isOpaque()) {
        content.push(`.monaco-list${suffix} .monaco-list-rows { background: ${styles.listBackground}; }`);
      } else if (!_common_platform__WEBPACK_IMPORTED_MODULE_16__.isMacintosh) {
        // subpixel AA doesn't exist in macOS
        console.warn(`List with id '${this.selectorSuffix}' was styled with a non-opaque background color. This will break sub-pixel antialiasing.`);
      }
    }

    if (styles.listFocusBackground) {
      content.push(`.monaco-list${suffix}:focus .monaco-list-row.focused { background-color: ${styles.listFocusBackground}; }`);
      content.push(`.monaco-list${suffix}:focus .monaco-list-row.focused:hover { background-color: ${styles.listFocusBackground}; }`); // overwrite :hover style in this case!
    }

    if (styles.listFocusForeground) {
      content.push(`.monaco-list${suffix}:focus .monaco-list-row.focused { color: ${styles.listFocusForeground}; }`);
    }

    if (styles.listActiveSelectionBackground) {
      content.push(`.monaco-list${suffix}:focus .monaco-list-row.selected { background-color: ${styles.listActiveSelectionBackground}; }`);
      content.push(`.monaco-list${suffix}:focus .monaco-list-row.selected:hover { background-color: ${styles.listActiveSelectionBackground}; }`); // overwrite :hover style in this case!
    }

    if (styles.listActiveSelectionForeground) {
      content.push(`.monaco-list${suffix}:focus .monaco-list-row.selected { color: ${styles.listActiveSelectionForeground}; }`);
    }

    if (styles.listActiveSelectionIconForeground) {
      content.push(`.monaco-list${suffix}:focus .monaco-list-row.selected .codicon { color: ${styles.listActiveSelectionIconForeground}; }`);
    }

    if (styles.listFocusAndSelectionOutline) {
      content.push(`.monaco-list${suffix}:focus .monaco-list-row.selected { outline-color: ${styles.listFocusAndSelectionOutline} !important; }`);
    }

    if (styles.listFocusAndSelectionBackground) {
      content.push(`
				.monaco-drag-image,
				.monaco-list${suffix}:focus .monaco-list-row.selected.focused { background-color: ${styles.listFocusAndSelectionBackground}; }
			`);
    }

    if (styles.listFocusAndSelectionForeground) {
      content.push(`
				.monaco-drag-image,
				.monaco-list${suffix}:focus .monaco-list-row.selected.focused { color: ${styles.listFocusAndSelectionForeground}; }
			`);
    }

    if (styles.listInactiveFocusForeground) {
      content.push(`.monaco-list${suffix} .monaco-list-row.focused { color:  ${styles.listInactiveFocusForeground}; }`);
      content.push(`.monaco-list${suffix} .monaco-list-row.focused:hover { color:  ${styles.listInactiveFocusForeground}; }`); // overwrite :hover style in this case!
    }

    if (styles.listInactiveSelectionIconForeground) {
      content.push(`.monaco-list${suffix} .monaco-list-row.focused .codicon { color:  ${styles.listInactiveSelectionIconForeground}; }`);
    }

    if (styles.listInactiveFocusBackground) {
      content.push(`.monaco-list${suffix} .monaco-list-row.focused { background-color:  ${styles.listInactiveFocusBackground}; }`);
      content.push(`.monaco-list${suffix} .monaco-list-row.focused:hover { background-color:  ${styles.listInactiveFocusBackground}; }`); // overwrite :hover style in this case!
    }

    if (styles.listInactiveSelectionBackground) {
      content.push(`.monaco-list${suffix} .monaco-list-row.selected { background-color:  ${styles.listInactiveSelectionBackground}; }`);
      content.push(`.monaco-list${suffix} .monaco-list-row.selected:hover { background-color:  ${styles.listInactiveSelectionBackground}; }`); // overwrite :hover style in this case!
    }

    if (styles.listInactiveSelectionForeground) {
      content.push(`.monaco-list${suffix} .monaco-list-row.selected { color: ${styles.listInactiveSelectionForeground}; }`);
    }

    if (styles.listHoverBackground) {
      content.push(`.monaco-list${suffix}:not(.drop-target) .monaco-list-row:hover:not(.selected):not(.focused) { background-color: ${styles.listHoverBackground}; }`);
    }

    if (styles.listHoverForeground) {
      content.push(`.monaco-list${suffix} .monaco-list-row:hover:not(.selected):not(.focused) { color:  ${styles.listHoverForeground}; }`);
    }

    if (styles.listSelectionOutline) {
      content.push(`.monaco-list${suffix} .monaco-list-row.selected { outline: 1px dotted ${styles.listSelectionOutline}; outline-offset: -1px; }`);
    }

    if (styles.listFocusOutline) {
      content.push(`
				.monaco-drag-image,
				.monaco-list${suffix}:focus .monaco-list-row.focused { outline: 1px solid ${styles.listFocusOutline}; outline-offset: -1px; }
				.monaco-workbench.context-menu-visible .monaco-list${suffix}.last-focused .monaco-list-row.focused { outline: 1px solid ${styles.listFocusOutline}; outline-offset: -1px; }
			`);
    }

    if (styles.listInactiveFocusOutline) {
      content.push(`.monaco-list${suffix} .monaco-list-row.focused { outline: 1px dotted ${styles.listInactiveFocusOutline}; outline-offset: -1px; }`);
    }

    if (styles.listHoverOutline) {
      content.push(`.monaco-list${suffix} .monaco-list-row:hover { outline: 1px dashed ${styles.listHoverOutline}; outline-offset: -1px; }`);
    }

    if (styles.listDropBackground) {
      content.push(`
				.monaco-list${suffix}.drop-target,
				.monaco-list${suffix} .monaco-list-rows.drop-target,
				.monaco-list${suffix} .monaco-list-row.drop-target { background-color: ${styles.listDropBackground} !important; color: inherit !important; }
			`);
    }

    if (styles.tableColumnsBorder) {
      content.push(`
				.monaco-table:hover > .monaco-split-view2,
				.monaco-table:hover > .monaco-split-view2 .monaco-sash.vertical::before {
					border-color: ${styles.tableColumnsBorder};
			}`);
    }

    if (styles.tableOddRowsBackgroundColor) {
      content.push(`
				.monaco-table .monaco-list-row[data-parity=odd]:not(.focused):not(.selected):not(:hover) .monaco-table-tr,
				.monaco-table .monaco-list:not(:focus) .monaco-list-row[data-parity=odd].focused:not(.selected):not(:hover) .monaco-table-tr,
				.monaco-table .monaco-list:not(.focused) .monaco-list-row[data-parity=odd].focused:not(.selected):not(:hover) .monaco-table-tr {
					background-color: ${styles.tableOddRowsBackgroundColor};
				}
			`);
    }

    this.styleElement.textContent = content.join('\n');
  }

}
const defaultStyles = {
  listFocusBackground: _common_color__WEBPACK_IMPORTED_MODULE_8__.Color.fromHex('#7FB0D0'),
  listActiveSelectionBackground: _common_color__WEBPACK_IMPORTED_MODULE_8__.Color.fromHex('#0E639C'),
  listActiveSelectionForeground: _common_color__WEBPACK_IMPORTED_MODULE_8__.Color.fromHex('#FFFFFF'),
  listActiveSelectionIconForeground: _common_color__WEBPACK_IMPORTED_MODULE_8__.Color.fromHex('#FFFFFF'),
  listFocusAndSelectionOutline: _common_color__WEBPACK_IMPORTED_MODULE_8__.Color.fromHex('#90C2F9'),
  listFocusAndSelectionBackground: _common_color__WEBPACK_IMPORTED_MODULE_8__.Color.fromHex('#094771'),
  listFocusAndSelectionForeground: _common_color__WEBPACK_IMPORTED_MODULE_8__.Color.fromHex('#FFFFFF'),
  listInactiveSelectionBackground: _common_color__WEBPACK_IMPORTED_MODULE_8__.Color.fromHex('#3F3F46'),
  listInactiveSelectionIconForeground: _common_color__WEBPACK_IMPORTED_MODULE_8__.Color.fromHex('#FFFFFF'),
  listHoverBackground: _common_color__WEBPACK_IMPORTED_MODULE_8__.Color.fromHex('#2A2D2E'),
  listDropBackground: _common_color__WEBPACK_IMPORTED_MODULE_8__.Color.fromHex('#383B3D'),
  treeIndentGuidesStroke: _common_color__WEBPACK_IMPORTED_MODULE_8__.Color.fromHex('#a9a9a9'),
  tableColumnsBorder: _common_color__WEBPACK_IMPORTED_MODULE_8__.Color.fromHex('#cccccc').transparent(0.2),
  tableOddRowsBackgroundColor: _common_color__WEBPACK_IMPORTED_MODULE_8__.Color.fromHex('#cccccc').transparent(0.04)
};
const DefaultOptions = {
  keyboardSupport: true,
  mouseSupport: true,
  multipleSelectionSupport: true,
  dnd: {
    getDragURI() {
      return null;
    },

    onDragStart() {},

    onDragOver() {
      return false;
    },

    drop() {}

  }
}; // TODO@Joao: move these utils into a SortedArray class

function getContiguousRangeContaining(range, value) {
  const index = range.indexOf(value);

  if (index === -1) {
    return [];
  }

  const result = [];
  let i = index - 1;

  while (i >= 0 && range[i] === value - (index - i)) {
    result.push(range[i--]);
  }

  result.reverse();
  i = index;

  while (i < range.length && range[i] === value + (i - index)) {
    result.push(range[i++]);
  }

  return result;
}
/**
 * Given two sorted collections of numbers, returns the intersection
 * between them (OR).
 */


function disjunction(one, other) {
  const result = [];
  let i = 0,
      j = 0;

  while (i < one.length || j < other.length) {
    if (i >= one.length) {
      result.push(other[j++]);
    } else if (j >= other.length) {
      result.push(one[i++]);
    } else if (one[i] === other[j]) {
      result.push(one[i]);
      i++;
      j++;
      continue;
    } else if (one[i] < other[j]) {
      result.push(one[i++]);
    } else {
      result.push(other[j++]);
    }
  }

  return result;
}
/**
 * Given two sorted collections of numbers, returns the relative
 * complement between them (XOR).
 */


function relativeComplement(one, other) {
  const result = [];
  let i = 0,
      j = 0;

  while (i < one.length || j < other.length) {
    if (i >= one.length) {
      result.push(other[j++]);
    } else if (j >= other.length) {
      result.push(one[i++]);
    } else if (one[i] === other[j]) {
      i++;
      j++;
      continue;
    } else if (one[i] < other[j]) {
      result.push(one[i++]);
    } else {
      j++;
    }
  }

  return result;
}

const numericSort = (a, b) => a - b;

class PipelineRenderer {
  constructor(_templateId, renderers) {
    this._templateId = _templateId;
    this.renderers = renderers;
  }

  get templateId() {
    return this._templateId;
  }

  renderTemplate(container) {
    return this.renderers.map(r => r.renderTemplate(container));
  }

  renderElement(element, index, templateData, height) {
    let i = 0;

    for (const renderer of this.renderers) {
      renderer.renderElement(element, index, templateData[i++], height);
    }
  }

  disposeElement(element, index, templateData, height) {
    let i = 0;

    for (const renderer of this.renderers) {
      renderer.disposeElement?.(element, index, templateData[i], height);
      i += 1;
    }
  }

  disposeTemplate(templateData) {
    let i = 0;

    for (const renderer of this.renderers) {
      renderer.disposeTemplate(templateData[i++]);
    }
  }

}

class AccessibiltyRenderer {
  templateId = 'a18n';

  constructor(accessibilityProvider) {
    this.accessibilityProvider = accessibilityProvider;
  }

  renderTemplate(container) {
    return container;
  }

  renderElement(element, index, container) {
    const ariaLabel = this.accessibilityProvider.getAriaLabel(element);

    if (ariaLabel) {
      container.setAttribute('aria-label', ariaLabel);
    } else {
      container.removeAttribute('aria-label');
    }

    const ariaLevel = this.accessibilityProvider.getAriaLevel && this.accessibilityProvider.getAriaLevel(element);

    if (typeof ariaLevel === 'number') {
      container.setAttribute('aria-level', `${ariaLevel}`);
    } else {
      container.removeAttribute('aria-level');
    }
  }

  disposeTemplate(templateData) {// noop
  }

}

class ListViewDragAndDrop {
  constructor(list, dnd) {
    this.list = list;
    this.dnd = dnd;
  }

  getDragElements(element) {
    const selection = this.list.getSelectedElements();
    const elements = selection.indexOf(element) > -1 ? selection : [element];
    return elements;
  }

  getDragURI(element) {
    return this.dnd.getDragURI(element);
  }

  getDragLabel(elements, originalEvent) {
    if (this.dnd.getDragLabel) {
      return this.dnd.getDragLabel(elements, originalEvent);
    }

    return undefined;
  }

  onDragStart(data, originalEvent) {
    this.dnd.onDragStart?.(data, originalEvent);
  }

  onDragOver(data, targetElement, targetIndex, originalEvent) {
    return this.dnd.onDragOver(data, targetElement, targetIndex, originalEvent);
  }

  onDragLeave(data, targetElement, targetIndex, originalEvent) {
    this.dnd.onDragLeave?.(data, targetElement, targetIndex, originalEvent);
  }

  onDragEnd(originalEvent) {
    this.dnd.onDragEnd?.(originalEvent);
  }

  drop(data, targetElement, targetIndex, originalEvent) {
    this.dnd.drop(data, targetElement, targetIndex, originalEvent);
  }

}
/**
 * The {@link List} is a virtual scrolling widget, built on top of the {@link ListView}
 * widget.
 *
 * Features:
 * - Customizable keyboard and mouse support
 * - Element traits: focus, selection, achor
 * - Accessibility support
 * - Touch support
 * - Performant template-based rendering
 * - Horizontal scrolling
 * - Variable element height support
 * - Dynamic element height support
 * - Drag-and-drop support
 */


let List = (_class3 = class List {
  focus = new Trait('focused');
  anchor = new Trait('anchor');
  eventBufferer = new _common_event__WEBPACK_IMPORTED_MODULE_10__.EventBufferer();
  _ariaLabel = '';
  disposables = new _common_lifecycle__WEBPACK_IMPORTED_MODULE_13__.DisposableStore();

  get onDidChangeFocus() {
    return _common_event__WEBPACK_IMPORTED_MODULE_10__.Event.map(this.eventBufferer.wrapEvent(this.focus.onChange), e => this.toListEvent(e), this.disposables);
  }

  get onDidChangeSelection() {
    return _common_event__WEBPACK_IMPORTED_MODULE_10__.Event.map(this.eventBufferer.wrapEvent(this.selection.onChange), e => this.toListEvent(e), this.disposables);
  }

  get domId() {
    return this.view.domId;
  }

  get onDidScroll() {
    return this.view.onDidScroll;
  }

  get onMouseClick() {
    return this.view.onMouseClick;
  }

  get onMouseDblClick() {
    return this.view.onMouseDblClick;
  }

  get onMouseMiddleClick() {
    return this.view.onMouseMiddleClick;
  }

  get onPointer() {
    return this.mouseController.onPointer;
  }

  get onMouseUp() {
    return this.view.onMouseUp;
  }

  get onMouseDown() {
    return this.view.onMouseDown;
  }

  get onMouseOver() {
    return this.view.onMouseOver;
  }

  get onMouseMove() {
    return this.view.onMouseMove;
  }

  get onMouseOut() {
    return this.view.onMouseOut;
  }

  get onTouchStart() {
    return this.view.onTouchStart;
  }

  get onTap() {
    return this.view.onTap;
  }
  /**
   * Possible context menu trigger events:
   * - ContextMenu key
   * - Shift F10
   * - Ctrl Option Shift M (macOS with VoiceOver)
   * - Mouse right click
   */


  get onContextMenu() {
    let didJustPressContextMenuKey = false;
    const fromKeyDown = this.disposables.add(_common_event__WEBPACK_IMPORTED_MODULE_10__.Event.chain(this.disposables.add(new _browser_event__WEBPACK_IMPORTED_MODULE_1__.DomEmitter(this.view.domNode, 'keydown')).event)).map(e => new _browser_keyboardEvent__WEBPACK_IMPORTED_MODULE_2__.StandardKeyboardEvent(e)).filter(e => didJustPressContextMenuKey = e.keyCode === _common_keyCodes__WEBPACK_IMPORTED_MODULE_12__.KeyCode.ContextMenu || e.shiftKey && e.keyCode === _common_keyCodes__WEBPACK_IMPORTED_MODULE_12__.KeyCode.F10).map(e => _browser_dom__WEBPACK_IMPORTED_MODULE_0__.EventHelper.stop(e, true)).filter(() => false).event;
    const fromKeyUp = this.disposables.add(_common_event__WEBPACK_IMPORTED_MODULE_10__.Event.chain(this.disposables.add(new _browser_event__WEBPACK_IMPORTED_MODULE_1__.DomEmitter(this.view.domNode, 'keyup')).event)).forEach(() => didJustPressContextMenuKey = false).map(e => new _browser_keyboardEvent__WEBPACK_IMPORTED_MODULE_2__.StandardKeyboardEvent(e)).filter(e => e.keyCode === _common_keyCodes__WEBPACK_IMPORTED_MODULE_12__.KeyCode.ContextMenu || e.shiftKey && e.keyCode === _common_keyCodes__WEBPACK_IMPORTED_MODULE_12__.KeyCode.F10).map(e => _browser_dom__WEBPACK_IMPORTED_MODULE_0__.EventHelper.stop(e, true)).map(({
      browserEvent
    }) => {
      const focus = this.getFocus();
      const index = focus.length ? focus[0] : undefined;
      const element = typeof index !== 'undefined' ? this.view.element(index) : undefined;
      const anchor = typeof index !== 'undefined' ? this.view.domElement(index) : this.view.domNode;
      return {
        index,
        element,
        anchor,
        browserEvent
      };
    }).event;
    const fromMouse = this.disposables.add(_common_event__WEBPACK_IMPORTED_MODULE_10__.Event.chain(this.view.onContextMenu)).filter(_ => !didJustPressContextMenuKey).map(({
      element,
      index,
      browserEvent
    }) => ({
      element,
      index,
      anchor: {
        x: browserEvent.pageX + 1,
        y: browserEvent.pageY
      },
      browserEvent
    })).event;
    return _common_event__WEBPACK_IMPORTED_MODULE_10__.Event.any(fromKeyDown, fromKeyUp, fromMouse);
  }

  get onKeyDown() {
    return this.disposables.add(new _browser_event__WEBPACK_IMPORTED_MODULE_1__.DomEmitter(this.view.domNode, 'keydown')).event;
  }

  get onKeyUp() {
    return this.disposables.add(new _browser_event__WEBPACK_IMPORTED_MODULE_1__.DomEmitter(this.view.domNode, 'keyup')).event;
  }

  get onKeyPress() {
    return this.disposables.add(new _browser_event__WEBPACK_IMPORTED_MODULE_1__.DomEmitter(this.view.domNode, 'keypress')).event;
  }

  get onDidFocus() {
    return _common_event__WEBPACK_IMPORTED_MODULE_10__.Event.signal(this.disposables.add(new _browser_event__WEBPACK_IMPORTED_MODULE_1__.DomEmitter(this.view.domNode, 'focus', true)).event);
  }

  get onDidBlur() {
    return _common_event__WEBPACK_IMPORTED_MODULE_10__.Event.signal(this.disposables.add(new _browser_event__WEBPACK_IMPORTED_MODULE_1__.DomEmitter(this.view.domNode, 'blur', true)).event);
  }

  _onDidDispose = new _common_event__WEBPACK_IMPORTED_MODULE_10__.Emitter();
  onDidDispose = this._onDidDispose.event;

  constructor(user, container, virtualDelegate, renderers, _options = DefaultOptions) {
    this.user = user;
    this._options = _options;
    const role = this._options.accessibilityProvider && this._options.accessibilityProvider.getWidgetRole ? this._options.accessibilityProvider?.getWidgetRole() : 'list';
    this.selection = new SelectionTrait(role !== 'listbox');
    (0,_common_objects__WEBPACK_IMPORTED_MODULE_15__.mixin)(_options, defaultStyles, false);
    const baseRenderers = [this.focus.renderer, this.selection.renderer];
    this.accessibilityProvider = _options.accessibilityProvider;

    if (this.accessibilityProvider) {
      baseRenderers.push(new AccessibiltyRenderer(this.accessibilityProvider));
      this.accessibilityProvider.onDidChangeActiveDescendant?.(this.onDidChangeActiveDescendant, this, this.disposables);
    }

    renderers = renderers.map(r => new PipelineRenderer(r.templateId, [...baseRenderers, r]));
    const viewOptions = { ..._options,
      dnd: _options.dnd && new ListViewDragAndDrop(this, _options.dnd)
    };
    this.view = new _listView__WEBPACK_IMPORTED_MODULE_20__.ListView(container, virtualDelegate, renderers, viewOptions);
    this.view.domNode.setAttribute('role', role);

    if (_options.styleController) {
      this.styleController = _options.styleController(this.view.domId);
    } else {
      const styleElement = (0,_browser_dom__WEBPACK_IMPORTED_MODULE_0__.createStyleSheet)(this.view.domNode);
      this.styleController = new DefaultStyleController(styleElement, this.view.domId);
    }

    this.spliceable = new _browser_ui_list_splice__WEBPACK_IMPORTED_MODULE_5__.CombinedSpliceable([new TraitSpliceable(this.focus, this.view, _options.identityProvider), new TraitSpliceable(this.selection, this.view, _options.identityProvider), new TraitSpliceable(this.anchor, this.view, _options.identityProvider), this.view]);
    this.disposables.add(this.focus);
    this.disposables.add(this.selection);
    this.disposables.add(this.anchor);
    this.disposables.add(this.view);
    this.disposables.add(this._onDidDispose);
    this.disposables.add(new DOMFocusController(this, this.view));

    if (typeof _options.keyboardSupport !== 'boolean' || _options.keyboardSupport) {
      this.keyboardController = new KeyboardController(this, this.view, _options);
      this.disposables.add(this.keyboardController);
    }

    if (_options.keyboardNavigationLabelProvider) {
      const delegate = _options.keyboardNavigationDelegate || DefaultKeyboardNavigationDelegate;
      this.typeNavigationController = new TypeNavigationController(this, this.view, _options.keyboardNavigationLabelProvider, _options.keyboardNavigationEventFilter ?? (() => true), delegate);
      this.disposables.add(this.typeNavigationController);
    }

    this.mouseController = this.createMouseController(_options);
    this.disposables.add(this.mouseController);
    this.onDidChangeFocus(this._onFocusChange, this, this.disposables);
    this.onDidChangeSelection(this._onSelectionChange, this, this.disposables);

    if (this.accessibilityProvider) {
      this.ariaLabel = this.accessibilityProvider.getWidgetAriaLabel();
    }

    if (this._options.multipleSelectionSupport !== false) {
      this.view.domNode.setAttribute('aria-multiselectable', 'true');
    }
  }

  createMouseController(options) {
    return new MouseController(this);
  }

  updateOptions(optionsUpdate = {}) {
    this._options = { ...this._options,
      ...optionsUpdate
    };
    this.typeNavigationController?.updateOptions(this._options);

    if (this._options.multipleSelectionController !== undefined) {
      if (this._options.multipleSelectionSupport) {
        this.view.domNode.setAttribute('aria-multiselectable', 'true');
      } else {
        this.view.domNode.removeAttribute('aria-multiselectable');
      }
    }

    this.mouseController.updateOptions(optionsUpdate);
    this.keyboardController?.updateOptions(optionsUpdate);
    this.view.updateOptions(optionsUpdate);
  }

  get options() {
    return this._options;
  }

  splice(start, deleteCount, elements = []) {
    if (start < 0 || start > this.view.length) {
      throw new _list__WEBPACK_IMPORTED_MODULE_19__.ListError(this.user, `Invalid start index: ${start}`);
    }

    if (deleteCount < 0) {
      throw new _list__WEBPACK_IMPORTED_MODULE_19__.ListError(this.user, `Invalid delete count: ${deleteCount}`);
    }

    if (deleteCount === 0 && elements.length === 0) {
      return;
    }

    this.eventBufferer.bufferEvents(() => this.spliceable.splice(start, deleteCount, elements));
  }

  updateWidth(index) {
    this.view.updateWidth(index);
  }

  updateElementHeight(index, size) {
    this.view.updateElementHeight(index, size, null);
  }

  rerender() {
    this.view.rerender();
  }

  element(index) {
    return this.view.element(index);
  }

  indexOf(element) {
    return this.view.indexOf(element);
  }

  get length() {
    return this.view.length;
  }

  get contentHeight() {
    return this.view.contentHeight;
  }

  get onDidChangeContentHeight() {
    return this.view.onDidChangeContentHeight;
  }

  get scrollTop() {
    return this.view.getScrollTop();
  }

  set scrollTop(scrollTop) {
    this.view.setScrollTop(scrollTop);
  }

  get scrollLeft() {
    return this.view.getScrollLeft();
  }

  set scrollLeft(scrollLeft) {
    this.view.setScrollLeft(scrollLeft);
  }

  get scrollHeight() {
    return this.view.scrollHeight;
  }

  get renderHeight() {
    return this.view.renderHeight;
  }

  get firstVisibleIndex() {
    return this.view.firstVisibleIndex;
  }

  get lastVisibleIndex() {
    return this.view.lastVisibleIndex;
  }

  get ariaLabel() {
    return this._ariaLabel;
  }

  set ariaLabel(value) {
    this._ariaLabel = value;
    this.view.domNode.setAttribute('aria-label', value);
  }

  domFocus() {
    this.view.domNode.focus({
      preventScroll: true
    });
  }

  layout(height, width) {
    this.view.layout(height, width);
  }

  triggerTypeNavigation() {
    this.typeNavigationController?.trigger();
  }

  setSelection(indexes, browserEvent) {
    for (const index of indexes) {
      if (index < 0 || index >= this.length) {
        throw new _list__WEBPACK_IMPORTED_MODULE_19__.ListError(this.user, `Invalid index ${index}`);
      }
    }

    this.selection.set(indexes, browserEvent);
  }

  getSelection() {
    return this.selection.get();
  }

  getSelectedElements() {
    return this.getSelection().map(i => this.view.element(i));
  }

  setAnchor(index) {
    if (typeof index === 'undefined') {
      this.anchor.set([]);
      return;
    }

    if (index < 0 || index >= this.length) {
      throw new _list__WEBPACK_IMPORTED_MODULE_19__.ListError(this.user, `Invalid index ${index}`);
    }

    this.anchor.set([index]);
  }

  getAnchor() {
    return (0,_common_arrays__WEBPACK_IMPORTED_MODULE_6__.firstOrDefault)(this.anchor.get(), undefined);
  }

  getAnchorElement() {
    const anchor = this.getAnchor();
    return typeof anchor === 'undefined' ? undefined : this.element(anchor);
  }

  setFocus(indexes, browserEvent) {
    for (const index of indexes) {
      if (index < 0 || index >= this.length) {
        throw new _list__WEBPACK_IMPORTED_MODULE_19__.ListError(this.user, `Invalid index ${index}`);
      }
    }

    this.focus.set(indexes, browserEvent);
  }

  focusNext(n = 1, loop = false, browserEvent, filter) {
    if (this.length === 0) {
      return;
    }

    const focus = this.focus.get();
    const index = this.findNextIndex(focus.length > 0 ? focus[0] + n : 0, loop, filter);

    if (index > -1) {
      this.setFocus([index], browserEvent);
    }
  }

  focusPrevious(n = 1, loop = false, browserEvent, filter) {
    if (this.length === 0) {
      return;
    }

    const focus = this.focus.get();
    const index = this.findPreviousIndex(focus.length > 0 ? focus[0] - n : 0, loop, filter);

    if (index > -1) {
      this.setFocus([index], browserEvent);
    }
  }

  async focusNextPage(browserEvent, filter) {
    let lastPageIndex = this.view.indexAt(this.view.getScrollTop() + this.view.renderHeight);
    lastPageIndex = lastPageIndex === 0 ? 0 : lastPageIndex - 1;
    const currentlyFocusedElementIndex = this.getFocus()[0];

    if (currentlyFocusedElementIndex !== lastPageIndex && (currentlyFocusedElementIndex === undefined || lastPageIndex > currentlyFocusedElementIndex)) {
      const lastGoodPageIndex = this.findPreviousIndex(lastPageIndex, false, filter);

      if (lastGoodPageIndex > -1 && currentlyFocusedElementIndex !== lastGoodPageIndex) {
        this.setFocus([lastGoodPageIndex], browserEvent);
      } else {
        this.setFocus([lastPageIndex], browserEvent);
      }
    } else {
      const previousScrollTop = this.view.getScrollTop();
      let nextpageScrollTop = previousScrollTop + this.view.renderHeight;

      if (lastPageIndex > currentlyFocusedElementIndex) {
        // scroll last page element to the top only if the last page element is below the focused element
        nextpageScrollTop -= this.view.elementHeight(lastPageIndex);
      }

      this.view.setScrollTop(nextpageScrollTop);

      if (this.view.getScrollTop() !== previousScrollTop) {
        this.setFocus([]); // Let the scroll event listener run

        await (0,_common_async__WEBPACK_IMPORTED_MODULE_7__.timeout)(0);
        await this.focusNextPage(browserEvent, filter);
      }
    }
  }

  async focusPreviousPage(browserEvent, filter) {
    let firstPageIndex;
    const scrollTop = this.view.getScrollTop();

    if (scrollTop === 0) {
      firstPageIndex = this.view.indexAt(scrollTop);
    } else {
      firstPageIndex = this.view.indexAfter(scrollTop - 1);
    }

    const currentlyFocusedElementIndex = this.getFocus()[0];

    if (currentlyFocusedElementIndex !== firstPageIndex && (currentlyFocusedElementIndex === undefined || currentlyFocusedElementIndex >= firstPageIndex)) {
      const firstGoodPageIndex = this.findNextIndex(firstPageIndex, false, filter);

      if (firstGoodPageIndex > -1 && currentlyFocusedElementIndex !== firstGoodPageIndex) {
        this.setFocus([firstGoodPageIndex], browserEvent);
      } else {
        this.setFocus([firstPageIndex], browserEvent);
      }
    } else {
      const previousScrollTop = scrollTop;
      this.view.setScrollTop(scrollTop - this.view.renderHeight);

      if (this.view.getScrollTop() !== previousScrollTop) {
        this.setFocus([]); // Let the scroll event listener run

        await (0,_common_async__WEBPACK_IMPORTED_MODULE_7__.timeout)(0);
        await this.focusPreviousPage(browserEvent, filter);
      }
    }
  }

  focusLast(browserEvent, filter) {
    if (this.length === 0) {
      return;
    }

    const index = this.findPreviousIndex(this.length - 1, false, filter);

    if (index > -1) {
      this.setFocus([index], browserEvent);
    }
  }

  focusFirst(browserEvent, filter) {
    this.focusNth(0, browserEvent, filter);
  }

  focusNth(n, browserEvent, filter) {
    if (this.length === 0) {
      return;
    }

    const index = this.findNextIndex(n, false, filter);

    if (index > -1) {
      this.setFocus([index], browserEvent);
    }
  }

  findNextIndex(index, loop = false, filter) {
    for (let i = 0; i < this.length; i++) {
      if (index >= this.length && !loop) {
        return -1;
      }

      index = index % this.length;

      if (!filter || filter(this.element(index))) {
        return index;
      }

      index++;
    }

    return -1;
  }

  findPreviousIndex(index, loop = false, filter) {
    for (let i = 0; i < this.length; i++) {
      if (index < 0 && !loop) {
        return -1;
      }

      index = (this.length + index % this.length) % this.length;

      if (!filter || filter(this.element(index))) {
        return index;
      }

      index--;
    }

    return -1;
  }

  getFocus() {
    return this.focus.get();
  }

  getFocusedElements() {
    return this.getFocus().map(i => this.view.element(i));
  }

  reveal(index, relativeTop) {
    if (index < 0 || index >= this.length) {
      throw new _list__WEBPACK_IMPORTED_MODULE_19__.ListError(this.user, `Invalid index ${index}`);
    }

    const scrollTop = this.view.getScrollTop();
    const elementTop = this.view.elementTop(index);
    const elementHeight = this.view.elementHeight(index);

    if ((0,_common_types__WEBPACK_IMPORTED_MODULE_17__.isNumber)(relativeTop)) {
      // y = mx + b
      const m = elementHeight - this.view.renderHeight;
      this.view.setScrollTop(m * (0,_common_numbers__WEBPACK_IMPORTED_MODULE_14__.clamp)(relativeTop, 0, 1) + elementTop);
    } else {
      const viewItemBottom = elementTop + elementHeight;
      const scrollBottom = scrollTop + this.view.renderHeight;

      if (elementTop < scrollTop && viewItemBottom >= scrollBottom) {// The element is already overflowing the viewport, no-op
      } else if (elementTop < scrollTop || viewItemBottom >= scrollBottom && elementHeight >= this.view.renderHeight) {
        this.view.setScrollTop(elementTop);
      } else if (viewItemBottom >= scrollBottom) {
        this.view.setScrollTop(viewItemBottom - this.view.renderHeight);
      }
    }
  }
  /**
   * Returns the relative position of an element rendered in the list.
   * Returns `null` if the element isn't *entirely* in the visible viewport.
   */


  getRelativeTop(index) {
    if (index < 0 || index >= this.length) {
      throw new _list__WEBPACK_IMPORTED_MODULE_19__.ListError(this.user, `Invalid index ${index}`);
    }

    const scrollTop = this.view.getScrollTop();
    const elementTop = this.view.elementTop(index);
    const elementHeight = this.view.elementHeight(index);

    if (elementTop < scrollTop || elementTop + elementHeight > scrollTop + this.view.renderHeight) {
      return null;
    } // y = mx + b


    const m = elementHeight - this.view.renderHeight;
    return Math.abs((scrollTop - elementTop) / m);
  }

  isDOMFocused() {
    return this.view.domNode === document.activeElement;
  }

  getHTMLElement() {
    return this.view.domNode;
  }

  getElementID(index) {
    return this.view.getElementDomId(index);
  }

  style(styles) {
    this.styleController.style(styles);
  }

  toListEvent({
    indexes,
    browserEvent
  }) {
    return {
      indexes,
      elements: indexes.map(i => this.view.element(i)),
      browserEvent
    };
  }

  _onFocusChange() {
    const focus = this.focus.get();
    this.view.domNode.classList.toggle('element-focused', focus.length > 0);
    this.onDidChangeActiveDescendant();
  }

  onDidChangeActiveDescendant() {
    const focus = this.focus.get();

    if (focus.length > 0) {
      let id;

      if (this.accessibilityProvider?.getActiveDescendantId) {
        id = this.accessibilityProvider.getActiveDescendantId(this.view.element(focus[0]));
      }

      this.view.domNode.setAttribute('aria-activedescendant', id || this.view.getElementDomId(focus[0]));
    } else {
      this.view.domNode.removeAttribute('aria-activedescendant');
    }
  }

  _onSelectionChange() {
    const selection = this.selection.get();
    this.view.domNode.classList.toggle('selection-none', selection.length === 0);
    this.view.domNode.classList.toggle('selection-single', selection.length === 1);
    this.view.domNode.classList.toggle('selection-multiple', selection.length > 1);
  }

  dispose() {
    this._onDidDispose.fire();

    this.disposables.dispose();

    this._onDidDispose.dispose();
  }

}, (_applyDecoratedDescriptor(_class3.prototype, "onDidChangeFocus", [_common_decorators__WEBPACK_IMPORTED_MODULE_9__.memoize], Object.getOwnPropertyDescriptor(_class3.prototype, "onDidChangeFocus"), _class3.prototype), _applyDecoratedDescriptor(_class3.prototype, "onDidChangeSelection", [_common_decorators__WEBPACK_IMPORTED_MODULE_9__.memoize], Object.getOwnPropertyDescriptor(_class3.prototype, "onDidChangeSelection"), _class3.prototype), _applyDecoratedDescriptor(_class3.prototype, "onContextMenu", [_common_decorators__WEBPACK_IMPORTED_MODULE_9__.memoize], Object.getOwnPropertyDescriptor(_class3.prototype, "onContextMenu"), _class3.prototype), _applyDecoratedDescriptor(_class3.prototype, "onKeyDown", [_common_decorators__WEBPACK_IMPORTED_MODULE_9__.memoize], Object.getOwnPropertyDescriptor(_class3.prototype, "onKeyDown"), _class3.prototype), _applyDecoratedDescriptor(_class3.prototype, "onKeyUp", [_common_decorators__WEBPACK_IMPORTED_MODULE_9__.memoize], Object.getOwnPropertyDescriptor(_class3.prototype, "onKeyUp"), _class3.prototype), _applyDecoratedDescriptor(_class3.prototype, "onKeyPress", [_common_decorators__WEBPACK_IMPORTED_MODULE_9__.memoize], Object.getOwnPropertyDescriptor(_class3.prototype, "onKeyPress"), _class3.prototype), _applyDecoratedDescriptor(_class3.prototype, "onDidFocus", [_common_decorators__WEBPACK_IMPORTED_MODULE_9__.memoize], Object.getOwnPropertyDescriptor(_class3.prototype, "onDidFocus"), _class3.prototype), _applyDecoratedDescriptor(_class3.prototype, "onDidBlur", [_common_decorators__WEBPACK_IMPORTED_MODULE_9__.memoize], Object.getOwnPropertyDescriptor(_class3.prototype, "onDidBlur"), _class3.prototype)), _class3);

/***/ }),
/* 139 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "setARIAContainer": () => (/* binding */ setARIAContainer),
/* harmony export */   "alert": () => (/* binding */ alert),
/* harmony export */   "status": () => (/* binding */ status)
/* harmony export */ });
/* harmony import */ var _browser_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(61);
/* harmony import */ var _common_platform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(58);
/* harmony import */ var _aria_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(140);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


 // Use a max length since we are inserting the whole msg in the DOM and that can cause browsers to freeze for long messages #94233

const MAX_MESSAGE_LENGTH = 20000;
let ariaContainer;
let alertContainer;
let alertContainer2;
let statusContainer;
let statusContainer2;
function setARIAContainer(parent) {
  ariaContainer = document.createElement('div');
  ariaContainer.className = 'monaco-aria-container';

  const createAlertContainer = () => {
    const element = document.createElement('div');
    element.className = 'monaco-alert';
    element.setAttribute('role', 'alert');
    element.setAttribute('aria-atomic', 'true');
    ariaContainer.appendChild(element);
    return element;
  };

  alertContainer = createAlertContainer();
  alertContainer2 = createAlertContainer();

  const createStatusContainer = () => {
    const element = document.createElement('div');
    element.className = 'monaco-status';
    element.setAttribute('role', 'complementary');
    element.setAttribute('aria-live', 'polite');
    element.setAttribute('aria-atomic', 'true');
    ariaContainer.appendChild(element);
    return element;
  };

  statusContainer = createStatusContainer();
  statusContainer2 = createStatusContainer();
  parent.appendChild(ariaContainer);
}
/**
 * Given the provided message, will make sure that it is read as alert to screen readers.
 */

function alert(msg) {
  if (!ariaContainer) {
    return;
  } // Use alternate containers such that duplicated messages get read out by screen readers #99466


  if (alertContainer.textContent !== msg) {
    _browser_dom__WEBPACK_IMPORTED_MODULE_0__.clearNode(alertContainer2);
    insertMessage(alertContainer, msg);
  } else {
    _browser_dom__WEBPACK_IMPORTED_MODULE_0__.clearNode(alertContainer);
    insertMessage(alertContainer2, msg);
  }
}
/**
 * Given the provided message, will make sure that it is read as status to screen readers.
 */

function status(msg) {
  if (!ariaContainer) {
    return;
  }

  if (_common_platform__WEBPACK_IMPORTED_MODULE_1__.isMacintosh) {
    alert(msg); // VoiceOver does not seem to support status role
  } else {
    if (statusContainer.textContent !== msg) {
      _browser_dom__WEBPACK_IMPORTED_MODULE_0__.clearNode(statusContainer2);
      insertMessage(statusContainer, msg);
    } else {
      _browser_dom__WEBPACK_IMPORTED_MODULE_0__.clearNode(statusContainer);
      insertMessage(statusContainer2, msg);
    }
  }
}

function insertMessage(target, msg) {
  _browser_dom__WEBPACK_IMPORTED_MODULE_0__.clearNode(target);

  if (msg.length > MAX_MESSAGE_LENGTH) {
    msg = msg.substr(0, MAX_MESSAGE_LENGTH);
  }

  target.textContent = msg; // See https://www.paciellogroup.com/blog/2012/06/html5-accessibility-chops-aria-rolealert-browser-support/

  target.style.visibility = 'hidden';
  target.style.visibility = 'visible';
}

/***/ }),
/* 140 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),
/* 141 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CombinedSpliceable": () => (/* binding */ CombinedSpliceable)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
class CombinedSpliceable {
  constructor(spliceables) {
    this.spliceables = spliceables;
  }

  splice(start, deleteCount, elements) {
    this.spliceables.forEach(s => s.splice(start, deleteCount, elements));
  }

}

/***/ }),
/* 142 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),
/* 143 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ListDragOverEffect": () => (/* binding */ ListDragOverEffect),
/* harmony export */   "ListDragOverReactions": () => (/* binding */ ListDragOverReactions),
/* harmony export */   "ListError": () => (/* binding */ ListError),
/* harmony export */   "CachedListVirtualDelegate": () => (/* binding */ CachedListVirtualDelegate)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
let ListDragOverEffect;

(function (ListDragOverEffect) {
  ListDragOverEffect[ListDragOverEffect["Copy"] = 0] = "Copy";
  ListDragOverEffect[ListDragOverEffect["Move"] = 1] = "Move";
})(ListDragOverEffect || (ListDragOverEffect = {}));

const ListDragOverReactions = {
  reject() {
    return {
      accept: false
    };
  },

  accept() {
    return {
      accept: true
    };
  }

};
class ListError extends Error {
  constructor(user, message) {
    super(`ListError [${user}] ${message}`);
  }

}
class CachedListVirtualDelegate {
  cache = new WeakMap();

  getHeight(element) {
    return this.cache.get(element) ?? this.estimateHeight(element);
  }

  setDynamicHeight(element, height) {
    if (height > 0) {
      this.cache.set(element, height);
    }
  }

}

/***/ }),
/* 144 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ElementsDragAndDropData": () => (/* binding */ ElementsDragAndDropData),
/* harmony export */   "ExternalElementsDragAndDropData": () => (/* binding */ ExternalElementsDragAndDropData),
/* harmony export */   "NativeDragAndDropData": () => (/* binding */ NativeDragAndDropData),
/* harmony export */   "ListView": () => (/* binding */ ListView)
/* harmony export */ });
/* harmony import */ var _browser_browser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(50);
/* harmony import */ var _browser_dnd__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(60);
/* harmony import */ var _browser_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(61);
/* harmony import */ var _browser_event__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(85);
/* harmony import */ var _browser_touch__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(86);
/* harmony import */ var _browser_ui_scrollbar_scrollableElement__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(94);
/* harmony import */ var _common_arrays__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(87);
/* harmony import */ var _common_async__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(68);
/* harmony import */ var _common_decorators__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(88);
/* harmony import */ var _common_event__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(51);
/* harmony import */ var _common_lifecycle__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(54);
/* harmony import */ var _common_range__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(136);
/* harmony import */ var _common_scrollable__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(102);
/* harmony import */ var _browser_ui_list_list__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(143);
/* harmony import */ var _browser_ui_list_rangeMap__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(145);
/* harmony import */ var _browser_ui_list_rowCache__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(146);
/* harmony import */ var _common_errors__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(52);
var _class;

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

















const StaticDND = {
  CurrentDragAndDropData: undefined
};
const DefaultOptions = {
  useShadows: true,
  verticalScrollMode: _common_scrollable__WEBPACK_IMPORTED_MODULE_12__.ScrollbarVisibility.Auto,
  setRowLineHeight: true,
  setRowHeight: true,
  supportDynamicHeights: false,
  dnd: {
    getDragElements(e) {
      return [e];
    },

    getDragURI() {
      return null;
    },

    onDragStart() {},

    onDragOver() {
      return false;
    },

    drop() {}

  },
  horizontalScrolling: false,
  transformOptimization: true,
  alwaysConsumeMouseWheel: true
};
class ElementsDragAndDropData {
  get context() {
    return this._context;
  }

  set context(value) {
    this._context = value;
  }

  constructor(elements) {
    this.elements = elements;
  }

  update() {}

  getData() {
    return this.elements;
  }

}
class ExternalElementsDragAndDropData {
  constructor(elements) {
    this.elements = elements;
  }

  update() {}

  getData() {
    return this.elements;
  }

}
class NativeDragAndDropData {
  constructor() {
    this.types = [];
    this.files = [];
  }

  update(dataTransfer) {
    if (dataTransfer.types) {
      this.types.splice(0, this.types.length, ...dataTransfer.types);
    }

    if (dataTransfer.files) {
      this.files.splice(0, this.files.length);

      for (let i = 0; i < dataTransfer.files.length; i++) {
        const file = dataTransfer.files.item(i);

        if (file && (file.size || file.type)) {
          this.files.push(file);
        }
      }
    }
  }

  getData() {
    return {
      types: this.types,
      files: this.files
    };
  }

}

function equalsDragFeedback(f1, f2) {
  if (Array.isArray(f1) && Array.isArray(f2)) {
    return (0,_common_arrays__WEBPACK_IMPORTED_MODULE_6__.equals)(f1, f2);
  }

  return f1 === f2;
}

class ListViewAccessibilityProvider {
  constructor(accessibilityProvider) {
    if (accessibilityProvider?.getSetSize) {
      this.getSetSize = accessibilityProvider.getSetSize.bind(accessibilityProvider);
    } else {
      this.getSetSize = (e, i, l) => l;
    }

    if (accessibilityProvider?.getPosInSet) {
      this.getPosInSet = accessibilityProvider.getPosInSet.bind(accessibilityProvider);
    } else {
      this.getPosInSet = (e, i) => i + 1;
    }

    if (accessibilityProvider?.getRole) {
      this.getRole = accessibilityProvider.getRole.bind(accessibilityProvider);
    } else {
      this.getRole = _ => 'listitem';
    }

    if (accessibilityProvider?.isChecked) {
      this.isChecked = accessibilityProvider.isChecked.bind(accessibilityProvider);
    } else {
      this.isChecked = _ => undefined;
    }
  }

}
/**
 * The {@link ListView} is a virtual scrolling engine.
 *
 * Given that it only renders elements within its viewport, it can hold large
 * collections of elements and stay very performant. The performance bottleneck
 * usually lies within the user's rendering code for each element.
 *
 * @remarks It is a low-level widget, not meant to be used directly. Refer to the
 * List widget instead.
 */


let ListView = (_class = class ListView {
  static InstanceCount = 0;
  domId = `list_id_${++ListView.InstanceCount}`;
  renderers = new Map();
  renderWidth = 0;
  _scrollHeight = 0;
  scrollableElementUpdateDisposable = null;
  scrollableElementWidthDelayer = new _common_async__WEBPACK_IMPORTED_MODULE_7__.Delayer(50);
  splicing = false;
  dragOverAnimationStopDisposable = _common_lifecycle__WEBPACK_IMPORTED_MODULE_10__.Disposable.None;
  dragOverMouseY = 0;
  canDrop = false;
  currentDragFeedbackDisposable = _common_lifecycle__WEBPACK_IMPORTED_MODULE_10__.Disposable.None;
  onDragLeaveTimeout = _common_lifecycle__WEBPACK_IMPORTED_MODULE_10__.Disposable.None;
  disposables = new _common_lifecycle__WEBPACK_IMPORTED_MODULE_10__.DisposableStore();
  _onDidChangeContentHeight = new _common_event__WEBPACK_IMPORTED_MODULE_9__.Emitter();
  onDidChangeContentHeight = _common_event__WEBPACK_IMPORTED_MODULE_9__.Event.latch(this._onDidChangeContentHeight.event, undefined, this.disposables);

  get contentHeight() {
    return this.rangeMap.size;
  }

  get onDidScroll() {
    return this.scrollableElement.onScroll;
  }

  get onWillScroll() {
    return this.scrollableElement.onWillScroll;
  }

  get containerDomNode() {
    return this.rowsContainer;
  }

  get scrollableElementDomNode() {
    return this.scrollableElement.getDomNode();
  }

  _horizontalScrolling = false;

  get horizontalScrolling() {
    return this._horizontalScrolling;
  }

  set horizontalScrolling(value) {
    if (value === this._horizontalScrolling) {
      return;
    }

    if (value && this.supportDynamicHeights) {
      throw new Error('Horizontal scrolling and dynamic heights not supported simultaneously');
    }

    this._horizontalScrolling = value;
    this.domNode.classList.toggle('horizontal-scrolling', this._horizontalScrolling);

    if (this._horizontalScrolling) {
      for (const item of this.items) {
        this.measureItemWidth(item);
      }

      this.updateScrollWidth();
      this.scrollableElement.setScrollDimensions({
        width: (0,_browser_dom__WEBPACK_IMPORTED_MODULE_2__.getContentWidth)(this.domNode)
      });
      this.rowsContainer.style.width = `${Math.max(this.scrollWidth || 0, this.renderWidth)}px`;
    } else {
      this.scrollableElementWidthDelayer.cancel();
      this.scrollableElement.setScrollDimensions({
        width: this.renderWidth,
        scrollWidth: this.renderWidth
      });
      this.rowsContainer.style.width = '';
    }
  }

  constructor(container, virtualDelegate, renderers, options = DefaultOptions) {
    this.virtualDelegate = virtualDelegate;

    if (options.horizontalScrolling && options.supportDynamicHeights) {
      throw new Error('Horizontal scrolling and dynamic heights not supported simultaneously');
    }

    this.items = [];
    this.itemId = 0;
    this.rangeMap = new _browser_ui_list_rangeMap__WEBPACK_IMPORTED_MODULE_14__.RangeMap();

    for (const renderer of renderers) {
      this.renderers.set(renderer.templateId, renderer);
    }

    this.cache = this.disposables.add(new _browser_ui_list_rowCache__WEBPACK_IMPORTED_MODULE_15__.RowCache(this.renderers));
    this.lastRenderTop = 0;
    this.lastRenderHeight = 0;
    this.domNode = document.createElement('div');
    this.domNode.className = 'monaco-list';
    this.domNode.classList.add(this.domId);
    this.domNode.tabIndex = 0;
    this.domNode.classList.toggle('mouse-support', typeof options.mouseSupport === 'boolean' ? options.mouseSupport : true);
    this._horizontalScrolling = options.horizontalScrolling ?? DefaultOptions.horizontalScrolling;
    this.domNode.classList.toggle('horizontal-scrolling', this._horizontalScrolling);
    this.additionalScrollHeight = typeof options.additionalScrollHeight === 'undefined' ? 0 : options.additionalScrollHeight;
    this.accessibilityProvider = new ListViewAccessibilityProvider(options.accessibilityProvider);
    this.rowsContainer = document.createElement('div');
    this.rowsContainer.className = 'monaco-list-rows';
    const transformOptimization = options.transformOptimization ?? DefaultOptions.transformOptimization;

    if (transformOptimization) {
      this.rowsContainer.style.transform = 'translate3d(0px, 0px, 0px)';
    }

    this.disposables.add(_browser_touch__WEBPACK_IMPORTED_MODULE_4__.Gesture.addTarget(this.rowsContainer));
    this.scrollable = new _common_scrollable__WEBPACK_IMPORTED_MODULE_12__.Scrollable({
      forceIntegerValues: true,
      smoothScrollDuration: options.smoothScrolling ?? false ? 125 : 0,
      scheduleAtNextAnimationFrame: cb => (0,_browser_dom__WEBPACK_IMPORTED_MODULE_2__.scheduleAtNextAnimationFrame)(cb)
    });
    this.scrollableElement = this.disposables.add(new _browser_ui_scrollbar_scrollableElement__WEBPACK_IMPORTED_MODULE_5__.SmoothScrollableElement(this.rowsContainer, {
      alwaysConsumeMouseWheel: options.alwaysConsumeMouseWheel ?? DefaultOptions.alwaysConsumeMouseWheel,
      horizontal: _common_scrollable__WEBPACK_IMPORTED_MODULE_12__.ScrollbarVisibility.Auto,
      vertical: options.verticalScrollMode ?? DefaultOptions.verticalScrollMode,
      useShadows: options.useShadows ?? DefaultOptions.useShadows,
      mouseWheelScrollSensitivity: options.mouseWheelScrollSensitivity,
      fastScrollSensitivity: options.fastScrollSensitivity
    }, this.scrollable));
    this.domNode.appendChild(this.scrollableElement.getDomNode());
    container.appendChild(this.domNode);
    this.scrollableElement.onScroll(this.onScroll, this, this.disposables);
    this.disposables.add((0,_browser_dom__WEBPACK_IMPORTED_MODULE_2__.addDisposableListener)(this.rowsContainer, _browser_touch__WEBPACK_IMPORTED_MODULE_4__.EventType.Change, e => this.onTouchChange(e))); // Prevent the monaco-scrollable-element from scrolling
    // https://github.com/microsoft/vscode/issues/44181

    this.disposables.add((0,_browser_dom__WEBPACK_IMPORTED_MODULE_2__.addDisposableListener)(this.scrollableElement.getDomNode(), 'scroll', e => e.target.scrollTop = 0));
    this.disposables.add((0,_browser_dom__WEBPACK_IMPORTED_MODULE_2__.addDisposableListener)(this.domNode, 'dragover', e => this.onDragOver(this.toDragEvent(e))));
    this.disposables.add((0,_browser_dom__WEBPACK_IMPORTED_MODULE_2__.addDisposableListener)(this.domNode, 'drop', e => this.onDrop(this.toDragEvent(e))));
    this.disposables.add((0,_browser_dom__WEBPACK_IMPORTED_MODULE_2__.addDisposableListener)(this.domNode, 'dragleave', e => this.onDragLeave(this.toDragEvent(e))));
    this.disposables.add((0,_browser_dom__WEBPACK_IMPORTED_MODULE_2__.addDisposableListener)(this.domNode, 'dragend', e => this.onDragEnd(e)));
    this.setRowLineHeight = options.setRowLineHeight ?? DefaultOptions.setRowLineHeight;
    this.setRowHeight = options.setRowHeight ?? DefaultOptions.setRowHeight;
    this.supportDynamicHeights = options.supportDynamicHeights ?? DefaultOptions.supportDynamicHeights;
    this.dnd = options.dnd ?? DefaultOptions.dnd;
    this.layout();
  }

  updateOptions(options) {
    if (options.additionalScrollHeight !== undefined) {
      this.additionalScrollHeight = options.additionalScrollHeight;
      this.scrollableElement.setScrollDimensions({
        scrollHeight: this.scrollHeight
      });
    }

    if (options.smoothScrolling !== undefined) {
      this.scrollable.setSmoothScrollDuration(options.smoothScrolling ? 125 : 0);
    }

    if (options.horizontalScrolling !== undefined) {
      this.horizontalScrolling = options.horizontalScrolling;
    }

    if (options.mouseWheelScrollSensitivity !== undefined) {
      this.scrollableElement.updateOptions({
        mouseWheelScrollSensitivity: options.mouseWheelScrollSensitivity
      });
    }

    if (options.fastScrollSensitivity !== undefined) {
      this.scrollableElement.updateOptions({
        fastScrollSensitivity: options.fastScrollSensitivity
      });
    }
  }

  triggerScrollFromMouseWheelEvent(browserEvent) {
    this.scrollableElement.triggerScrollFromMouseWheelEvent(browserEvent);
  }

  updateElementHeight(index, size, anchorIndex) {
    if (index < 0 || index >= this.items.length) {
      return;
    }

    const originalSize = this.items[index].size;

    if (typeof size === 'undefined') {
      if (!this.supportDynamicHeights) {
        console.warn('Dynamic heights not supported');
        return;
      }

      this.items[index].lastDynamicHeightWidth = undefined;
      size = originalSize + this.probeDynamicHeight(index);
    }

    if (originalSize === size) {
      return;
    }

    const lastRenderRange = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight);
    let heightDiff = 0;

    if (index < lastRenderRange.start) {
      // do not scroll the viewport if resized element is out of viewport
      heightDiff = size - originalSize;
    } else {
      if (anchorIndex !== null && anchorIndex > index && anchorIndex <= lastRenderRange.end) {
        // anchor in viewport
        // resized element in viewport and above the anchor
        heightDiff = size - originalSize;
      } else {
        heightDiff = 0;
      }
    }

    this.rangeMap.splice(index, 1, [{
      size: size
    }]);
    this.items[index].size = size;
    this.render(lastRenderRange, Math.max(0, this.lastRenderTop + heightDiff), this.lastRenderHeight, undefined, undefined, true);
    this.setScrollTop(this.lastRenderTop);
    this.eventuallyUpdateScrollDimensions();

    if (this.supportDynamicHeights) {
      this._rerender(this.lastRenderTop, this.lastRenderHeight);
    }
  }

  splice(start, deleteCount, elements = []) {
    if (this.splicing) {
      throw new Error('Can\'t run recursive splices.');
    }

    this.splicing = true;

    try {
      return this._splice(start, deleteCount, elements);
    } finally {
      this.splicing = false;

      this._onDidChangeContentHeight.fire(this.contentHeight);
    }
  }

  _splice(start, deleteCount, elements = []) {
    const previousRenderRange = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight);
    const deleteRange = {
      start,
      end: start + deleteCount
    };
    const removeRange = _common_range__WEBPACK_IMPORTED_MODULE_11__.Range.intersect(previousRenderRange, deleteRange); // try to reuse rows, avoid removing them from DOM

    const rowsToDispose = new Map();

    for (let i = removeRange.end - 1; i >= removeRange.start; i--) {
      const item = this.items[i];
      item.dragStartDisposable.dispose();
      item.checkedDisposable.dispose();

      if (item.row) {
        let rows = rowsToDispose.get(item.templateId);

        if (!rows) {
          rows = [];
          rowsToDispose.set(item.templateId, rows);
        }

        const renderer = this.renderers.get(item.templateId);

        if (renderer && renderer.disposeElement) {
          renderer.disposeElement(item.element, i, item.row.templateData, item.size);
        }

        rows.push(item.row);
      }

      item.row = null;
    }

    const previousRestRange = {
      start: start + deleteCount,
      end: this.items.length
    };
    const previousRenderedRestRange = _common_range__WEBPACK_IMPORTED_MODULE_11__.Range.intersect(previousRestRange, previousRenderRange);
    const previousUnrenderedRestRanges = _common_range__WEBPACK_IMPORTED_MODULE_11__.Range.relativeComplement(previousRestRange, previousRenderRange);
    const inserted = elements.map(element => ({
      id: String(this.itemId++),
      element,
      templateId: this.virtualDelegate.getTemplateId(element),
      size: this.virtualDelegate.getHeight(element),
      width: undefined,
      hasDynamicHeight: !!this.virtualDelegate.hasDynamicHeight && this.virtualDelegate.hasDynamicHeight(element),
      lastDynamicHeightWidth: undefined,
      row: null,
      uri: undefined,
      dropTarget: false,
      dragStartDisposable: _common_lifecycle__WEBPACK_IMPORTED_MODULE_10__.Disposable.None,
      checkedDisposable: _common_lifecycle__WEBPACK_IMPORTED_MODULE_10__.Disposable.None
    }));
    let deleted; // TODO@joao: improve this optimization to catch even more cases

    if (start === 0 && deleteCount >= this.items.length) {
      this.rangeMap = new _browser_ui_list_rangeMap__WEBPACK_IMPORTED_MODULE_14__.RangeMap();
      this.rangeMap.splice(0, 0, inserted);
      deleted = this.items;
      this.items = inserted;
    } else {
      this.rangeMap.splice(start, deleteCount, inserted);
      deleted = this.items.splice(start, deleteCount, ...inserted);
    }

    const delta = elements.length - deleteCount;
    const renderRange = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight);
    const renderedRestRange = (0,_browser_ui_list_rangeMap__WEBPACK_IMPORTED_MODULE_14__.shift)(previousRenderedRestRange, delta);
    const updateRange = _common_range__WEBPACK_IMPORTED_MODULE_11__.Range.intersect(renderRange, renderedRestRange);

    for (let i = updateRange.start; i < updateRange.end; i++) {
      this.updateItemInDOM(this.items[i], i);
    }

    const removeRanges = _common_range__WEBPACK_IMPORTED_MODULE_11__.Range.relativeComplement(renderedRestRange, renderRange);

    for (const range of removeRanges) {
      for (let i = range.start; i < range.end; i++) {
        this.removeItemFromDOM(i);
      }
    }

    const unrenderedRestRanges = previousUnrenderedRestRanges.map(r => (0,_browser_ui_list_rangeMap__WEBPACK_IMPORTED_MODULE_14__.shift)(r, delta));
    const elementsRange = {
      start,
      end: start + elements.length
    };
    const insertRanges = [elementsRange, ...unrenderedRestRanges].map(r => _common_range__WEBPACK_IMPORTED_MODULE_11__.Range.intersect(renderRange, r));
    const beforeElement = this.getNextToLastElement(insertRanges);

    for (const range of insertRanges) {
      for (let i = range.start; i < range.end; i++) {
        const item = this.items[i];
        const rows = rowsToDispose.get(item.templateId);
        const row = rows?.pop();
        this.insertItemInDOM(i, beforeElement, row);
      }
    }

    for (const rows of rowsToDispose.values()) {
      for (const row of rows) {
        this.cache.release(row);
      }
    }

    this.eventuallyUpdateScrollDimensions();

    if (this.supportDynamicHeights) {
      this._rerender(this.scrollTop, this.renderHeight);
    }

    return deleted.map(i => i.element);
  }

  eventuallyUpdateScrollDimensions() {
    this._scrollHeight = this.contentHeight;
    this.rowsContainer.style.height = `${this._scrollHeight}px`;

    if (!this.scrollableElementUpdateDisposable) {
      this.scrollableElementUpdateDisposable = (0,_browser_dom__WEBPACK_IMPORTED_MODULE_2__.scheduleAtNextAnimationFrame)(() => {
        this.scrollableElement.setScrollDimensions({
          scrollHeight: this.scrollHeight
        });
        this.updateScrollWidth();
        this.scrollableElementUpdateDisposable = null;
      });
    }
  }

  eventuallyUpdateScrollWidth() {
    if (!this.horizontalScrolling) {
      this.scrollableElementWidthDelayer.cancel();
      return;
    }

    this.scrollableElementWidthDelayer.trigger(() => this.updateScrollWidth());
  }

  updateScrollWidth() {
    if (!this.horizontalScrolling) {
      return;
    }

    let scrollWidth = 0;

    for (const item of this.items) {
      if (typeof item.width !== 'undefined') {
        scrollWidth = Math.max(scrollWidth, item.width);
      }
    }

    this.scrollWidth = scrollWidth;
    this.scrollableElement.setScrollDimensions({
      scrollWidth: scrollWidth === 0 ? 0 : scrollWidth + 10
    });
  }

  updateWidth(index) {
    if (!this.horizontalScrolling || typeof this.scrollWidth === 'undefined') {
      return;
    }

    const item = this.items[index];
    this.measureItemWidth(item);

    if (typeof item.width !== 'undefined' && item.width > this.scrollWidth) {
      this.scrollWidth = item.width;
      this.scrollableElement.setScrollDimensions({
        scrollWidth: this.scrollWidth + 10
      });
    }
  }

  rerender() {
    if (!this.supportDynamicHeights) {
      return;
    }

    for (const item of this.items) {
      item.lastDynamicHeightWidth = undefined;
    }

    this._rerender(this.lastRenderTop, this.lastRenderHeight);
  }

  get length() {
    return this.items.length;
  }

  get renderHeight() {
    const scrollDimensions = this.scrollableElement.getScrollDimensions();
    return scrollDimensions.height;
  }

  get firstVisibleIndex() {
    const range = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight);
    const firstElTop = this.rangeMap.positionAt(range.start);
    const nextElTop = this.rangeMap.positionAt(range.start + 1);

    if (nextElTop !== -1) {
      const firstElMidpoint = (nextElTop - firstElTop) / 2 + firstElTop;

      if (firstElMidpoint < this.scrollTop) {
        return range.start + 1;
      }
    }

    return range.start;
  }

  get lastVisibleIndex() {
    const range = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight);
    return range.end - 1;
  }

  element(index) {
    return this.items[index].element;
  }

  indexOf(element) {
    return this.items.findIndex(item => item.element === element);
  }

  domElement(index) {
    const row = this.items[index].row;
    return row && row.domNode;
  }

  elementHeight(index) {
    return this.items[index].size;
  }

  elementTop(index) {
    return this.rangeMap.positionAt(index);
  }

  indexAt(position) {
    return this.rangeMap.indexAt(position);
  }

  indexAfter(position) {
    return this.rangeMap.indexAfter(position);
  }

  layout(height, width) {
    const scrollDimensions = {
      height: typeof height === 'number' ? height : (0,_browser_dom__WEBPACK_IMPORTED_MODULE_2__.getContentHeight)(this.domNode)
    };

    if (this.scrollableElementUpdateDisposable) {
      this.scrollableElementUpdateDisposable.dispose();
      this.scrollableElementUpdateDisposable = null;
      scrollDimensions.scrollHeight = this.scrollHeight;
    }

    this.scrollableElement.setScrollDimensions(scrollDimensions);

    if (typeof width !== 'undefined') {
      this.renderWidth = width;

      if (this.supportDynamicHeights) {
        this._rerender(this.scrollTop, this.renderHeight);
      }
    }

    if (this.horizontalScrolling) {
      this.scrollableElement.setScrollDimensions({
        width: typeof width === 'number' ? width : (0,_browser_dom__WEBPACK_IMPORTED_MODULE_2__.getContentWidth)(this.domNode)
      });
    }
  } // Render


  render(previousRenderRange, renderTop, renderHeight, renderLeft, scrollWidth, updateItemsInDOM = false) {
    const renderRange = this.getRenderRange(renderTop, renderHeight);
    const rangesToInsert = _common_range__WEBPACK_IMPORTED_MODULE_11__.Range.relativeComplement(renderRange, previousRenderRange);
    const rangesToRemove = _common_range__WEBPACK_IMPORTED_MODULE_11__.Range.relativeComplement(previousRenderRange, renderRange);
    const beforeElement = this.getNextToLastElement(rangesToInsert);

    if (updateItemsInDOM) {
      const rangesToUpdate = _common_range__WEBPACK_IMPORTED_MODULE_11__.Range.intersect(previousRenderRange, renderRange);

      for (let i = rangesToUpdate.start; i < rangesToUpdate.end; i++) {
        this.updateItemInDOM(this.items[i], i);
      }
    }

    for (const range of rangesToInsert) {
      for (let i = range.start; i < range.end; i++) {
        this.insertItemInDOM(i, beforeElement);
      }
    }

    for (const range of rangesToRemove) {
      for (let i = range.start; i < range.end; i++) {
        this.removeItemFromDOM(i);
      }
    }

    if (renderLeft !== undefined) {
      this.rowsContainer.style.left = `-${renderLeft}px`;
    }

    this.rowsContainer.style.top = `-${renderTop}px`;

    if (this.horizontalScrolling && scrollWidth !== undefined) {
      this.rowsContainer.style.width = `${Math.max(scrollWidth, this.renderWidth)}px`;
    }

    this.lastRenderTop = renderTop;
    this.lastRenderHeight = renderHeight;
  } // DOM operations


  insertItemInDOM(index, beforeElement, row) {
    const item = this.items[index];

    if (!item.row) {
      item.row = row ?? this.cache.alloc(item.templateId);
    }

    const role = this.accessibilityProvider.getRole(item.element) || 'listitem';
    item.row.domNode.setAttribute('role', role);
    const checked = this.accessibilityProvider.isChecked(item.element);

    if (typeof checked === 'boolean') {
      item.row.domNode.setAttribute('aria-checked', String(!!checked));
    } else if (checked) {
      const update = checked => item.row.domNode.setAttribute('aria-checked', String(!!checked));

      update(checked.value);
      item.checkedDisposable = checked.onDidChange(update);
    }

    if (!item.row.domNode.parentElement) {
      if (beforeElement) {
        this.rowsContainer.insertBefore(item.row.domNode, beforeElement);
      } else {
        this.rowsContainer.appendChild(item.row.domNode);
      }
    }

    this.updateItemInDOM(item, index);
    const renderer = this.renderers.get(item.templateId);

    if (!renderer) {
      throw new Error(`No renderer found for template id ${item.templateId}`);
    }

    renderer?.renderElement(item.element, index, item.row.templateData, item.size);
    const uri = this.dnd.getDragURI(item.element);
    item.dragStartDisposable.dispose();
    item.row.domNode.draggable = !!uri;

    if (uri) {
      item.dragStartDisposable = (0,_browser_dom__WEBPACK_IMPORTED_MODULE_2__.addDisposableListener)(item.row.domNode, 'dragstart', event => this.onDragStart(item.element, uri, event));
    }

    if (this.horizontalScrolling) {
      this.measureItemWidth(item);
      this.eventuallyUpdateScrollWidth();
    }
  }

  measureItemWidth(item) {
    if (!item.row || !item.row.domNode) {
      return;
    }

    item.row.domNode.style.width = _browser_browser__WEBPACK_IMPORTED_MODULE_0__.isFirefox ? '-moz-fit-content' : 'fit-content';
    item.width = (0,_browser_dom__WEBPACK_IMPORTED_MODULE_2__.getContentWidth)(item.row.domNode);
    const style = window.getComputedStyle(item.row.domNode);

    if (style.paddingLeft) {
      item.width += parseFloat(style.paddingLeft);
    }

    if (style.paddingRight) {
      item.width += parseFloat(style.paddingRight);
    }

    item.row.domNode.style.width = '';
  }

  updateItemInDOM(item, index) {
    item.row.domNode.style.top = `${this.elementTop(index)}px`;

    if (this.setRowHeight) {
      item.row.domNode.style.height = `${item.size}px`;
    }

    if (this.setRowLineHeight) {
      item.row.domNode.style.lineHeight = `${item.size}px`;
    }

    item.row.domNode.setAttribute('data-index', `${index}`);
    item.row.domNode.setAttribute('data-last-element', index === this.length - 1 ? 'true' : 'false');
    item.row.domNode.setAttribute('data-parity', index % 2 === 0 ? 'even' : 'odd');
    item.row.domNode.setAttribute('aria-setsize', String(this.accessibilityProvider.getSetSize(item.element, index, this.length)));
    item.row.domNode.setAttribute('aria-posinset', String(this.accessibilityProvider.getPosInSet(item.element, index)));
    item.row.domNode.setAttribute('id', this.getElementDomId(index));
    item.row.domNode.classList.toggle('drop-target', item.dropTarget);
  }

  removeItemFromDOM(index) {
    const item = this.items[index];
    item.dragStartDisposable.dispose();
    item.checkedDisposable.dispose();

    if (item.row) {
      const renderer = this.renderers.get(item.templateId);

      if (renderer && renderer.disposeElement) {
        renderer.disposeElement(item.element, index, item.row.templateData, item.size);
      }

      this.cache.release(item.row);
      item.row = null;
    }

    if (this.horizontalScrolling) {
      this.eventuallyUpdateScrollWidth();
    }
  }

  getScrollTop() {
    const scrollPosition = this.scrollableElement.getScrollPosition();
    return scrollPosition.scrollTop;
  }

  setScrollTop(scrollTop, reuseAnimation) {
    if (this.scrollableElementUpdateDisposable) {
      this.scrollableElementUpdateDisposable.dispose();
      this.scrollableElementUpdateDisposable = null;
      this.scrollableElement.setScrollDimensions({
        scrollHeight: this.scrollHeight
      });
    }

    this.scrollableElement.setScrollPosition({
      scrollTop,
      reuseAnimation
    });
  }

  getScrollLeft() {
    const scrollPosition = this.scrollableElement.getScrollPosition();
    return scrollPosition.scrollLeft;
  }

  setScrollLeft(scrollLeft) {
    if (this.scrollableElementUpdateDisposable) {
      this.scrollableElementUpdateDisposable.dispose();
      this.scrollableElementUpdateDisposable = null;
      this.scrollableElement.setScrollDimensions({
        scrollWidth: this.scrollWidth
      });
    }

    this.scrollableElement.setScrollPosition({
      scrollLeft
    });
  }

  get scrollTop() {
    return this.getScrollTop();
  }

  set scrollTop(scrollTop) {
    this.setScrollTop(scrollTop);
  }

  get scrollHeight() {
    return this._scrollHeight + (this.horizontalScrolling ? 10 : 0) + this.additionalScrollHeight;
  } // Events


  get onMouseClick() {
    return _common_event__WEBPACK_IMPORTED_MODULE_9__.Event.map(this.disposables.add(new _browser_event__WEBPACK_IMPORTED_MODULE_3__.DomEmitter(this.domNode, 'click')).event, e => this.toMouseEvent(e), this.disposables);
  }

  get onMouseDblClick() {
    return _common_event__WEBPACK_IMPORTED_MODULE_9__.Event.map(this.disposables.add(new _browser_event__WEBPACK_IMPORTED_MODULE_3__.DomEmitter(this.domNode, 'dblclick')).event, e => this.toMouseEvent(e), this.disposables);
  }

  get onMouseMiddleClick() {
    return _common_event__WEBPACK_IMPORTED_MODULE_9__.Event.filter(_common_event__WEBPACK_IMPORTED_MODULE_9__.Event.map(this.disposables.add(new _browser_event__WEBPACK_IMPORTED_MODULE_3__.DomEmitter(this.domNode, 'auxclick')).event, e => this.toMouseEvent(e), this.disposables), e => e.browserEvent.button === 1, this.disposables);
  }

  get onMouseUp() {
    return _common_event__WEBPACK_IMPORTED_MODULE_9__.Event.map(this.disposables.add(new _browser_event__WEBPACK_IMPORTED_MODULE_3__.DomEmitter(this.domNode, 'mouseup')).event, e => this.toMouseEvent(e), this.disposables);
  }

  get onMouseDown() {
    return _common_event__WEBPACK_IMPORTED_MODULE_9__.Event.map(this.disposables.add(new _browser_event__WEBPACK_IMPORTED_MODULE_3__.DomEmitter(this.domNode, 'mousedown')).event, e => this.toMouseEvent(e), this.disposables);
  }

  get onMouseOver() {
    return _common_event__WEBPACK_IMPORTED_MODULE_9__.Event.map(this.disposables.add(new _browser_event__WEBPACK_IMPORTED_MODULE_3__.DomEmitter(this.domNode, 'mouseover')).event, e => this.toMouseEvent(e), this.disposables);
  }

  get onMouseMove() {
    return _common_event__WEBPACK_IMPORTED_MODULE_9__.Event.map(this.disposables.add(new _browser_event__WEBPACK_IMPORTED_MODULE_3__.DomEmitter(this.domNode, 'mousemove')).event, e => this.toMouseEvent(e), this.disposables);
  }

  get onMouseOut() {
    return _common_event__WEBPACK_IMPORTED_MODULE_9__.Event.map(this.disposables.add(new _browser_event__WEBPACK_IMPORTED_MODULE_3__.DomEmitter(this.domNode, 'mouseout')).event, e => this.toMouseEvent(e), this.disposables);
  }

  get onContextMenu() {
    return _common_event__WEBPACK_IMPORTED_MODULE_9__.Event.any(_common_event__WEBPACK_IMPORTED_MODULE_9__.Event.map(this.disposables.add(new _browser_event__WEBPACK_IMPORTED_MODULE_3__.DomEmitter(this.domNode, 'contextmenu')).event, e => this.toMouseEvent(e), this.disposables), _common_event__WEBPACK_IMPORTED_MODULE_9__.Event.map(this.disposables.add(new _browser_event__WEBPACK_IMPORTED_MODULE_3__.DomEmitter(this.domNode, _browser_touch__WEBPACK_IMPORTED_MODULE_4__.EventType.Contextmenu)).event, e => this.toGestureEvent(e), this.disposables));
  }

  get onTouchStart() {
    return _common_event__WEBPACK_IMPORTED_MODULE_9__.Event.map(this.disposables.add(new _browser_event__WEBPACK_IMPORTED_MODULE_3__.DomEmitter(this.domNode, 'touchstart')).event, e => this.toTouchEvent(e), this.disposables);
  }

  get onTap() {
    return _common_event__WEBPACK_IMPORTED_MODULE_9__.Event.map(this.disposables.add(new _browser_event__WEBPACK_IMPORTED_MODULE_3__.DomEmitter(this.rowsContainer, _browser_touch__WEBPACK_IMPORTED_MODULE_4__.EventType.Tap)).event, e => this.toGestureEvent(e), this.disposables);
  }

  toMouseEvent(browserEvent) {
    const index = this.getItemIndexFromEventTarget(browserEvent.target || null);
    const item = typeof index === 'undefined' ? undefined : this.items[index];
    const element = item && item.element;
    return {
      browserEvent,
      index,
      element
    };
  }

  toTouchEvent(browserEvent) {
    const index = this.getItemIndexFromEventTarget(browserEvent.target || null);
    const item = typeof index === 'undefined' ? undefined : this.items[index];
    const element = item && item.element;
    return {
      browserEvent,
      index,
      element
    };
  }

  toGestureEvent(browserEvent) {
    const index = this.getItemIndexFromEventTarget(browserEvent.initialTarget || null);
    const item = typeof index === 'undefined' ? undefined : this.items[index];
    const element = item && item.element;
    return {
      browserEvent,
      index,
      element
    };
  }

  toDragEvent(browserEvent) {
    const index = this.getItemIndexFromEventTarget(browserEvent.target || null);
    const item = typeof index === 'undefined' ? undefined : this.items[index];
    const element = item && item.element;
    return {
      browserEvent,
      index,
      element
    };
  }

  onScroll(e) {
    try {
      const previousRenderRange = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight);
      this.render(previousRenderRange, e.scrollTop, e.height, e.scrollLeft, e.scrollWidth);

      if (this.supportDynamicHeights) {
        this._rerender(e.scrollTop, e.height, e.inSmoothScrolling);
      }
    } catch (err) {
      console.error('Got bad scroll event:', e);
      throw err;
    }
  }

  onTouchChange(event) {
    event.preventDefault();
    event.stopPropagation();
    this.scrollTop -= event.translationY;
  } // DND


  onDragStart(element, uri, event) {
    if (!event.dataTransfer) {
      return;
    }

    const elements = this.dnd.getDragElements(element);
    event.dataTransfer.effectAllowed = 'copyMove';
    event.dataTransfer.setData(_browser_dnd__WEBPACK_IMPORTED_MODULE_1__.DataTransfers.TEXT, uri);

    if (event.dataTransfer.setDragImage) {
      let label;

      if (this.dnd.getDragLabel) {
        label = this.dnd.getDragLabel(elements, event);
      }

      if (typeof label === 'undefined') {
        label = String(elements.length);
      }

      const dragImage = (0,_browser_dom__WEBPACK_IMPORTED_MODULE_2__.$)('.monaco-drag-image');
      dragImage.textContent = label;
      document.body.appendChild(dragImage);
      event.dataTransfer.setDragImage(dragImage, -10, -10);
      setTimeout(() => document.body.removeChild(dragImage), 0);
    }

    this.currentDragData = new ElementsDragAndDropData(elements);
    StaticDND.CurrentDragAndDropData = new ExternalElementsDragAndDropData(elements);
    this.dnd.onDragStart?.(this.currentDragData, event);
  }

  onDragOver(event) {
    event.browserEvent.preventDefault(); // needed so that the drop event fires (https://stackoverflow.com/questions/21339924/drop-event-not-firing-in-chrome)

    this.onDragLeaveTimeout.dispose();

    if (StaticDND.CurrentDragAndDropData && StaticDND.CurrentDragAndDropData.getData() === 'vscode-ui') {
      return false;
    }

    this.setupDragAndDropScrollTopAnimation(event.browserEvent);

    if (!event.browserEvent.dataTransfer) {
      return false;
    } // Drag over from outside


    if (!this.currentDragData) {
      if (StaticDND.CurrentDragAndDropData) {
        // Drag over from another list
        this.currentDragData = StaticDND.CurrentDragAndDropData;
      } else {
        // Drag over from the desktop
        if (!event.browserEvent.dataTransfer.types) {
          return false;
        }

        this.currentDragData = new NativeDragAndDropData();
      }
    }

    const result = this.dnd.onDragOver(this.currentDragData, event.element, event.index, event.browserEvent);
    this.canDrop = typeof result === 'boolean' ? result : result.accept;

    if (!this.canDrop) {
      this.currentDragFeedback = undefined;
      this.currentDragFeedbackDisposable.dispose();
      return false;
    }

    event.browserEvent.dataTransfer.dropEffect = typeof result !== 'boolean' && result.effect === _browser_ui_list_list__WEBPACK_IMPORTED_MODULE_13__.ListDragOverEffect.Copy ? 'copy' : 'move';
    let feedback;

    if (typeof result !== 'boolean' && result.feedback) {
      feedback = result.feedback;
    } else {
      if (typeof event.index === 'undefined') {
        feedback = [-1];
      } else {
        feedback = [event.index];
      }
    } // sanitize feedback list


    feedback = (0,_common_arrays__WEBPACK_IMPORTED_MODULE_6__.distinct)(feedback).filter(i => i >= -1 && i < this.length).sort((a, b) => a - b);
    feedback = feedback[0] === -1 ? [-1] : feedback;

    if (equalsDragFeedback(this.currentDragFeedback, feedback)) {
      return true;
    }

    this.currentDragFeedback = feedback;
    this.currentDragFeedbackDisposable.dispose();

    if (feedback[0] === -1) {
      // entire list feedback
      this.domNode.classList.add('drop-target');
      this.rowsContainer.classList.add('drop-target');
      this.currentDragFeedbackDisposable = (0,_common_lifecycle__WEBPACK_IMPORTED_MODULE_10__.toDisposable)(() => {
        this.domNode.classList.remove('drop-target');
        this.rowsContainer.classList.remove('drop-target');
      });
    } else {
      for (const index of feedback) {
        const item = this.items[index];
        item.dropTarget = true;
        item.row?.domNode.classList.add('drop-target');
      }

      this.currentDragFeedbackDisposable = (0,_common_lifecycle__WEBPACK_IMPORTED_MODULE_10__.toDisposable)(() => {
        for (const index of feedback) {
          const item = this.items[index];
          item.dropTarget = false;
          item.row?.domNode.classList.remove('drop-target');
        }
      });
    }

    return true;
  }

  onDragLeave(event) {
    this.onDragLeaveTimeout.dispose();
    this.onDragLeaveTimeout = (0,_common_async__WEBPACK_IMPORTED_MODULE_7__.disposableTimeout)(() => this.clearDragOverFeedback(), 100);

    if (this.currentDragData) {
      this.dnd.onDragLeave?.(this.currentDragData, event.element, event.index, event.browserEvent);
    }
  }

  onDrop(event) {
    if (!this.canDrop) {
      return;
    }

    const dragData = this.currentDragData;
    this.teardownDragAndDropScrollTopAnimation();
    this.clearDragOverFeedback();
    this.currentDragData = undefined;
    StaticDND.CurrentDragAndDropData = undefined;

    if (!dragData || !event.browserEvent.dataTransfer) {
      return;
    }

    event.browserEvent.preventDefault();
    dragData.update(event.browserEvent.dataTransfer);
    this.dnd.drop(dragData, event.element, event.index, event.browserEvent);
  }

  onDragEnd(event) {
    this.canDrop = false;
    this.teardownDragAndDropScrollTopAnimation();
    this.clearDragOverFeedback();
    this.currentDragData = undefined;
    StaticDND.CurrentDragAndDropData = undefined;
    this.dnd.onDragEnd?.(event);
  }

  clearDragOverFeedback() {
    this.currentDragFeedback = undefined;
    this.currentDragFeedbackDisposable.dispose();
    this.currentDragFeedbackDisposable = _common_lifecycle__WEBPACK_IMPORTED_MODULE_10__.Disposable.None;
  } // DND scroll top animation


  setupDragAndDropScrollTopAnimation(event) {
    if (!this.dragOverAnimationDisposable) {
      const viewTop = (0,_browser_dom__WEBPACK_IMPORTED_MODULE_2__.getTopLeftOffset)(this.domNode).top;
      this.dragOverAnimationDisposable = (0,_browser_dom__WEBPACK_IMPORTED_MODULE_2__.animate)(this.animateDragAndDropScrollTop.bind(this, viewTop));
    }

    this.dragOverAnimationStopDisposable.dispose();
    this.dragOverAnimationStopDisposable = (0,_common_async__WEBPACK_IMPORTED_MODULE_7__.disposableTimeout)(() => {
      if (this.dragOverAnimationDisposable) {
        this.dragOverAnimationDisposable.dispose();
        this.dragOverAnimationDisposable = undefined;
      }
    }, 1000);
    this.dragOverMouseY = event.pageY;
  }

  animateDragAndDropScrollTop(viewTop) {
    if (this.dragOverMouseY === undefined) {
      return;
    }

    const diff = this.dragOverMouseY - viewTop;
    const upperLimit = this.renderHeight - 35;

    if (diff < 35) {
      this.scrollTop += Math.max(-14, Math.floor(0.3 * (diff - 35)));
    } else if (diff > upperLimit) {
      this.scrollTop += Math.min(14, Math.floor(0.3 * (diff - upperLimit)));
    }
  }

  teardownDragAndDropScrollTopAnimation() {
    this.dragOverAnimationStopDisposable.dispose();

    if (this.dragOverAnimationDisposable) {
      this.dragOverAnimationDisposable.dispose();
      this.dragOverAnimationDisposable = undefined;
    }
  } // Util


  getItemIndexFromEventTarget(target) {
    const scrollableElement = this.scrollableElement.getDomNode();
    let element = target;

    while (element instanceof HTMLElement && element !== this.rowsContainer && scrollableElement.contains(element)) {
      const rawIndex = element.getAttribute('data-index');

      if (rawIndex) {
        const index = Number(rawIndex);

        if (!isNaN(index)) {
          return index;
        }
      }

      element = element.parentElement;
    }

    return undefined;
  }

  getRenderRange(renderTop, renderHeight) {
    return {
      start: this.rangeMap.indexAt(renderTop),
      end: this.rangeMap.indexAfter(renderTop + renderHeight - 1)
    };
  }
  /**
   * Given a stable rendered state, checks every rendered element whether it needs
   * to be probed for dynamic height. Adjusts scroll height and top if necessary.
   */


  _rerender(renderTop, renderHeight, inSmoothScrolling) {
    const previousRenderRange = this.getRenderRange(renderTop, renderHeight); // Let's remember the second element's position, this helps in scrolling up
    // and preserving a linear upwards scroll movement

    let anchorElementIndex;
    let anchorElementTopDelta;

    if (renderTop === this.elementTop(previousRenderRange.start)) {
      anchorElementIndex = previousRenderRange.start;
      anchorElementTopDelta = 0;
    } else if (previousRenderRange.end - previousRenderRange.start > 1) {
      anchorElementIndex = previousRenderRange.start + 1;
      anchorElementTopDelta = this.elementTop(anchorElementIndex) - renderTop;
    }

    let heightDiff = 0;

    while (true) {
      const renderRange = this.getRenderRange(renderTop, renderHeight);
      let didChange = false;

      for (let i = renderRange.start; i < renderRange.end; i++) {
        const diff = this.probeDynamicHeight(i);

        if (diff !== 0) {
          this.rangeMap.splice(i, 1, [this.items[i]]);
        }

        heightDiff += diff;
        didChange = didChange || diff !== 0;
      }

      if (!didChange) {
        if (heightDiff !== 0) {
          this.eventuallyUpdateScrollDimensions();
        }

        const unrenderRanges = _common_range__WEBPACK_IMPORTED_MODULE_11__.Range.relativeComplement(previousRenderRange, renderRange);

        for (const range of unrenderRanges) {
          for (let i = range.start; i < range.end; i++) {
            if (this.items[i].row) {
              this.removeItemFromDOM(i);
            }
          }
        }

        const renderRanges = _common_range__WEBPACK_IMPORTED_MODULE_11__.Range.relativeComplement(renderRange, previousRenderRange);

        for (const range of renderRanges) {
          for (let i = range.start; i < range.end; i++) {
            const afterIndex = i + 1;
            const beforeRow = afterIndex < this.items.length ? this.items[afterIndex].row : null;
            const beforeElement = beforeRow ? beforeRow.domNode : null;
            this.insertItemInDOM(i, beforeElement);
          }
        }

        for (let i = renderRange.start; i < renderRange.end; i++) {
          if (this.items[i].row) {
            this.updateItemInDOM(this.items[i], i);
          }
        }

        if (typeof anchorElementIndex === 'number') {
          // To compute a destination scroll top, we need to take into account the current smooth scrolling
          // animation, and then reuse it with a new target (to avoid prolonging the scroll)
          // See https://github.com/microsoft/vscode/issues/104144
          // See https://github.com/microsoft/vscode/pull/104284
          // See https://github.com/microsoft/vscode/issues/107704
          const deltaScrollTop = this.scrollable.getFutureScrollPosition().scrollTop - renderTop;
          const newScrollTop = this.elementTop(anchorElementIndex) - anchorElementTopDelta + deltaScrollTop;
          this.setScrollTop(newScrollTop, inSmoothScrolling);
        }

        this._onDidChangeContentHeight.fire(this.contentHeight);

        return;
      }
    }
  }

  probeDynamicHeight(index) {
    const item = this.items[index];

    if (!!this.virtualDelegate.getDynamicHeight) {
      const newSize = this.virtualDelegate.getDynamicHeight(item.element);

      if (newSize !== null) {
        const size = item.size;
        item.size = newSize;
        item.lastDynamicHeightWidth = this.renderWidth;
        return newSize - size;
      }
    }

    if (!item.hasDynamicHeight || item.lastDynamicHeightWidth === this.renderWidth) {
      return 0;
    }

    if (!!this.virtualDelegate.hasDynamicHeight && !this.virtualDelegate.hasDynamicHeight(item.element)) {
      return 0;
    }

    const size = item.size;

    if (item.row) {
      item.row.domNode.style.height = '';
      item.size = item.row.domNode.offsetHeight;
      item.lastDynamicHeightWidth = this.renderWidth;
      return item.size - size;
    }

    const row = this.cache.alloc(item.templateId);
    row.domNode.style.height = '';
    this.rowsContainer.appendChild(row.domNode);
    const renderer = this.renderers.get(item.templateId);

    if (!renderer) {
      throw new _common_errors__WEBPACK_IMPORTED_MODULE_16__.BugIndicatingError('Missing renderer for templateId: ' + item.templateId);
    }

    renderer.renderElement(item.element, index, row.templateData, undefined);
    item.size = row.domNode.offsetHeight;
    renderer.disposeElement?.(item.element, index, row.templateData, undefined);
    this.virtualDelegate.setDynamicHeight?.(item.element, item.size);
    item.lastDynamicHeightWidth = this.renderWidth;
    this.rowsContainer.removeChild(row.domNode);
    this.cache.release(row);
    return item.size - size;
  }

  getNextToLastElement(ranges) {
    const lastRange = ranges[ranges.length - 1];

    if (!lastRange) {
      return null;
    }

    const nextToLastItem = this.items[lastRange.end];

    if (!nextToLastItem) {
      return null;
    }

    if (!nextToLastItem.row) {
      return null;
    }

    return nextToLastItem.row.domNode;
  }

  getElementDomId(index) {
    return `${this.domId}_${index}`;
  } // Dispose


  dispose() {
    if (this.items) {
      for (const item of this.items) {
        if (item.row) {
          const renderer = this.renderers.get(item.row.templateId);

          if (renderer) {
            renderer.disposeElement?.(item.element, -1, item.row.templateData, undefined);
            renderer.disposeTemplate(item.row.templateData);
          }
        }
      }

      this.items = [];
    }

    if (this.domNode && this.domNode.parentNode) {
      this.domNode.parentNode.removeChild(this.domNode);
    }

    (0,_common_lifecycle__WEBPACK_IMPORTED_MODULE_10__.dispose)(this.disposables);
  }

}, (_applyDecoratedDescriptor(_class.prototype, "onMouseClick", [_common_decorators__WEBPACK_IMPORTED_MODULE_8__.memoize], Object.getOwnPropertyDescriptor(_class.prototype, "onMouseClick"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "onMouseDblClick", [_common_decorators__WEBPACK_IMPORTED_MODULE_8__.memoize], Object.getOwnPropertyDescriptor(_class.prototype, "onMouseDblClick"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "onMouseMiddleClick", [_common_decorators__WEBPACK_IMPORTED_MODULE_8__.memoize], Object.getOwnPropertyDescriptor(_class.prototype, "onMouseMiddleClick"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "onMouseUp", [_common_decorators__WEBPACK_IMPORTED_MODULE_8__.memoize], Object.getOwnPropertyDescriptor(_class.prototype, "onMouseUp"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "onMouseDown", [_common_decorators__WEBPACK_IMPORTED_MODULE_8__.memoize], Object.getOwnPropertyDescriptor(_class.prototype, "onMouseDown"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "onMouseOver", [_common_decorators__WEBPACK_IMPORTED_MODULE_8__.memoize], Object.getOwnPropertyDescriptor(_class.prototype, "onMouseOver"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "onMouseMove", [_common_decorators__WEBPACK_IMPORTED_MODULE_8__.memoize], Object.getOwnPropertyDescriptor(_class.prototype, "onMouseMove"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "onMouseOut", [_common_decorators__WEBPACK_IMPORTED_MODULE_8__.memoize], Object.getOwnPropertyDescriptor(_class.prototype, "onMouseOut"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "onContextMenu", [_common_decorators__WEBPACK_IMPORTED_MODULE_8__.memoize], Object.getOwnPropertyDescriptor(_class.prototype, "onContextMenu"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "onTouchStart", [_common_decorators__WEBPACK_IMPORTED_MODULE_8__.memoize], Object.getOwnPropertyDescriptor(_class.prototype, "onTouchStart"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "onTap", [_common_decorators__WEBPACK_IMPORTED_MODULE_8__.memoize], Object.getOwnPropertyDescriptor(_class.prototype, "onTap"), _class.prototype)), _class);

/***/ }),
/* 145 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "groupIntersect": () => (/* binding */ groupIntersect),
/* harmony export */   "shift": () => (/* binding */ shift),
/* harmony export */   "consolidate": () => (/* binding */ consolidate),
/* harmony export */   "RangeMap": () => (/* binding */ RangeMap)
/* harmony export */ });
/* harmony import */ var _common_range__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(136);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


/**
 * Returns the intersection between a ranged group and a range.
 * Returns `[]` if the intersection is empty.
 */
function groupIntersect(range, groups) {
  const result = [];

  for (const r of groups) {
    if (range.start >= r.range.end) {
      continue;
    }

    if (range.end < r.range.start) {
      break;
    }

    const intersection = _common_range__WEBPACK_IMPORTED_MODULE_0__.Range.intersect(range, r.range);

    if (_common_range__WEBPACK_IMPORTED_MODULE_0__.Range.isEmpty(intersection)) {
      continue;
    }

    result.push({
      range: intersection,
      size: r.size
    });
  }

  return result;
}
/**
 * Shifts a range by that `much`.
 */

function shift({
  start,
  end
}, much) {
  return {
    start: start + much,
    end: end + much
  };
}
/**
 * Consolidates a collection of ranged groups.
 *
 * Consolidation is the process of merging consecutive ranged groups
 * that share the same `size`.
 */

function consolidate(groups) {
  const result = [];
  let previousGroup = null;

  for (const group of groups) {
    const start = group.range.start;
    const end = group.range.end;
    const size = group.size;

    if (previousGroup && size === previousGroup.size) {
      previousGroup.range.end = end;
      continue;
    }

    previousGroup = {
      range: {
        start,
        end
      },
      size
    };
    result.push(previousGroup);
  }

  return result;
}
/**
 * Concatenates several collections of ranged groups into a single
 * collection.
 */

function concat(...groups) {
  return consolidate(groups.reduce((r, g) => r.concat(g), []));
}

class RangeMap {
  groups = [];
  _size = 0;

  splice(index, deleteCount, items = []) {
    const diff = items.length - deleteCount;
    const before = groupIntersect({
      start: 0,
      end: index
    }, this.groups);
    const after = groupIntersect({
      start: index + deleteCount,
      end: Number.POSITIVE_INFINITY
    }, this.groups).map(g => ({
      range: shift(g.range, diff),
      size: g.size
    }));
    const middle = items.map((item, i) => ({
      range: {
        start: index + i,
        end: index + i + 1
      },
      size: item.size
    }));
    this.groups = concat(before, middle, after);
    this._size = this.groups.reduce((t, g) => t + g.size * (g.range.end - g.range.start), 0);
  }
  /**
   * Returns the number of items in the range map.
   */


  get count() {
    const len = this.groups.length;

    if (!len) {
      return 0;
    }

    return this.groups[len - 1].range.end;
  }
  /**
   * Returns the sum of the sizes of all items in the range map.
   */


  get size() {
    return this._size;
  }
  /**
   * Returns the index of the item at the given position.
   */


  indexAt(position) {
    if (position < 0) {
      return -1;
    }

    let index = 0;
    let size = 0;

    for (const group of this.groups) {
      const count = group.range.end - group.range.start;
      const newSize = size + count * group.size;

      if (position < newSize) {
        return index + Math.floor((position - size) / group.size);
      }

      index += count;
      size = newSize;
    }

    return index;
  }
  /**
   * Returns the index of the item right after the item at the
   * index of the given position.
   */


  indexAfter(position) {
    return Math.min(this.indexAt(position) + 1, this.count);
  }
  /**
   * Returns the start position of the item at the given index.
   */


  positionAt(index) {
    if (index < 0) {
      return -1;
    }

    let position = 0;
    let count = 0;

    for (const group of this.groups) {
      const groupCount = group.range.end - group.range.start;
      const newCount = count + groupCount;

      if (index < newCount) {
        return position + (index - count) * group.size;
      }

      position += groupCount * group.size;
      count = newCount;
    }

    return -1;
  }

}

/***/ }),
/* 146 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RowCache": () => (/* binding */ RowCache)
/* harmony export */ });
/* harmony import */ var _browser_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(61);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


function removeFromParent(element) {
  try {
    element.parentElement?.removeChild(element);
  } catch (e) {// this will throw if this happens due to a blur event, nasty business
  }
}

class RowCache {
  cache = new Map();

  constructor(renderers) {
    this.renderers = renderers;
  }
  /**
   * Returns a row either by creating a new one or reusing
   * a previously released row which shares the same templateId.
   */


  alloc(templateId) {
    let result = this.getTemplateCache(templateId).pop();

    if (!result) {
      const domNode = (0,_browser_dom__WEBPACK_IMPORTED_MODULE_0__.$)('.monaco-list-row');
      const renderer = this.getRenderer(templateId);
      const templateData = renderer.renderTemplate(domNode);
      result = {
        domNode,
        templateId,
        templateData
      };
    }

    return result;
  }
  /**
   * Releases the row for eventual reuse.
   */


  release(row) {
    if (!row) {
      return;
    }

    this.releaseRow(row);
  }

  releaseRow(row) {
    const {
      domNode,
      templateId
    } = row;

    if (domNode) {
      domNode.classList.remove('scrolling');
      removeFromParent(domNode);
    }

    const cache = this.getTemplateCache(templateId);
    cache.push(row);
  }

  getTemplateCache(templateId) {
    let result = this.cache.get(templateId);

    if (!result) {
      result = [];
      this.cache.set(templateId, result);
    }

    return result;
  }

  dispose() {
    this.cache.forEach((cachedRows, templateId) => {
      for (const cachedRow of cachedRows) {
        const renderer = this.getRenderer(templateId);
        renderer.disposeTemplate(cachedRow.templateData);
        cachedRow.templateData = null;
      }
    });
    this.cache.clear();
  }

  getRenderer(templateId) {
    const renderer = this.renderers.get(templateId);

    if (!renderer) {
      throw new Error(`No renderer found for ${templateId}`);
    }

    return renderer;
  }

}

/***/ }),
/* 147 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),
/* 148 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SelectBoxNative": () => (/* binding */ SelectBoxNative)
/* harmony export */ });
/* harmony import */ var _browser_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(61);
/* harmony import */ var _browser_touch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(86);
/* harmony import */ var _common_arrays__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(87);
/* harmony import */ var _common_event__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(51);
/* harmony import */ var _common_keyCodes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(64);
/* harmony import */ var _common_lifecycle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(54);
/* harmony import */ var _common_platform__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(58);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/







class SelectBoxNative extends _common_lifecycle__WEBPACK_IMPORTED_MODULE_5__.Disposable {
  selected = 0;

  constructor(options, selected, styles, selectBoxOptions) {
    super();
    this.selectBoxOptions = selectBoxOptions || Object.create(null);
    this.options = [];
    this.selectElement = document.createElement('select');
    this.selectElement.className = 'monaco-select-box';

    if (typeof this.selectBoxOptions.ariaLabel === 'string') {
      this.selectElement.setAttribute('aria-label', this.selectBoxOptions.ariaLabel);
    }

    if (typeof this.selectBoxOptions.ariaDescription === 'string') {
      this.selectElement.setAttribute('aria-description', this.selectBoxOptions.ariaDescription);
    }

    this._onDidSelect = this._register(new _common_event__WEBPACK_IMPORTED_MODULE_3__.Emitter());
    this.styles = styles;
    this.registerListeners();
    this.setOptions(options, selected);
  }

  registerListeners() {
    this._register(_browser_touch__WEBPACK_IMPORTED_MODULE_1__.Gesture.addTarget(this.selectElement));

    [_browser_touch__WEBPACK_IMPORTED_MODULE_1__.EventType.Tap].forEach(eventType => {
      this._register(_browser_dom__WEBPACK_IMPORTED_MODULE_0__.addDisposableListener(this.selectElement, eventType, e => {
        this.selectElement.focus();
      }));
    });

    this._register(_browser_dom__WEBPACK_IMPORTED_MODULE_0__.addStandardDisposableListener(this.selectElement, 'click', e => {
      _browser_dom__WEBPACK_IMPORTED_MODULE_0__.EventHelper.stop(e, true);
    }));

    this._register(_browser_dom__WEBPACK_IMPORTED_MODULE_0__.addStandardDisposableListener(this.selectElement, 'change', e => {
      this.selectElement.title = e.target.value;

      this._onDidSelect.fire({
        index: e.target.selectedIndex,
        selected: e.target.value
      });
    }));

    this._register(_browser_dom__WEBPACK_IMPORTED_MODULE_0__.addStandardDisposableListener(this.selectElement, 'keydown', e => {
      let showSelect = false;

      if (_common_platform__WEBPACK_IMPORTED_MODULE_6__.isMacintosh) {
        if (e.keyCode === _common_keyCodes__WEBPACK_IMPORTED_MODULE_4__.KeyCode.DownArrow || e.keyCode === _common_keyCodes__WEBPACK_IMPORTED_MODULE_4__.KeyCode.UpArrow || e.keyCode === _common_keyCodes__WEBPACK_IMPORTED_MODULE_4__.KeyCode.Space) {
          showSelect = true;
        }
      } else {
        if (e.keyCode === _common_keyCodes__WEBPACK_IMPORTED_MODULE_4__.KeyCode.DownArrow && e.altKey || e.keyCode === _common_keyCodes__WEBPACK_IMPORTED_MODULE_4__.KeyCode.Space || e.keyCode === _common_keyCodes__WEBPACK_IMPORTED_MODULE_4__.KeyCode.Enter) {
          showSelect = true;
        }
      }

      if (showSelect) {
        // Space, Enter, is used to expand select box, do not propagate it (prevent action bar action run)
        e.stopPropagation();
      }
    }));
  }

  get onDidSelect() {
    return this._onDidSelect.event;
  }

  setOptions(options, selected) {
    if (!this.options || !_common_arrays__WEBPACK_IMPORTED_MODULE_2__.equals(this.options, options)) {
      this.options = options;
      this.selectElement.options.length = 0;
      this.options.forEach((option, index) => {
        this.selectElement.add(this.createOption(option.text, index, option.isDisabled));
      });
    }

    if (selected !== undefined) {
      this.select(selected);
    }
  }

  select(index) {
    if (this.options.length === 0) {
      this.selected = 0;
    } else if (index >= 0 && index < this.options.length) {
      this.selected = index;
    } else if (index > this.options.length - 1) {
      // Adjust index to end of list
      // This could make client out of sync with the select
      this.select(this.options.length - 1);
    } else if (this.selected < 0) {
      this.selected = 0;
    }

    this.selectElement.selectedIndex = this.selected;

    if (this.selected < this.options.length && typeof this.options[this.selected].text === 'string') {
      this.selectElement.title = this.options[this.selected].text;
    } else {
      this.selectElement.title = '';
    }
  }

  setAriaLabel(label) {
    this.selectBoxOptions.ariaLabel = label;
    this.selectElement.setAttribute('aria-label', label);
  }

  focus() {
    if (this.selectElement) {
      this.selectElement.tabIndex = 0;
      this.selectElement.focus();
    }
  }

  blur() {
    if (this.selectElement) {
      this.selectElement.tabIndex = -1;
      this.selectElement.blur();
    }
  }

  setFocusable(focusable) {
    this.selectElement.tabIndex = focusable ? 0 : -1;
  }

  render(container) {
    container.classList.add('select-container');
    container.appendChild(this.selectElement);
    this.setOptions(this.options, this.selected);
    this.applyStyles();
  }

  style(styles) {
    this.styles = styles;
    this.applyStyles();
  }

  applyStyles() {
    // Style native select
    if (this.selectElement) {
      const background = this.styles.selectBackground ? this.styles.selectBackground.toString() : '';
      const foreground = this.styles.selectForeground ? this.styles.selectForeground.toString() : '';
      const border = this.styles.selectBorder ? this.styles.selectBorder.toString() : '';
      this.selectElement.style.backgroundColor = background;
      this.selectElement.style.color = foreground;
      this.selectElement.style.borderColor = border;
    }
  }

  createOption(value, index, disabled) {
    const option = document.createElement('option');
    option.value = value;
    option.text = value;
    option.disabled = !!disabled;
    return option;
  }

}

/***/ }),
/* 149 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),
/* 150 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Action": () => (/* binding */ Action),
/* harmony export */   "ActionRunner": () => (/* binding */ ActionRunner),
/* harmony export */   "Separator": () => (/* binding */ Separator),
/* harmony export */   "SubmenuAction": () => (/* binding */ SubmenuAction),
/* harmony export */   "EmptySubmenuAction": () => (/* binding */ EmptySubmenuAction),
/* harmony export */   "toAction": () => (/* binding */ toAction)
/* harmony export */ });
/* harmony import */ var _event__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(51);
/* harmony import */ var _lifecycle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(54);
/* harmony import */ var _nls__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(59);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/



class Action extends _lifecycle__WEBPACK_IMPORTED_MODULE_1__.Disposable {
  _onDidChange = this._register(new _event__WEBPACK_IMPORTED_MODULE_0__.Emitter());
  onDidChange = this._onDidChange.event;
  _enabled = true;

  constructor(id, label = '', cssClass = '', enabled = true, actionCallback) {
    super();
    this._id = id;
    this._label = label;
    this._cssClass = cssClass;
    this._enabled = enabled;
    this._actionCallback = actionCallback;
  }

  get id() {
    return this._id;
  }

  get label() {
    return this._label;
  }

  set label(value) {
    this._setLabel(value);
  }

  _setLabel(value) {
    if (this._label !== value) {
      this._label = value;

      this._onDidChange.fire({
        label: value
      });
    }
  }

  get tooltip() {
    return this._tooltip || '';
  }

  set tooltip(value) {
    this._setTooltip(value);
  }

  _setTooltip(value) {
    if (this._tooltip !== value) {
      this._tooltip = value;

      this._onDidChange.fire({
        tooltip: value
      });
    }
  }

  get class() {
    return this._cssClass;
  }

  set class(value) {
    this._setClass(value);
  }

  _setClass(value) {
    if (this._cssClass !== value) {
      this._cssClass = value;

      this._onDidChange.fire({
        class: value
      });
    }
  }

  get enabled() {
    return this._enabled;
  }

  set enabled(value) {
    this._setEnabled(value);
  }

  _setEnabled(value) {
    if (this._enabled !== value) {
      this._enabled = value;

      this._onDidChange.fire({
        enabled: value
      });
    }
  }

  get checked() {
    return this._checked;
  }

  set checked(value) {
    this._setChecked(value);
  }

  _setChecked(value) {
    if (this._checked !== value) {
      this._checked = value;

      this._onDidChange.fire({
        checked: value
      });
    }
  }

  async run(event, data) {
    if (this._actionCallback) {
      await this._actionCallback(event);
    }
  }

}
class ActionRunner extends _lifecycle__WEBPACK_IMPORTED_MODULE_1__.Disposable {
  _onWillRun = this._register(new _event__WEBPACK_IMPORTED_MODULE_0__.Emitter());
  onWillRun = this._onWillRun.event;
  _onDidRun = this._register(new _event__WEBPACK_IMPORTED_MODULE_0__.Emitter());
  onDidRun = this._onDidRun.event;

  async run(action, context) {
    if (!action.enabled) {
      return;
    }

    this._onWillRun.fire({
      action
    });

    let error = undefined;

    try {
      await this.runAction(action, context);
    } catch (e) {
      error = e;
    }

    this._onDidRun.fire({
      action,
      error
    });
  }

  async runAction(action, context) {
    await action.run(context);
  }

}
class Separator {
  /**
   * Joins all non-empty lists of actions with separators.
   */
  static join(...actionLists) {
    let out = [];

    for (const list of actionLists) {
      if (!list.length) {// skip
      } else if (out.length) {
        out = [...out, new Separator(), ...list];
      } else {
        out = list;
      }
    }

    return out;
  }

  static ID = 'vs.actions.separator';
  id = Separator.ID;
  label = '';
  tooltip = '';
  class = '';
  enabled = false;
  checked = false;

  async run() {}

}
class SubmenuAction {
  tooltip = '';
  enabled = true;
  checked = undefined;

  get actions() {
    return this._actions;
  }

  constructor(id, label, actions, cssClass) {
    this.id = id;
    this.label = label;
    this.class = cssClass;
    this._actions = actions;
  }

  async run() {}

}
class EmptySubmenuAction extends Action {
  static ID = 'vs.actions.empty';

  constructor() {
    super(EmptySubmenuAction.ID, _nls__WEBPACK_IMPORTED_MODULE_2__.localize('submenu.empty', '(empty)'), undefined, false);
  }

}
function toAction(props) {
  return {
    id: props.id,
    label: props.label,
    class: undefined,
    enabled: props.enabled ?? true,
    checked: props.checked ?? false,
    run: async () => props.run(),
    tooltip: props.label
  };
}

/***/ }),
/* 151 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),
/* 152 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FindInput": () => (/* binding */ FindInput)
/* harmony export */ });
/* harmony import */ var _browser_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(61);
/* harmony import */ var _browser_ui_findinput_findInputToggles__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(153);
/* harmony import */ var _browser_ui_inputbox_inputBox__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(156);
/* harmony import */ var _browser_ui_widget__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(100);
/* harmony import */ var _common_event__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(51);
/* harmony import */ var _common_keyCodes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(64);
/* harmony import */ var _findInput_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(160);
/* harmony import */ var _common_nls__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(59);
/* harmony import */ var _common_lifecycle__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(54);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









const NLS_DEFAULT_LABEL = _common_nls__WEBPACK_IMPORTED_MODULE_7__.localize('defaultLabel', "input");
class FindInput extends _browser_ui_widget__WEBPACK_IMPORTED_MODULE_3__.Widget {
  static OPTION_CHANGE = 'optionChange';
  fixFocusOnOptionClickEnabled = true;
  imeSessionInProgress = false;
  additionalTogglesDisposables = new _common_lifecycle__WEBPACK_IMPORTED_MODULE_8__.DisposableStore();
  additionalToggles = [];
  _onDidOptionChange = this._register(new _common_event__WEBPACK_IMPORTED_MODULE_4__.Emitter());
  onDidOptionChange = this._onDidOptionChange.event;
  _onKeyDown = this._register(new _common_event__WEBPACK_IMPORTED_MODULE_4__.Emitter());
  onKeyDown = this._onKeyDown.event;
  _onMouseDown = this._register(new _common_event__WEBPACK_IMPORTED_MODULE_4__.Emitter());
  onMouseDown = this._onMouseDown.event;
  _onInput = this._register(new _common_event__WEBPACK_IMPORTED_MODULE_4__.Emitter());
  onInput = this._onInput.event;
  _onKeyUp = this._register(new _common_event__WEBPACK_IMPORTED_MODULE_4__.Emitter());
  onKeyUp = this._onKeyUp.event;
  _onCaseSensitiveKeyDown = this._register(new _common_event__WEBPACK_IMPORTED_MODULE_4__.Emitter());
  onCaseSensitiveKeyDown = this._onCaseSensitiveKeyDown.event;
  _onRegexKeyDown = this._register(new _common_event__WEBPACK_IMPORTED_MODULE_4__.Emitter());
  onRegexKeyDown = this._onRegexKeyDown.event;

  constructor(parent, contextViewProvider, options) {
    super();
    this.placeholder = options.placeholder || '';
    this.validation = options.validation;
    this.label = options.label || NLS_DEFAULT_LABEL;
    this.showCommonFindToggles = !!options.showCommonFindToggles;
    this.inputActiveOptionBorder = options.inputActiveOptionBorder;
    this.inputActiveOptionForeground = options.inputActiveOptionForeground;
    this.inputActiveOptionBackground = options.inputActiveOptionBackground;
    this.inputBackground = options.inputBackground;
    this.inputForeground = options.inputForeground;
    this.inputBorder = options.inputBorder;
    this.inputValidationInfoBorder = options.inputValidationInfoBorder;
    this.inputValidationInfoBackground = options.inputValidationInfoBackground;
    this.inputValidationInfoForeground = options.inputValidationInfoForeground;
    this.inputValidationWarningBorder = options.inputValidationWarningBorder;
    this.inputValidationWarningBackground = options.inputValidationWarningBackground;
    this.inputValidationWarningForeground = options.inputValidationWarningForeground;
    this.inputValidationErrorBorder = options.inputValidationErrorBorder;
    this.inputValidationErrorBackground = options.inputValidationErrorBackground;
    this.inputValidationErrorForeground = options.inputValidationErrorForeground;
    const appendCaseSensitiveLabel = options.appendCaseSensitiveLabel || '';
    const appendWholeWordsLabel = options.appendWholeWordsLabel || '';
    const appendRegexLabel = options.appendRegexLabel || '';
    const history = options.history || [];
    const flexibleHeight = !!options.flexibleHeight;
    const flexibleWidth = !!options.flexibleWidth;
    const flexibleMaxHeight = options.flexibleMaxHeight;
    this.domNode = document.createElement('div');
    this.domNode.classList.add('monaco-findInput');
    this.inputBox = this._register(new _browser_ui_inputbox_inputBox__WEBPACK_IMPORTED_MODULE_2__.HistoryInputBox(this.domNode, contextViewProvider, {
      placeholder: this.placeholder || '',
      ariaLabel: this.label || '',
      validationOptions: {
        validation: this.validation
      },
      inputBackground: this.inputBackground,
      inputForeground: this.inputForeground,
      inputBorder: this.inputBorder,
      inputValidationInfoBackground: this.inputValidationInfoBackground,
      inputValidationInfoForeground: this.inputValidationInfoForeground,
      inputValidationInfoBorder: this.inputValidationInfoBorder,
      inputValidationWarningBackground: this.inputValidationWarningBackground,
      inputValidationWarningForeground: this.inputValidationWarningForeground,
      inputValidationWarningBorder: this.inputValidationWarningBorder,
      inputValidationErrorBackground: this.inputValidationErrorBackground,
      inputValidationErrorForeground: this.inputValidationErrorForeground,
      inputValidationErrorBorder: this.inputValidationErrorBorder,
      history,
      showHistoryHint: options.showHistoryHint,
      flexibleHeight,
      flexibleWidth,
      flexibleMaxHeight
    }));
    this.regex = this._register(new _browser_ui_findinput_findInputToggles__WEBPACK_IMPORTED_MODULE_1__.RegexToggle({
      appendTitle: appendRegexLabel,
      isChecked: false,
      inputActiveOptionBorder: this.inputActiveOptionBorder,
      inputActiveOptionForeground: this.inputActiveOptionForeground,
      inputActiveOptionBackground: this.inputActiveOptionBackground
    }));

    this._register(this.regex.onChange(viaKeyboard => {
      this._onDidOptionChange.fire(viaKeyboard);

      if (!viaKeyboard && this.fixFocusOnOptionClickEnabled) {
        this.inputBox.focus();
      }

      this.validate();
    }));

    this._register(this.regex.onKeyDown(e => {
      this._onRegexKeyDown.fire(e);
    }));

    this.wholeWords = this._register(new _browser_ui_findinput_findInputToggles__WEBPACK_IMPORTED_MODULE_1__.WholeWordsToggle({
      appendTitle: appendWholeWordsLabel,
      isChecked: false,
      inputActiveOptionBorder: this.inputActiveOptionBorder,
      inputActiveOptionForeground: this.inputActiveOptionForeground,
      inputActiveOptionBackground: this.inputActiveOptionBackground
    }));

    this._register(this.wholeWords.onChange(viaKeyboard => {
      this._onDidOptionChange.fire(viaKeyboard);

      if (!viaKeyboard && this.fixFocusOnOptionClickEnabled) {
        this.inputBox.focus();
      }

      this.validate();
    }));

    this.caseSensitive = this._register(new _browser_ui_findinput_findInputToggles__WEBPACK_IMPORTED_MODULE_1__.CaseSensitiveToggle({
      appendTitle: appendCaseSensitiveLabel,
      isChecked: false,
      inputActiveOptionBorder: this.inputActiveOptionBorder,
      inputActiveOptionForeground: this.inputActiveOptionForeground,
      inputActiveOptionBackground: this.inputActiveOptionBackground
    }));

    this._register(this.caseSensitive.onChange(viaKeyboard => {
      this._onDidOptionChange.fire(viaKeyboard);

      if (!viaKeyboard && this.fixFocusOnOptionClickEnabled) {
        this.inputBox.focus();
      }

      this.validate();
    }));

    this._register(this.caseSensitive.onKeyDown(e => {
      this._onCaseSensitiveKeyDown.fire(e);
    })); // Arrow-Key support to navigate between options


    const indexes = [this.caseSensitive.domNode, this.wholeWords.domNode, this.regex.domNode];
    this.onkeydown(this.domNode, event => {
      if (event.equals(_common_keyCodes__WEBPACK_IMPORTED_MODULE_5__.KeyCode.LeftArrow) || event.equals(_common_keyCodes__WEBPACK_IMPORTED_MODULE_5__.KeyCode.RightArrow) || event.equals(_common_keyCodes__WEBPACK_IMPORTED_MODULE_5__.KeyCode.Escape)) {
        const index = indexes.indexOf(document.activeElement);

        if (index >= 0) {
          let newIndex = -1;

          if (event.equals(_common_keyCodes__WEBPACK_IMPORTED_MODULE_5__.KeyCode.RightArrow)) {
            newIndex = (index + 1) % indexes.length;
          } else if (event.equals(_common_keyCodes__WEBPACK_IMPORTED_MODULE_5__.KeyCode.LeftArrow)) {
            if (index === 0) {
              newIndex = indexes.length - 1;
            } else {
              newIndex = index - 1;
            }
          }

          if (event.equals(_common_keyCodes__WEBPACK_IMPORTED_MODULE_5__.KeyCode.Escape)) {
            indexes[index].blur();
            this.inputBox.focus();
          } else if (newIndex >= 0) {
            indexes[newIndex].focus();
          }

          _browser_dom__WEBPACK_IMPORTED_MODULE_0__.EventHelper.stop(event, true);
        }
      }
    });
    this.controls = document.createElement('div');
    this.controls.className = 'controls';
    this.controls.style.display = this.showCommonFindToggles ? 'block' : 'none';
    this.controls.appendChild(this.caseSensitive.domNode);
    this.controls.appendChild(this.wholeWords.domNode);
    this.controls.appendChild(this.regex.domNode);

    if (!this.showCommonFindToggles) {
      this.caseSensitive.domNode.style.display = 'none';
      this.wholeWords.domNode.style.display = 'none';
      this.regex.domNode.style.display = 'none';
    }

    this.setAdditionalToggles(options?.additionalToggles);
    this.domNode.appendChild(this.controls);
    parent?.appendChild(this.domNode);

    this._register(_browser_dom__WEBPACK_IMPORTED_MODULE_0__.addDisposableListener(this.inputBox.inputElement, 'compositionstart', e => {
      this.imeSessionInProgress = true;
    }));

    this._register(_browser_dom__WEBPACK_IMPORTED_MODULE_0__.addDisposableListener(this.inputBox.inputElement, 'compositionend', e => {
      this.imeSessionInProgress = false;

      this._onInput.fire();
    }));

    this.onkeydown(this.inputBox.inputElement, e => this._onKeyDown.fire(e));
    this.onkeyup(this.inputBox.inputElement, e => this._onKeyUp.fire(e));
    this.oninput(this.inputBox.inputElement, e => this._onInput.fire());
    this.onmousedown(this.inputBox.inputElement, e => this._onMouseDown.fire(e));
  }

  get isImeSessionInProgress() {
    return this.imeSessionInProgress;
  }

  get onDidChange() {
    return this.inputBox.onDidChange;
  }

  enable() {
    this.domNode.classList.remove('disabled');
    this.inputBox.enable();
    this.regex.enable();
    this.wholeWords.enable();
    this.caseSensitive.enable();

    for (const toggle of this.additionalToggles) {
      toggle.enable();
    }
  }

  disable() {
    this.domNode.classList.add('disabled');
    this.inputBox.disable();
    this.regex.disable();
    this.wholeWords.disable();
    this.caseSensitive.disable();

    for (const toggle of this.additionalToggles) {
      toggle.disable();
    }
  }

  setFocusInputOnOptionClick(value) {
    this.fixFocusOnOptionClickEnabled = value;
  }

  setEnabled(enabled) {
    if (enabled) {
      this.enable();
    } else {
      this.disable();
    }
  }

  setAdditionalToggles(toggles) {
    for (const currentToggle of this.additionalToggles) {
      currentToggle.domNode.remove();
    }

    this.additionalToggles = [];
    this.additionalTogglesDisposables.dispose();
    this.additionalTogglesDisposables = new _common_lifecycle__WEBPACK_IMPORTED_MODULE_8__.DisposableStore();

    for (const toggle of toggles ?? []) {
      this.additionalTogglesDisposables.add(toggle);
      this.controls.appendChild(toggle.domNode);
      this.additionalTogglesDisposables.add(toggle.onChange(viaKeyboard => {
        this._onDidOptionChange.fire(viaKeyboard);

        if (!viaKeyboard && this.fixFocusOnOptionClickEnabled) {
          this.inputBox.focus();
        }
      }));
      this.additionalToggles.push(toggle);
    }

    if (this.additionalToggles.length > 0) {
      this.controls.style.display = 'block';
    }

    this.inputBox.paddingRight = (this.showCommonFindToggles ? this.caseSensitive.width() + this.wholeWords.width() + this.regex.width() : 0) + this.additionalToggles.reduce((r, t) => r + t.width(), 0);
  }

  clear() {
    this.clearValidation();
    this.setValue('');
    this.focus();
  }

  getValue() {
    return this.inputBox.value;
  }

  setValue(value) {
    if (this.inputBox.value !== value) {
      this.inputBox.value = value;
    }
  }

  onSearchSubmit() {
    this.inputBox.addToHistory();
  }

  style(styles) {
    this.inputActiveOptionBorder = styles.inputActiveOptionBorder;
    this.inputActiveOptionForeground = styles.inputActiveOptionForeground;
    this.inputActiveOptionBackground = styles.inputActiveOptionBackground;
    this.inputBackground = styles.inputBackground;
    this.inputForeground = styles.inputForeground;
    this.inputBorder = styles.inputBorder;
    this.inputValidationInfoBackground = styles.inputValidationInfoBackground;
    this.inputValidationInfoForeground = styles.inputValidationInfoForeground;
    this.inputValidationInfoBorder = styles.inputValidationInfoBorder;
    this.inputValidationWarningBackground = styles.inputValidationWarningBackground;
    this.inputValidationWarningForeground = styles.inputValidationWarningForeground;
    this.inputValidationWarningBorder = styles.inputValidationWarningBorder;
    this.inputValidationErrorBackground = styles.inputValidationErrorBackground;
    this.inputValidationErrorForeground = styles.inputValidationErrorForeground;
    this.inputValidationErrorBorder = styles.inputValidationErrorBorder;
    this.applyStyles();
  }

  applyStyles() {
    if (this.domNode) {
      const toggleStyles = {
        inputActiveOptionBorder: this.inputActiveOptionBorder,
        inputActiveOptionForeground: this.inputActiveOptionForeground,
        inputActiveOptionBackground: this.inputActiveOptionBackground
      };
      this.regex.style(toggleStyles);
      this.wholeWords.style(toggleStyles);
      this.caseSensitive.style(toggleStyles);

      for (const toggle of this.additionalToggles) {
        toggle.style(toggleStyles);
      }

      const inputBoxStyles = {
        inputBackground: this.inputBackground,
        inputForeground: this.inputForeground,
        inputBorder: this.inputBorder,
        inputValidationInfoBackground: this.inputValidationInfoBackground,
        inputValidationInfoForeground: this.inputValidationInfoForeground,
        inputValidationInfoBorder: this.inputValidationInfoBorder,
        inputValidationWarningBackground: this.inputValidationWarningBackground,
        inputValidationWarningForeground: this.inputValidationWarningForeground,
        inputValidationWarningBorder: this.inputValidationWarningBorder,
        inputValidationErrorBackground: this.inputValidationErrorBackground,
        inputValidationErrorForeground: this.inputValidationErrorForeground,
        inputValidationErrorBorder: this.inputValidationErrorBorder
      };
      this.inputBox.style(inputBoxStyles);
    }
  }

  select() {
    this.inputBox.select();
  }

  focus() {
    this.inputBox.focus();
  }

  getCaseSensitive() {
    return this.caseSensitive.checked;
  }

  setCaseSensitive(value) {
    this.caseSensitive.checked = value;
  }

  getWholeWords() {
    return this.wholeWords.checked;
  }

  setWholeWords(value) {
    this.wholeWords.checked = value;
  }

  getRegex() {
    return this.regex.checked;
  }

  setRegex(value) {
    this.regex.checked = value;
    this.validate();
  }

  focusOnCaseSensitive() {
    this.caseSensitive.focus();
  }

  focusOnRegex() {
    this.regex.focus();
  }

  _lastHighlightFindOptions = 0;

  highlightFindOptions() {
    this.domNode.classList.remove('highlight-' + this._lastHighlightFindOptions);
    this._lastHighlightFindOptions = 1 - this._lastHighlightFindOptions;
    this.domNode.classList.add('highlight-' + this._lastHighlightFindOptions);
  }

  validate() {
    this.inputBox.validate();
  }

  showMessage(message) {
    this.inputBox.showMessage(message);
  }

  clearMessage() {
    this.inputBox.hideMessage();
  }

  clearValidation() {
    this.inputBox.hideMessage();
  }

}

/***/ }),
/* 153 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CaseSensitiveToggle": () => (/* binding */ CaseSensitiveToggle),
/* harmony export */   "WholeWordsToggle": () => (/* binding */ WholeWordsToggle),
/* harmony export */   "RegexToggle": () => (/* binding */ RegexToggle)
/* harmony export */ });
/* harmony import */ var _browser_ui_toggle_toggle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(154);
/* harmony import */ var _common_codicons__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(104);
/* harmony import */ var _common_nls__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(59);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/



const NLS_CASE_SENSITIVE_TOGGLE_LABEL = _common_nls__WEBPACK_IMPORTED_MODULE_2__.localize('caseDescription', "Match Case");
const NLS_WHOLE_WORD_TOGGLE_LABEL = _common_nls__WEBPACK_IMPORTED_MODULE_2__.localize('wordsDescription', "Match Whole Word");
const NLS_REGEX_TOGGLE_LABEL = _common_nls__WEBPACK_IMPORTED_MODULE_2__.localize('regexDescription', "Use Regular Expression");
class CaseSensitiveToggle extends _browser_ui_toggle_toggle__WEBPACK_IMPORTED_MODULE_0__.Toggle {
  constructor(opts) {
    super({
      icon: _common_codicons__WEBPACK_IMPORTED_MODULE_1__.Codicon.caseSensitive,
      title: NLS_CASE_SENSITIVE_TOGGLE_LABEL + opts.appendTitle,
      isChecked: opts.isChecked,
      inputActiveOptionBorder: opts.inputActiveOptionBorder,
      inputActiveOptionForeground: opts.inputActiveOptionForeground,
      inputActiveOptionBackground: opts.inputActiveOptionBackground
    });
  }

}
class WholeWordsToggle extends _browser_ui_toggle_toggle__WEBPACK_IMPORTED_MODULE_0__.Toggle {
  constructor(opts) {
    super({
      icon: _common_codicons__WEBPACK_IMPORTED_MODULE_1__.Codicon.wholeWord,
      title: NLS_WHOLE_WORD_TOGGLE_LABEL + opts.appendTitle,
      isChecked: opts.isChecked,
      inputActiveOptionBorder: opts.inputActiveOptionBorder,
      inputActiveOptionForeground: opts.inputActiveOptionForeground,
      inputActiveOptionBackground: opts.inputActiveOptionBackground
    });
  }

}
class RegexToggle extends _browser_ui_toggle_toggle__WEBPACK_IMPORTED_MODULE_0__.Toggle {
  constructor(opts) {
    super({
      icon: _common_codicons__WEBPACK_IMPORTED_MODULE_1__.Codicon.regex,
      title: NLS_REGEX_TOGGLE_LABEL + opts.appendTitle,
      isChecked: opts.isChecked,
      inputActiveOptionBorder: opts.inputActiveOptionBorder,
      inputActiveOptionForeground: opts.inputActiveOptionForeground,
      inputActiveOptionBackground: opts.inputActiveOptionBackground
    });
  }

}

/***/ }),
/* 154 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ToggleActionViewItem": () => (/* binding */ ToggleActionViewItem),
/* harmony export */   "Toggle": () => (/* binding */ Toggle),
/* harmony export */   "Checkbox": () => (/* binding */ Checkbox)
/* harmony export */ });
/* harmony import */ var _browser_ui_actionbar_actionViewItems__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(116);
/* harmony import */ var _browser_ui_widget__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(100);
/* harmony import */ var _common_codicons__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(104);
/* harmony import */ var _common_color__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(91);
/* harmony import */ var _common_event__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(51);
/* harmony import */ var _common_keyCodes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(64);
/* harmony import */ var _toggle_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(155);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/







const defaultOpts = {
  inputActiveOptionBorder: _common_color__WEBPACK_IMPORTED_MODULE_3__.Color.fromHex('#007ACC00'),
  inputActiveOptionForeground: _common_color__WEBPACK_IMPORTED_MODULE_3__.Color.fromHex('#FFFFFF'),
  inputActiveOptionBackground: _common_color__WEBPACK_IMPORTED_MODULE_3__.Color.fromHex('#0E639C50')
};
class ToggleActionViewItem extends _browser_ui_actionbar_actionViewItems__WEBPACK_IMPORTED_MODULE_0__.BaseActionViewItem {
  constructor(context, action, options) {
    super(context, action, options);
    this.toggle = this._register(new Toggle({
      actionClassName: this._action.class,
      isChecked: !!this._action.checked,
      title: this.options.keybinding ? `${this._action.label} (${this.options.keybinding})` : this._action.label,
      notFocusable: true
    }));

    this._register(this.toggle.onChange(() => this._action.checked = !!this.toggle && this.toggle.checked));
  }

  render(container) {
    this.element = container;
    this.element.appendChild(this.toggle.domNode);
  }

  updateEnabled() {
    if (this.toggle) {
      if (this.isEnabled()) {
        this.toggle.enable();
      } else {
        this.toggle.disable();
      }
    }
  }

  updateChecked() {
    this.toggle.checked = !!this._action.checked;
  }

  focus() {
    this.toggle.domNode.tabIndex = 0;
    this.toggle.focus();
  }

  blur() {
    this.toggle.domNode.tabIndex = -1;
    this.toggle.domNode.blur();
  }

  setFocusable(focusable) {
    this.toggle.domNode.tabIndex = focusable ? 0 : -1;
  }

}
class Toggle extends _browser_ui_widget__WEBPACK_IMPORTED_MODULE_1__.Widget {
  _onChange = this._register(new _common_event__WEBPACK_IMPORTED_MODULE_4__.Emitter());
  onChange = this._onChange.event;
  _onKeyDown = this._register(new _common_event__WEBPACK_IMPORTED_MODULE_4__.Emitter());
  onKeyDown = this._onKeyDown.event;

  constructor(opts) {
    super();
    this._opts = { ...defaultOpts,
      ...opts
    };
    this._checked = this._opts.isChecked;
    const classes = ['monaco-custom-toggle'];

    if (this._opts.icon) {
      this._icon = this._opts.icon;
      classes.push(..._common_codicons__WEBPACK_IMPORTED_MODULE_2__.CSSIcon.asClassNameArray(this._icon));
    }

    if (this._opts.actionClassName) {
      classes.push(...this._opts.actionClassName.split(' '));
    }

    if (this._checked) {
      classes.push('checked');
    }

    this.domNode = document.createElement('div');
    this.domNode.title = this._opts.title;
    this.domNode.classList.add(...classes);

    if (!this._opts.notFocusable) {
      this.domNode.tabIndex = 0;
    }

    this.domNode.setAttribute('role', 'checkbox');
    this.domNode.setAttribute('aria-checked', String(this._checked));
    this.domNode.setAttribute('aria-label', this._opts.title);
    this.applyStyles();
    this.onclick(this.domNode, ev => {
      if (this.enabled) {
        this.checked = !this._checked;

        this._onChange.fire(false);

        ev.preventDefault();
      }
    });
    this.ignoreGesture(this.domNode);
    this.onkeydown(this.domNode, keyboardEvent => {
      if (keyboardEvent.keyCode === _common_keyCodes__WEBPACK_IMPORTED_MODULE_5__.KeyCode.Space || keyboardEvent.keyCode === _common_keyCodes__WEBPACK_IMPORTED_MODULE_5__.KeyCode.Enter) {
        this.checked = !this._checked;

        this._onChange.fire(true);

        keyboardEvent.preventDefault();
        keyboardEvent.stopPropagation();
        return;
      }

      this._onKeyDown.fire(keyboardEvent);
    });
  }

  get enabled() {
    return this.domNode.getAttribute('aria-disabled') !== 'true';
  }

  focus() {
    this.domNode.focus();
  }

  get checked() {
    return this._checked;
  }

  set checked(newIsChecked) {
    this._checked = newIsChecked;
    this.domNode.setAttribute('aria-checked', String(this._checked));
    this.domNode.classList.toggle('checked', this._checked);
    this.applyStyles();
  }

  setIcon(icon) {
    if (this._icon) {
      this.domNode.classList.remove(..._common_codicons__WEBPACK_IMPORTED_MODULE_2__.CSSIcon.asClassNameArray(this._icon));
    }

    this._icon = icon;

    if (this._icon) {
      this.domNode.classList.add(..._common_codicons__WEBPACK_IMPORTED_MODULE_2__.CSSIcon.asClassNameArray(this._icon));
    }
  }

  width() {
    return 2
    /*margin left*/
    + 2
    /*border*/
    + 2
    /*padding*/
    + 16
    /* icon width */
    ;
  }

  style(styles) {
    if (styles.inputActiveOptionBorder) {
      this._opts.inputActiveOptionBorder = styles.inputActiveOptionBorder;
    }

    if (styles.inputActiveOptionForeground) {
      this._opts.inputActiveOptionForeground = styles.inputActiveOptionForeground;
    }

    if (styles.inputActiveOptionBackground) {
      this._opts.inputActiveOptionBackground = styles.inputActiveOptionBackground;
    }

    this.applyStyles();
  }

  applyStyles() {
    if (this.domNode) {
      this.domNode.style.borderColor = this._checked && this._opts.inputActiveOptionBorder ? this._opts.inputActiveOptionBorder.toString() : '';
      this.domNode.style.color = this._checked && this._opts.inputActiveOptionForeground ? this._opts.inputActiveOptionForeground.toString() : 'inherit';
      this.domNode.style.backgroundColor = this._checked && this._opts.inputActiveOptionBackground ? this._opts.inputActiveOptionBackground.toString() : '';
    }
  }

  enable() {
    this.domNode.setAttribute('aria-disabled', String(false));
  }

  disable() {
    this.domNode.setAttribute('aria-disabled', String(true));
  }

  setTitle(newTitle) {
    this.domNode.title = newTitle;
    this.domNode.setAttribute('aria-label', newTitle);
  }

}
class Checkbox extends _browser_ui_widget__WEBPACK_IMPORTED_MODULE_1__.Widget {
  constructor(title, isChecked) {
    super();
    this.title = title;
    this.isChecked = isChecked;
    this.checkbox = new Toggle({
      title: this.title,
      isChecked: this.isChecked,
      icon: _common_codicons__WEBPACK_IMPORTED_MODULE_2__.Codicon.check,
      actionClassName: 'monaco-checkbox'
    });
    this.domNode = this.checkbox.domNode;
    this.styles = {};
    this.checkbox.onChange(() => {
      this.applyStyles();
    });
  }

  get checked() {
    return this.checkbox.checked;
  }

  set checked(newIsChecked) {
    this.checkbox.checked = newIsChecked;
    this.applyStyles();
  }

  focus() {
    this.domNode.focus();
  }

  hasFocus() {
    return this.domNode === document.activeElement;
  }

  style(styles) {
    this.styles = styles;
    this.applyStyles();
  }

  applyStyles() {
    this.domNode.style.color = this.styles.checkboxForeground ? this.styles.checkboxForeground.toString() : '';
    this.domNode.style.backgroundColor = this.styles.checkboxBackground ? this.styles.checkboxBackground.toString() : '';
    this.domNode.style.borderColor = this.styles.checkboxBorder ? this.styles.checkboxBorder.toString() : '';
  }

}

/***/ }),
/* 155 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),
/* 156 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MessageType": () => (/* binding */ MessageType),
/* harmony export */   "InputBox": () => (/* binding */ InputBox),
/* harmony export */   "HistoryInputBox": () => (/* binding */ HistoryInputBox)
/* harmony export */ });
/* harmony import */ var _browser_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(61);
/* harmony import */ var _browser_event__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(85);
/* harmony import */ var _browser_formattedTextRenderer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(127);
/* harmony import */ var _browser_ui_actionbar_actionbar__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(115);
/* harmony import */ var _browser_ui_aria_aria__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(139);
/* harmony import */ var _browser_ui_contextview_contextview__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(135);
/* harmony import */ var _browser_ui_scrollbar_scrollableElement__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(94);
/* harmony import */ var _browser_ui_widget__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(100);
/* harmony import */ var _common_color__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(91);
/* harmony import */ var _common_event__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(51);
/* harmony import */ var _common_history__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(157);
/* harmony import */ var _common_objects__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(134);
/* harmony import */ var _common_scrollable__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(102);
/* harmony import */ var _inputBox_css__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(159);
/* harmony import */ var _common_nls__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(59);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/















const $ = _browser_dom__WEBPACK_IMPORTED_MODULE_0__.$;
let MessageType;

(function (MessageType) {
  MessageType[MessageType["INFO"] = 1] = "INFO";
  MessageType[MessageType["WARNING"] = 2] = "WARNING";
  MessageType[MessageType["ERROR"] = 3] = "ERROR";
})(MessageType || (MessageType = {}));

const defaultOpts = {
  inputBackground: _common_color__WEBPACK_IMPORTED_MODULE_8__.Color.fromHex('#3C3C3C'),
  inputForeground: _common_color__WEBPACK_IMPORTED_MODULE_8__.Color.fromHex('#CCCCCC'),
  inputValidationInfoBorder: _common_color__WEBPACK_IMPORTED_MODULE_8__.Color.fromHex('#55AAFF'),
  inputValidationInfoBackground: _common_color__WEBPACK_IMPORTED_MODULE_8__.Color.fromHex('#063B49'),
  inputValidationWarningBorder: _common_color__WEBPACK_IMPORTED_MODULE_8__.Color.fromHex('#B89500'),
  inputValidationWarningBackground: _common_color__WEBPACK_IMPORTED_MODULE_8__.Color.fromHex('#352A05'),
  inputValidationErrorBorder: _common_color__WEBPACK_IMPORTED_MODULE_8__.Color.fromHex('#BE1100'),
  inputValidationErrorBackground: _common_color__WEBPACK_IMPORTED_MODULE_8__.Color.fromHex('#5A1D1D')
};
class InputBox extends _browser_ui_widget__WEBPACK_IMPORTED_MODULE_7__.Widget {
  state = 'idle';
  maxHeight = Number.POSITIVE_INFINITY;
  _onDidChange = this._register(new _common_event__WEBPACK_IMPORTED_MODULE_9__.Emitter());
  onDidChange = this._onDidChange.event;
  _onDidHeightChange = this._register(new _common_event__WEBPACK_IMPORTED_MODULE_9__.Emitter());
  onDidHeightChange = this._onDidHeightChange.event;

  constructor(container, contextViewProvider, options) {
    super();
    this.contextViewProvider = contextViewProvider;
    this.options = options || Object.create(null);
    (0,_common_objects__WEBPACK_IMPORTED_MODULE_11__.mixin)(this.options, defaultOpts, false);
    this.message = null;
    this.placeholder = this.options.placeholder || '';
    this.tooltip = this.options.tooltip ?? (this.placeholder || '');
    this.ariaLabel = this.options.ariaLabel || '';
    this.inputBackground = this.options.inputBackground;
    this.inputForeground = this.options.inputForeground;
    this.inputBorder = this.options.inputBorder;
    this.inputValidationInfoBorder = this.options.inputValidationInfoBorder;
    this.inputValidationInfoBackground = this.options.inputValidationInfoBackground;
    this.inputValidationInfoForeground = this.options.inputValidationInfoForeground;
    this.inputValidationWarningBorder = this.options.inputValidationWarningBorder;
    this.inputValidationWarningBackground = this.options.inputValidationWarningBackground;
    this.inputValidationWarningForeground = this.options.inputValidationWarningForeground;
    this.inputValidationErrorBorder = this.options.inputValidationErrorBorder;
    this.inputValidationErrorBackground = this.options.inputValidationErrorBackground;
    this.inputValidationErrorForeground = this.options.inputValidationErrorForeground;

    if (this.options.validationOptions) {
      this.validation = this.options.validationOptions.validation;
    }

    this.element = _browser_dom__WEBPACK_IMPORTED_MODULE_0__.append(container, $('.monaco-inputbox.idle'));
    const tagName = this.options.flexibleHeight ? 'textarea' : 'input';
    const wrapper = _browser_dom__WEBPACK_IMPORTED_MODULE_0__.append(this.element, $('.ibwrapper'));
    this.input = _browser_dom__WEBPACK_IMPORTED_MODULE_0__.append(wrapper, $(tagName + '.input.empty'));
    this.input.setAttribute('autocorrect', 'off');
    this.input.setAttribute('autocapitalize', 'off');
    this.input.setAttribute('spellcheck', 'false');
    this.onfocus(this.input, () => this.element.classList.add('synthetic-focus'));
    this.onblur(this.input, () => this.element.classList.remove('synthetic-focus'));

    if (this.options.flexibleHeight) {
      this.maxHeight = typeof this.options.flexibleMaxHeight === 'number' ? this.options.flexibleMaxHeight : Number.POSITIVE_INFINITY;
      this.mirror = _browser_dom__WEBPACK_IMPORTED_MODULE_0__.append(wrapper, $('div.mirror'));
      this.mirror.innerText = '\u00a0';
      this.scrollableElement = new _browser_ui_scrollbar_scrollableElement__WEBPACK_IMPORTED_MODULE_6__.ScrollableElement(this.element, {
        vertical: _common_scrollable__WEBPACK_IMPORTED_MODULE_12__.ScrollbarVisibility.Auto
      });

      if (this.options.flexibleWidth) {
        this.input.setAttribute('wrap', 'off');
        this.mirror.style.whiteSpace = 'pre';
        this.mirror.style.wordWrap = 'initial';
      }

      _browser_dom__WEBPACK_IMPORTED_MODULE_0__.append(container, this.scrollableElement.getDomNode());

      this._register(this.scrollableElement); // from ScrollableElement to DOM


      this._register(this.scrollableElement.onScroll(e => this.input.scrollTop = e.scrollTop));

      const onSelectionChange = this._register(new _browser_event__WEBPACK_IMPORTED_MODULE_1__.DomEmitter(document, 'selectionchange'));

      const onAnchoredSelectionChange = _common_event__WEBPACK_IMPORTED_MODULE_9__.Event.filter(onSelectionChange.event, () => {
        const selection = document.getSelection();
        return selection?.anchorNode === wrapper;
      }); // from DOM to ScrollableElement

      this._register(onAnchoredSelectionChange(this.updateScrollDimensions, this));

      this._register(this.onDidHeightChange(this.updateScrollDimensions, this));
    } else {
      this.input.type = this.options.type || 'text';
      this.input.setAttribute('wrap', 'off');
    }

    if (this.ariaLabel) {
      this.input.setAttribute('aria-label', this.ariaLabel);
    }

    if (this.placeholder && !this.options.showPlaceholderOnFocus) {
      this.setPlaceHolder(this.placeholder);
    }

    if (this.tooltip) {
      this.setTooltip(this.tooltip);
    }

    this.oninput(this.input, () => this.onValueChange());
    this.onblur(this.input, () => this.onBlur());
    this.onfocus(this.input, () => this.onFocus());
    this.ignoreGesture(this.input);
    setTimeout(() => this.updateMirror(), 0); // Support actions

    if (this.options.actions) {
      this.actionbar = this._register(new _browser_ui_actionbar_actionbar__WEBPACK_IMPORTED_MODULE_3__.ActionBar(this.element));
      this.actionbar.push(this.options.actions, {
        icon: true,
        label: false
      });
    }

    this.applyStyles();
  }

  onBlur() {
    this._hideMessage();

    if (this.options.showPlaceholderOnFocus) {
      this.input.setAttribute('placeholder', '');
    }
  }

  onFocus() {
    this._showMessage();

    if (this.options.showPlaceholderOnFocus) {
      this.input.setAttribute('placeholder', this.placeholder || '');
    }
  }

  setPlaceHolder(placeHolder) {
    this.placeholder = placeHolder;
    this.input.setAttribute('placeholder', placeHolder);
  }

  setTooltip(tooltip) {
    this.tooltip = tooltip;
    this.input.title = tooltip;
  }

  setAriaLabel(label) {
    this.ariaLabel = label;

    if (label) {
      this.input.setAttribute('aria-label', this.ariaLabel);
    } else {
      this.input.removeAttribute('aria-label');
    }
  }

  getAriaLabel() {
    return this.ariaLabel;
  }

  get mirrorElement() {
    return this.mirror;
  }

  get inputElement() {
    return this.input;
  }

  get value() {
    return this.input.value;
  }

  set value(newValue) {
    if (this.input.value !== newValue) {
      this.input.value = newValue;
      this.onValueChange();
    }
  }

  get height() {
    return typeof this.cachedHeight === 'number' ? this.cachedHeight : _browser_dom__WEBPACK_IMPORTED_MODULE_0__.getTotalHeight(this.element);
  }

  focus() {
    this.input.focus();
  }

  blur() {
    this.input.blur();
  }

  hasFocus() {
    return document.activeElement === this.input;
  }

  select(range = null) {
    this.input.select();

    if (range) {
      this.input.setSelectionRange(range.start, range.end);

      if (range.end === this.input.value.length) {
        this.input.scrollLeft = this.input.scrollWidth;
      }
    }
  }

  isSelectionAtEnd() {
    return this.input.selectionEnd === this.input.value.length && this.input.selectionStart === this.input.selectionEnd;
  }

  enable() {
    this.input.removeAttribute('disabled');
  }

  disable() {
    this.blur();
    this.input.disabled = true;

    this._hideMessage();
  }

  setEnabled(enabled) {
    if (enabled) {
      this.enable();
    } else {
      this.disable();
    }
  }

  get width() {
    return _browser_dom__WEBPACK_IMPORTED_MODULE_0__.getTotalWidth(this.input);
  }

  set width(width) {
    if (this.options.flexibleHeight && this.options.flexibleWidth) {
      // textarea with horizontal scrolling
      let horizontalPadding = 0;

      if (this.mirror) {
        const paddingLeft = parseFloat(this.mirror.style.paddingLeft || '') || 0;
        const paddingRight = parseFloat(this.mirror.style.paddingRight || '') || 0;
        horizontalPadding = paddingLeft + paddingRight;
      }

      this.input.style.width = width - horizontalPadding + 'px';
    } else {
      this.input.style.width = width + 'px';
    }

    if (this.mirror) {
      this.mirror.style.width = width + 'px';
    }
  }

  set paddingRight(paddingRight) {
    // Set width to avoid hint text overlapping buttons
    this.input.style.width = `calc(100% - ${paddingRight}px)`;

    if (this.mirror) {
      this.mirror.style.paddingRight = paddingRight + 'px';
    }
  }

  updateScrollDimensions() {
    if (typeof this.cachedContentHeight !== 'number' || typeof this.cachedHeight !== 'number' || !this.scrollableElement) {
      return;
    }

    const scrollHeight = this.cachedContentHeight;
    const height = this.cachedHeight;
    const scrollTop = this.input.scrollTop;
    this.scrollableElement.setScrollDimensions({
      scrollHeight,
      height
    });
    this.scrollableElement.setScrollPosition({
      scrollTop
    });
  }

  showMessage(message, force) {
    this.message = message;
    this.element.classList.remove('idle');
    this.element.classList.remove('info');
    this.element.classList.remove('warning');
    this.element.classList.remove('error');
    this.element.classList.add(this.classForType(message.type));
    const styles = this.stylesForType(this.message.type);
    this.element.style.border = styles.border ? `1px solid ${styles.border}` : '';

    if (this.hasFocus() || force) {
      this._showMessage();
    }
  }

  hideMessage() {
    this.message = null;
    this.element.classList.remove('info');
    this.element.classList.remove('warning');
    this.element.classList.remove('error');
    this.element.classList.add('idle');

    this._hideMessage();

    this.applyStyles();
  }

  isInputValid() {
    return !!this.validation && !this.validation(this.value);
  }

  validate() {
    let errorMsg = null;

    if (this.validation) {
      errorMsg = this.validation(this.value);

      if (errorMsg) {
        this.inputElement.setAttribute('aria-invalid', 'true');
        this.showMessage(errorMsg);
      } else if (this.inputElement.hasAttribute('aria-invalid')) {
        this.inputElement.removeAttribute('aria-invalid');
        this.hideMessage();
      }
    }

    return errorMsg?.type;
  }

  stylesForType(type) {
    switch (type) {
      case MessageType.INFO:
        return {
          border: this.inputValidationInfoBorder,
          background: this.inputValidationInfoBackground,
          foreground: this.inputValidationInfoForeground
        };

      case MessageType.WARNING:
        return {
          border: this.inputValidationWarningBorder,
          background: this.inputValidationWarningBackground,
          foreground: this.inputValidationWarningForeground
        };

      default:
        return {
          border: this.inputValidationErrorBorder,
          background: this.inputValidationErrorBackground,
          foreground: this.inputValidationErrorForeground
        };
    }
  }

  classForType(type) {
    switch (type) {
      case MessageType.INFO:
        return 'info';

      case MessageType.WARNING:
        return 'warning';

      default:
        return 'error';
    }
  }

  _showMessage() {
    if (!this.contextViewProvider || !this.message) {
      return;
    }

    let div;

    const layout = () => div.style.width = _browser_dom__WEBPACK_IMPORTED_MODULE_0__.getTotalWidth(this.element) + 'px';

    this.contextViewProvider.showContextView({
      getAnchor: () => this.element,
      anchorAlignment: _browser_ui_contextview_contextview__WEBPACK_IMPORTED_MODULE_5__.AnchorAlignment.RIGHT,
      render: container => {
        if (!this.message) {
          return null;
        }

        div = _browser_dom__WEBPACK_IMPORTED_MODULE_0__.append(container, $('.monaco-inputbox-container'));
        layout();
        const renderOptions = {
          inline: true,
          className: 'monaco-inputbox-message'
        };
        const spanElement = this.message.formatContent ? (0,_browser_formattedTextRenderer__WEBPACK_IMPORTED_MODULE_2__.renderFormattedText)(this.message.content, renderOptions) : (0,_browser_formattedTextRenderer__WEBPACK_IMPORTED_MODULE_2__.renderText)(this.message.content, renderOptions);
        spanElement.classList.add(this.classForType(this.message.type));
        const styles = this.stylesForType(this.message.type);
        spanElement.style.backgroundColor = styles.background ? styles.background.toString() : '';
        spanElement.style.color = styles.foreground ? styles.foreground.toString() : '';
        spanElement.style.border = styles.border ? `1px solid ${styles.border}` : '';
        _browser_dom__WEBPACK_IMPORTED_MODULE_0__.append(div, spanElement);
        return null;
      },
      onHide: () => {
        this.state = 'closed';
      },
      layout: layout
    }); // ARIA Support

    let alertText;

    if (this.message.type === MessageType.ERROR) {
      alertText = _common_nls__WEBPACK_IMPORTED_MODULE_14__.localize('alertErrorMessage', "Error: {0}", this.message.content);
    } else if (this.message.type === MessageType.WARNING) {
      alertText = _common_nls__WEBPACK_IMPORTED_MODULE_14__.localize('alertWarningMessage', "Warning: {0}", this.message.content);
    } else {
      alertText = _common_nls__WEBPACK_IMPORTED_MODULE_14__.localize('alertInfoMessage', "Info: {0}", this.message.content);
    }

    _browser_ui_aria_aria__WEBPACK_IMPORTED_MODULE_4__.alert(alertText);
    this.state = 'open';
  }

  _hideMessage() {
    if (!this.contextViewProvider) {
      return;
    }

    if (this.state === 'open') {
      this.contextViewProvider.hideContextView();
    }

    this.state = 'idle';
  }

  onValueChange() {
    this._onDidChange.fire(this.value);

    this.validate();
    this.updateMirror();
    this.input.classList.toggle('empty', !this.value);

    if (this.state === 'open' && this.contextViewProvider) {
      this.contextViewProvider.layout();
    }
  }

  updateMirror() {
    if (!this.mirror) {
      return;
    }

    const value = this.value;
    const lastCharCode = value.charCodeAt(value.length - 1);
    const suffix = lastCharCode === 10 ? ' ' : '';
    const mirrorTextContent = (value + suffix).replace(/\u000c/g, ''); // Don't measure with the form feed character, which messes up sizing

    if (mirrorTextContent) {
      this.mirror.textContent = value + suffix;
    } else {
      this.mirror.innerText = '\u00a0';
    }

    this.layout();
  }

  style(styles) {
    this.inputBackground = styles.inputBackground;
    this.inputForeground = styles.inputForeground;
    this.inputBorder = styles.inputBorder;
    this.inputValidationInfoBackground = styles.inputValidationInfoBackground;
    this.inputValidationInfoForeground = styles.inputValidationInfoForeground;
    this.inputValidationInfoBorder = styles.inputValidationInfoBorder;
    this.inputValidationWarningBackground = styles.inputValidationWarningBackground;
    this.inputValidationWarningForeground = styles.inputValidationWarningForeground;
    this.inputValidationWarningBorder = styles.inputValidationWarningBorder;
    this.inputValidationErrorBackground = styles.inputValidationErrorBackground;
    this.inputValidationErrorForeground = styles.inputValidationErrorForeground;
    this.inputValidationErrorBorder = styles.inputValidationErrorBorder;
    this.applyStyles();
  }

  applyStyles() {
    const background = this.inputBackground ? this.inputBackground.toString() : '';
    const foreground = this.inputForeground ? this.inputForeground.toString() : '';
    const border = this.inputBorder ? this.inputBorder.toString() : '';
    this.element.style.backgroundColor = background;
    this.element.style.color = foreground;
    this.input.style.backgroundColor = 'inherit';
    this.input.style.color = foreground;
    this.element.style.borderWidth = border ? '1px' : '';
    this.element.style.borderStyle = border ? 'solid' : '';
    this.element.style.borderColor = border;
  }

  layout() {
    if (!this.mirror) {
      return;
    }

    const previousHeight = this.cachedContentHeight;
    this.cachedContentHeight = _browser_dom__WEBPACK_IMPORTED_MODULE_0__.getTotalHeight(this.mirror);

    if (previousHeight !== this.cachedContentHeight) {
      this.cachedHeight = Math.min(this.cachedContentHeight, this.maxHeight);
      this.input.style.height = this.cachedHeight + 'px';

      this._onDidHeightChange.fire(this.cachedContentHeight);
    }
  }

  insertAtCursor(text) {
    const inputElement = this.inputElement;
    const start = inputElement.selectionStart;
    const end = inputElement.selectionEnd;
    const content = inputElement.value;

    if (start !== null && end !== null) {
      this.value = content.substr(0, start) + text + content.substr(end);
      inputElement.setSelectionRange(start + 1, start + 1);
      this.layout();
    }
  }

  dispose() {
    this._hideMessage();

    this.message = null;
    this.actionbar?.dispose();
    super.dispose();
  }

}
class HistoryInputBox extends InputBox {
  _onDidFocus = this._register(new _common_event__WEBPACK_IMPORTED_MODULE_9__.Emitter());
  onDidFocus = this._onDidFocus.event;
  _onDidBlur = this._register(new _common_event__WEBPACK_IMPORTED_MODULE_9__.Emitter());
  onDidBlur = this._onDidBlur.event;

  constructor(container, contextViewProvider, options) {
    const NLS_PLACEHOLDER_HISTORY_HINT = _common_nls__WEBPACK_IMPORTED_MODULE_14__.localize({
      key: 'history.inputbox.hint',
      comment: ['Text will be prefixed with \u21C5 plus a single space, then used as a hint where input field keeps history']
    }, "for history");
    const NLS_PLACEHOLDER_HISTORY_HINT_SUFFIX = ` or \u21C5 ${NLS_PLACEHOLDER_HISTORY_HINT}`;
    const NLS_PLACEHOLDER_HISTORY_HINT_SUFFIX_IN_PARENS = ` (\u21C5 ${NLS_PLACEHOLDER_HISTORY_HINT})`;
    super(container, contextViewProvider, options);
    this.history = new _common_history__WEBPACK_IMPORTED_MODULE_10__.HistoryNavigator(options.history, 100); // Function to append the history suffix to the placeholder if necessary

    const addSuffix = () => {
      if (options.showHistoryHint && options.showHistoryHint() && !this.placeholder.endsWith(NLS_PLACEHOLDER_HISTORY_HINT_SUFFIX) && !this.placeholder.endsWith(NLS_PLACEHOLDER_HISTORY_HINT_SUFFIX_IN_PARENS) && this.history.getHistory().length) {
        const suffix = this.placeholder.endsWith(')') ? NLS_PLACEHOLDER_HISTORY_HINT_SUFFIX : NLS_PLACEHOLDER_HISTORY_HINT_SUFFIX_IN_PARENS;
        const suffixedPlaceholder = this.placeholder + suffix;

        if (options.showPlaceholderOnFocus && document.activeElement !== this.input) {
          this.placeholder = suffixedPlaceholder;
        } else {
          this.setPlaceHolder(suffixedPlaceholder);
        }
      }
    }; // Spot the change to the textarea class attribute which occurs when it changes between non-empty and empty,
    // and add the history suffix to the placeholder if not yet present


    this.observer = new MutationObserver((mutationList, observer) => {
      mutationList.forEach(mutation => {
        if (!mutation.target.textContent) {
          addSuffix();
        }
      });
    });
    this.observer.observe(this.input, {
      attributeFilter: ['class']
    });
    this.onfocus(this.input, () => addSuffix());
    this.onblur(this.input, () => {
      const resetPlaceholder = historyHint => {
        if (!this.placeholder.endsWith(historyHint)) {
          return false;
        } else {
          const revertedPlaceholder = this.placeholder.slice(0, this.placeholder.length - historyHint.length);

          if (options.showPlaceholderOnFocus) {
            this.placeholder = revertedPlaceholder;
          } else {
            this.setPlaceHolder(revertedPlaceholder);
          }

          return true;
        }
      };

      if (!resetPlaceholder(NLS_PLACEHOLDER_HISTORY_HINT_SUFFIX_IN_PARENS)) {
        resetPlaceholder(NLS_PLACEHOLDER_HISTORY_HINT_SUFFIX);
      }
    });
  }

  dispose() {
    super.dispose();

    if (this.observer) {
      this.observer.disconnect();
      this.observer = undefined;
    }
  }

  addToHistory() {
    if (this.value && this.value !== this.getCurrentValue()) {
      this.history.add(this.value);
    }
  }

  getHistory() {
    return this.history.getHistory();
  }

  showNextValue() {
    if (!this.history.has(this.value)) {
      this.addToHistory();
    }

    let next = this.getNextValue();

    if (next) {
      next = next === this.value ? this.getNextValue() : next;
    }

    if (next) {
      this.value = next;
      _browser_ui_aria_aria__WEBPACK_IMPORTED_MODULE_4__.status(this.value);
    }
  }

  showPreviousValue() {
    if (!this.history.has(this.value)) {
      this.addToHistory();
    }

    let previous = this.getPreviousValue();

    if (previous) {
      previous = previous === this.value ? this.getPreviousValue() : previous;
    }

    if (previous) {
      this.value = previous;
      _browser_ui_aria_aria__WEBPACK_IMPORTED_MODULE_4__.status(this.value);
    }
  }

  clearHistory() {
    this.history.clear();
  }

  onBlur() {
    super.onBlur();

    this._onDidBlur.fire();
  }

  onFocus() {
    super.onFocus();

    this._onDidFocus.fire();
  }

  getCurrentValue() {
    let currentValue = this.history.current();

    if (!currentValue) {
      currentValue = this.history.last();
      this.history.next();
    }

    return currentValue;
  }

  getPreviousValue() {
    return this.history.previous() || this.history.first();
  }

  getNextValue() {
    return this.history.next() || this.history.last();
  }

}

/***/ }),
/* 157 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HistoryNavigator": () => (/* binding */ HistoryNavigator),
/* harmony export */   "HistoryNavigator2": () => (/* binding */ HistoryNavigator2)
/* harmony export */ });
/* harmony import */ var _navigator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(158);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

class HistoryNavigator {
  constructor(history = [], limit = 10) {
    this._initialize(history);

    this._limit = limit;

    this._onChange();
  }

  getHistory() {
    return this._elements;
  }

  add(t) {
    this._history.delete(t);

    this._history.add(t);

    this._onChange();
  }

  next() {
    if (this._currentPosition() !== this._elements.length - 1) {
      return this._navigator.next();
    }

    return null;
  }

  previous() {
    if (this._currentPosition() !== 0) {
      return this._navigator.previous();
    }

    return null;
  }

  current() {
    return this._navigator.current();
  }

  first() {
    return this._navigator.first();
  }

  last() {
    return this._navigator.last();
  }

  has(t) {
    return this._history.has(t);
  }

  clear() {
    this._initialize([]);

    this._onChange();
  }

  _onChange() {
    this._reduceToLimit();

    const elements = this._elements;
    this._navigator = new _navigator__WEBPACK_IMPORTED_MODULE_0__.ArrayNavigator(elements, 0, elements.length, elements.length);
  }

  _reduceToLimit() {
    const data = this._elements;

    if (data.length > this._limit) {
      this._initialize(data.slice(data.length - this._limit));
    }
  }

  _currentPosition() {
    const currentElement = this._navigator.current();

    if (!currentElement) {
      return -1;
    }

    return this._elements.indexOf(currentElement);
  }

  _initialize(history) {
    this._history = new Set();

    for (const entry of history) {
      this._history.add(entry);
    }
  }

  get _elements() {
    const elements = [];

    this._history.forEach(e => elements.push(e));

    return elements;
  }

}
class HistoryNavigator2 {
  constructor(history, capacity = 10) {
    this.capacity = capacity;

    if (history.length < 1) {
      throw new Error('not supported');
    }

    this.size = 1;
    this.head = this.tail = this.cursor = {
      value: history[0],
      previous: undefined,
      next: undefined
    };

    for (let i = 1; i < history.length; i++) {
      this.add(history[i]);
    }
  }

  add(value) {
    const node = {
      value,
      previous: this.tail,
      next: undefined
    };
    this.tail.next = node;
    this.tail = node;
    this.cursor = this.tail;
    this.size++;

    while (this.size > this.capacity) {
      this.head = this.head.next;
      this.head.previous = undefined;
      this.size--;
    }
  }
  /**
   * @returns old last value
   */


  replaceLast(value) {
    const oldValue = this.tail.value;
    this.tail.value = value;
    return oldValue;
  }

  isAtEnd() {
    return this.cursor === this.tail;
  }

  current() {
    return this.cursor.value;
  }

  previous() {
    if (this.cursor.previous) {
      this.cursor = this.cursor.previous;
    }

    return this.cursor.value;
  }

  next() {
    if (this.cursor.next) {
      this.cursor = this.cursor.next;
    }

    return this.cursor.value;
  }

  has(t) {
    let temp = this.head;

    while (temp) {
      if (temp.value === t) {
        return true;
      }

      temp = temp.next;
    }

    return false;
  }

  resetCursor() {
    this.cursor = this.tail;
    return this.cursor.value;
  }

  *[Symbol.iterator]() {
    let node = this.head;

    while (node) {
      yield node.value;
      node = node.next;
    }
  }

}

/***/ }),
/* 158 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ArrayNavigator": () => (/* binding */ ArrayNavigator)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
class ArrayNavigator {
  constructor(items, start = 0, end = items.length, index = start - 1) {
    this.items = items;
    this.start = start;
    this.end = end;
    this.index = index;
  }

  current() {
    if (this.index === this.start - 1 || this.index === this.end) {
      return null;
    }

    return this.items[this.index];
  }

  next() {
    this.index = Math.min(this.index + 1, this.end);
    return this.current();
  }

  previous() {
    this.index = Math.max(this.index - 1, this.start - 1);
    return this.current();
  }

  first() {
    this.index = this.start;
    return this.current();
  }

  last() {
    this.index = this.end - 1;
    return this.current();
  }

}

/***/ }),
/* 159 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),
/* 160 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),
/* 161 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isFilterResult": () => (/* binding */ isFilterResult),
/* harmony export */   "getVisibleState": () => (/* binding */ getVisibleState),
/* harmony export */   "IndexTreeModel": () => (/* binding */ IndexTreeModel)
/* harmony export */ });
/* harmony import */ var _browser_ui_tree_tree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(162);
/* harmony import */ var _common_arrays__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(87);
/* harmony import */ var _common_async__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(68);
/* harmony import */ var _common_diff_diff__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(163);
/* harmony import */ var _common_event__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(51);
/* harmony import */ var _common_iterator__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(55);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






function isFilterResult(obj) {
  return typeof obj === 'object' && 'visibility' in obj && 'data' in obj;
}
function getVisibleState(visibility) {
  switch (visibility) {
    case true:
      return _browser_ui_tree_tree__WEBPACK_IMPORTED_MODULE_0__.TreeVisibility.Visible;

    case false:
      return _browser_ui_tree_tree__WEBPACK_IMPORTED_MODULE_0__.TreeVisibility.Hidden;

    default:
      return visibility;
  }
}

function isCollapsibleStateUpdate(update) {
  return typeof update.collapsible === 'boolean';
}

class IndexTreeModel {
  rootRef = [];
  eventBufferer = new _common_event__WEBPACK_IMPORTED_MODULE_4__.EventBufferer();
  _onDidChangeCollapseState = new _common_event__WEBPACK_IMPORTED_MODULE_4__.Emitter();
  onDidChangeCollapseState = this.eventBufferer.wrapEvent(this._onDidChangeCollapseState.event);
  _onDidChangeRenderNodeCount = new _common_event__WEBPACK_IMPORTED_MODULE_4__.Emitter();
  onDidChangeRenderNodeCount = this.eventBufferer.wrapEvent(this._onDidChangeRenderNodeCount.event);
  _onDidSplice = new _common_event__WEBPACK_IMPORTED_MODULE_4__.Emitter();
  onDidSplice = this._onDidSplice.event;
  refilterDelayer = new _common_async__WEBPACK_IMPORTED_MODULE_2__.Delayer(_common_async__WEBPACK_IMPORTED_MODULE_2__.MicrotaskDelay);

  constructor(user, list, rootElement, options = {}) {
    this.user = user;
    this.list = list;
    this.collapseByDefault = typeof options.collapseByDefault === 'undefined' ? false : options.collapseByDefault;
    this.filter = options.filter;
    this.autoExpandSingleChildren = typeof options.autoExpandSingleChildren === 'undefined' ? false : options.autoExpandSingleChildren;
    this.root = {
      parent: undefined,
      element: rootElement,
      children: [],
      depth: 0,
      visibleChildrenCount: 0,
      visibleChildIndex: -1,
      collapsible: false,
      collapsed: false,
      renderNodeCount: 0,
      visibility: _browser_ui_tree_tree__WEBPACK_IMPORTED_MODULE_0__.TreeVisibility.Visible,
      visible: true,
      filterData: undefined
    };
  }

  splice(location, deleteCount, toInsert = _common_iterator__WEBPACK_IMPORTED_MODULE_5__.Iterable.empty(), options = {}) {
    if (location.length === 0) {
      throw new _browser_ui_tree_tree__WEBPACK_IMPORTED_MODULE_0__.TreeError(this.user, 'Invalid tree location');
    }

    if (options.diffIdentityProvider) {
      this.spliceSmart(options.diffIdentityProvider, location, deleteCount, toInsert, options);
    } else {
      this.spliceSimple(location, deleteCount, toInsert, options);
    }
  }

  spliceSmart(identity, location, deleteCount, toInsertIterable = _common_iterator__WEBPACK_IMPORTED_MODULE_5__.Iterable.empty(), options, recurseLevels = options.diffDepth ?? 0) {
    const {
      parentNode
    } = this.getParentNodeWithListIndex(location);

    if (!parentNode.lastDiffIds) {
      return this.spliceSimple(location, deleteCount, toInsertIterable, options);
    }

    const toInsert = [...toInsertIterable];
    const index = location[location.length - 1];
    const diff = new _common_diff_diff__WEBPACK_IMPORTED_MODULE_3__.LcsDiff({
      getElements: () => parentNode.lastDiffIds
    }, {
      getElements: () => [...parentNode.children.slice(0, index), ...toInsert, ...parentNode.children.slice(index + deleteCount)].map(e => identity.getId(e.element).toString())
    }).ComputeDiff(false); // if we were given a 'best effort' diff, use default behavior

    if (diff.quitEarly) {
      parentNode.lastDiffIds = undefined;
      return this.spliceSimple(location, deleteCount, toInsert, options);
    }

    const locationPrefix = location.slice(0, -1);

    const recurseSplice = (fromOriginal, fromModified, count) => {
      if (recurseLevels > 0) {
        for (let i = 0; i < count; i++) {
          fromOriginal--;
          fromModified--;
          this.spliceSmart(identity, [...locationPrefix, fromOriginal, 0], Number.MAX_SAFE_INTEGER, toInsert[fromModified].children, options, recurseLevels - 1);
        }
      }
    };

    let lastStartO = Math.min(parentNode.children.length, index + deleteCount);
    let lastStartM = toInsert.length;

    for (const change of diff.changes.sort((a, b) => b.originalStart - a.originalStart)) {
      recurseSplice(lastStartO, lastStartM, lastStartO - (change.originalStart + change.originalLength));
      lastStartO = change.originalStart;
      lastStartM = change.modifiedStart - index;
      this.spliceSimple([...locationPrefix, lastStartO], change.originalLength, _common_iterator__WEBPACK_IMPORTED_MODULE_5__.Iterable.slice(toInsert, lastStartM, lastStartM + change.modifiedLength), options);
    } // at this point, startO === startM === count since any remaining prefix should match


    recurseSplice(lastStartO, lastStartM, lastStartO);
  }

  spliceSimple(location, deleteCount, toInsert = _common_iterator__WEBPACK_IMPORTED_MODULE_5__.Iterable.empty(), {
    onDidCreateNode,
    onDidDeleteNode,
    diffIdentityProvider
  }) {
    const {
      parentNode,
      listIndex,
      revealed,
      visible
    } = this.getParentNodeWithListIndex(location);
    const treeListElementsToInsert = [];
    const nodesToInsertIterator = _common_iterator__WEBPACK_IMPORTED_MODULE_5__.Iterable.map(toInsert, el => this.createTreeNode(el, parentNode, parentNode.visible ? _browser_ui_tree_tree__WEBPACK_IMPORTED_MODULE_0__.TreeVisibility.Visible : _browser_ui_tree_tree__WEBPACK_IMPORTED_MODULE_0__.TreeVisibility.Hidden, revealed, treeListElementsToInsert, onDidCreateNode));
    const lastIndex = location[location.length - 1];
    const lastHadChildren = parentNode.children.length > 0; // figure out what's the visible child start index right before the
    // splice point

    let visibleChildStartIndex = 0;

    for (let i = lastIndex; i >= 0 && i < parentNode.children.length; i--) {
      const child = parentNode.children[i];

      if (child.visible) {
        visibleChildStartIndex = child.visibleChildIndex;
        break;
      }
    }

    const nodesToInsert = [];
    let insertedVisibleChildrenCount = 0;
    let renderNodeCount = 0;

    for (const child of nodesToInsertIterator) {
      nodesToInsert.push(child);
      renderNodeCount += child.renderNodeCount;

      if (child.visible) {
        child.visibleChildIndex = visibleChildStartIndex + insertedVisibleChildrenCount++;
      }
    }

    const deletedNodes = (0,_common_arrays__WEBPACK_IMPORTED_MODULE_1__.splice)(parentNode.children, lastIndex, deleteCount, nodesToInsert);

    if (!diffIdentityProvider) {
      parentNode.lastDiffIds = undefined;
    } else if (parentNode.lastDiffIds) {
      (0,_common_arrays__WEBPACK_IMPORTED_MODULE_1__.splice)(parentNode.lastDiffIds, lastIndex, deleteCount, nodesToInsert.map(n => diffIdentityProvider.getId(n.element).toString()));
    } else {
      parentNode.lastDiffIds = parentNode.children.map(n => diffIdentityProvider.getId(n.element).toString());
    } // figure out what is the count of deleted visible children


    let deletedVisibleChildrenCount = 0;

    for (const child of deletedNodes) {
      if (child.visible) {
        deletedVisibleChildrenCount++;
      }
    } // and adjust for all visible children after the splice point


    if (deletedVisibleChildrenCount !== 0) {
      for (let i = lastIndex + nodesToInsert.length; i < parentNode.children.length; i++) {
        const child = parentNode.children[i];

        if (child.visible) {
          child.visibleChildIndex -= deletedVisibleChildrenCount;
        }
      }
    } // update parent's visible children count


    parentNode.visibleChildrenCount += insertedVisibleChildrenCount - deletedVisibleChildrenCount;

    if (revealed && visible) {
      const visibleDeleteCount = deletedNodes.reduce((r, node) => r + (node.visible ? node.renderNodeCount : 0), 0);

      this._updateAncestorsRenderNodeCount(parentNode, renderNodeCount - visibleDeleteCount);

      this.list.splice(listIndex, visibleDeleteCount, treeListElementsToInsert);
    }

    if (deletedNodes.length > 0 && onDidDeleteNode) {
      const visit = node => {
        onDidDeleteNode(node);
        node.children.forEach(visit);
      };

      deletedNodes.forEach(visit);
    }

    this._onDidSplice.fire({
      insertedNodes: nodesToInsert,
      deletedNodes
    });

    const currentlyHasChildren = parentNode.children.length > 0;

    if (lastHadChildren !== currentlyHasChildren) {
      this.setCollapsible(location.slice(0, -1), currentlyHasChildren);
    }

    let node = parentNode;

    while (node) {
      if (node.visibility === _browser_ui_tree_tree__WEBPACK_IMPORTED_MODULE_0__.TreeVisibility.Recurse) {
        // delayed to avoid excessive refiltering, see #135941
        this.refilterDelayer.trigger(() => this.refilter());
        break;
      }

      node = node.parent;
    }
  }

  rerender(location) {
    if (location.length === 0) {
      throw new _browser_ui_tree_tree__WEBPACK_IMPORTED_MODULE_0__.TreeError(this.user, 'Invalid tree location');
    }

    const {
      node,
      listIndex,
      revealed
    } = this.getTreeNodeWithListIndex(location);

    if (node.visible && revealed) {
      this.list.splice(listIndex, 1, [node]);
    }
  }

  updateElementHeight(location, height) {
    if (location.length === 0) {
      throw new _browser_ui_tree_tree__WEBPACK_IMPORTED_MODULE_0__.TreeError(this.user, 'Invalid tree location');
    }

    const {
      listIndex
    } = this.getTreeNodeWithListIndex(location);
    this.list.updateElementHeight(listIndex, height);
  }

  has(location) {
    return this.hasTreeNode(location);
  }

  getListIndex(location) {
    const {
      listIndex,
      visible,
      revealed
    } = this.getTreeNodeWithListIndex(location);
    return visible && revealed ? listIndex : -1;
  }

  getListRenderCount(location) {
    return this.getTreeNode(location).renderNodeCount;
  }

  isCollapsible(location) {
    return this.getTreeNode(location).collapsible;
  }

  setCollapsible(location, collapsible) {
    const node = this.getTreeNode(location);

    if (typeof collapsible === 'undefined') {
      collapsible = !node.collapsible;
    }

    const update = {
      collapsible
    };
    return this.eventBufferer.bufferEvents(() => this._setCollapseState(location, update));
  }

  isCollapsed(location) {
    return this.getTreeNode(location).collapsed;
  }

  setCollapsed(location, collapsed, recursive) {
    const node = this.getTreeNode(location);

    if (typeof collapsed === 'undefined') {
      collapsed = !node.collapsed;
    }

    const update = {
      collapsed,
      recursive: recursive || false
    };
    return this.eventBufferer.bufferEvents(() => this._setCollapseState(location, update));
  }

  _setCollapseState(location, update) {
    const {
      node,
      listIndex,
      revealed
    } = this.getTreeNodeWithListIndex(location);

    const result = this._setListNodeCollapseState(node, listIndex, revealed, update);

    if (node !== this.root && this.autoExpandSingleChildren && result && !isCollapsibleStateUpdate(update) && node.collapsible && !node.collapsed && !update.recursive) {
      let onlyVisibleChildIndex = -1;

      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];

        if (child.visible) {
          if (onlyVisibleChildIndex > -1) {
            onlyVisibleChildIndex = -1;
            break;
          } else {
            onlyVisibleChildIndex = i;
          }
        }
      }

      if (onlyVisibleChildIndex > -1) {
        this._setCollapseState([...location, onlyVisibleChildIndex], update);
      }
    }

    return result;
  }

  _setListNodeCollapseState(node, listIndex, revealed, update) {
    const result = this._setNodeCollapseState(node, update, false);

    if (!revealed || !node.visible || !result) {
      return result;
    }

    const previousRenderNodeCount = node.renderNodeCount;
    const toInsert = this.updateNodeAfterCollapseChange(node);
    const deleteCount = previousRenderNodeCount - (listIndex === -1 ? 0 : 1);
    this.list.splice(listIndex + 1, deleteCount, toInsert.slice(1));
    return result;
  }

  _setNodeCollapseState(node, update, deep) {
    let result;

    if (node === this.root) {
      result = false;
    } else {
      if (isCollapsibleStateUpdate(update)) {
        result = node.collapsible !== update.collapsible;
        node.collapsible = update.collapsible;
      } else if (!node.collapsible) {
        result = false;
      } else {
        result = node.collapsed !== update.collapsed;
        node.collapsed = update.collapsed;
      }

      if (result) {
        this._onDidChangeCollapseState.fire({
          node,
          deep
        });
      }
    }

    if (!isCollapsibleStateUpdate(update) && update.recursive) {
      for (const child of node.children) {
        result = this._setNodeCollapseState(child, update, true) || result;
      }
    }

    return result;
  }

  expandTo(location) {
    this.eventBufferer.bufferEvents(() => {
      let node = this.getTreeNode(location);

      while (node.parent) {
        node = node.parent;
        location = location.slice(0, location.length - 1);

        if (node.collapsed) {
          this._setCollapseState(location, {
            collapsed: false,
            recursive: false
          });
        }
      }
    });
  }

  refilter() {
    const previousRenderNodeCount = this.root.renderNodeCount;
    const toInsert = this.updateNodeAfterFilterChange(this.root);
    this.list.splice(0, previousRenderNodeCount, toInsert);
    this.refilterDelayer.cancel();
  }

  createTreeNode(treeElement, parent, parentVisibility, revealed, treeListElements, onDidCreateNode) {
    const node = {
      parent,
      element: treeElement.element,
      children: [],
      depth: parent.depth + 1,
      visibleChildrenCount: 0,
      visibleChildIndex: -1,
      collapsible: typeof treeElement.collapsible === 'boolean' ? treeElement.collapsible : typeof treeElement.collapsed !== 'undefined',
      collapsed: typeof treeElement.collapsed === 'undefined' ? this.collapseByDefault : treeElement.collapsed,
      renderNodeCount: 1,
      visibility: _browser_ui_tree_tree__WEBPACK_IMPORTED_MODULE_0__.TreeVisibility.Visible,
      visible: true,
      filterData: undefined
    };

    const visibility = this._filterNode(node, parentVisibility);

    node.visibility = visibility;

    if (revealed) {
      treeListElements.push(node);
    }

    const childElements = treeElement.children || _common_iterator__WEBPACK_IMPORTED_MODULE_5__.Iterable.empty();
    const childRevealed = revealed && visibility !== _browser_ui_tree_tree__WEBPACK_IMPORTED_MODULE_0__.TreeVisibility.Hidden && !node.collapsed;
    const childNodes = _common_iterator__WEBPACK_IMPORTED_MODULE_5__.Iterable.map(childElements, el => this.createTreeNode(el, node, visibility, childRevealed, treeListElements, onDidCreateNode));
    let visibleChildrenCount = 0;
    let renderNodeCount = 1;

    for (const child of childNodes) {
      node.children.push(child);
      renderNodeCount += child.renderNodeCount;

      if (child.visible) {
        child.visibleChildIndex = visibleChildrenCount++;
      }
    }

    node.collapsible = node.collapsible || node.children.length > 0;
    node.visibleChildrenCount = visibleChildrenCount;
    node.visible = visibility === _browser_ui_tree_tree__WEBPACK_IMPORTED_MODULE_0__.TreeVisibility.Recurse ? visibleChildrenCount > 0 : visibility === _browser_ui_tree_tree__WEBPACK_IMPORTED_MODULE_0__.TreeVisibility.Visible;

    if (!node.visible) {
      node.renderNodeCount = 0;

      if (revealed) {
        treeListElements.pop();
      }
    } else if (!node.collapsed) {
      node.renderNodeCount = renderNodeCount;
    }

    onDidCreateNode?.(node);
    return node;
  }

  updateNodeAfterCollapseChange(node) {
    const previousRenderNodeCount = node.renderNodeCount;
    const result = [];

    this._updateNodeAfterCollapseChange(node, result);

    this._updateAncestorsRenderNodeCount(node.parent, result.length - previousRenderNodeCount);

    return result;
  }

  _updateNodeAfterCollapseChange(node, result) {
    if (node.visible === false) {
      return 0;
    }

    result.push(node);
    node.renderNodeCount = 1;

    if (!node.collapsed) {
      for (const child of node.children) {
        node.renderNodeCount += this._updateNodeAfterCollapseChange(child, result);
      }
    }

    this._onDidChangeRenderNodeCount.fire(node);

    return node.renderNodeCount;
  }

  updateNodeAfterFilterChange(node) {
    const previousRenderNodeCount = node.renderNodeCount;
    const result = [];

    this._updateNodeAfterFilterChange(node, node.visible ? _browser_ui_tree_tree__WEBPACK_IMPORTED_MODULE_0__.TreeVisibility.Visible : _browser_ui_tree_tree__WEBPACK_IMPORTED_MODULE_0__.TreeVisibility.Hidden, result);

    this._updateAncestorsRenderNodeCount(node.parent, result.length - previousRenderNodeCount);

    return result;
  }

  _updateNodeAfterFilterChange(node, parentVisibility, result, revealed = true) {
    let visibility;

    if (node !== this.root) {
      visibility = this._filterNode(node, parentVisibility);

      if (visibility === _browser_ui_tree_tree__WEBPACK_IMPORTED_MODULE_0__.TreeVisibility.Hidden) {
        node.visible = false;
        node.renderNodeCount = 0;
        return false;
      }

      if (revealed) {
        result.push(node);
      }
    }

    const resultStartLength = result.length;
    node.renderNodeCount = node === this.root ? 0 : 1;
    let hasVisibleDescendants = false;

    if (!node.collapsed || visibility !== _browser_ui_tree_tree__WEBPACK_IMPORTED_MODULE_0__.TreeVisibility.Hidden) {
      let visibleChildIndex = 0;

      for (const child of node.children) {
        hasVisibleDescendants = this._updateNodeAfterFilterChange(child, visibility, result, revealed && !node.collapsed) || hasVisibleDescendants;

        if (child.visible) {
          child.visibleChildIndex = visibleChildIndex++;
        }
      }

      node.visibleChildrenCount = visibleChildIndex;
    } else {
      node.visibleChildrenCount = 0;
    }

    if (node !== this.root) {
      node.visible = visibility === _browser_ui_tree_tree__WEBPACK_IMPORTED_MODULE_0__.TreeVisibility.Recurse ? hasVisibleDescendants : visibility === _browser_ui_tree_tree__WEBPACK_IMPORTED_MODULE_0__.TreeVisibility.Visible;
      node.visibility = visibility;
    }

    if (!node.visible) {
      node.renderNodeCount = 0;

      if (revealed) {
        result.pop();
      }
    } else if (!node.collapsed) {
      node.renderNodeCount += result.length - resultStartLength;
    }

    this._onDidChangeRenderNodeCount.fire(node);

    return node.visible;
  }

  _updateAncestorsRenderNodeCount(node, diff) {
    if (diff === 0) {
      return;
    }

    while (node) {
      node.renderNodeCount += diff;

      this._onDidChangeRenderNodeCount.fire(node);

      node = node.parent;
    }
  }

  _filterNode(node, parentVisibility) {
    const result = this.filter ? this.filter.filter(node.element, parentVisibility) : _browser_ui_tree_tree__WEBPACK_IMPORTED_MODULE_0__.TreeVisibility.Visible;

    if (typeof result === 'boolean') {
      node.filterData = undefined;
      return result ? _browser_ui_tree_tree__WEBPACK_IMPORTED_MODULE_0__.TreeVisibility.Visible : _browser_ui_tree_tree__WEBPACK_IMPORTED_MODULE_0__.TreeVisibility.Hidden;
    } else if (isFilterResult(result)) {
      node.filterData = result.data;
      return getVisibleState(result.visibility);
    } else {
      node.filterData = undefined;
      return getVisibleState(result);
    }
  } // cheap


  hasTreeNode(location, node = this.root) {
    if (!location || location.length === 0) {
      return true;
    }

    const [index, ...rest] = location;

    if (index < 0 || index > node.children.length) {
      return false;
    }

    return this.hasTreeNode(rest, node.children[index]);
  } // cheap


  getTreeNode(location, node = this.root) {
    if (!location || location.length === 0) {
      return node;
    }

    const [index, ...rest] = location;

    if (index < 0 || index > node.children.length) {
      throw new _browser_ui_tree_tree__WEBPACK_IMPORTED_MODULE_0__.TreeError(this.user, 'Invalid tree location');
    }

    return this.getTreeNode(rest, node.children[index]);
  } // expensive


  getTreeNodeWithListIndex(location) {
    if (location.length === 0) {
      return {
        node: this.root,
        listIndex: -1,
        revealed: true,
        visible: false
      };
    }

    const {
      parentNode,
      listIndex,
      revealed,
      visible
    } = this.getParentNodeWithListIndex(location);
    const index = location[location.length - 1];

    if (index < 0 || index > parentNode.children.length) {
      throw new _browser_ui_tree_tree__WEBPACK_IMPORTED_MODULE_0__.TreeError(this.user, 'Invalid tree location');
    }

    const node = parentNode.children[index];
    return {
      node,
      listIndex,
      revealed,
      visible: visible && node.visible
    };
  }

  getParentNodeWithListIndex(location, node = this.root, listIndex = 0, revealed = true, visible = true) {
    const [index, ...rest] = location;

    if (index < 0 || index > node.children.length) {
      throw new _browser_ui_tree_tree__WEBPACK_IMPORTED_MODULE_0__.TreeError(this.user, 'Invalid tree location');
    } // TODO@joao perf!


    for (let i = 0; i < index; i++) {
      listIndex += node.children[i].renderNodeCount;
    }

    revealed = revealed && !node.collapsed;
    visible = visible && node.visible;

    if (rest.length === 0) {
      return {
        parentNode: node,
        listIndex,
        revealed,
        visible
      };
    }

    return this.getParentNodeWithListIndex(rest, node.children[index], listIndex + 1, revealed, visible);
  }

  getNode(location = []) {
    return this.getTreeNode(location);
  } // TODO@joao perf!


  getNodeLocation(node) {
    const location = [];
    let indexTreeNode = node; // typing woes

    while (indexTreeNode.parent) {
      location.push(indexTreeNode.parent.children.indexOf(indexTreeNode));
      indexTreeNode = indexTreeNode.parent;
    }

    return location.reverse();
  }

  getParentNodeLocation(location) {
    if (location.length === 0) {
      return undefined;
    } else if (location.length === 1) {
      return [];
    } else {
      return (0,_common_arrays__WEBPACK_IMPORTED_MODULE_1__.tail2)(location)[0];
    }
  }

  getFirstElementChild(location) {
    const node = this.getTreeNode(location);

    if (node.children.length === 0) {
      return undefined;
    }

    return node.children[0].element;
  }

  getLastElementAncestor(location = []) {
    const node = this.getTreeNode(location);

    if (node.children.length === 0) {
      return undefined;
    }

    return this._getLastElementAncestor(node);
  }

  _getLastElementAncestor(node) {
    if (node.children.length === 0) {
      return node.element;
    }

    return this._getLastElementAncestor(node.children[node.children.length - 1]);
  }

}

/***/ }),
/* 162 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TreeVisibility": () => (/* binding */ TreeVisibility),
/* harmony export */   "TreeMouseEventTarget": () => (/* binding */ TreeMouseEventTarget),
/* harmony export */   "TreeDragOverBubble": () => (/* binding */ TreeDragOverBubble),
/* harmony export */   "TreeDragOverReactions": () => (/* binding */ TreeDragOverReactions),
/* harmony export */   "TreeError": () => (/* binding */ TreeError),
/* harmony export */   "WeakMapper": () => (/* binding */ WeakMapper)
/* harmony export */ });
/* harmony import */ var _browser_ui_list_list__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(143);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

let TreeVisibility;
/**
 * A composed filter result containing the visibility result as well as
 * metadata.
 */

(function (TreeVisibility) {
  TreeVisibility[TreeVisibility["Hidden"] = 0] = "Hidden";
  TreeVisibility[TreeVisibility["Visible"] = 1] = "Visible";
  TreeVisibility[TreeVisibility["Recurse"] = 2] = "Recurse";
})(TreeVisibility || (TreeVisibility = {}));

let TreeMouseEventTarget;

(function (TreeMouseEventTarget) {
  TreeMouseEventTarget[TreeMouseEventTarget["Unknown"] = 0] = "Unknown";
  TreeMouseEventTarget[TreeMouseEventTarget["Twistie"] = 1] = "Twistie";
  TreeMouseEventTarget[TreeMouseEventTarget["Element"] = 2] = "Element";
  TreeMouseEventTarget[TreeMouseEventTarget["Filter"] = 3] = "Filter";
})(TreeMouseEventTarget || (TreeMouseEventTarget = {}));

let TreeDragOverBubble;

(function (TreeDragOverBubble) {
  TreeDragOverBubble[TreeDragOverBubble["Down"] = 0] = "Down";
  TreeDragOverBubble[TreeDragOverBubble["Up"] = 1] = "Up";
})(TreeDragOverBubble || (TreeDragOverBubble = {}));

const TreeDragOverReactions = {
  acceptBubbleUp() {
    return {
      accept: true,
      bubble: TreeDragOverBubble.Up
    };
  },

  acceptBubbleDown(autoExpand = false) {
    return {
      accept: true,
      bubble: TreeDragOverBubble.Down,
      autoExpand
    };
  },

  acceptCopyBubbleUp() {
    return {
      accept: true,
      bubble: TreeDragOverBubble.Up,
      effect: _browser_ui_list_list__WEBPACK_IMPORTED_MODULE_0__.ListDragOverEffect.Copy
    };
  },

  acceptCopyBubbleDown(autoExpand = false) {
    return {
      accept: true,
      bubble: TreeDragOverBubble.Down,
      effect: _browser_ui_list_list__WEBPACK_IMPORTED_MODULE_0__.ListDragOverEffect.Copy,
      autoExpand
    };
  }

};
class TreeError extends Error {
  constructor(user, message) {
    super(`TreeError [${user}] ${message}`);
  }

}
class WeakMapper {
  constructor(fn) {
    this.fn = fn;
  }

  _map = new WeakMap();

  map(key) {
    let result = this._map.get(key);

    if (!result) {
      result = this.fn(key);

      this._map.set(key, result);
    }

    return result;
  }

}

/***/ }),
/* 163 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StringDiffSequence": () => (/* binding */ StringDiffSequence),
/* harmony export */   "stringDiff": () => (/* binding */ stringDiff),
/* harmony export */   "Debug": () => (/* binding */ Debug),
/* harmony export */   "MyArray": () => (/* binding */ MyArray),
/* harmony export */   "LcsDiff": () => (/* binding */ LcsDiff)
/* harmony export */ });
/* harmony import */ var _hash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(164);
/* harmony import */ var _uint__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(78);
/* harmony import */ var _diffChange__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(165);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/



class StringDiffSequence {
  constructor(source) {
    this.source = source;
  }

  getElements() {
    const source = this.source;
    const characters = new Int32Array(source.length);

    for (let i = 0, len = source.length; i < len; i++) {
      characters[i] = source.charCodeAt(i);
    }

    return characters;
  }

}
function stringDiff(original, modified, pretty) {
  return new LcsDiff(new StringDiffSequence(original), new StringDiffSequence(modified)).ComputeDiff(pretty).changes;
}
//
// The code below has been ported from a C# implementation in VS
//
class Debug {
  static Assert(condition, message) {
    if (!condition) {
      throw new Error(message);
    }
  }

}
class MyArray {
  /**
   * Copies a range of elements from an Array starting at the specified source index and pastes
   * them to another Array starting at the specified destination index. The length and the indexes
   * are specified as 64-bit integers.
   * sourceArray:
   *		The Array that contains the data to copy.
   * sourceIndex:
   *		A 64-bit integer that represents the index in the sourceArray at which copying begins.
   * destinationArray:
   *		The Array that receives the data.
   * destinationIndex:
   *		A 64-bit integer that represents the index in the destinationArray at which storing begins.
   * length:
   *		A 64-bit integer that represents the number of elements to copy.
   */
  static Copy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
    for (let i = 0; i < length; i++) {
      destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];
    }
  }

  static Copy2(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
    for (let i = 0; i < length; i++) {
      destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];
    }
  }

} //*****************************************************************************
// LcsDiff.cs
//
// An implementation of the difference algorithm described in
// "An O(ND) Difference Algorithm and its variations" by Eugene W. Myers
//
// Copyright (C) 2008 Microsoft Corporation @minifier_do_not_preserve
//*****************************************************************************
// Our total memory usage for storing history is (worst-case):
// 2 * [(MaxDifferencesHistory + 1) * (MaxDifferencesHistory + 1) - 1] * sizeof(int)
// 2 * [1448*1448 - 1] * 4 = 16773624 = 16MB

var LocalConstants;
/**
 * A utility class which helps to create the set of DiffChanges from
 * a difference operation. This class accepts original DiffElements and
 * modified DiffElements that are involved in a particular change. The
 * MarkNextChange() method can be called to mark the separation between
 * distinct changes. At the end, the Changes property can be called to retrieve
 * the constructed changes.
 */

(function (LocalConstants) {
  LocalConstants[LocalConstants["MaxDifferencesHistory"] = 1447] = "MaxDifferencesHistory";
})(LocalConstants || (LocalConstants = {}));

class DiffChangeHelper {
  /**
   * Constructs a new DiffChangeHelper for the given DiffSequences.
   */
  constructor() {
    this.m_changes = [];
    this.m_originalStart = _uint__WEBPACK_IMPORTED_MODULE_1__.Constants.MAX_SAFE_SMALL_INTEGER;
    this.m_modifiedStart = _uint__WEBPACK_IMPORTED_MODULE_1__.Constants.MAX_SAFE_SMALL_INTEGER;
    this.m_originalCount = 0;
    this.m_modifiedCount = 0;
  }
  /**
   * Marks the beginning of the next change in the set of differences.
   */


  MarkNextChange() {
    // Only add to the list if there is something to add
    if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {
      // Add the new change to our list
      this.m_changes.push(new _diffChange__WEBPACK_IMPORTED_MODULE_2__.DiffChange(this.m_originalStart, this.m_originalCount, this.m_modifiedStart, this.m_modifiedCount));
    } // Reset for the next change


    this.m_originalCount = 0;
    this.m_modifiedCount = 0;
    this.m_originalStart = _uint__WEBPACK_IMPORTED_MODULE_1__.Constants.MAX_SAFE_SMALL_INTEGER;
    this.m_modifiedStart = _uint__WEBPACK_IMPORTED_MODULE_1__.Constants.MAX_SAFE_SMALL_INTEGER;
  }
  /**
   * Adds the original element at the given position to the elements
   * affected by the current change. The modified index gives context
   * to the change position with respect to the original sequence.
   * @param originalIndex The index of the original element to add.
   * @param modifiedIndex The index of the modified element that provides corresponding position in the modified sequence.
   */


  AddOriginalElement(originalIndex, modifiedIndex) {
    // The 'true' start index is the smallest of the ones we've seen
    this.m_originalStart = Math.min(this.m_originalStart, originalIndex);
    this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);
    this.m_originalCount++;
  }
  /**
   * Adds the modified element at the given position to the elements
   * affected by the current change. The original index gives context
   * to the change position with respect to the modified sequence.
   * @param originalIndex The index of the original element that provides corresponding position in the original sequence.
   * @param modifiedIndex The index of the modified element to add.
   */


  AddModifiedElement(originalIndex, modifiedIndex) {
    // The 'true' start index is the smallest of the ones we've seen
    this.m_originalStart = Math.min(this.m_originalStart, originalIndex);
    this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);
    this.m_modifiedCount++;
  }
  /**
   * Retrieves all of the changes marked by the class.
   */


  getChanges() {
    if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {
      // Finish up on whatever is left
      this.MarkNextChange();
    }

    return this.m_changes;
  }
  /**
   * Retrieves all of the changes marked by the class in the reverse order
   */


  getReverseChanges() {
    if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {
      // Finish up on whatever is left
      this.MarkNextChange();
    }

    this.m_changes.reverse();
    return this.m_changes;
  }

}
/**
 * An implementation of the difference algorithm described in
 * "An O(ND) Difference Algorithm and its variations" by Eugene W. Myers
 */


class LcsDiff {
  /**
   * Constructs the DiffFinder
   */
  constructor(originalSequence, modifiedSequence, continueProcessingPredicate = null) {
    this.ContinueProcessingPredicate = continueProcessingPredicate;
    this._originalSequence = originalSequence;
    this._modifiedSequence = modifiedSequence;

    const [originalStringElements, originalElementsOrHash, originalHasStrings] = LcsDiff._getElements(originalSequence);

    const [modifiedStringElements, modifiedElementsOrHash, modifiedHasStrings] = LcsDiff._getElements(modifiedSequence);

    this._hasStrings = originalHasStrings && modifiedHasStrings;
    this._originalStringElements = originalStringElements;
    this._originalElementsOrHash = originalElementsOrHash;
    this._modifiedStringElements = modifiedStringElements;
    this._modifiedElementsOrHash = modifiedElementsOrHash;
    this.m_forwardHistory = [];
    this.m_reverseHistory = [];
  }

  static _isStringArray(arr) {
    return arr.length > 0 && typeof arr[0] === 'string';
  }

  static _getElements(sequence) {
    const elements = sequence.getElements();

    if (LcsDiff._isStringArray(elements)) {
      const hashes = new Int32Array(elements.length);

      for (let i = 0, len = elements.length; i < len; i++) {
        hashes[i] = (0,_hash__WEBPACK_IMPORTED_MODULE_0__.stringHash)(elements[i], 0);
      }

      return [elements, hashes, true];
    }

    if (elements instanceof Int32Array) {
      return [[], elements, false];
    }

    return [[], new Int32Array(elements), false];
  }

  ElementsAreEqual(originalIndex, newIndex) {
    if (this._originalElementsOrHash[originalIndex] !== this._modifiedElementsOrHash[newIndex]) {
      return false;
    }

    return this._hasStrings ? this._originalStringElements[originalIndex] === this._modifiedStringElements[newIndex] : true;
  }

  ElementsAreStrictEqual(originalIndex, newIndex) {
    if (!this.ElementsAreEqual(originalIndex, newIndex)) {
      return false;
    }

    const originalElement = LcsDiff._getStrictElement(this._originalSequence, originalIndex);

    const modifiedElement = LcsDiff._getStrictElement(this._modifiedSequence, newIndex);

    return originalElement === modifiedElement;
  }

  static _getStrictElement(sequence, index) {
    if (typeof sequence.getStrictElement === 'function') {
      return sequence.getStrictElement(index);
    }

    return null;
  }

  OriginalElementsAreEqual(index1, index2) {
    if (this._originalElementsOrHash[index1] !== this._originalElementsOrHash[index2]) {
      return false;
    }

    return this._hasStrings ? this._originalStringElements[index1] === this._originalStringElements[index2] : true;
  }

  ModifiedElementsAreEqual(index1, index2) {
    if (this._modifiedElementsOrHash[index1] !== this._modifiedElementsOrHash[index2]) {
      return false;
    }

    return this._hasStrings ? this._modifiedStringElements[index1] === this._modifiedStringElements[index2] : true;
  }

  ComputeDiff(pretty) {
    return this._ComputeDiff(0, this._originalElementsOrHash.length - 1, 0, this._modifiedElementsOrHash.length - 1, pretty);
  }
  /**
   * Computes the differences between the original and modified input
   * sequences on the bounded range.
   * @returns An array of the differences between the two input sequences.
   */


  _ComputeDiff(originalStart, originalEnd, modifiedStart, modifiedEnd, pretty) {
    const quitEarlyArr = [false];
    let changes = this.ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr);

    if (pretty) {
      // We have to clean up the computed diff to be more intuitive
      // but it turns out this cannot be done correctly until the entire set
      // of diffs have been computed
      changes = this.PrettifyChanges(changes);
    }

    return {
      quitEarly: quitEarlyArr[0],
      changes: changes
    };
  }
  /**
   * Private helper method which computes the differences on the bounded range
   * recursively.
   * @returns An array of the differences between the two input sequences.
   */


  ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr) {
    quitEarlyArr[0] = false; // Find the start of the differences

    while (originalStart <= originalEnd && modifiedStart <= modifiedEnd && this.ElementsAreEqual(originalStart, modifiedStart)) {
      originalStart++;
      modifiedStart++;
    } // Find the end of the differences


    while (originalEnd >= originalStart && modifiedEnd >= modifiedStart && this.ElementsAreEqual(originalEnd, modifiedEnd)) {
      originalEnd--;
      modifiedEnd--;
    } // In the special case where we either have all insertions or all deletions or the sequences are identical


    if (originalStart > originalEnd || modifiedStart > modifiedEnd) {
      let changes;

      if (modifiedStart <= modifiedEnd) {
        Debug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd'); // All insertions

        changes = [new _diffChange__WEBPACK_IMPORTED_MODULE_2__.DiffChange(originalStart, 0, modifiedStart, modifiedEnd - modifiedStart + 1)];
      } else if (originalStart <= originalEnd) {
        Debug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd'); // All deletions

        changes = [new _diffChange__WEBPACK_IMPORTED_MODULE_2__.DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, 0)];
      } else {
        Debug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');
        Debug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd'); // Identical sequences - No differences

        changes = [];
      }

      return changes;
    } // This problem can be solved using the Divide-And-Conquer technique.


    const midOriginalArr = [0];
    const midModifiedArr = [0];
    const result = this.ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr);
    const midOriginal = midOriginalArr[0];
    const midModified = midModifiedArr[0];

    if (result !== null) {
      // Result is not-null when there was enough memory to compute the changes while
      // searching for the recursion point
      return result;
    } else if (!quitEarlyArr[0]) {
      // We can break the problem down recursively by finding the changes in the
      // First Half:   (originalStart, modifiedStart) to (midOriginal, midModified)
      // Second Half:  (midOriginal + 1, minModified + 1) to (originalEnd, modifiedEnd)
      // NOTE: ComputeDiff() is inclusive, therefore the second range starts on the next point
      const leftChanges = this.ComputeDiffRecursive(originalStart, midOriginal, modifiedStart, midModified, quitEarlyArr);
      let rightChanges = [];

      if (!quitEarlyArr[0]) {
        rightChanges = this.ComputeDiffRecursive(midOriginal + 1, originalEnd, midModified + 1, modifiedEnd, quitEarlyArr);
      } else {
        // We didn't have time to finish the first half, so we don't have time to compute this half.
        // Consider the entire rest of the sequence different.
        rightChanges = [new _diffChange__WEBPACK_IMPORTED_MODULE_2__.DiffChange(midOriginal + 1, originalEnd - (midOriginal + 1) + 1, midModified + 1, modifiedEnd - (midModified + 1) + 1)];
      }

      return this.ConcatenateChanges(leftChanges, rightChanges);
    } // If we hit here, we quit early, and so can't return anything meaningful


    return [new _diffChange__WEBPACK_IMPORTED_MODULE_2__.DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)];
  }

  WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr) {
    let forwardChanges = null;
    let reverseChanges = null; // First, walk backward through the forward diagonals history

    let changeHelper = new DiffChangeHelper();
    let diagonalMin = diagonalForwardStart;
    let diagonalMax = diagonalForwardEnd;
    let diagonalRelative = midOriginalArr[0] - midModifiedArr[0] - diagonalForwardOffset;
    let lastOriginalIndex = _uint__WEBPACK_IMPORTED_MODULE_1__.Constants.MIN_SAFE_SMALL_INTEGER;
    let historyIndex = this.m_forwardHistory.length - 1;

    do {
      // Get the diagonal index from the relative diagonal number
      const diagonal = diagonalRelative + diagonalForwardBase; // Figure out where we came from

      if (diagonal === diagonalMin || diagonal < diagonalMax && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1]) {
        // Vertical line (the element is an insert)
        originalIndex = forwardPoints[diagonal + 1];
        modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;

        if (originalIndex < lastOriginalIndex) {
          changeHelper.MarkNextChange();
        }

        lastOriginalIndex = originalIndex;
        changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex);
        diagonalRelative = diagonal + 1 - diagonalForwardBase; //Setup for the next iteration
      } else {
        // Horizontal line (the element is a deletion)
        originalIndex = forwardPoints[diagonal - 1] + 1;
        modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;

        if (originalIndex < lastOriginalIndex) {
          changeHelper.MarkNextChange();
        }

        lastOriginalIndex = originalIndex - 1;
        changeHelper.AddOriginalElement(originalIndex, modifiedIndex + 1);
        diagonalRelative = diagonal - 1 - diagonalForwardBase; //Setup for the next iteration
      }

      if (historyIndex >= 0) {
        forwardPoints = this.m_forwardHistory[historyIndex];
        diagonalForwardBase = forwardPoints[0]; //We stored this in the first spot

        diagonalMin = 1;
        diagonalMax = forwardPoints.length - 1;
      }
    } while (--historyIndex >= -1); // Ironically, we get the forward changes as the reverse of the
    // order we added them since we technically added them backwards


    forwardChanges = changeHelper.getReverseChanges();

    if (quitEarlyArr[0]) {
      // TODO: Calculate a partial from the reverse diagonals.
      //       For now, just assume everything after the midOriginal/midModified point is a diff
      let originalStartPoint = midOriginalArr[0] + 1;
      let modifiedStartPoint = midModifiedArr[0] + 1;

      if (forwardChanges !== null && forwardChanges.length > 0) {
        const lastForwardChange = forwardChanges[forwardChanges.length - 1];
        originalStartPoint = Math.max(originalStartPoint, lastForwardChange.getOriginalEnd());
        modifiedStartPoint = Math.max(modifiedStartPoint, lastForwardChange.getModifiedEnd());
      }

      reverseChanges = [new _diffChange__WEBPACK_IMPORTED_MODULE_2__.DiffChange(originalStartPoint, originalEnd - originalStartPoint + 1, modifiedStartPoint, modifiedEnd - modifiedStartPoint + 1)];
    } else {
      // Now walk backward through the reverse diagonals history
      changeHelper = new DiffChangeHelper();
      diagonalMin = diagonalReverseStart;
      diagonalMax = diagonalReverseEnd;
      diagonalRelative = midOriginalArr[0] - midModifiedArr[0] - diagonalReverseOffset;
      lastOriginalIndex = _uint__WEBPACK_IMPORTED_MODULE_1__.Constants.MAX_SAFE_SMALL_INTEGER;
      historyIndex = deltaIsEven ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;

      do {
        // Get the diagonal index from the relative diagonal number
        const diagonal = diagonalRelative + diagonalReverseBase; // Figure out where we came from

        if (diagonal === diagonalMin || diagonal < diagonalMax && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1]) {
          // Horizontal line (the element is a deletion))
          originalIndex = reversePoints[diagonal + 1] - 1;
          modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;

          if (originalIndex > lastOriginalIndex) {
            changeHelper.MarkNextChange();
          }

          lastOriginalIndex = originalIndex + 1;
          changeHelper.AddOriginalElement(originalIndex + 1, modifiedIndex + 1);
          diagonalRelative = diagonal + 1 - diagonalReverseBase; //Setup for the next iteration
        } else {
          // Vertical line (the element is an insertion)
          originalIndex = reversePoints[diagonal - 1];
          modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;

          if (originalIndex > lastOriginalIndex) {
            changeHelper.MarkNextChange();
          }

          lastOriginalIndex = originalIndex;
          changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex + 1);
          diagonalRelative = diagonal - 1 - diagonalReverseBase; //Setup for the next iteration
        }

        if (historyIndex >= 0) {
          reversePoints = this.m_reverseHistory[historyIndex];
          diagonalReverseBase = reversePoints[0]; //We stored this in the first spot

          diagonalMin = 1;
          diagonalMax = reversePoints.length - 1;
        }
      } while (--historyIndex >= -1); // There are cases where the reverse history will find diffs that
      // are correct, but not intuitive, so we need shift them.


      reverseChanges = changeHelper.getChanges();
    }

    return this.ConcatenateChanges(forwardChanges, reverseChanges);
  }
  /**
   * Given the range to compute the diff on, this method finds the point:
   * (midOriginal, midModified)
   * that exists in the middle of the LCS of the two sequences and
   * is the point at which the LCS problem may be broken down recursively.
   * This method will try to keep the LCS trace in memory. If the LCS recursion
   * point is calculated and the full trace is available in memory, then this method
   * will return the change list.
   * @param originalStart The start bound of the original sequence range
   * @param originalEnd The end bound of the original sequence range
   * @param modifiedStart The start bound of the modified sequence range
   * @param modifiedEnd The end bound of the modified sequence range
   * @param midOriginal The middle point of the original sequence range
   * @param midModified The middle point of the modified sequence range
   * @returns The diff changes, if available, otherwise null
   */


  ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr) {
    let originalIndex = 0,
        modifiedIndex = 0;
    let diagonalForwardStart = 0,
        diagonalForwardEnd = 0;
    let diagonalReverseStart = 0,
        diagonalReverseEnd = 0; // To traverse the edit graph and produce the proper LCS, our actual
    // start position is just outside the given boundary

    originalStart--;
    modifiedStart--; // We set these up to make the compiler happy, but they will
    // be replaced before we return with the actual recursion point

    midOriginalArr[0] = 0;
    midModifiedArr[0] = 0; // Clear out the history

    this.m_forwardHistory = [];
    this.m_reverseHistory = []; // Each cell in the two arrays corresponds to a diagonal in the edit graph.
    // The integer value in the cell represents the originalIndex of the furthest
    // reaching point found so far that ends in that diagonal.
    // The modifiedIndex can be computed mathematically from the originalIndex and the diagonal number.

    const maxDifferences = originalEnd - originalStart + (modifiedEnd - modifiedStart);
    const numDiagonals = maxDifferences + 1;
    const forwardPoints = new Int32Array(numDiagonals);
    const reversePoints = new Int32Array(numDiagonals); // diagonalForwardBase: Index into forwardPoints of the diagonal which passes through (originalStart, modifiedStart)
    // diagonalReverseBase: Index into reversePoints of the diagonal which passes through (originalEnd, modifiedEnd)

    const diagonalForwardBase = modifiedEnd - modifiedStart;
    const diagonalReverseBase = originalEnd - originalStart; // diagonalForwardOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the
    //    diagonal number (relative to diagonalForwardBase)
    // diagonalReverseOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the
    //    diagonal number (relative to diagonalReverseBase)

    const diagonalForwardOffset = originalStart - modifiedStart;
    const diagonalReverseOffset = originalEnd - modifiedEnd; // delta: The difference between the end diagonal and the start diagonal. This is used to relate diagonal numbers
    //   relative to the start diagonal with diagonal numbers relative to the end diagonal.
    // The Even/Oddn-ness of this delta is important for determining when we should check for overlap

    const delta = diagonalReverseBase - diagonalForwardBase;
    const deltaIsEven = delta % 2 === 0; // Here we set up the start and end points as the furthest points found so far
    // in both the forward and reverse directions, respectively

    forwardPoints[diagonalForwardBase] = originalStart;
    reversePoints[diagonalReverseBase] = originalEnd; // Remember if we quit early, and thus need to do a best-effort result instead of a real result.

    quitEarlyArr[0] = false; // A couple of points:
    // --With this method, we iterate on the number of differences between the two sequences.
    //   The more differences there actually are, the longer this will take.
    // --Also, as the number of differences increases, we have to search on diagonals further
    //   away from the reference diagonal (which is diagonalForwardBase for forward, diagonalReverseBase for reverse).
    // --We extend on even diagonals (relative to the reference diagonal) only when numDifferences
    //   is even and odd diagonals only when numDifferences is odd.

    for (let numDifferences = 1; numDifferences <= maxDifferences / 2 + 1; numDifferences++) {
      let furthestOriginalIndex = 0;
      let furthestModifiedIndex = 0; // Run the algorithm in the forward direction

      diagonalForwardStart = this.ClipDiagonalBound(diagonalForwardBase - numDifferences, numDifferences, diagonalForwardBase, numDiagonals);
      diagonalForwardEnd = this.ClipDiagonalBound(diagonalForwardBase + numDifferences, numDifferences, diagonalForwardBase, numDiagonals);

      for (let diagonal = diagonalForwardStart; diagonal <= diagonalForwardEnd; diagonal += 2) {
        // STEP 1: We extend the furthest reaching point in the present diagonal
        // by looking at the diagonals above and below and picking the one whose point
        // is further away from the start point (originalStart, modifiedStart)
        if (diagonal === diagonalForwardStart || diagonal < diagonalForwardEnd && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1]) {
          originalIndex = forwardPoints[diagonal + 1];
        } else {
          originalIndex = forwardPoints[diagonal - 1] + 1;
        }

        modifiedIndex = originalIndex - (diagonal - diagonalForwardBase) - diagonalForwardOffset; // Save the current originalIndex so we can test for false overlap in step 3

        const tempOriginalIndex = originalIndex; // STEP 2: We can continue to extend the furthest reaching point in the present diagonal
        // so long as the elements are equal.

        while (originalIndex < originalEnd && modifiedIndex < modifiedEnd && this.ElementsAreEqual(originalIndex + 1, modifiedIndex + 1)) {
          originalIndex++;
          modifiedIndex++;
        }

        forwardPoints[diagonal] = originalIndex;

        if (originalIndex + modifiedIndex > furthestOriginalIndex + furthestModifiedIndex) {
          furthestOriginalIndex = originalIndex;
          furthestModifiedIndex = modifiedIndex;
        } // STEP 3: If delta is odd (overlap first happens on forward when delta is odd)
        // and diagonal is in the range of reverse diagonals computed for numDifferences-1
        // (the previous iteration; we haven't computed reverse diagonals for numDifferences yet)
        // then check for overlap.


        if (!deltaIsEven && Math.abs(diagonal - diagonalReverseBase) <= numDifferences - 1) {
          if (originalIndex >= reversePoints[diagonal]) {
            midOriginalArr[0] = originalIndex;
            midModifiedArr[0] = modifiedIndex;

            if (tempOriginalIndex <= reversePoints[diagonal] && LocalConstants.MaxDifferencesHistory > 0 && numDifferences <= LocalConstants.MaxDifferencesHistory + 1) {
              // BINGO! We overlapped, and we have the full trace in memory!
              return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
            } else {
              // Either false overlap, or we didn't have enough memory for the full trace
              // Just return the recursion point
              return null;
            }
          }
        }
      } // Check to see if we should be quitting early, before moving on to the next iteration.


      const matchLengthOfLongest = (furthestOriginalIndex - originalStart + (furthestModifiedIndex - modifiedStart) - numDifferences) / 2;

      if (this.ContinueProcessingPredicate !== null && !this.ContinueProcessingPredicate(furthestOriginalIndex, matchLengthOfLongest)) {
        // We can't finish, so skip ahead to generating a result from what we have.
        quitEarlyArr[0] = true; // Use the furthest distance we got in the forward direction.

        midOriginalArr[0] = furthestOriginalIndex;
        midModifiedArr[0] = furthestModifiedIndex;

        if (matchLengthOfLongest > 0 && LocalConstants.MaxDifferencesHistory > 0 && numDifferences <= LocalConstants.MaxDifferencesHistory + 1) {
          // Enough of the history is in memory to walk it backwards
          return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
        } else {
          // We didn't actually remember enough of the history.
          //Since we are quitting the diff early, we need to shift back the originalStart and modified start
          //back into the boundary limits since we decremented their value above beyond the boundary limit.
          originalStart++;
          modifiedStart++;
          return [new _diffChange__WEBPACK_IMPORTED_MODULE_2__.DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)];
        }
      } // Run the algorithm in the reverse direction


      diagonalReverseStart = this.ClipDiagonalBound(diagonalReverseBase - numDifferences, numDifferences, diagonalReverseBase, numDiagonals);
      diagonalReverseEnd = this.ClipDiagonalBound(diagonalReverseBase + numDifferences, numDifferences, diagonalReverseBase, numDiagonals);

      for (let diagonal = diagonalReverseStart; diagonal <= diagonalReverseEnd; diagonal += 2) {
        // STEP 1: We extend the furthest reaching point in the present diagonal
        // by looking at the diagonals above and below and picking the one whose point
        // is further away from the start point (originalEnd, modifiedEnd)
        if (diagonal === diagonalReverseStart || diagonal < diagonalReverseEnd && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1]) {
          originalIndex = reversePoints[diagonal + 1] - 1;
        } else {
          originalIndex = reversePoints[diagonal - 1];
        }

        modifiedIndex = originalIndex - (diagonal - diagonalReverseBase) - diagonalReverseOffset; // Save the current originalIndex so we can test for false overlap

        const tempOriginalIndex = originalIndex; // STEP 2: We can continue to extend the furthest reaching point in the present diagonal
        // as long as the elements are equal.

        while (originalIndex > originalStart && modifiedIndex > modifiedStart && this.ElementsAreEqual(originalIndex, modifiedIndex)) {
          originalIndex--;
          modifiedIndex--;
        }

        reversePoints[diagonal] = originalIndex; // STEP 4: If delta is even (overlap first happens on reverse when delta is even)
        // and diagonal is in the range of forward diagonals computed for numDifferences
        // then check for overlap.

        if (deltaIsEven && Math.abs(diagonal - diagonalForwardBase) <= numDifferences) {
          if (originalIndex <= forwardPoints[diagonal]) {
            midOriginalArr[0] = originalIndex;
            midModifiedArr[0] = modifiedIndex;

            if (tempOriginalIndex >= forwardPoints[diagonal] && LocalConstants.MaxDifferencesHistory > 0 && numDifferences <= LocalConstants.MaxDifferencesHistory + 1) {
              // BINGO! We overlapped, and we have the full trace in memory!
              return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
            } else {
              // Either false overlap, or we didn't have enough memory for the full trace
              // Just return the recursion point
              return null;
            }
          }
        }
      } // Save current vectors to history before the next iteration


      if (numDifferences <= LocalConstants.MaxDifferencesHistory) {
        // We are allocating space for one extra int, which we fill with
        // the index of the diagonal base index
        let temp = new Int32Array(diagonalForwardEnd - diagonalForwardStart + 2);
        temp[0] = diagonalForwardBase - diagonalForwardStart + 1;
        MyArray.Copy2(forwardPoints, diagonalForwardStart, temp, 1, diagonalForwardEnd - diagonalForwardStart + 1);
        this.m_forwardHistory.push(temp);
        temp = new Int32Array(diagonalReverseEnd - diagonalReverseStart + 2);
        temp[0] = diagonalReverseBase - diagonalReverseStart + 1;
        MyArray.Copy2(reversePoints, diagonalReverseStart, temp, 1, diagonalReverseEnd - diagonalReverseStart + 1);
        this.m_reverseHistory.push(temp);
      }
    } // If we got here, then we have the full trace in history. We just have to convert it to a change list
    // NOTE: This part is a bit messy


    return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
  }
  /**
   * Shifts the given changes to provide a more intuitive diff.
   * While the first element in a diff matches the first element after the diff,
   * we shift the diff down.
   *
   * @param changes The list of changes to shift
   * @returns The shifted changes
   */


  PrettifyChanges(changes) {
    // Shift all the changes down first
    for (let i = 0; i < changes.length; i++) {
      const change = changes[i];
      const originalStop = i < changes.length - 1 ? changes[i + 1].originalStart : this._originalElementsOrHash.length;
      const modifiedStop = i < changes.length - 1 ? changes[i + 1].modifiedStart : this._modifiedElementsOrHash.length;
      const checkOriginal = change.originalLength > 0;
      const checkModified = change.modifiedLength > 0;

      while (change.originalStart + change.originalLength < originalStop && change.modifiedStart + change.modifiedLength < modifiedStop && (!checkOriginal || this.OriginalElementsAreEqual(change.originalStart, change.originalStart + change.originalLength)) && (!checkModified || this.ModifiedElementsAreEqual(change.modifiedStart, change.modifiedStart + change.modifiedLength))) {
        const startStrictEqual = this.ElementsAreStrictEqual(change.originalStart, change.modifiedStart);
        const endStrictEqual = this.ElementsAreStrictEqual(change.originalStart + change.originalLength, change.modifiedStart + change.modifiedLength);

        if (endStrictEqual && !startStrictEqual) {
          // moving the change down would create an equal change, but the elements are not strict equal
          break;
        }

        change.originalStart++;
        change.modifiedStart++;
      }

      const mergedChangeArr = [null];

      if (i < changes.length - 1 && this.ChangesOverlap(changes[i], changes[i + 1], mergedChangeArr)) {
        changes[i] = mergedChangeArr[0];
        changes.splice(i + 1, 1);
        i--;
        continue;
      }
    } // Shift changes back up until we hit empty or whitespace-only lines


    for (let i = changes.length - 1; i >= 0; i--) {
      const change = changes[i];
      let originalStop = 0;
      let modifiedStop = 0;

      if (i > 0) {
        const prevChange = changes[i - 1];
        originalStop = prevChange.originalStart + prevChange.originalLength;
        modifiedStop = prevChange.modifiedStart + prevChange.modifiedLength;
      }

      const checkOriginal = change.originalLength > 0;
      const checkModified = change.modifiedLength > 0;
      let bestDelta = 0;

      let bestScore = this._boundaryScore(change.originalStart, change.originalLength, change.modifiedStart, change.modifiedLength);

      for (let delta = 1;; delta++) {
        const originalStart = change.originalStart - delta;
        const modifiedStart = change.modifiedStart - delta;

        if (originalStart < originalStop || modifiedStart < modifiedStop) {
          break;
        }

        if (checkOriginal && !this.OriginalElementsAreEqual(originalStart, originalStart + change.originalLength)) {
          break;
        }

        if (checkModified && !this.ModifiedElementsAreEqual(modifiedStart, modifiedStart + change.modifiedLength)) {
          break;
        }

        const touchingPreviousChange = originalStart === originalStop && modifiedStart === modifiedStop;

        const score = (touchingPreviousChange ? 5 : 0) + this._boundaryScore(originalStart, change.originalLength, modifiedStart, change.modifiedLength);

        if (score > bestScore) {
          bestScore = score;
          bestDelta = delta;
        }
      }

      change.originalStart -= bestDelta;
      change.modifiedStart -= bestDelta;
      const mergedChangeArr = [null];

      if (i > 0 && this.ChangesOverlap(changes[i - 1], changes[i], mergedChangeArr)) {
        changes[i - 1] = mergedChangeArr[0];
        changes.splice(i, 1);
        i++;
        continue;
      }
    } // There could be multiple longest common substrings.
    // Give preference to the ones containing longer lines


    if (this._hasStrings) {
      for (let i = 1, len = changes.length; i < len; i++) {
        const aChange = changes[i - 1];
        const bChange = changes[i];
        const matchedLength = bChange.originalStart - aChange.originalStart - aChange.originalLength;
        const aOriginalStart = aChange.originalStart;
        const bOriginalEnd = bChange.originalStart + bChange.originalLength;
        const abOriginalLength = bOriginalEnd - aOriginalStart;
        const aModifiedStart = aChange.modifiedStart;
        const bModifiedEnd = bChange.modifiedStart + bChange.modifiedLength;
        const abModifiedLength = bModifiedEnd - aModifiedStart; // Avoid wasting a lot of time with these searches

        if (matchedLength < 5 && abOriginalLength < 20 && abModifiedLength < 20) {
          const t = this._findBetterContiguousSequence(aOriginalStart, abOriginalLength, aModifiedStart, abModifiedLength, matchedLength);

          if (t) {
            const [originalMatchStart, modifiedMatchStart] = t;

            if (originalMatchStart !== aChange.originalStart + aChange.originalLength || modifiedMatchStart !== aChange.modifiedStart + aChange.modifiedLength) {
              // switch to another sequence that has a better score
              aChange.originalLength = originalMatchStart - aChange.originalStart;
              aChange.modifiedLength = modifiedMatchStart - aChange.modifiedStart;
              bChange.originalStart = originalMatchStart + matchedLength;
              bChange.modifiedStart = modifiedMatchStart + matchedLength;
              bChange.originalLength = bOriginalEnd - bChange.originalStart;
              bChange.modifiedLength = bModifiedEnd - bChange.modifiedStart;
            }
          }
        }
      }
    }

    return changes;
  }

  _findBetterContiguousSequence(originalStart, originalLength, modifiedStart, modifiedLength, desiredLength) {
    if (originalLength < desiredLength || modifiedLength < desiredLength) {
      return null;
    }

    const originalMax = originalStart + originalLength - desiredLength + 1;
    const modifiedMax = modifiedStart + modifiedLength - desiredLength + 1;
    let bestScore = 0;
    let bestOriginalStart = 0;
    let bestModifiedStart = 0;

    for (let i = originalStart; i < originalMax; i++) {
      for (let j = modifiedStart; j < modifiedMax; j++) {
        const score = this._contiguousSequenceScore(i, j, desiredLength);

        if (score > 0 && score > bestScore) {
          bestScore = score;
          bestOriginalStart = i;
          bestModifiedStart = j;
        }
      }
    }

    if (bestScore > 0) {
      return [bestOriginalStart, bestModifiedStart];
    }

    return null;
  }

  _contiguousSequenceScore(originalStart, modifiedStart, length) {
    let score = 0;

    for (let l = 0; l < length; l++) {
      if (!this.ElementsAreEqual(originalStart + l, modifiedStart + l)) {
        return 0;
      }

      score += this._originalStringElements[originalStart + l].length;
    }

    return score;
  }

  _OriginalIsBoundary(index) {
    if (index <= 0 || index >= this._originalElementsOrHash.length - 1) {
      return true;
    }

    return this._hasStrings && /^\s*$/.test(this._originalStringElements[index]);
  }

  _OriginalRegionIsBoundary(originalStart, originalLength) {
    if (this._OriginalIsBoundary(originalStart) || this._OriginalIsBoundary(originalStart - 1)) {
      return true;
    }

    if (originalLength > 0) {
      const originalEnd = originalStart + originalLength;

      if (this._OriginalIsBoundary(originalEnd - 1) || this._OriginalIsBoundary(originalEnd)) {
        return true;
      }
    }

    return false;
  }

  _ModifiedIsBoundary(index) {
    if (index <= 0 || index >= this._modifiedElementsOrHash.length - 1) {
      return true;
    }

    return this._hasStrings && /^\s*$/.test(this._modifiedStringElements[index]);
  }

  _ModifiedRegionIsBoundary(modifiedStart, modifiedLength) {
    if (this._ModifiedIsBoundary(modifiedStart) || this._ModifiedIsBoundary(modifiedStart - 1)) {
      return true;
    }

    if (modifiedLength > 0) {
      const modifiedEnd = modifiedStart + modifiedLength;

      if (this._ModifiedIsBoundary(modifiedEnd - 1) || this._ModifiedIsBoundary(modifiedEnd)) {
        return true;
      }
    }

    return false;
  }

  _boundaryScore(originalStart, originalLength, modifiedStart, modifiedLength) {
    const originalScore = this._OriginalRegionIsBoundary(originalStart, originalLength) ? 1 : 0;
    const modifiedScore = this._ModifiedRegionIsBoundary(modifiedStart, modifiedLength) ? 1 : 0;
    return originalScore + modifiedScore;
  }
  /**
   * Concatenates the two input DiffChange lists and returns the resulting
   * list.
   * @param The left changes
   * @param The right changes
   * @returns The concatenated list
   */


  ConcatenateChanges(left, right) {
    const mergedChangeArr = [];

    if (left.length === 0 || right.length === 0) {
      return right.length > 0 ? right : left;
    } else if (this.ChangesOverlap(left[left.length - 1], right[0], mergedChangeArr)) {
      // Since we break the problem down recursively, it is possible that we
      // might recurse in the middle of a change thereby splitting it into
      // two changes. Here in the combining stage, we detect and fuse those
      // changes back together
      const result = new Array(left.length + right.length - 1);
      MyArray.Copy(left, 0, result, 0, left.length - 1);
      result[left.length - 1] = mergedChangeArr[0];
      MyArray.Copy(right, 1, result, left.length, right.length - 1);
      return result;
    } else {
      const result = new Array(left.length + right.length);
      MyArray.Copy(left, 0, result, 0, left.length);
      MyArray.Copy(right, 0, result, left.length, right.length);
      return result;
    }
  }
  /**
   * Returns true if the two changes overlap and can be merged into a single
   * change
   * @param left The left change
   * @param right The right change
   * @param mergedChange The merged change if the two overlap, null otherwise
   * @returns True if the two changes overlap
   */


  ChangesOverlap(left, right, mergedChangeArr) {
    Debug.Assert(left.originalStart <= right.originalStart, 'Left change is not less than or equal to right change');
    Debug.Assert(left.modifiedStart <= right.modifiedStart, 'Left change is not less than or equal to right change');

    if (left.originalStart + left.originalLength >= right.originalStart || left.modifiedStart + left.modifiedLength >= right.modifiedStart) {
      const originalStart = left.originalStart;
      let originalLength = left.originalLength;
      const modifiedStart = left.modifiedStart;
      let modifiedLength = left.modifiedLength;

      if (left.originalStart + left.originalLength >= right.originalStart) {
        originalLength = right.originalStart + right.originalLength - left.originalStart;
      }

      if (left.modifiedStart + left.modifiedLength >= right.modifiedStart) {
        modifiedLength = right.modifiedStart + right.modifiedLength - left.modifiedStart;
      }

      mergedChangeArr[0] = new _diffChange__WEBPACK_IMPORTED_MODULE_2__.DiffChange(originalStart, originalLength, modifiedStart, modifiedLength);
      return true;
    } else {
      mergedChangeArr[0] = null;
      return false;
    }
  }
  /**
   * Helper method used to clip a diagonal index to the range of valid
   * diagonals. This also decides whether or not the diagonal index,
   * if it exceeds the boundary, should be clipped to the boundary or clipped
   * one inside the boundary depending on the Even/Odd status of the boundary
   * and numDifferences.
   * @param diagonal The index of the diagonal to clip.
   * @param numDifferences The current number of differences being iterated upon.
   * @param diagonalBaseIndex The base reference diagonal.
   * @param numDiagonals The total number of diagonals.
   * @returns The clipped diagonal index.
   */


  ClipDiagonalBound(diagonal, numDifferences, diagonalBaseIndex, numDiagonals) {
    if (diagonal >= 0 && diagonal < numDiagonals) {
      // Nothing to clip, its in range
      return diagonal;
    } // diagonalsBelow: The number of diagonals below the reference diagonal
    // diagonalsAbove: The number of diagonals above the reference diagonal


    const diagonalsBelow = diagonalBaseIndex;
    const diagonalsAbove = numDiagonals - diagonalBaseIndex - 1;
    const diffEven = numDifferences % 2 === 0;

    if (diagonal < 0) {
      const lowerBoundEven = diagonalsBelow % 2 === 0;
      return diffEven === lowerBoundEven ? 0 : 1;
    } else {
      const upperBoundEven = diagonalsAbove % 2 === 0;
      return diffEven === upperBoundEven ? numDiagonals - 1 : numDiagonals - 2;
    }
  }

}

/***/ }),
/* 164 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "hash": () => (/* binding */ hash),
/* harmony export */   "doHash": () => (/* binding */ doHash),
/* harmony export */   "numberHash": () => (/* binding */ numberHash),
/* harmony export */   "stringHash": () => (/* binding */ stringHash),
/* harmony export */   "Hasher": () => (/* binding */ Hasher),
/* harmony export */   "toHexString": () => (/* binding */ toHexString),
/* harmony export */   "StringSHA1": () => (/* binding */ StringSHA1)
/* harmony export */ });
/* harmony import */ var _strings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(75);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

/**
 * Return a hash value for an object.
 */

function hash(obj) {
  return doHash(obj, 0);
}
function doHash(obj, hashVal) {
  switch (typeof obj) {
    case 'object':
      if (obj === null) {
        return numberHash(349, hashVal);
      } else if (Array.isArray(obj)) {
        return arrayHash(obj, hashVal);
      }

      return objectHash(obj, hashVal);

    case 'string':
      return stringHash(obj, hashVal);

    case 'boolean':
      return booleanHash(obj, hashVal);

    case 'number':
      return numberHash(obj, hashVal);

    case 'undefined':
      return numberHash(937, hashVal);

    default:
      return numberHash(617, hashVal);
  }
}
function numberHash(val, initialHashVal) {
  return (initialHashVal << 5) - initialHashVal + val | 0; // hashVal * 31 + ch, keep as int32
}

function booleanHash(b, initialHashVal) {
  return numberHash(b ? 433 : 863, initialHashVal);
}

function stringHash(s, hashVal) {
  hashVal = numberHash(149417, hashVal);

  for (let i = 0, length = s.length; i < length; i++) {
    hashVal = numberHash(s.charCodeAt(i), hashVal);
  }

  return hashVal;
}

function arrayHash(arr, initialHashVal) {
  initialHashVal = numberHash(104579, initialHashVal);
  return arr.reduce((hashVal, item) => doHash(item, hashVal), initialHashVal);
}

function objectHash(obj, initialHashVal) {
  initialHashVal = numberHash(181387, initialHashVal);
  return Object.keys(obj).sort().reduce((hashVal, key) => {
    hashVal = stringHash(key, hashVal);
    return doHash(obj[key], hashVal);
  }, initialHashVal);
}

class Hasher {
  _value = 0;

  get value() {
    return this._value;
  }

  hash(obj) {
    this._value = doHash(obj, this._value);
    return this._value;
  }

}
var SHA1Constant;

(function (SHA1Constant) {
  SHA1Constant[SHA1Constant["BLOCK_SIZE"] = 64] = "BLOCK_SIZE";
  SHA1Constant[SHA1Constant["UNICODE_REPLACEMENT"] = 65533] = "UNICODE_REPLACEMENT";
})(SHA1Constant || (SHA1Constant = {}));

function leftRotate(value, bits, totalBits = 32) {
  // delta + bits = totalBits
  const delta = totalBits - bits; // All ones, expect `delta` zeros aligned to the right

  const mask = ~((1 << delta) - 1); // Join (value left-shifted `bits` bits) with (masked value right-shifted `delta` bits)

  return (value << bits | (mask & value) >>> delta) >>> 0;
}

function fill(dest, index = 0, count = dest.byteLength, value = 0) {
  for (let i = 0; i < count; i++) {
    dest[index + i] = value;
  }
}

function leftPad(value, length, char = '0') {
  while (value.length < length) {
    value = char + value;
  }

  return value;
}

function toHexString(bufferOrValue, bitsize = 32) {
  if (bufferOrValue instanceof ArrayBuffer) {
    return Array.from(new Uint8Array(bufferOrValue)).map(b => b.toString(16).padStart(2, '0')).join('');
  }

  return leftPad((bufferOrValue >>> 0).toString(16), bitsize / 4);
}
/**
 * A SHA1 implementation that works with strings and does not allocate.
 */

class StringSHA1 {
  static _bigBlock32 = new DataView(new ArrayBuffer(320)); // 80 * 4 = 320

  _h0 = 0x67452301;
  _h1 = 0xEFCDAB89;
  _h2 = 0x98BADCFE;
  _h3 = 0x10325476;
  _h4 = 0xC3D2E1F0;

  constructor() {
    this._buff = new Uint8Array(SHA1Constant.BLOCK_SIZE + 3
    /* to fit any utf-8 */
    );
    this._buffDV = new DataView(this._buff.buffer);
    this._buffLen = 0;
    this._totalLen = 0;
    this._leftoverHighSurrogate = 0;
    this._finished = false;
  }

  update(str) {
    const strLen = str.length;

    if (strLen === 0) {
      return;
    }

    const buff = this._buff;
    let buffLen = this._buffLen;
    let leftoverHighSurrogate = this._leftoverHighSurrogate;
    let charCode;
    let offset;

    if (leftoverHighSurrogate !== 0) {
      charCode = leftoverHighSurrogate;
      offset = -1;
      leftoverHighSurrogate = 0;
    } else {
      charCode = str.charCodeAt(0);
      offset = 0;
    }

    while (true) {
      let codePoint = charCode;

      if (_strings__WEBPACK_IMPORTED_MODULE_0__.isHighSurrogate(charCode)) {
        if (offset + 1 < strLen) {
          const nextCharCode = str.charCodeAt(offset + 1);

          if (_strings__WEBPACK_IMPORTED_MODULE_0__.isLowSurrogate(nextCharCode)) {
            offset++;
            codePoint = _strings__WEBPACK_IMPORTED_MODULE_0__.computeCodePoint(charCode, nextCharCode);
          } else {
            // illegal => unicode replacement character
            codePoint = SHA1Constant.UNICODE_REPLACEMENT;
          }
        } else {
          // last character is a surrogate pair
          leftoverHighSurrogate = charCode;
          break;
        }
      } else if (_strings__WEBPACK_IMPORTED_MODULE_0__.isLowSurrogate(charCode)) {
        // illegal => unicode replacement character
        codePoint = SHA1Constant.UNICODE_REPLACEMENT;
      }

      buffLen = this._push(buff, buffLen, codePoint);
      offset++;

      if (offset < strLen) {
        charCode = str.charCodeAt(offset);
      } else {
        break;
      }
    }

    this._buffLen = buffLen;
    this._leftoverHighSurrogate = leftoverHighSurrogate;
  }

  _push(buff, buffLen, codePoint) {
    if (codePoint < 0x0080) {
      buff[buffLen++] = codePoint;
    } else if (codePoint < 0x0800) {
      buff[buffLen++] = 0b11000000 | (codePoint & 0b00000000000000000000011111000000) >>> 6;
      buff[buffLen++] = 0b10000000 | (codePoint & 0b00000000000000000000000000111111) >>> 0;
    } else if (codePoint < 0x10000) {
      buff[buffLen++] = 0b11100000 | (codePoint & 0b00000000000000001111000000000000) >>> 12;
      buff[buffLen++] = 0b10000000 | (codePoint & 0b00000000000000000000111111000000) >>> 6;
      buff[buffLen++] = 0b10000000 | (codePoint & 0b00000000000000000000000000111111) >>> 0;
    } else {
      buff[buffLen++] = 0b11110000 | (codePoint & 0b00000000000111000000000000000000) >>> 18;
      buff[buffLen++] = 0b10000000 | (codePoint & 0b00000000000000111111000000000000) >>> 12;
      buff[buffLen++] = 0b10000000 | (codePoint & 0b00000000000000000000111111000000) >>> 6;
      buff[buffLen++] = 0b10000000 | (codePoint & 0b00000000000000000000000000111111) >>> 0;
    }

    if (buffLen >= SHA1Constant.BLOCK_SIZE) {
      this._step();

      buffLen -= SHA1Constant.BLOCK_SIZE;
      this._totalLen += SHA1Constant.BLOCK_SIZE; // take last 3 in case of UTF8 overflow

      buff[0] = buff[SHA1Constant.BLOCK_SIZE + 0];
      buff[1] = buff[SHA1Constant.BLOCK_SIZE + 1];
      buff[2] = buff[SHA1Constant.BLOCK_SIZE + 2];
    }

    return buffLen;
  }

  digest() {
    if (!this._finished) {
      this._finished = true;

      if (this._leftoverHighSurrogate) {
        // illegal => unicode replacement character
        this._leftoverHighSurrogate = 0;
        this._buffLen = this._push(this._buff, this._buffLen, SHA1Constant.UNICODE_REPLACEMENT);
      }

      this._totalLen += this._buffLen;

      this._wrapUp();
    }

    return toHexString(this._h0) + toHexString(this._h1) + toHexString(this._h2) + toHexString(this._h3) + toHexString(this._h4);
  }

  _wrapUp() {
    this._buff[this._buffLen++] = 0x80;
    fill(this._buff, this._buffLen);

    if (this._buffLen > 56) {
      this._step();

      fill(this._buff);
    } // this will fit because the mantissa can cover up to 52 bits


    const ml = 8 * this._totalLen;

    this._buffDV.setUint32(56, Math.floor(ml / 4294967296), false);

    this._buffDV.setUint32(60, ml % 4294967296, false);

    this._step();
  }

  _step() {
    const bigBlock32 = StringSHA1._bigBlock32;
    const data = this._buffDV;

    for (let j = 0; j < 64
    /* 16*4 */
    ; j += 4) {
      bigBlock32.setUint32(j, data.getUint32(j, false), false);
    }

    for (let j = 64; j < 320
    /* 80*4 */
    ; j += 4) {
      bigBlock32.setUint32(j, leftRotate(bigBlock32.getUint32(j - 12, false) ^ bigBlock32.getUint32(j - 32, false) ^ bigBlock32.getUint32(j - 56, false) ^ bigBlock32.getUint32(j - 64, false), 1), false);
    }

    let a = this._h0;
    let b = this._h1;
    let c = this._h2;
    let d = this._h3;
    let e = this._h4;
    let f, k;
    let temp;

    for (let j = 0; j < 80; j++) {
      if (j < 20) {
        f = b & c | ~b & d;
        k = 0x5A827999;
      } else if (j < 40) {
        f = b ^ c ^ d;
        k = 0x6ED9EBA1;
      } else if (j < 60) {
        f = b & c | b & d | c & d;
        k = 0x8F1BBCDC;
      } else {
        f = b ^ c ^ d;
        k = 0xCA62C1D6;
      }

      temp = leftRotate(a, 5) + f + e + k + bigBlock32.getUint32(j * 4, false) & 0xffffffff;
      e = d;
      d = c;
      c = leftRotate(b, 30);
      b = a;
      a = temp;
    }

    this._h0 = this._h0 + a & 0xffffffff;
    this._h1 = this._h1 + b & 0xffffffff;
    this._h2 = this._h2 + c & 0xffffffff;
    this._h3 = this._h3 + d & 0xffffffff;
    this._h4 = this._h4 + e & 0xffffffff;
  }

}

/***/ }),
/* 165 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DiffChange": () => (/* binding */ DiffChange)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

/**
 * Represents information about a specific difference between two sequences.
 */
class DiffChange {
  /**
   * The position of the first element in the original sequence which
   * this change affects.
   */

  /**
   * The number of elements from the original sequence which were
   * affected.
   */

  /**
   * The position of the first element in the modified sequence which
   * this change affects.
   */

  /**
   * The number of elements from the modified sequence which were
   * affected (added).
   */

  /**
   * Constructs a new DiffChange with the given sequence information
   * and content.
   */
  constructor(originalStart, originalLength, modifiedStart, modifiedLength) {
    //Debug.Assert(originalLength > 0 || modifiedLength > 0, "originalLength and modifiedLength cannot both be <= 0");
    this.originalStart = originalStart;
    this.originalLength = originalLength;
    this.modifiedStart = modifiedStart;
    this.modifiedLength = modifiedLength;
  }
  /**
   * The end point (exclusive) of the change in the original sequence.
   */


  getOriginalEnd() {
    return this.originalStart + this.originalLength;
  }
  /**
   * The end point (exclusive) of the change in the modified sequence.
   */


  getModifiedEnd() {
    return this.modifiedStart + this.modifiedLength;
  }

}

/***/ }),
/* 166 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "groupBy": () => (/* binding */ groupBy),
/* harmony export */   "diffSets": () => (/* binding */ diffSets),
/* harmony export */   "diffMaps": () => (/* binding */ diffMaps),
/* harmony export */   "SetMap": () => (/* binding */ SetMap)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

/**
 * An interface for a JavaScript object that
 * acts a dictionary. The keys are strings.
 */

/**
 * An interface for a JavaScript object that
 * acts a dictionary. The keys are numbers.
 */

/**
 * Groups the collection into a dictionary based on the provided
 * group function.
 */
function groupBy(data, groupFn) {
  const result = Object.create(null);

  for (const element of data) {
    const key = groupFn(element);
    let target = result[key];

    if (!target) {
      target = result[key] = [];
    }

    target.push(element);
  }

  return result;
}
function diffSets(before, after) {
  const removed = [];
  const added = [];

  for (const element of before) {
    if (!after.has(element)) {
      removed.push(element);
    }
  }

  for (const element of after) {
    if (!before.has(element)) {
      added.push(element);
    }
  }

  return {
    removed,
    added
  };
}
function diffMaps(before, after) {
  const removed = [];
  const added = [];

  for (const [index, value] of before) {
    if (!after.has(index)) {
      removed.push(value);
    }
  }

  for (const [index, value] of after) {
    if (!before.has(index)) {
      added.push(value);
    }
  }

  return {
    removed,
    added
  };
}
class SetMap {
  map = new Map();

  add(key, value) {
    let values = this.map.get(key);

    if (!values) {
      values = new Set();
      this.map.set(key, values);
    }

    values.add(value);
  }

  delete(key, value) {
    const values = this.map.get(key);

    if (!values) {
      return;
    }

    values.delete(value);

    if (values.size === 0) {
      this.map.delete(key);
    }
  }

  forEach(key, fn) {
    const values = this.map.get(key);

    if (!values) {
      return;
    }

    values.forEach(fn);
  }

}

/***/ }),
/* 167 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),
/* 168 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ObjectTreeModel": () => (/* binding */ ObjectTreeModel)
/* harmony export */ });
/* harmony import */ var _browser_ui_tree_indexTreeModel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(161);
/* harmony import */ var _browser_ui_tree_tree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(162);
/* harmony import */ var _common_iterator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/



class ObjectTreeModel {
  rootRef = null;
  nodes = new Map();
  nodesByIdentity = new Map();

  get size() {
    return this.nodes.size;
  }

  constructor(user, list, options = {}) {
    this.user = user;
    this.model = new _browser_ui_tree_indexTreeModel__WEBPACK_IMPORTED_MODULE_0__.IndexTreeModel(user, list, null, options);
    this.onDidSplice = this.model.onDidSplice;
    this.onDidChangeCollapseState = this.model.onDidChangeCollapseState;
    this.onDidChangeRenderNodeCount = this.model.onDidChangeRenderNodeCount;

    if (options.sorter) {
      this.sorter = {
        compare(a, b) {
          return options.sorter.compare(a.element, b.element);
        }

      };
    }

    this.identityProvider = options.identityProvider;
  }

  setChildren(element, children = _common_iterator__WEBPACK_IMPORTED_MODULE_2__.Iterable.empty(), options = {}) {
    const location = this.getElementLocation(element);

    this._setChildren(location, this.preserveCollapseState(children), options);
  }

  _setChildren(location, children = _common_iterator__WEBPACK_IMPORTED_MODULE_2__.Iterable.empty(), options) {
    const insertedElements = new Set();
    const insertedElementIds = new Set();

    const onDidCreateNode = node => {
      if (node.element === null) {
        return;
      }

      const tnode = node;
      insertedElements.add(tnode.element);
      this.nodes.set(tnode.element, tnode);

      if (this.identityProvider) {
        const id = this.identityProvider.getId(tnode.element).toString();
        insertedElementIds.add(id);
        this.nodesByIdentity.set(id, tnode);
      }

      options.onDidCreateNode?.(tnode);
    };

    const onDidDeleteNode = node => {
      if (node.element === null) {
        return;
      }

      const tnode = node;

      if (!insertedElements.has(tnode.element)) {
        this.nodes.delete(tnode.element);
      }

      if (this.identityProvider) {
        const id = this.identityProvider.getId(tnode.element).toString();

        if (!insertedElementIds.has(id)) {
          this.nodesByIdentity.delete(id);
        }
      }

      options.onDidDeleteNode?.(tnode);
    };

    this.model.splice([...location, 0], Number.MAX_VALUE, children, { ...options,
      onDidCreateNode,
      onDidDeleteNode
    });
  }

  preserveCollapseState(elements = _common_iterator__WEBPACK_IMPORTED_MODULE_2__.Iterable.empty()) {
    if (this.sorter) {
      elements = [...elements].sort(this.sorter.compare.bind(this.sorter));
    }

    return _common_iterator__WEBPACK_IMPORTED_MODULE_2__.Iterable.map(elements, treeElement => {
      let node = this.nodes.get(treeElement.element);

      if (!node && this.identityProvider) {
        const id = this.identityProvider.getId(treeElement.element).toString();
        node = this.nodesByIdentity.get(id);
      }

      if (!node) {
        return { ...treeElement,
          children: this.preserveCollapseState(treeElement.children)
        };
      }

      const collapsible = typeof treeElement.collapsible === 'boolean' ? treeElement.collapsible : node.collapsible;
      const collapsed = typeof treeElement.collapsed !== 'undefined' ? treeElement.collapsed : node.collapsed;
      return { ...treeElement,
        collapsible,
        collapsed,
        children: this.preserveCollapseState(treeElement.children)
      };
    });
  }

  rerender(element) {
    const location = this.getElementLocation(element);
    this.model.rerender(location);
  }

  updateElementHeight(element, height) {
    const location = this.getElementLocation(element);
    this.model.updateElementHeight(location, height);
  }

  resort(element = null, recursive = true) {
    if (!this.sorter) {
      return;
    }

    const location = this.getElementLocation(element);
    const node = this.model.getNode(location);

    this._setChildren(location, this.resortChildren(node, recursive), {});
  }

  resortChildren(node, recursive, first = true) {
    let childrenNodes = [...node.children];

    if (recursive || first) {
      childrenNodes = childrenNodes.sort(this.sorter.compare.bind(this.sorter));
    }

    return _common_iterator__WEBPACK_IMPORTED_MODULE_2__.Iterable.map(childrenNodes, node => ({
      element: node.element,
      collapsible: node.collapsible,
      collapsed: node.collapsed,
      children: this.resortChildren(node, recursive, false)
    }));
  }

  getFirstElementChild(ref = null) {
    const location = this.getElementLocation(ref);
    return this.model.getFirstElementChild(location);
  }

  getLastElementAncestor(ref = null) {
    const location = this.getElementLocation(ref);
    return this.model.getLastElementAncestor(location);
  }

  has(element) {
    return this.nodes.has(element);
  }

  getListIndex(element) {
    const location = this.getElementLocation(element);
    return this.model.getListIndex(location);
  }

  getListRenderCount(element) {
    const location = this.getElementLocation(element);
    return this.model.getListRenderCount(location);
  }

  isCollapsible(element) {
    const location = this.getElementLocation(element);
    return this.model.isCollapsible(location);
  }

  setCollapsible(element, collapsible) {
    const location = this.getElementLocation(element);
    return this.model.setCollapsible(location, collapsible);
  }

  isCollapsed(element) {
    const location = this.getElementLocation(element);
    return this.model.isCollapsed(location);
  }

  setCollapsed(element, collapsed, recursive) {
    const location = this.getElementLocation(element);
    return this.model.setCollapsed(location, collapsed, recursive);
  }

  expandTo(element) {
    const location = this.getElementLocation(element);
    this.model.expandTo(location);
  }

  refilter() {
    this.model.refilter();
  }

  getNode(element = null) {
    if (element === null) {
      return this.model.getNode(this.model.rootRef);
    }

    const node = this.nodes.get(element);

    if (!node) {
      throw new _browser_ui_tree_tree__WEBPACK_IMPORTED_MODULE_1__.TreeError(this.user, `Tree element not found: ${element}`);
    }

    return node;
  }

  getNodeLocation(node) {
    return node.element;
  }

  getParentNodeLocation(element) {
    if (element === null) {
      throw new _browser_ui_tree_tree__WEBPACK_IMPORTED_MODULE_1__.TreeError(this.user, `Invalid getParentNodeLocation call`);
    }

    const node = this.nodes.get(element);

    if (!node) {
      throw new _browser_ui_tree_tree__WEBPACK_IMPORTED_MODULE_1__.TreeError(this.user, `Tree element not found: ${element}`);
    }

    const location = this.model.getNodeLocation(node);
    const parentLocation = this.model.getParentNodeLocation(location);
    const parent = this.model.getNode(parentLocation);
    return parent.element;
  }

  getElementLocation(element) {
    if (element === null) {
      return [];
    }

    const node = this.nodes.get(element);

    if (!node) {
      throw new _browser_ui_tree_tree__WEBPACK_IMPORTED_MODULE_1__.TreeError(this.user, `Tree element not found: ${element}`);
    }

    return this.model.getNodeLocation(node);
  }

}

/***/ }),
/* 169 */,
/* 170 */,
/* 171 */,
/* 172 */,
/* 173 */,
/* 174 */,
/* 175 */,
/* 176 */,
/* 177 */,
/* 178 */,
/* 179 */,
/* 180 */,
/* 181 */,
/* 182 */,
/* 183 */,
/* 184 */,
/* 185 */,
/* 186 */,
/* 187 */,
/* 188 */,
/* 189 */,
/* 190 */,
/* 191 */,
/* 192 */,
/* 193 */,
/* 194 */,
/* 195 */,
/* 196 */,
/* 197 */,
/* 198 */,
/* 199 */,
/* 200 */,
/* 201 */,
/* 202 */,
/* 203 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Table": () => (/* binding */ Table)
/* harmony export */ });
/* harmony import */ var _browser_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(61);
/* harmony import */ var _browser_ui_list_listWidget__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(138);
/* harmony import */ var _browser_ui_splitview_splitview__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(93);
/* harmony import */ var _common_event__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(51);
/* harmony import */ var _common_lifecycle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(54);
/* harmony import */ var _common_scrollable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(102);
/* harmony import */ var _table_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(204);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






 // TODO@joao

class TableListRenderer {
  static TemplateId = 'row';
  templateId = TableListRenderer.TemplateId;
  renderedTemplates = new Set();

  constructor(columns, renderers, getColumnSize) {
    this.columns = columns;
    this.getColumnSize = getColumnSize;
    const rendererMap = new Map(renderers.map(r => [r.templateId, r]));
    this.renderers = [];

    for (const column of columns) {
      const renderer = rendererMap.get(column.templateId);

      if (!renderer) {
        throw new Error(`Table cell renderer for template id ${column.templateId} not found.`);
      }

      this.renderers.push(renderer);
    }
  }

  renderTemplate(container) {
    const rowContainer = (0,_browser_dom__WEBPACK_IMPORTED_MODULE_0__.append)(container, (0,_browser_dom__WEBPACK_IMPORTED_MODULE_0__.$)('.monaco-table-tr'));
    const cellContainers = [];
    const cellTemplateData = [];

    for (let i = 0; i < this.columns.length; i++) {
      const renderer = this.renderers[i];
      const cellContainer = (0,_browser_dom__WEBPACK_IMPORTED_MODULE_0__.append)(rowContainer, (0,_browser_dom__WEBPACK_IMPORTED_MODULE_0__.$)('.monaco-table-td', {
        'data-col-index': i
      }));
      cellContainer.style.width = `${this.getColumnSize(i)}px`;
      cellContainers.push(cellContainer);
      cellTemplateData.push(renderer.renderTemplate(cellContainer));
    }

    const result = {
      container,
      cellContainers,
      cellTemplateData
    };
    this.renderedTemplates.add(result);
    return result;
  }

  renderElement(element, index, templateData, height) {
    for (let i = 0; i < this.columns.length; i++) {
      const column = this.columns[i];
      const cell = column.project(element);
      const renderer = this.renderers[i];
      renderer.renderElement(cell, index, templateData.cellTemplateData[i], height);
    }
  }

  disposeElement(element, index, templateData, height) {
    for (let i = 0; i < this.columns.length; i++) {
      const renderer = this.renderers[i];

      if (renderer.disposeElement) {
        const column = this.columns[i];
        const cell = column.project(element);
        renderer.disposeElement(cell, index, templateData.cellTemplateData[i], height);
      }
    }
  }

  disposeTemplate(templateData) {
    for (let i = 0; i < this.columns.length; i++) {
      const renderer = this.renderers[i];
      renderer.disposeTemplate(templateData.cellTemplateData[i]);
    }

    (0,_browser_dom__WEBPACK_IMPORTED_MODULE_0__.clearNode)(templateData.container);
    this.renderedTemplates.delete(templateData);
  }

  layoutColumn(index, size) {
    for (const {
      cellContainers
    } of this.renderedTemplates) {
      cellContainers[index].style.width = `${size}px`;
    }
  }

}

function asListVirtualDelegate(delegate) {
  return {
    getHeight(row) {
      return delegate.getHeight(row);
    },

    getTemplateId() {
      return TableListRenderer.TemplateId;
    }

  };
}

class ColumnHeader {
  get minimumSize() {
    return this.column.minimumWidth ?? 120;
  }

  get maximumSize() {
    return this.column.maximumWidth ?? Number.POSITIVE_INFINITY;
  }

  get onDidChange() {
    return this.column.onDidChangeWidthConstraints ?? _common_event__WEBPACK_IMPORTED_MODULE_3__.Event.None;
  }

  _onDidLayout = new _common_event__WEBPACK_IMPORTED_MODULE_3__.Emitter();
  onDidLayout = this._onDidLayout.event;

  constructor(column, index) {
    this.column = column;
    this.index = index;
    this.element = (0,_browser_dom__WEBPACK_IMPORTED_MODULE_0__.$)('.monaco-table-th', {
      'data-col-index': index,
      title: column.tooltip
    }, column.label);
  }

  layout(size) {
    this._onDidLayout.fire([this.index, size]);
  }

}

class Table {
  static InstanceCount = 0;
  domId = `table_id_${++Table.InstanceCount}`;
  disposables = new _common_lifecycle__WEBPACK_IMPORTED_MODULE_4__.DisposableStore();
  cachedWidth = 0;
  cachedHeight = 0;

  get onDidChangeFocus() {
    return this.list.onDidChangeFocus;
  }

  get onDidChangeSelection() {
    return this.list.onDidChangeSelection;
  }

  get onDidScroll() {
    return this.list.onDidScroll;
  }

  get onMouseClick() {
    return this.list.onMouseClick;
  }

  get onMouseDblClick() {
    return this.list.onMouseDblClick;
  }

  get onMouseMiddleClick() {
    return this.list.onMouseMiddleClick;
  }

  get onPointer() {
    return this.list.onPointer;
  }

  get onMouseUp() {
    return this.list.onMouseUp;
  }

  get onMouseDown() {
    return this.list.onMouseDown;
  }

  get onMouseOver() {
    return this.list.onMouseOver;
  }

  get onMouseMove() {
    return this.list.onMouseMove;
  }

  get onMouseOut() {
    return this.list.onMouseOut;
  }

  get onTouchStart() {
    return this.list.onTouchStart;
  }

  get onTap() {
    return this.list.onTap;
  }

  get onContextMenu() {
    return this.list.onContextMenu;
  }

  get onDidFocus() {
    return this.list.onDidFocus;
  }

  get onDidBlur() {
    return this.list.onDidBlur;
  }

  get scrollTop() {
    return this.list.scrollTop;
  }

  set scrollTop(scrollTop) {
    this.list.scrollTop = scrollTop;
  }

  get scrollLeft() {
    return this.list.scrollLeft;
  }

  set scrollLeft(scrollLeft) {
    this.list.scrollLeft = scrollLeft;
  }

  get scrollHeight() {
    return this.list.scrollHeight;
  }

  get renderHeight() {
    return this.list.renderHeight;
  }

  get onDidDispose() {
    return this.list.onDidDispose;
  }

  constructor(user, container, virtualDelegate, columns, renderers, _options) {
    this.virtualDelegate = virtualDelegate;
    this.domNode = (0,_browser_dom__WEBPACK_IMPORTED_MODULE_0__.append)(container, (0,_browser_dom__WEBPACK_IMPORTED_MODULE_0__.$)(`.monaco-table.${this.domId}`));
    const headers = columns.map((c, i) => new ColumnHeader(c, i));
    const descriptor = {
      size: headers.reduce((a, b) => a + b.column.weight, 0),
      views: headers.map(view => ({
        size: view.column.weight,
        view
      }))
    };
    this.splitview = this.disposables.add(new _browser_ui_splitview_splitview__WEBPACK_IMPORTED_MODULE_2__.SplitView(this.domNode, {
      orientation: _browser_ui_splitview_splitview__WEBPACK_IMPORTED_MODULE_2__.Orientation.HORIZONTAL,
      scrollbarVisibility: _common_scrollable__WEBPACK_IMPORTED_MODULE_5__.ScrollbarVisibility.Hidden,
      getSashOrthogonalSize: () => this.cachedHeight,
      descriptor
    }));
    this.splitview.el.style.height = `${virtualDelegate.headerRowHeight}px`;
    this.splitview.el.style.lineHeight = `${virtualDelegate.headerRowHeight}px`;
    const renderer = new TableListRenderer(columns, renderers, i => this.splitview.getViewSize(i));
    this.list = this.disposables.add(new _browser_ui_list_listWidget__WEBPACK_IMPORTED_MODULE_1__.List(user, this.domNode, asListVirtualDelegate(virtualDelegate), [renderer], _options));
    _common_event__WEBPACK_IMPORTED_MODULE_3__.Event.any(...headers.map(h => h.onDidLayout))(([index, size]) => renderer.layoutColumn(index, size), null, this.disposables);
    this.splitview.onDidSashReset(index => {
      const totalWeight = columns.reduce((r, c) => r + c.weight, 0);
      const size = columns[index].weight / totalWeight * this.cachedWidth;
      this.splitview.resizeView(index, size);
    }, null, this.disposables);
    this.styleElement = (0,_browser_dom__WEBPACK_IMPORTED_MODULE_0__.createStyleSheet)(this.domNode);
    this.style({});
  }

  updateOptions(options) {
    this.list.updateOptions(options);
  }

  splice(start, deleteCount, elements = []) {
    this.list.splice(start, deleteCount, elements);
  }

  rerender() {
    this.list.rerender();
  }

  row(index) {
    return this.list.element(index);
  }

  indexOf(element) {
    return this.list.indexOf(element);
  }

  get length() {
    return this.list.length;
  }

  getHTMLElement() {
    return this.domNode;
  }

  layout(height, width) {
    height = height ?? (0,_browser_dom__WEBPACK_IMPORTED_MODULE_0__.getContentHeight)(this.domNode);
    width = width ?? (0,_browser_dom__WEBPACK_IMPORTED_MODULE_0__.getContentWidth)(this.domNode);
    this.cachedWidth = width;
    this.cachedHeight = height;
    this.splitview.layout(width);
    const listHeight = height - this.virtualDelegate.headerRowHeight;
    this.list.getHTMLElement().style.height = `${listHeight}px`;
    this.list.layout(listHeight, width);
  }

  triggerTypeNavigation() {
    this.list.triggerTypeNavigation();
  }

  style(styles) {
    const content = [];
    content.push(`.monaco-table.${this.domId} > .monaco-split-view2 .monaco-sash.vertical::before {
			top: ${this.virtualDelegate.headerRowHeight + 1}px;
			height: calc(100% - ${this.virtualDelegate.headerRowHeight}px);
		}`);
    this.styleElement.textContent = content.join('\n');
    this.list.style(styles);
  }

  domFocus() {
    this.list.domFocus();
  }

  setAnchor(index) {
    this.list.setAnchor(index);
  }

  getAnchor() {
    return this.list.getAnchor();
  }

  getSelectedElements() {
    return this.list.getSelectedElements();
  }

  setSelection(indexes, browserEvent) {
    this.list.setSelection(indexes, browserEvent);
  }

  getSelection() {
    return this.list.getSelection();
  }

  setFocus(indexes, browserEvent) {
    this.list.setFocus(indexes, browserEvent);
  }

  focusNext(n = 1, loop = false, browserEvent) {
    this.list.focusNext(n, loop, browserEvent);
  }

  focusPrevious(n = 1, loop = false, browserEvent) {
    this.list.focusPrevious(n, loop, browserEvent);
  }

  focusNextPage(browserEvent) {
    return this.list.focusNextPage(browserEvent);
  }

  focusPreviousPage(browserEvent) {
    return this.list.focusPreviousPage(browserEvent);
  }

  focusFirst(browserEvent) {
    this.list.focusFirst(browserEvent);
  }

  focusLast(browserEvent) {
    this.list.focusLast(browserEvent);
  }

  getFocus() {
    return this.list.getFocus();
  }

  getFocusedElements() {
    return this.list.getFocusedElements();
  }

  getRelativeTop(index) {
    return this.list.getRelativeTop(index);
  }

  reveal(index, relativeTop) {
    this.list.reveal(index, relativeTop);
  }

  dispose() {
    this.disposables.dispose();
  }

}

/***/ }),
/* 204 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ })
/******/ 	]));
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _style_less__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(48);
/* harmony import */ var _base_browser_ui_splitview_paneview__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49);
/* harmony import */ var _base_browser_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(61);
/* harmony import */ var _base_common_event__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(51);
/* harmony import */ var _base_common_assert__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(109);
/* harmony import */ var _base_browser_ui_grid_grid__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(110);
/* harmony import */ var _base_common_lifecycle__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(54);
/* harmony import */ var _base_browser_fastDomNode__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(95);
/* harmony import */ var _base_browser_ui_tree_dataTree__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(113);
/* harmony import */ var _base_browser_ui_table_tableWidget__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(203);
/* harmony import */ var _base_common_scrollable__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(102);












class TestPane extends _base_browser_ui_splitview_paneview__WEBPACK_IMPORTED_MODULE_1__.Pane {
  renderHeader(container) {
    const title = (0,_base_browser_dom__WEBPACK_IMPORTED_MODULE_2__.$)('.title');
    title.innerHTML = '123';
    container.append(title);
  }

  renderBody(container) {// container.append($('.content'));
  }

  layoutBody(height, width) {
    console.info(height, width);
  }

}

class TestView extends _base_common_lifecycle__WEBPACK_IMPORTED_MODULE_6__.Disposable {
  _onDidChange = new _base_common_event__WEBPACK_IMPORTED_MODULE_3__.Emitter();
  onDidChange = this._onDidChange.event;

  get minimumWidth() {
    return this._minimumWidth;
  }

  set minimumWidth(size) {
    this._minimumWidth = size;

    this._onDidChange.fire(undefined);
  }

  get maximumWidth() {
    return this._maximumWidth;
  }

  set maximumWidth(size) {
    this._maximumWidth = size;

    this._onDidChange.fire(undefined);
  }

  get minimumHeight() {
    return this._minimumHeight;
  }

  set minimumHeight(size) {
    this._minimumHeight = size;

    this._onDidChange.fire(undefined);
  }

  get maximumHeight() {
    return this._maximumHeight;
  }

  set maximumHeight(size) {
    this._maximumHeight = size;

    this._onDidChange.fire(undefined);
  }

  get element() {
    this._onDidGetElement.fire();

    return this._element;
  }

  _onDidGetElement = new _base_common_event__WEBPACK_IMPORTED_MODULE_3__.Emitter();
  onDidGetElement = this._onDidGetElement.event;
  _width = 0;

  get width() {
    return this._width;
  }

  _height = 0;

  get height() {
    return this._height;
  }

  get size() {
    return [this.width, this.height];
  }

  _onDidLayout = new _base_common_event__WEBPACK_IMPORTED_MODULE_3__.Emitter();
  onDidLayout = this._onDidLayout.event;
  _onDidFocus = new _base_common_event__WEBPACK_IMPORTED_MODULE_3__.Emitter();
  onDidFocus = this._onDidFocus.event;

  constructor(_minimumWidth, _maximumWidth, _minimumHeight, _maximumHeight) {
    super();
    this._minimumWidth = _minimumWidth;
    this._maximumWidth = _maximumWidth;
    this._minimumHeight = _minimumHeight;
    this._maximumHeight = _maximumHeight;
    _base_common_assert__WEBPACK_IMPORTED_MODULE_4__.assert(_minimumWidth <= _maximumWidth);
    _base_common_assert__WEBPACK_IMPORTED_MODULE_4__.assert(_minimumHeight <= _maximumHeight);
    this._element = (0,_base_browser_dom__WEBPACK_IMPORTED_MODULE_2__.$)('div');
    this._fastDom = new _base_browser_fastDomNode__WEBPACK_IMPORTED_MODULE_7__.FastDomNode(this._element);
  }

  layout(width, height) {
    this._width = width;
    this._height = height;

    this._fastDom.setWidth(width);

    this._fastDom.setHeight(height);

    this._onDidLayout.fire({
      width,
      height
    });
  }

  focus() {
    this._onDidFocus.fire();
  }

  dispose() {
    super.dispose();

    this._onDidChange.dispose();

    this._onDidGetElement.dispose();

    this._onDidLayout.dispose();

    this._onDidFocus.dispose();
  }

}

document.documentElement.style.setProperty('--sash-size', 4 + 'px');
document.documentElement.style.setProperty('--sash-hover-size', 4 + 'px');
const view1 = new TestView(50, Number.MAX_VALUE, 50, Number.MAX_VALUE);
const grid = new _base_browser_ui_grid_grid__WEBPACK_IMPORTED_MODULE_5__.Grid(view1);
document.querySelector('div.container').appendChild(grid.element);
grid.layout(document.documentElement.clientWidth, document.documentElement.clientHeight);

window.onresize = () => {
  grid.layout(document.documentElement.clientWidth, document.documentElement.clientHeight);
};

const view2 = new TestView(50, Number.MAX_VALUE, 50, Number.MAX_VALUE);

class TreeData {}

class Template extends _base_common_lifecycle__WEBPACK_IMPORTED_MODULE_6__.Disposable {
  constructor(container) {
    super();
    this._el = (0,_base_browser_dom__WEBPACK_IMPORTED_MODULE_2__.$)('.tree-data');
    container.append(this._el);
  }

  render(data) {
    this._el.innerHTML = data.title;
  }

  dispose() {
    super.dispose();

    this._el.remove();
  }

}

class TreeAdapter {
  getListRender() {
    return [{
      templateId: 'test',
      renderTemplate: container => {
        return new Template(container);
      },

      renderElement(element, index, templateData, height) {
        templateData.render(element.element);
      },

      disposeTemplate(templateData) {
        templateData.dispose();
      },

      renderTwistie(element, twistieElement) {
        if (element.children) {
          twistieElement.innerHTML = '';
          twistieElement.append((0,_base_browser_dom__WEBPACK_IMPORTED_MODULE_2__.$)('.folder'));
        }

        return true;
      }

    }];
  }

  hasChildren(element) {
    console.info('hasChildren', element);
    return !!element.children;
  }

  getChildren(element) {
    return element.children || [];
  }

  getHeight(element) {
    return 24;
  }

  getTemplateId(element) {
    return 'test';
  }

  hasDynamicHeight(element) {
    return false;
  }

  getDynamicHeight(element) {
    return null;
  }

  setDynamicHeight(element, height) {}

}

const adapt = new TreeAdapter();
grid.addView(view2, 200, view1, _base_browser_ui_grid_grid__WEBPACK_IMPORTED_MODULE_5__.Direction.Left);
const data = new _base_browser_ui_tree_dataTree__WEBPACK_IMPORTED_MODULE_8__.DataTree('', view2.element, adapt, adapt.getListRender(), adapt, {
  findWidgetEnabled: true
});
data.setInput({
  title: '123',
  children: [{
    title: '',
    children: [{
      title: ''
    }, {
      title: ''
    }]
  }, {
    title: '789'
  }]
}); // data.style({
//     listFocusAndSelectionBackground: Color.fromHex('#37373d'),
//     listActiveSelectionBackground: Color.fromHex('#37373d'),
// });

class IRowData {}

class TableAdapt {
  headerRowHeight = 24;

  getHeight(row) {
    return 24;
  }

  getColumns() {
    return [{
      label: '',
      weight: 200,
      templateId: 'title',

      project(row) {
        return {
          title: row.title
        };
      }

    }, {
      label: '',
      weight: 200,
      templateId: 'value',

      project(row) {
        return {
          title: row.value
        };
      }

    }];
  }

  getRenders() {
    return [{
      templateId: 'title',
      renderTemplate: container => {
        return new Template(container);
      },

      renderElement(element, index, templateData, height) {
        templateData.render(element);
      },

      disposeTemplate(templateData) {
        templateData.dispose();
      }

    }, {
      templateId: 'value',
      renderTemplate: container => {
        return new Template(container);
      },

      renderElement(element, index, templateData, height) {
        templateData.render(element);
      },

      disposeTemplate(templateData) {
        templateData.dispose();
      }

    }];
  }

}

const tableAdapt = new TableAdapt();
const table = new _base_browser_ui_table_tableWidget__WEBPACK_IMPORTED_MODULE_9__.Table('', view1.element, tableAdapt, tableAdapt.getColumns(), tableAdapt.getRenders(), {
  verticalScrollMode: _base_common_scrollable__WEBPACK_IMPORTED_MODULE_10__.ScrollbarVisibility.Visible
});
table.layout(view1.width, view1.height);
table.splice(0, 0, [{
  title: '123',
  value: '123'
}, {
  title: '456',
  value: '456'
}]);
table.style({});
data.onDidChangeFocus(e => {
  table.setFocus([]);
  table.setSelection([]);
  table.splice(0, table.length, new Array(100).fill(0).map(v => ({
    title: Math.random().toString(26),
    value: '123'
  })));
  table.layout(view1.width, view1.height);
});
})();

module.exports = __webpack_exports__;
/******/ })()
;
//# sourceMappingURL=objectEditor.js.map